<div class="wrap">
   
    <h2 class="header-style">Основы программирования на 1с</h2>


    <ul class="list">
        <li><a href="#1">Типы данных</a></li>
        <li><a href="#1a">Преобразование типов данных</a></li>
        <li><a href="#2">Операции сравнения</a></li>
        <li><a href="#3">Функция Формат()</a></li>
        <li><a href="#4">Встроенные методы 1С</a></li>
        <li><a href="#4a"></a></li>
        <li><a href="#4b">Проверка даты, строки, числа на <b>пустоту</b></a></li>
        <li><a href="#interactiv">Процедуры и функции для взаимодействия с пользователем</a>
            <ul class="list2">
                <li><a href="#interactiv-1">Как показать пользователю текстовое сообщение</a></li>
                <li><a href="#interactiv-2">Как открыть форму</a></li>
                <li><a href="#interactiv-3">Модальное окно. Почему надо отказываться от модальности. Асинхронные методы.</a></li>
                <li><a href="#interactiv-4"></a></li>
                <li><a href="#interactiv-5"></a></li>
            </ul>
        </li>
        <li><a href="#5">Условный оператор</a></li>
        <li><a href="#5a">Тройной оператор</a></li>
        <li><a href="#6">Циклы</a></li>
        <li><a href="#7">Процедуры и функции</a></li>
        <li><a href="#7a">Переменные передаются по ссылке в процедуры и функции. Оператор <b>Знач</b>.</a></li>
        <li><a href="#8"></a></li>
        <li><a href="#9"></a></li>
        <li><a href="#10">Не срабатывает метод Сообшить</a></li>
        <li><a href="#11">Объекты конфигурации</a></li>
        <li><a href="#11a">Отдельно об регистре накопления</a>
            <ul class="list2">
                <li><a href="#11a-baseTable">Основная таблица регистра накпления</a></li>
                <li><a href="#11a-vTableOstatki">Виртуальная таблица Остатки</a></li>
                <li><a href="#11a-vTableOboroti">Виртуальная таблица Обороты</a></li>
                <li><a href="#11a-vTableOborotiIOstatki">Виртуальная таблица ОборотыИОстатки</a></li>
            </ul>
        </li>
        <li><a href="#11aa">Отдельно об регистре сведений</a>
            <ul class="list2">
                <li><a href="#11aa1">Рассмотрим переодический регистр сведений</a></li>
                <li><a href="#11aa2">Что такое регистр сведений</a></li>
                <li><a href="#11aa3">Добавление переодического регистра сведений.</a></li>
                <li><a href="#11aa4">Создание записей в регистре сведений.</a></li>
                <li><a href="#11aa5">Автоматическая подстановка цены в документ при выборе номенклатуры. Обращение к регистр с помощью <b>объектной модели</b></a></li>
                <li><a href="#11aa6">Запись в регистр сведений из документа числовых значений</a></li>
                <li><a href="#11aa7">Запись в регистр сведений из документа не числовых значений</a></li>
                <li><a href="#11aa8">Запись в регистр сведений программно из обработки</a></li>
                <li><a href="#11aa9">Читаем данные из регистра сведений с помощью <b>табличной модели</b>(пишем запрос)</a></li>
                <li><a href="#11aa10">Дополнение от меня.</a></li>
                <li><a href="#11aa11">Виртуальная таблица РегистраСведений - СрезПервых и СрезПоследних</a></li>
                <li><a href="#11aa12"></a></li>
            </ul>
        </li>
        <li><a href="#11b">Крестики-нолики</a></li>
        <li><a href="#12">Объектная модель запросов к БД</a></li>
        <li><a href="#13">Получение данных "Справочника" из базы</a>
            <ul class="list2">
                <li><a href="#13a">Получение данных "Справочника" из базы объектным способом</a></li>
                <li><a href="#13b">Получение данных "Справочника" по ссылке объектным способом и через запрос</a></li>
                <li><a href="#13c">Получение ссылки на элемент справочника</a></li>
            </ul>
        </li>
        <li><a href="#14">Объект встроенного языка УправляемаяФорма</a>
            <ul class="list2">
                <li><a href="#14a">Получение данных полей табличной части из элементов формы документа</a></li>
                <li><a href="#14b">Выносим процедуру подсчёта суммы в Общие Модули</a></li>
                <li><a href="#14c">Свойства и методы управляемой формы</a></li>
            </ul>
        </li>
        <li><a href="#15">Модули</a>
            <ul class="list2">
                <li><a href="#15a">Модуль управляемого приложения</a></li>
                <li><a href="#15b">Общие модули. Что такое ДокументМенеджер и ДокументОбъект.</a></li>
                <li><a href="#15c">Модуль объектов</a></li>
                <li><a href="#15d">Модуль форм</a></li>
                <li><a href="#15e">Модуль сеанса</a></li>
                <li><a href="#15f">Модуль внешнего соединения</a></li>
                <li><a href="#15g">Модуль менеджера</a></li>
                <li><a href="#15h">Модули команды</a></li>
            </ul>
        </li>
        <li><a href="#16">Контекст модуля формы</a></li>
        <li><a href="#17">Анализ незнакомого кода с помощью синтакс-помощника</a></li>
        <li><a href="#18">Анализ кода с помощью отладчика</a></li>
        <li><a href="#19">Заметки из видеокурса 1С</a>
            <ul class="list2">
                <li><a href="#19a">Делаем резервную копию информационной базы и конфигурации</a></li>
                <li><a href="#19b">Про то как удалить данные из справочника и что такое ссылочная целостность</a></li>
            </ul>
        </li>
        <li><a href="#20">Обработка, которая выводит по клику в табличный документ данные из БД</a></li>
        <li><a href="#21">Запись в регистр накопления из формы списка документа. Получение выделенных строк списка. Работа с процедурой из модуля менеджера документа.</a></li>
        <li><a href="#22">Новый способ записи напрямую в регистр из формы документа.</a></li>
        <li><a href="#23">Показываем остаток выбранного товара в табличной части документа. Использую <b>объектную модель запроса и табличную</b> к регистру накопления Остатки</a></li>
    </ul>




    <h3 class="header-style2" id="1">Типы данных</h3>
    <p>1. <b>Простые типы</b>:  1)Строка - "", 2)Число - 2, 3)Дата - '19610412'(ггггммдд), 4)Логический тип(Булево) - Истина или Ложь(Выводит Да или Нет), 5)Неопределено - когда объявили переменную, но ничего туда пока не положили, 6)Тип - используется для того, чтобы хранить в себе описание типа данных. Обычно используется в условных операторах при сравнении с каким то типом, например: Если ТипЗнч(Номенклатура) = Тип("СправочникСсылка.Номенклатура") Тогда ... , 7)NULL - то же самое что и Неопределено, но только для БД используется в запросах</p>
    <p>Подробнее о <a href="#string">строках</a></p>
    <p>Подробнее о <a href="#num">числах</a></p>
    <p>Подробнее о <a href="#date">датах</a></p>
    <p><b>Сложные типы данных</b>.</p>
    <ul class="list">
        <li><b>Ниже перечислены универсальные коллекции.</b>Большое количество коллекций нужно для решения своих каких то задач. В синтакс помошнике можно посмотреть справку по всем этим коллекциям в разделе "Универсальные коллекции значений"</li>
        <li><b><a href="#array">Массив</a></b></li>
        <li><b><a href="#structure">Структура</a></b></li>
        <li><b><a href="#accordance">Соответствие</a></b></li>
        <li><b><a href="#list">Список значений</a></b></li>
        <li><b><a href="#table">Таблица зачений</a></b>
            <ul class="list2">
                <li><a href="#table-1">Отображение виртуальной таблицы регистра накопления Остатки в таблице значений формы внешней обработки, документа или ещё чего.</a></li>
            </ul>
        </li>
        <li><b><a href="#tree">Дерево значений(ещё не описан)</a></b></li>
    </ul>







    <h3 class="header-style2" id="1a">Преобразование типов данных</h3>
    <p>Чтобы преобразовывать типы есть встроенные методы. Например преобразовать другой тип в строку - <b>Строка(23)</b> -> "23". Или другой способ: "12" + 23 -> "1223". Наоборот уже не стработает - 23 + "12" -> 35(если левый операнд число, то правый операнд будет преобразован в число). И так тоже будет преобразовано в число - Истина + "12" -> 13(Истина преобразовалась к 1)</p>
    <p>Остальные методы - Число(), Булево(), Дата().</p>

    




    <h3 class="header-style2" id="2">Операции сравнения</h3>
    <p>1. Равно - =, Не равно - &lt;>, Больше - >, Меньше - &lt;, Больше или равно - >=, Меньше или равно - &lt;=</p>
    <p>2. Операции сравнения со знаками > или &lt; можно производить только с одинаковыми примитивными типами. Например, нельзя сравнивать строку и число, число и дату и т.д.</p>





    <h3 class="header-style2" id="3">Функция Формат</h3>
    <p>Часто приходится выводить(в те же отчёты) значения различных типов(строки, даты, числа, ...). У каждого из этих значений есть различные отображения. Например, одну и ту же дату('01.01.2005') можно представить в виде строки - "01.01.2005", "1 января 2005", "01.01.05". Всё это строки отображения одного и того же значения, для формировния которых используется функция <b>Формат()</b>. Что эта функция может:</p>
    <ul class="list">
        <li><b>Отключаем группировку разрядов</b> - нам нужно вывести число 10000, пишем Сообщить(10000); выводит 10 000. Так получилось, потому что 1С по умолчанию группирует по 3 цифры начиная справа и разделяет их пробелом. Чтобы отменить это правило напишем Сообщить(Формат(10000, "ЧГ=0")); выыведет 10000</li>
        <li><b>Выводим лидирующие нули</b> - часто нужно выводить лидирующие нули перед цифрой. Например, выведем лидирующий ноль перед цифрой 5 - в виде "05". пишем Сообщить(Формат(5, "ЧЦ=2; ЧВН=")); получим "05". Сообщить(Формат(5, "ЧЦ=3; ЧВН=")); получим "005". Более подробно описано в справке или тут на сайте - https://helpme1s.ru/vnutrennij-yazyk-programmirovaniya-1s-8-3-dlya-nachinayushhix-programmistov-urok-19-format-v-1s</li>
        <li><b>Меняем разделитель целой и дробной части</b> - выведем дробное число со звёздочкой вместо точки. Сообщить(Формат(100.38, "ЧРД=*")); получим 100*38</li>
        <li><b>Задаём разделитель групп</b>
            <ul class="list">
                <li>Формат(1000000, "ЧРГ=*");// 10*000*000</li>
            </ul>  
        </li>
        <li><b>Общее представлении даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДЛФ=Д");// <ins>01.01.2005</ins>.</li>
                <li>Формат('20050101', "ДЛФ=ДД");// <ins>1 января 2005</ins>.</li>
                <li>Покажем время - Формат('20050101', "ДЛФ=В");// <ins>20:01:03</ins>.</li>
                <li>Показ даты с временем - Формат('20050101', "ДЛФ=ДДВ");// <ins>1 января 2005 20:01:03</ins>.</li>
                <li>Показ даты с временем - Формат('20050101', "ДЛФ=ДВ");// <ins>01.01.2005 20:01:03</ins></li>
            </ul> 
        </li>
        <li><b>Отображение часа даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=ч");// 8</li>
                <li>Формат('20050101', "ДФ=чч");// 08</li>
                <li>Формат('20050101', "ДФ=Ч");// 20</li>
                <li>Формат('20050101', "ДФ=ЧЧ");// 20</li>
            </ul>
        </li>
        <li><b>Отображение минуты даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=м");// 1</li>
                <li>Формат('20050101', "ДФ=мм");// 01</li>
            </ul>
        </li>
        <li><b>Отображение секунды даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=с");// 3</li>
                <li>Формат('20050101', "ДФ=сс");// 03</li>
            </ul>
        </li>
        <li><b>Отображение дня недели даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=д");// 1</li>
                <li>Формат('20050101', "ДФ=дд");// 01</li>
                <li>Формат('20050101', "ДФ=ддд");// Сб</li>
                <li>Формат('20050101', "ДФ=дддд");// Суббота</li>
            </ul>
        </li>
        <li><b>Отображение месяца даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=М");// 1</li>
                <li>Формат('20050101', "ДФ=ММ");// 01</li>
                <li>Формат('20050101', "ДФ=МММ");// янв.</li>
                <li>Формат('20050101', "ДФ=ММММ");// Январь</li>
            </ul>
        </li>
        <li><b>Отображение года даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=г");// 5</li>
                <li>Формат('20050101', "ДФ=гг");// 05</li>
                <li>Формат('20050101', "ДФ=гггг");// 2005</li>
            </ul>
        </li>
        <li><b>Отображение квартала от года из даты</b>
            <ul class="list">
                <li>Формат('20050101', "ДФ=к");// 1</li>
            </ul>
        </li>
        <li><b>Округление дробной части через Формат()</b>
            <ul class="list">
                <li>Формат(125.368, "ЧДЦ=2"); // 125.37</li>
                <li>Формат(125.368, "ЧДЦ=1");// 125.4</li>
            </ul>
        </li>
        <li><b>Двигаем разряды числа</b>
            <ul class="list">
                <li>Формат(2, "ЧС=1");// 0.2</li>
                <li>Формат(2, "ЧС=-2");// 200</li>
            </ul>
        </li>
        <li><b>Задаём нулевое представление числа 0</b>
            <ul class="list">
                <li>Формат(0, "ЧН=ноль");// ноль</li>
            </ul>
        </li>
        <li><b>Задаём отображение булевого значения</b>
            <ul class="list">
                <li>Формат(Истина, "БЛ=""врёшь""");// врёшь</li>
                <li>Формат(Ложь, "БЛ=""правду говоришь""");// правду говоришь</li>
            </ul>
        </li>
    </ul>
    <div class="code-style">
        <pre>
            //примеры
            Пример1 = Формат(250.99, "ЧРД==");
            Сообщить(Пример1);//250=99

            Пример2 = Формат(5000, "ЧГ=0");
            Сообщить(Пример2);// 5000

            Пример3 = Формат(235325, "ЧРГ=*");
            Сообщить(Пример3);// 235*325

            Пример4 = Формат(3, "ЧЦ=2; ЧВН=");
            Сообщить(Пример4);// 03

            Пример5 = Формат(0, "ЧН=ноль");
            Сообщить(Пример5);// ноль

            Пример6 = Формат(1, "ЧС=3");
            Сообщить(Пример6);// 0,001

            Пример7 = Формат(10.567, "ЧДЦ=2");
            Сообщить(Пример7);// 10.57

            ПрописьЧисла1 = ЧислоПрописью(9999);
            Сообщить(ПрописьЧисла1);// девять тысяч девятсот девяносто девять 00

            ПрописьЧисла2 = ЧислоПрописью(25.99, ,"рубль,рубля,рублей,м,копейка,копейки,копеек,ж,2");
            Сообщить(ПрописьЧисла2);// двадцать пать рублей 99 копеек


            Квартал = Формат('20140101', "ДФ=к");
            Квартал = Строка(Квартал) + " квартал";
            Год = Формат('20140101', "ДФ=гггг");
            Итог = Квартал + " " + Год;
            Сообщить(Итог); // 1 квартал 2014
                    //или 2 способ
            ПК = ПредставлениеПериода(НачалоКвартала('20140101'),КонецКвартала('20140101'),"ФП=Истина");
            Сообщить(Пк);// 1 квартал 2014г.
            
            
            Пример8 = Формат('20140101', "ДЛФ=ДД");
            Сообщить(Пример8);// 1 января 2014г.

            Пример9 = Формат('20140101', "ДФ=дддд");
            Сообщить(Пример9);// среда

            Пример10 = Формат('20140101', "ДФ=ддд");
            Сообщить(Пример10);// Ср

            Пример11 = Формат('20140101', "ДФ=ММММ");
            Сообщить(Пример11);// Январь

            Пример12 = Формат('20140101', "ДФ=МММ");
            Сообщить(Пример12);// янв.

            Пример13 = Формат('20140101', "ДЛФ=Д");
            Сообщить(Пример13);// 01.01.2014

        </pre>
    </div>














    <h3 class="header-style2" id="4">Встроенные методы 1С</h3>
    <p>. <span class="vue-b"><b>ВвестиЧисло(ЧислоА = 0)</b></span> - метод просит ввести число, предварительно укажем переменную по умолчанию в этом методе - ЧислоА. Когда пользователь вводит число, то это число сохраняется в этой переменной и дальше мы можем использовать эту переменную в вычислениях.</p>
    <p>. <span class="vue-b"><b>Ввести строку(Строка = "")</b></span> - тоже самое только строку вводим</p>
    <p>. <span class="vue-b"><b>ВвестиДату(Дата = '19610412')</b></span> - тоже самое</p>
    <p>. <span class="vue-b"><b>ОткрытьЗначение(...)</b></span> - метод выводит в модальном окне то, что вы в него положим, например результат вычисления чисел, которые мы просили у пользователя.</p>
    <p>. <span class="vue-b"><b>Сообщить(...)</b></span> - метод при запуске программы выводит сообщение в него переданное.</p>
    <p>. <span class="vue-b"><b>ТипЗнч(Переменная)</b></span> - метод покажет какой тип данных лежит в переменной(вывод такой - Строка, Число, Дата). Например, там лежит тип данных Число и если ещё раз посмотреть тип данных самого вывода Число, то тип данных будет Тип. Например в JS все типы данных выводятся в типе данных строка, а здесь в типе данных Тип.</p>
    <p>. <span class="vue-b"><b>Тип("Строка")</b></span> - с результатом этого метода сравнивают типы данных. Например, нам неизвестен тип данных находящийся в переменной ТруЛяЛя, а там лежит строка "красный", тода мы в условии сравниваем:</p>
    <div class="code-style">
        <pre>
            ТруЛяЛя = "красный";
            Если ТипЗнч(ТруЛяЛя) = Тип("Строка") Тогда
                Сообщить("Тип данных в переменной ТруЛяЛя является трокой");
            КонецЕсли;
            //условие сработает и вывод будет виден на экране

            //сравнения такое не сработает
            ТруЛяЛя = "красный";
            Если ТипЗнч(ТруЛяЛя) = "Строка" Тогда
                Сообщить("Тип данных в переменной ТруЛяЛя является трокой");
            КонецЕсли;
            //это условие не сработает, так не сравнивают

            //тоже самое из js
            let someVar = 'красный';
            if(typeof someVar == 'строка'){
                console.log("Тип данных в переменной ТруЛяЛя является трокой")
            }
        </pre>
    </div>
    <p>. <span class="vue-b"><b>ПоказатьОповещениеПользователя(Текст)</b></span> - методу передаём сообщение и он его показывает во всплывающем окне справа внизу угла экрана.</p>
    <p><b>Функции и процедуры диалоговых окон</b>.</p>
    <ul class="list">
        <li><b>Предупреждение</b> - Предупреждение(текст, таймаут, заголовок), выводит модальное окно с введённым текстом, пока открыто это окно код застыл на этом месте.</li>
        <li><b>Окна просящие ввести что то - числа, строки, даты, ...</b></li>
        <li><b>Вопрос</b> - Вопрос("Вы хорошо выспались?", РежимДиалогаВопрос.ДаНет)
        <div class="code-style">
            <pre>
                Результат = Вопрос("Вы хорошо выспались?", РежимДиалогаВопрос.ДаНет);
                Если Результат = КодВозвратаДиалога.Да Тогда
                    ОткрытьЗначение("Какой вы молодец");
                Иначе
                    ОткрытьЗначение("Нужно ложиться раньше");
                КонецЕсли;
            </pre>
        </div>
        </li>
    </ul>














    <h3 class="header-style2" id="4b">Проверка даты, строки, числа на пустоту</h3>
    <p>Не забываем что в свойствах реквизитов в форме есть такой параметр как "Проверка заполнения", где можно указать выделять ли поле красным цветом если поле не заполнено.</p>
    <p><b>Проверка даты</b>. Бывает нужно проверить ввёл ли пользователь дату или нет. Для этого надо проверить поле с датой на пустоту. Если в поле Дата не ввести ничего, то система автоматом вставит туда дату '00010101 0:00:00' и в коде нужно проверять на сравнение с этой датой, если равно этой дате, то пользователь ничего не ввёл.</p>
    <p><b>Проверка строки</b>. Бывает мы хотим узнать пустая ли строка, например, ввёл ли пользователь в поле ввода что то, а вдруг он ввёл несколько пробелов и всё это пустая строка или нет? Для нас да это пустая строка, но тогда проверка ПолеВвода = "" не даст истину, потому что строка содержит пробелы и уже не считается пустой строкой. Для этого существует метод <span class="vue-b"><b>Пустая строка(&lt;Значение>)</b></span>, он проверяет значение на наличие пробелов и табуляций и если кроме них ничего больше в строке нет, то он вернёт истину(строка пустая). Ну и собственно если строка равна "", то также вернёт истину. Как я понял то же самое для строки сделает и функция <span class="vue-b"><b>ЗначениеЗаполнено(&lt;Значение>)</b></span>.</p>
     <p><b>Проверка числа</b>. Сравниваем с 0 или можно использовать функцию <span class="vue-b"><b>ЗначениеЗаполнено(&lt;Значение>)</b></span>.</p>
     <p><b>Проверка документа</b>. Есть поле "Документ" с типом ДокументСсылка.ИмяДокумента. Проверяем выбран ли в поле какой-то документ. Есть такая функция как <span class="vue-b"><b>ЗначениеЗаполнено(&lt;Значение>)</b></span>, передадим в неё значение поля "Документ". Она проверяет отличается ли значение от значения по умолчанию того же типа, если нет, значит не заполнено. Значением по умолчанию для поля "Документ" будет пустая ссылка.</p>













    <h3 class="header-style2" id="interactiv">Процедуры и функции для взаимодействия с пользователем</h3>
    <p>В синтакс помошнике про эти функции описано по пути Глобальный контекст -> Процедуры и функции для интерактивной работы. Если процедуры и функции взаимодействия с пользователем лежат в глобаном подтексте, это значит они доступны во всех модулях, наверно). Для тренировки я описываю их в форме обработки. Начнём.</p>
    <p id="interactiv-1"><b>1. Как показать пользователю текстовое сообщение.</b></p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//способ 1</span>
            Сообщить(&ltТекстСообщения> Обяз.,&ltСтатус>Необяз.)
            Статус это системное перечисление, обратиться мы можем к нему так - СтатусСообщения.Важное
            Через точку можно выбрать статус. Статусы видны в обычном приложении, а в управляемом указывать
            их особого смысла нет.
            <span class="vue-b">Сообщить<span class="vue-r">(</span><span class="vue-bl">"Текст сообщения"</span>, СтатусСообщения.ОченьВажное<span class="vue-r">);</span></span>

            <span class="vue-g">//способ 2(рекомендуется использовать вместо метода Сообщить)</span>
            Можно написать в коде "сообщ" и нажать Ввод и развернётся шаблон объекта.
            В чём разница между методом Сообшить() и объектом Сообшить? Объект Сообшить позволяет привязать
            какое то сообщение к конкретному элементу формы. Например, создадим в форме реквизит "Результат"
            и расположим его в элементах. У объекта есть свойство Поле, в котором нужно указать путь к
            реквизиту формы в виде строки. Понятно, что надо объект Сообшить создавать в подтексте этой формы.
            Как видно на картинке у элемента формы "Результат" появляется отдельное окошко с сообщением.
            С помощью такого механизма можно пользователю указать, что нужно заполнить именно это поле.
            <span class="vue-b">Сообщение <span class="vue-r">= Новый</span> СообщениеПользователю<span class="vue-r">;</span></span>
            <span class="vue-b">Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Постание для поля Результат"</span><span class="vue-r">;</span></span>
            <span class="vue-b">Сообщение<span class="vue-r">.</span>Поле <span class="vue-r">=</span> <span class="vue-bl">"Результат"</span><span class="vue-r">;</span>
            Сообщение<span class="vue-r">.</span>УстановитьДанные<span class="vue-r">();</span></span>
            <span class="vue-b">Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">();</span></span>
            <img src="../img/1С-1/2023-01-24_08-44-57.png" alt="">

            <span class="vue-g">//способ 3</span>
            Предупреждение(&lt;ТекстПредупреждения>Обяз., &lt;Таймаут>Необяз., &lt;Заголовок>Необяз.).
            Выводит окно предупреждения. Выводится только при режиме использования модальности.
            <span class="vue-b">Предупреждение<span class="vue-r">(</span><span class="vue-bl">"Текст сообщения", , "Заголовок"</span><span class="vue-r">);</span></span>
            <img src="../img/1С-1/2023-01-24_09-03-50.png" alt="">

            <span class="vue-g">//способ 4</span>
            ПоказатьОповещениеПользователя(&lt;Текст>, &lt;ДействиеПриНажатии>, &lt;Пояснение>, &lt;Картинка>, &lt;СтатусОповещенияПользователя>, &lt;КлючУникальности>);
            При задании только 1го параметра мы увидем окошко с оповещением внизу справа экрана.
            Во 2м параметре можно указать ссылку, если параметр строка, и когда появляется окошко, то при
            нажатии на него перейдём по ссылке.
            <span class="vue-b">ПоказатьОповещениеПользователя<span class="vue-r">(</span><span class="vue-bl">"Текст сообщения"</span><span class="vue-r">);</span></span>
        </pre>
    </div>

    <p id="interactiv-2"><b>2. Как открыть форму</b>. Для того, чтобы открыть форму какого то объекта конфигурации используется метод ОткрытьФорму(&lt;ИмяФормы>, &lt;Параметры>, &lt;Владелец>, &lt;Уникальность>, &lt;Окно>, &lt;НавигационнаяСсылка>, &lt;ОписаниеОповещенияОЗакрытии>, &lt;РежимОткрытияОкна>). Обязательный параметр только 1й. В тренировочной форме обработки создадим кнопку и в обработчике этой кнопки напишем глобальный метод открытия формы, при нажатии на кнопку в польз. режиме откроется указанная форма указанного объекта конфигурации. При поставке первой кавычки, когда начинаяю писать имя формы, нам будут вылетать подсказки, по подсказкам мы можем указать путь до нужной формы:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//открыть форму элемента справочника "Номенклатура"</span>
            --ФормаОбъекта откроет именно ту форму элемента справочника, которая является основной. 
            --Если же форм элемента несколько и мы хотим открыть не основную, то нужно указать полный путь к этой форме. 
            --Метод открывает форму НОВОГО элемента, т.е. по сути запустили создание нового элемента формы.
            <span class="vue-b">ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаОбъекта"</span><span class="vue-r">);</span></span>

            --А вот чтобы открыть форму какого то конкретного элемента, 
            --то тут пригодится 2й аргумент. 2й аргумент это структура. 
            --"Ключ" это имя ключа свойства структуры, а значение это ссылка
            --на номенклатуру. Имя "Ключ" для ключа свойства тут не случайно 
            --и тип значения этого свойства должен быть СправочникСсылка.
            --&lt;ИмяСправочника>(если мы для справочника делаем), т.е. там должна 
            --быть ссылка. Какие ещё параметры формы мы можем использовать для открытия 
            --форм помимо "Ключ". Про это можно посмотреть в синтакс-помошнике:
            --Интерфейс(управляемый) -> Форма клиентского приложения -> 
            --Расширение справочника -> Параметры формы. Это параметры формы 
            --для справочника. Далее нам нужно получить ссылку. Чтобы получить 
            --ссылку, нужна функция выполняющаяся на сервере. 
            <span class="vue-b">&НаКлиенте
            <span class="vue-r">Процедура</span> ОткрытьФормуНоменклатуры<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                СсылкаНаНоменклатуру <span class="vue-r">=</span> ПолучитьНоменклатуруПоКоду<span class="vue-r">(</span><span class="vue-bl">"000000004"</span><span class="vue-r">);</span>
                ПараметрыФормы <span class="vue-r">= Новый</span> Структура<span class="vue-r">(</span><span class="vue-bl">"Ключ"</span>, СсылкаНаНоменклатуру<span class="vue-r">);</span>
                ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаОбъекта"</span>, ПараметрыФормы<span class="vue-r">);
            КонецПроцедуры </span>   

            &НаСервере
            <span class="vue-r">Функция</span> ПолучитьНоменклатуруПоКоду<span class="vue-r">(</span>Код<span class="vue-r">)</span>
                <span class="vue-r">Возврат</span> Справочники<span class="vue-r">.</span>Номенклатура<span class="vue-r">.</span>НайтиПоКоду<span class="vue-r">(</span>Код<span class="vue-r">);
            КонецФункции</span></span>


            --Кроме "Ключ" можно передать имя параметра "ЗначениеКопирования" и 
            --тогда при открытии формы с таким параметром формы, у нас откроется 
            --копия элемента справочника указанного в ссылке. 
            <span class="vue-b">&НаКлиенте
            <span class="vue-r">Процедура</span> ОткрытьФормуНоменклатуры<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                СсылкаНаНоменклатуру <span class="vue-r">=</span> ПолучитьНоменклатуруПоКоду<span class="vue-r">(</span><span class="vue-bl">"000000004"</span><span class="vue-r">);</span>
                ПараметрыФормы <span class="vue-r">= Новый</span> Структура<span class="vue-r">(</span><span class="vue-bl">"ЗначениеКопирования"</span>, СсылкаНаНоменклатуру<span class="vue-r">);</span>
                ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаОбъекта"</span>, ПараметрыФормы<span class="vue-r">);
            КонецПроцедуры </span>   

            &НаСервере
            <span class="vue-r">Функция</span> ПолучитьНоменклатуруПоКоду<span class="vue-r">(</span>Код<span class="vue-r">)</span>
                <span class="vue-r">Возврат</span> Справочники<span class="vue-r">.</span>Номенклатура<span class="vue-r">.</span>НайтиПоКоду<span class="vue-r">(</span>Код<span class="vue-r">);
            КонецФункции</span></span> 


            <span class="vue-g">//открыть форму списка справочника "Номенклатура"</span>
            --Просто открываем форму списка.
            <span class="vue-b">ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаСписка"</span><span class="vue-r">);</span></span>

            --Ещё давайте посмотрим как открыть форму списка с отбором. 
            --Например, в справочнике Номенклатура есть реквизит 
            --"ВидНоменклатуры"(Товар или Услуги) и мы хотим открыть форму 
            --списка с отбором по "ВидНоменклатуры -> Товар". Для этого будем
            --использовать опять 2й параметр - параметр формы. Нам нужно понять
            --как правильно описать структуру отбора. На этот раз нам нужно 
            --расширение динамического списка в том же разделе где и расширение
            --справочника. В расширении есть параметры формы и в ней есть параметр 
            --"Отбор". Создаём структуру Отбор. Ключом будет имя поля("ВидНоменклатуры"),
            --а значением ссылка на элемент перечисления. Затем надо создать ещё 
            --структуру уже ПараметрыФормы. Куда ключом указываем слово "Отбор", 
            --а значением структуру выше созданную. Да вот так всё мудрённо.
            --Функция ПердопределенноеЗначение() возвращает ссылку на предопределенный 
            --элемент из предопределенных данных, прикладных перечислений и точек 
            --маршрута бизнес-процессов, а также значения системных перечислений.
            <span class="vue-b">&НаКлиенте
            <span class="vue-r">Процедура</span> ОткрытьФормуСпискаСОтбором<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                Отбор <span class="vue-r">= Новый</span> Структура<span class="vue-r">(</span><span class="vue-bl">"ВидНоменклатуры"</span>, ПредопределенноеЗначение<span class="vue-r">(</span><span class="vue-bl">"Перечисление.ВидыНоменклатуры.Товар"</span><span class="vue-r">));</span>
                ПараметрыФормы <span class="vue-r">= Новый</span> Структура<span class="vue-r">(</span><span class="vue-bl">"Отбор"</span>, Отбор<span class="vue-r">);</span>
                ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаСписка"</span>, ПараметрыФормы<span class="vue-r">);
            КонецПроцедуры </span>

            <span class="vue-g">//открыть форму выбора справочника "Номенклатура"</span>
            <span class="vue-b">ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаВыбора"</span><span class="vue-r">);</span></span>

            <span class="vue-g">//открыть форму справочника "Номенклатура" с именем "ФормаЭлементаУправляемая"</span>
            <span class="vue-b">ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Справочник.Номенклатура.ФормаЭлементаУправляемая"</span><span class="vue-r">);</span></span>
        </pre>
    </div>

    <p id="interactiv-3"><b>Модальное окно. Почему надо отказываться от модальности. Асинхронные методы.</b></p>
    <p>Выше мы уже описывали модальные методы(синхронные), например, метод Предупреждение, который открывает модальное окно. При разработке нужно придерживаться принципа отказа от модальности. Во встроенном языке для каждого модального(синхронного) метода есть соответствующий не модальный(асинхронный) метод. Для того же метода Предупреждение() есть соответствующий асинхронный метод ПоказатьПредупреждение(). Отличие их в том, что асинхронный метод по прежнему блокирует интерфейс пользователя, но не останавливает выполнение кода.</p>
    <p>Функции для вызова диалога ввода данных. Находятся в Глобальном контексте:</p>
    <p><span class="vue-r">Модальные(синхронные)</span>.</p>
    <ul class="list">
        <li>ВвестиЗначение()</li>
        <li>ВвестиЧисло()</li>
        <li>ВвестиСтроку()</li>
        <li>ВвестиДату()</li>
    </ul>
    <p><span class="vue-b">Не модальные(асинхронные)</span>.</p>
    <ul class="list">
        <li>ПоказатьВводЗначения()</li>
        <li>ВвестиЗначениеАсинх()</li>
        <li>ПоказатьВводЧисла()</li>
        <li>ВвестиЧислоАсинх()</li>
        <li>ПоказатьВводСтроки()</li>
        <li>ВвестиСтрокуАсинх()</li>
        <li>ПоказатьВводДаты()</li>
        <li>ВвестиДатуАсинх()</li>
    </ul>
    <p><span class="vue-r">Синхронные методы</span></p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//все эти методы работают только если включён режим использования модальности</span>	
	
            <span class="vue-g">//ввод числа синхронно</span>
            <span class="vue-b">ВведенноеЧисло <span class="vue-r">=</span> Неопределено;
            ОтветЧисло <span class="vue-r">=</span> ВвестиЧисло<span class="vue-r">(</span>ВведенноеЧисло, <span class="vue-bl">"Введите свой возраст"</span>, 3<span class="vue-r">)</span>;
            <span class="vue-g">//Цифра 0 тоже считается числом</span>
            <span class="vue-r">Если</span> ОтветЧисло <span class="vue-r">Тогда</span>
                Сообщение <span class="vue-r">=</span> Новый СообщениеПользователю;
                Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Ваш возраст:"</span> <span class="vue-r">+</span> ВведенноеЧисло;
                Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;
            <span class="vue-r">КонецЕсли;</span>
            
            
            <span class="vue-g">//ввод строки синхронно</span>
            ВведённаяСтрока <span class="vue-r">=</span> Неопределено;
            ОтветСтрока <span class="vue-r">=</span> ВвестиСтроку<span class="vue-r">(</span>ВведённаяСтрока, <span class="vue-bl">"Введите ваше имя"</span>, 50<span class="vue-r">)</span>;
            <span class="vue-r">Если</span> ОтветСтрока  <span class="vue-r">И НЕ</span> ПустаяСтрока<span class="vue-r">(</span>ВведённаяСтрока<span class="vue-r">)</span> <span class="vue-r">Тогда</span>
                Сообщение <span class="vue-r">=</span> Новый СообщениеПользователю;
                Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Ваше имя:"</span> <span class="vue-r">+</span> ВведённаяСтрока;
                Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;
            <span class="vue-r">КонецЕсли;</span> 
            
            
            <span class="vue-g">//ввод даты синхронно</span>
            ВведённаяДата <span class="vue-r">=</span> Неопределено;
            <span class="vue-g">//ЧастиДаты это системное перечисление, через точку имет 3 свойства: Дата, Время, ДатаВремя(по умолчанию)</span>
            ОтветДата <span class="vue-r">=</span> ВвестиДату<span class="vue-r">(</span>ВведённаяДата, <span class="vue-bl">"ВведитеДату"</span>, ЧастиДаты.Дата<span class="vue-r">)</span>;
            <span class="vue-r">Если</span> ОтветДата <span class="vue-r">Тогда</span>
                Сообщение <span class="vue-r">=</span> Новый СообщениеПользователю;
                Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Вы ввели дату: "</span> <span class="vue-r">+</span> ВведённаяДата;
                Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;
            <span class="vue-r">КонецЕсли;</span> 
            
            
            <span class="vue-g">//ввод значения синхронно. Значение это не простой тип(число, строка), а это например, ссылка на элемент справочника или документа</span>  
            ВыбраннаяНоменклатура <span class="vue-r">=</span> Неопределено;
            <span class="vue-g">//3й параметр вводим либо Тип(), либо ОписаниеТипов</span>
            ОтветНоменклатура <span class="vue-r">=</span> ВвестиЗначение<span class="vue-r">(</span>ВыбраннаяНоменклатура, <span class="vue-bl">"ВыберитеТовар"</span>, Тип(<span class="vue-bl">"СправочникСсылка.Номенклатура"</span>)<span class="vue-r">)</span>;
            <span class="vue-r">Если</span> ОтветНоменклатура <span class="vue-r">Тогда</span>
                Сообщение <span class="vue-r">=</span> Новый СообщениеПользователю;
                Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Вы ввели товар: "</span> <span class="vue-r">+</span> ВыбраннаяНоменклатура;
                Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;
            <span class="vue-r">КонецЕсли;</span></span>

            <span class="vue-g">//синхронный метод Вопрос()</span>
            <img src="../img/1С-1/2023-01-28_19-50-43.png" class="screen-3" alt="">
        </pre>
    </div>
    <p><span class="vue-b">Асинхронные методы с использованием функций отложенного вызова(с колбеками)</span>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><span class="vue-r">&НаКлиенте
            Процедура</span> ОбработкаАсинхронныхМетодов1<span class="vue-r">(</span>Команда<span class="vue-r">)</span>    
                <span class="vue-g">//отличие от синхронных методов в том, что теперь добавлен ещё 1 параметр
                //этот параметр соответствует функции отложенного вызова в JS(колбек)
                //тут это немножко по другому сделано. Тут мы создаём объект  ОписаниеОповещения, 
                //в котором описываем имя процедуры и текущий модуль.  Процедура будет вызвана по 
                //по окончанию ввода пользователем данных в модальном окне
                //Процедура должна быть экспортная.
                //Судя по справке, то асинхронные методы ничего не возвращают, всё делает 
                //процедура вызванная оповещением, в которую и передаются данные от пользователя
                
                
                //ввод числа асинхронно</span>
                ВведенноеЧисло <span class="vue-r">=</span> 0;
                Оповещение <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span><span class="vue-bl">"ПослеВводаЧисла"</span>, ЭтотОбъект<span class="vue-r">)</span>;
                ПоказатьВводЧисла<span class="vue-r">(</span>Оповещение, ВведенноеЧисло, <span class="vue-bl">"Сколько вам лет?"</span>, 3<span class="vue-r">)</span>; 
                
                
                <span class="vue-g">//ввод строки асинхронно</span>
                ВведеннаяСтрока <span class="vue-r">=</span> "";
                Оповещение <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span><span class="vue-bl">"ПослеВводаСтроки"</span>, ЭтотОбъект<span class="vue-r">)</span>;
                ПоказатьВводСтроки<span class="vue-r">(</span>Оповещение, ВведеннаяСтрока, <span class="vue-bl">"Ваше имя?"</span>, 50<span class="vue-r">)</span>; 
            
            
                <span class="vue-g">//показ Предупреждения асинхронного. 1й параметр с оповещением можно опустить
                //потому что нам не требуется обрабатывать ответ</span>
                ПоказатьПредупреждение<span class="vue-r">(</span> , <span class="vue-bl">"Какой то текст"</span><span class="vue-r">)</span>; 
            КонецПроцедуры

            <span class="vue-r">&НаКлиенте
            Процедура</span> ПослеВводаЧисла<span class="vue-r">(</span>Число, Параметры<span class="vue-r">) Экспорт</span> 
                <span class="vue-g">//в отличии от синхронного метода ввода числа, тут уже надо написать такое условие чтобы и 0 тоже выводился
                //всё из за того что переменная Число тут не булево значение имеет, а числовое</span>
                <span class="vue-r">Если НЕ</span> Число <span class="vue-r">=</span> Неопределено <span class="vue-r">Тогда</span>
                    Сообщение <span class="vue-r">= Новый</span> СообщениеПользователю;
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Вам " <span class="vue-r">+</span> Число <span class="vue-r">+</span> " лет"</span>;
                    Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;	
                <span class="vue-r">КонецЕсли;
            КонецПроцедуры 

            &НаКлиенте
            Процедура</span> ПослеВводаСтроки<span class="vue-r">(</span>Строка, Параметры<span class="vue-r">) Экспорт</span> 
                <span class="vue-g">//в отличии от синхронного метода ввода числа, тут уже надо написать такое условие чтобы и 0 тоже выводился
                //всё из за того что переменная Число тут не булево значение имеет, а числовое</span>
                <span class="vue-r">Если НЕ</span> Строка <span class="vue-r">=</span> Неопределено <span class="vue-r">Тогда</span>
                    Сообщение <span class="vue-r">= Новый</span> СообщениеПользователю;
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Ваше имя "</span> <span class="vue-r">+</span> Строка;
                    Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;	
                <span class="vue-r">КонецЕсли;
            КонецПроцедуры;</span></span>




            <span class="vue-g">//асинхронный метод Вопрос()</span>
            <span class="vue-b"><span class="vue-r">&НаКлиенте
            Процедура</span> ЗадатьВопросАсинхронно<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                <span class="vue-g">//вопрос со стандартными кнопками</span>
                Оповещение <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span><span class="vue-bl">"ПослеОтветаНаВопросСоСтандартнымиКнопками"</span>, ЭтотОбъект<span class="vue-r">)</span>; 
                <span class="vue-g">//РежимДиалогаВопрос это системное перечисление, которое позволяет выбрать 
                //надписи на кнопках и их количество. Кнопки можно самом делать</span>
                ПоказатьВопрос<span class="vue-r">(</span>Оповещение, <span class="vue-bl">"Вы хотите удалить этот блок?"</span>, РежимДиалогаВопрос<span class="vue-r">.</span>ДаНет<span class="vue-r">)</span>;


                <span class="vue-g">//вопрос со своими кнопками</span>
                Оповещение <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span><span class="vue-bl">"ПослеОтветаНаВопросСоСвоимиКнопками"</span>, ЭтотОбъект<span class="vue-r">)</span>; 
                <span class="vue-g">//мы хотим создать свои кнопки. Пусть у 1й кнопки будет текст "Создать новый документ" 
                //у 2й "Открыть форму существующего документа" и 3я "Отмена" 
                //чтобы создать эти кнопки будем использовать СписокЗначений</span>
                СписокКнопок <span class="vue-r">= Новый</span> СписокЗначений;
                СписокКнопок<span class="vue-r">.</span>Добавить<span class="vue-r">(</span><span class="vue-bl">"СоздатьНовый"</span>, <span class="vue-bl">"Создать новый документ"</span><span class="vue-r">)</span>;
                СписокКнопок<span class="vue-r">.</span>Добавить<span class="vue-r">(</span><span class="vue-bl">"ОткрытьФорму"</span>, <span class="vue-bl">"Открыть форму существующего документа"</span><span class="vue-r">)</span>;
                СписокКнопок<span class="vue-r">.</span>Добавить<span class="vue-r">(</span><span class="vue-bl">"Отмена"</span>, <span class="vue-bl">"Отмена"</span><span class="vue-r">)</span>;
                ПоказатьВопрос<span class="vue-r">(</span>Оповещение, <span class="vue-bl">"Выберите действие"</span>, СписокКнопок<span class="vue-r">)</span>;
            <span class="vue-r">КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеОтветаНаВопросСоСтандартнымиКнопками<span class="vue-r">(</span>Ответ, Параметры<span class="vue-r">) Экспорт</span> 
                <span class="vue-g">//в Ответ будет лежать разные значения в зависимости от того, кнопки создавали мы или 
                //использовали РежимДиалогаВопрос. Если 2е, то в ответе будет КодВозвратаДиалога</span>
                <span class="vue-r">Если</span> Ответ <span class="vue-r">=</span> КодВозвратаДиалога<span class="vue-r">.</span>Да <span class="vue-r">Тогда</span>
                    Сообщение <span class="vue-r">= Новый</span> СообщениеПользователю;
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Хорошо, удаляем"</span>;
                    Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">()</span>;		
                <span class="vue-r">КонецЕсли;
            КонецПроцедуры  

            &НаКлиенте
            Процедура</span> ПослеОтветаНаВопросСоСвоимиКнопками<span class="vue-r">(</span>Ответ, Параметры<span class="vue-r">) Экспорт</span> 
                <span class="vue-g">//в Ответ теперь будет лежать выбранное значение списка кнопок, 
                //не представлениеЮ а именно значение</span>
                <span class="vue-r">Если</span> Ответ <span class="vue-r">=</span> <span class="vue-bl">"СоздатьНовый"</span> <span class="vue-r">Тогда</span>
                    <span class="vue-g">//делаем что то</span>
                <span class="vue-r">ИначеЕсли</span> Ответ <span class="vue-r">=</span> <span class="vue-bl">"ОткрытьФорму"</span> <span class="vue-r">Тогда</span>
                    <span class="vue-g">//делаем что то</span>
                <span class="vue-r">Иначе</span>
                    <span class="vue-g">//делаем что то</span>		
                <span class="vue-r">КонецЕсли;
            КонецПроцедуры</span></span>
        </pre>
    </div>














    <h3 class="header-style2" id="5">Условный оператор</h3>
    <p>Условный оператор описывается в 1с так:</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">Если</span> <span class="vue-b">логическое выражение</span> <span class="vue-r">Тогда</span>
                Различные команды;
            <span class="vue-r">ИначеЕсли</span> <span class="vue-b">логическое выражение</span> <span class="vue-r">Тогда</span>
                Различные команды;
            <span class="vue-r">Иначе</span>
                Различные команды;
            <span class="vue-r">КонецЕсли;</span>
        </pre>
    </div>







    <h3 class="header-style2" id="5a">Тройной оператор</h3>
    <p>Есть такой оператор, заменяющий в некоторых случаях условный оперратор:</p>
    <div class="code-style">
        <pre>
            //тройной оператор обязательно должен быть в выражении, сам по себе не используется
            Буква = ?(2 >3, "А", "Б"); 
            Сообщить(Буква);// "А"
        </pre>
    </div>








    <h3 class="header-style2" id="6">Циклы</h3>
    <p>В 1С бывает 3 цикла: <b>Цикл Для</b>, <b>Цикл Пока</b> и <b>Для каждого</b>.</p>
    <p><b>Цикл Для</b>. Синтаксис цикла выглядит так:</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">Для</span> <span class="vue-b">Имя</span> <span class="vue-r">=</span> <span class="vue-b">Начальное число</span> <span class="vue-r">По</span> <span class="vue-b">Конечное число</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Команда1<span class="vue-r">();</span></span>
                <span class="vue-b">Команда2<span class="vue-r">();</span></span>
                <span class="vue-r">...</span>
            <span class="vue-r">КонецЦикла;</span>

            <span class="vue-g">//пример</span>
            <span class="vue-r">Для</span> <span class="vue-b">Шаг</span> <span class="vue-r">=</span> <span class="vue-b">1</span> <span class="vue-r">По</span> <span class="vue-b">5</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Сообщить<span class="vue-r">("Круг " + <span class="vue-b">Шаг</span>);</span></span>
            <span class="vue-r">КонецЦикла;</span>
            Вывод: 
                Круг 1
                Круг 2
                Круг 3
                Круг 4
                Круг 5
            <span class="vue-g">//Шаг увеличивается на 1 каждый круг самостоятельно и сравнивается с конечным числом оператором &lt;=</span>
        </pre>
    </div>
    <p><b>Цикл Пока</b>. Команды заключённые между словами Цикл и ЦонецЦикла выполняются пока Логическое выражение равно Истине. Синтаксис цикла выглядит так:</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">Пока</span> <span class="vue-b">Логическое выражение</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Команда1<span class="vue-r">();</span></span>
                <span class="vue-b">Команда2<span class="vue-r">();</span></span>
                <span class="vue-r">...</span>
            <span class="vue-r">КонецЦикла;</span>

            <span class="vue-g">//пример</span>
            <span class="vue-b">Шаг = 1</span>
            <span class="vue-r">Пока</span> <span class="vue-b">Шаг</span> <span class="vue-r">&lt;=</span> <span class="vue-b">5</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Сообщить<span class="vue-r">(<span class="vue-b">Шаг</span>);</span></span>
                <span class="vue-b">Шаг<span class="vue-r"> = </span><>Шаг<span class="vue-r"> + </span>1</span><span class="vue-r">;</span>
            <span class="vue-r">КонецЦикла;</span>
            Вывод: 
                Шаг 1
                Шаг 2
                Шаг 3
                Шаг 4
                Шаг 5
            <span class="vue-g">//этот цикл по своей структуре очень похож на цикл while() из js</span>
            <span class="vue-g">//в этом цикле как я понял уже можно менять и занк сравнения и указывать шагам увеличиваться им или уменьшаться в отличии от первого цикла</span>
        </pre>
    </div>
    <p><b>Цикл для каждого</b>. Этот цикл перебирает все коллекции.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">МассивЧисел <span class="vue-r">= Новый</span> Массив<span class="vue-r">(</span>4<span class="vue-r">);</span></span>
            <span class="vue-b">МассивЧисел[0]<span class="vue-r"> = 9;</span></span>
            <span class="vue-b">МассивЧисел[1]<span class="vue-r"> = "Строка";</span></span>
            <span class="vue-b">МассивЧисел[2]<span class="vue-r"> = Истина;</span></span>
            <span class="vue-b">МассивЧисел[3]<span class="vue-r"> = 23;</span></span>
            <span class="vue-r">Для каждого</span> <span class="vue-b">ЗначениеМассива</span> <span class="vue-r">Из</span> <span class="vue-b">МассивЧисел</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Сообщить<span class="vue-r">(</span>ЗначениеМассива<span class="vue-r">);</span></span>
            <span class="vue-r">КонецЦикла;</span>
            Вывод: 
                9
                Строка
                Да
                23
        </pre>
    </div>






    <h3 class="header-style2" id="string">Тип данных - строки</h3>
    <p>Тут подробно работа со строками - https://helpme1s.ru/stroki-v-yazyke-1s-8-v-primerax</p>
    <p>Чтобы написать имя фирмы вот такое - ООО "Блины со сгущонкой" в строке нужно экранировать двойные кавычки внутри строки, т.к. строка сама по себе обозначается двойными кавычками, то экранирование в 1С происходит также двойными кавычками, вот пример - НазваниеФирмы = "ООО ""Блины со сгущонкой""". Ну по крайней мере с названием фирмы так, как там далее обстоят дела узнаем дальше.</p>
    <p><b>СЛОЖЕНИЕ СО СТРОКОЙ</b> булет только если строка находится слева, справо число преобразуется в строку и строки складываются. Если слева число, а справа строка, то справа строка преобразуется в число. Но если слева число всё же надо сложить со строкой, то приводим число слева к строке и слаживаем - <span class="vue-r">Строка(25)</span> + "10"</p>
    <p><b>Привести к строке число</b> - Число = 12; Стр = <span class="vue-r">Строка(Число)</span>; <span class="vue-r">Сообщить(ТипЗнч(Стр));</span> - Строка</p>
    <p><b>Ввод строки от поль-ля</b> - Строка= ""; <span class="vue-r">ВвестиСтроку(Строка)</span>;</p>
    <p><b>Из чего состоит строка</b> - строка состоит из символов и мы можем обращаться к ним также как и к элементам массива, но у строки обращение к начальному символу начинается не 0, а с 1.</p>
    <p><b>Узнать кол-во символов с строке</b> - Строка = "привет"; <span class="vue-r">СтрДлина(Строка)</span>; вернёт 6, поэтому обходить строку можно в обычном цикле по счётчику.</p>
    <p><b>Получить подстроку в строке</b> - для этого есть не одна функция, вот пример одной из них. Функция <span class="vue-r">Сред(стр, номер, кол-во)</span>; стр - это сама строка из котрой мы получаем подстроку; номер - это начальная позиция символа/ов, который/е хотим получить; кол-во - это кол-во символов, котрое хотим получить. Как я понял, все 3 параметра обязательны.</p>
    <p><b>Что представляет из себя символ</b> - каждому символу соответствует числовое значение, его код. Зачем может понадобится код символа? Ответ - для шифрования и дешифрования текстов. За перевод символа в числовой код отвечает функция <span class="vue-r">КодСимвола(строка, позицияСимвола)</span>. За перевод обратно числовго кода в символ отвечает функция <span class="vue-r">Символ(код)</span></p>
    <p><b>Поиск в строке</b> - чтобы найти подстроку в строке есть функция <span class="vue-r">СтрНайти(строка, подстрока)</span>. параметров в ней больше, но обязательны эти 2. Функция возвращает 0 если позиция не найдена и позицию, если позиция найдена. Функция ищет только первое вхождение подстроки в строку.</p>
    <p><b>Замена в строке</b> - за замену одной подстроки на другую в строке отвечает функция <span class="vue-r">СтрЗаменить(строка, искомаяСтрока, заменяемаяСтрока)</span>. Функция возвращает новую строку, полученную в результате замены, старая строка остаётся неизменной. Если замена не удаласьЮ но возвращается старая строка, насколько я понял. Функция заменяет все вхождения в строку.</p>
    <p><b>Верхний и нижний регистр</b> - строки тут сравниваются через знак равенства =, наверно точно также как и в js. Верхний и нижний регистры имеют разные коды. Чтобы привести строку в разные регистры есть 2 функции - <span class="vue-r">Нрег(строка); - нижний регистр и Врег(строка); - верхний регистр</span>. Потому что разные регистры имеют разные коды, мы не найдём в строке - "какое счастье просыпаться по утрам" слово "Счастье", поэтому мы приводим всё к нижнему регистру и ищем.</p>
    <p>Тут приведено далеко не все функции работы со строками, по ходу дела буду добавлять их сюда с примерами.</p>
    <p>Многострочный режим строки:</p>
    <img src="../img/1С-1/2023-01-25_18-22-20.png" alt="">






    <h3 class="header-style2" id="num">Тип данных - числа</h3>
    <p>Подробнее о <b>числах</b>. Рассмотрим наиболее часто используемые функции для чисел.</p>
    <p>Чтобы убрать минус у числа перемножим это число на -1</p>
    <ul class="list">
        <li><span class="vue-b"><b>Окр(число, разрядность, режим округления)</b></span> - например возмём дробное число 100.384 и округлим до первого дробного знака - Окр(100.384, 1);, получим 100.4, почему 100.4, а не 100.3, потому что округление идёт до ближайшего целого. Есть правило, что когда мы округляем до N знака(в нашем случае 3), то смотрим на N + 1 знак(8) и если он меньше 5, то N знак оставляем как есть, а если >= 5, то увеличиваем на 1.   8 больше 5, значит 3 увеличиваем на 1. Также есть 3й параметр у этой функции - режим округления, по умолчанию стоит Окр15как20(можно обозначать цифрой 1), а кр15как10(можно обозначать цифрой 0). Этот режим будет работат только если после 3 идёт 5, а за 5 стоят все нули, тогда этим режимом можно регулировать в большую или в меньшую округлить 3. Например, Окр(100.350, 1, РежимОкругления.Окр15как20); будет округлено в большую сторону, т.е. получим 100.4, а если Окр(100.350, 1, РежимОкругления.Окр15как10) то коруглится в меньшую сторону - 100.3. Ещё раз внимание. 3й параметр влияет только тогда когда - 1)Округляем до N знака, 2)N + 1 равен 5, 3)а все знаки с N + 2 равны 0.</li>
        <li><span class="vue-b"><b>Цел(100.384);</b></span> - получим целую часть - 100.</li>
        <li><span class="vue-b"><b>Pow(10, 3);</b></span> - возведём число в степень -  получим 1000</li>
        <li><span class="vue-b"><b>Sqrt(25);</b></span> - извлечём квадратный корень из числа -  получим 5</li>
        <li><span class="vue-b"><b>Макс(25, 12, 4, -2);</b></span> - получим наибольшее число - 25</li>
        <li><span class="vue-b"><b>Мин(2, -4, 545, -8)</b></span> - получим наименьшее число - -8</li>
        <li><span class="vue-b"><b>ГСЧ = Новый ГенераторСлучайныхЧисел; Сообщить(ГСЧ.СлучайноеЧисло(0, 2));</b></span> - создание случайного числа от заданных параметров, включая эти параметры.</li>
        <li><span class="vue-b"><b>ЧислоРописью(&lt;Число>, &lt;ФорматнаяСтрока>, &lt;ПараметрыПредметаИсчисления>)</b></span> - формирует представление переданного числа прописью в соответствии с заданными форматной строкой и параметрами предмета исчисления.
        <div class="code-style">
            <pre>
                <span class="vue-g">//форматная строка задаёт параметры, перечисляемые через ;
                //Л - означает код локализации, по умолчанию стоит тот, который в винде
                //ДП - дробную часть выводить прописью если Истина, по умолчанию - Ложь(Числом);
                //остальные параметры в синтакс помошнике</span>
                <span class="vue-b">ФормСтрока <span class="vue-r">=</span> "Л = ru_RU; ДП = Истина"<span class="vue-r">;</span></span>

                <span class="vue-g">//строка ПарПредмета передаёт в падежах название денежной ценности
                //м - мужской род, ж - женский род
                //2 - кол-во разрядов дробной части, по умолчанию 2, можно не указывать</span>
                <span class="vue-b">ПарПредмета <span class="vue-r">=</span> "рубль,рубля,рублей,м,копейка,копейки,копеек,м,2"<span class="vue-r">;</span></span>

                <span class="vue-b">ПрописьЧисла <span class="vue-r">=</span> ЧислоПрописью<span class="vue-r">(</span>2341.56, ФормСтрока, ПарПредмета<span class="vue-r">)</span><span class="vue-r">;</span></span>
                Сообщить(ПрописьЧисла);-> две тысячисорок один рубль пятьдесят шесть копеек

                <span class="vue-g">//ещё пример</span>
                <span class="vue-b">ПрописьЧисла <span class="vue-r">=</span> ЧислоПрописью<span class="vue-r">(</span>123.65<span class="vue-r">)</span><span class="vue-r">;</span></span>
                Сообщить(ПрописьЧисла);-> сто двадцать три 65

                <span class="vue-g">//ещё пример</span>
                <span class="vue-b">ПрописьЧисла <span class="vue-r">=</span> ЧислоПрописью<span class="vue-r">(</span>123.65, "рубль, рубля, рублей, м, копейка, копейки, копеек, ж, 2"<span class="vue-r">)</span><span class="vue-r">;</span></span>
                Сообщить(ПрописьЧисла);-> сто двадцать три рубля 65 копеек
            </pre>
        </div>
        </li>
        <li></li>
        <li></li>
    </ul>








    <h3 class="header-style2" id="date">Тип данных - дата</h3>
    <p>Подробнее о <b>датах</b>.</p>
    <p>Дата во строенном языке должна задаваться так  - '20220405' - год, месяц, день. Также можно продолжить и дописать часы, минуты, секунды.</p>
    <p>К датам можно прибавлять и отнимать. Чтобы прибавить к дате сутки нужно прибавить кол-во секунд. Например, ЗавтрашняяДата = '19610412' + 3600 * 24; или наоборот отнять сутки - ВчерашняяДата = '19610412' - 3600 * 24;</p>
    <p>Даты можно вычитать друг из друга, результатом будет кол-во секунд. Получить из какой то даты количество секунд нельзя, я так понимаю, что тут у дат нету отсчёта от какого то времени. Чтобы вычислить секунды, надо вычислять самостоятельно от какой то даты, например, от текущей даты или от какой то другой даты путём вычитания и сложения.</p>
    <p><b>Текущая дата</b> - </p>
    <div class="code-style">
        <pre>
            <span class="vue-b">Сегодня <span class="vue-r">=</span> ТекущаяДата<span class="vue-r">();</span></span> 
            <span class="vue-b">Сегодня <span class="vue-r">=</span> ТекущаяДата<span class="vue-r">()<span class="vue-b"> + 1</span>;</span></span> <span class="vue-g">// прибавили секунду</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Сегодня<span class="vue-r">);</span></span> <span class="vue-g">// 14.10.2022 18:40:34</span>
        </pre>
    </div>
    <p><b>Получение года, месяца и дня из даты</b> - </p>
    <div class="code-style">
        <pre>
            <span class="vue-b">МояДата<span class="vue-r">=</span> '19610412'<span class="vue-r">;</span></span> 
            <span class="vue-b">Г <span class="vue-r">=</span> Год<span class="vue-r">(</span>МояДата<span class="vue-r">);</span></span><span class="vue-g">// 2013</span> 
            <span class="vue-b">М <span class="vue-r">=</span> Месяц<span class="vue-r">(</span>МояДата<span class="vue-r">);</span></span> <span class="vue-g">// 7</span>
            <span class="vue-b">Д <span class="vue-r">=</span> День<span class="vue-r">(</span>МояДата<span class="vue-r">);</span></span> <span class="vue-g">// 24</span>
            <span class="vue-b">Ч <span class="vue-r">=</span> Час<span class="vue-r">(</span>МояДата<span class="vue-r">);</span></span> <span class="vue-g">// 13</span>
            <span class="vue-b">Ми <span class="vue-r">=</span> Минута<span class="vue-r">(</span>МояДата<span class="vue-r">);</span></span> <span class="vue-g">// 25</span>
            <span class="vue-b">С <span class="vue-r">=</span> Секунда<span class="vue-r">(</span>МояДата<span class="vue-r">);</span></span> <span class="vue-g">// 6</span>
        </pre>
    </div>
    
    <p><b>Добавление месяца к дате</b> - </p>
    <div class="code-style">
        <pre>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>ДобавитьМесяц<span class="vue-r">(</span>ТекущаяДата<span class="vue-r">(),</span> 1<span class="vue-r">));</span></span><span class="vue-g">// прибавили месяц</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>ДобавитьМесяц<span class="vue-r">(</span>ТекущаяДата<span class="vue-r">(),</span> - 1<span class="vue-r">));</span></span><span class="vue-g">// отняли месяц</span>
        </pre>
    </div>

    <p><b>Другие функции</b> - </p>
    <img src="../img/1С-1/2022-10-26_20-25-04.png" class="screen" alt="">

    <p><b>Коструктор Дата()</b> - можно задать дату через встроенный конструктор Дата() - </p>
    <div class="code-style">
        <pre>
            <span class="vue-b">ПервыйДеньЛета <span class="vue-r">=</span> Дата<span class="vue-r">(</span>2022, 06, 01<span class="vue-r">);</span></span> 
            <span class="vue-b">Сообщить<span class="vue-r">(</span>ПервыйДеньЛета<span class="vue-r">);</span></span> <span class="vue-g">// 01.06.2022 00:00:00</span>
        </pre>
    </div>
    <p>Также можно через встроенную функцию ВвестиДату() запросить у пользователя ввод даты.</p>

    <p><b>Переводим строку с датой в дату</b> - </p>
    <div class="code-style">
        <pre>
            <span class="vue-b">МояДата <span class="vue-r">=</span> Дата<span class="vue-r">(</span>"20130724"<span class="vue-r">);</span></span> <span class="vue-g">// 24.07.2013</span>
        </pre>
    </div>

    <p><b>Указываем в дате часы, минуты и секунды</b> - </p>
    <div class="code-style">
        <pre>
            <span class="vue-b">МояДата <span class="vue-r">=</span> '20130724132506'<span class="vue-r">;</span></span> <span class="vue-g">// 24 июля 2013 г. 13 ч. 25 мин. 6 сек</span>
        </pre>
    </div>
    <p></p>















    <h3 class="header-style2" id="array">Тип данных - Массив</h3>
    <img src="../img/1С-1/2022-10-21_10-03-43.png" class="screen" alt="">
    <p>Массив доступен и на клиенте и на сервере.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//если мы объявляем пустой массив, то заполнять его надо через метод Вставить()</span>
            <span class="vue-b">Массив1<span class="vue-r"> = Новый</span> Массив<span class="vue-r">();</span></span>

            <span class="vue-g">//попытаемся обратиться к его первому элементу</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Массив1[0]<span class="vue-r">);</span></span>//<span class="vue-g">Ошибка! Массив пока не содержит элементов</span>

            <span class="vue-g">//добавление в конец массива значения</span>
            <span class="vue-b">Массив1<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Иванов"<span class="vue-r">);</span></span>
            <span class="vue-b">Массив1<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Петров"<span class="vue-r">);</span></span>
            <span class="vue-g">//можно вставить элемент в любое место массива, если вставка между элементами, то
            //вставляемый элемент расталкивает другие элементы, заставляя их передвигаться на новые позиции</span>
            <span class="vue-b">Массив1<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>1, "Сидоров"<span class="vue-r">);</span></span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Массив1[0]<span class="vue-r">);</span></span>//<span class="vue-g">Иванов</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Массив1[1]<span class="vue-r">);</span></span>//<span class="vue-g">Сидоров</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Массив1[2]<span class="vue-r">);</span></span>//<span class="vue-g">Петров</span>

            <span class="vue-g">//мы можем заменить элемент массива на другой, для это есть Установить()</span>
            <span class="vue-b">Массив1<span class="vue-r">.</span>Установить<span class="vue-r">(</span>0, "Николаев"<span class="vue-r">);</span></span>
            <span class="vue-g">//делает то же самое</span>
            <span class="vue-b">Массив1<span class="vue-r">[</span>0<span class="vue-r">] = </span> "Николаев";</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Массив1[0]<span class="vue-r">);</span></span>//<span class="vue-g">Николаев</span>

            <span class="vue-g">//поиск элемента в массиве</span>
            <span class="vue-b">Массив1<span class="vue-r">.</span>Найти<span class="vue-r">(</span>"Иванов"<span class="vue-r">);</span></span>
            <span class="vue-g">//если нашёл, вернёт индекс, если нет - Неопределено</span>

            <span class="vue-g">//получить элемент массива можно через [], а можно через метод Получить(0)</span>

            <span class="vue-g">//есть такой метод как Массив.ВГраница() он означает последний индекс массива</span>
            <span class="vue-g">//это то же самое что Массив.Количество() - 1</span>
            <span class="vue-g">//но если массив пуст, то ВГраница() вернёт -1</span>

            <span class="vue-g">//Удаление элемента из массива</span>
            <span class="vue-b">Индекс = Массив1<span class="vue-r">.</span>Найти<span class="vue-r">(</span>"Иванов"<span class="vue-r">);</span></span>
            <span class="vue-b">Массив1<span class="vue-r">.</span>Удалить<span class="vue-r">(</span>Индекс<span class="vue-r">)</span>;</span>
            
            <span class="vue-g">//если объявляем массив с заранее известным числом элементов, то заполняем так</span>
            <span class="vue-b">МассивРазныхТипов<span class="vue-r"> = Новый</span> Массив<span class="vue-r">(3);</span></span>
            <span class="vue-b">МассивРазныхТипов[0]<span class="vue-r"> = 9;</span></span>
            <span class="vue-b">МассивРазныхТипов[1]<span class="vue-r"> = "Строка";</span></span>
            <span class="vue-b">МассивРазныхТипов[2]<span class="vue-r"> = Истина;</span></span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>МассивРазныхТипов[2]<span class="vue-r">);</span></span>//<span class="vue-g">Да</span>

            <span class="vue-g">//чтобы узнать число элементов в массиве(длину массива)</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>МассивРазныхТипов<span class="vue-r">.</span>Количество<span class="vue-r">()</span><span class="vue-r">);</span></span>//<span class="vue-g">3</span>

            <span class="vue-g">//Очищение массива</span>
            <span class="vue-b">МассивРазныхТипов<span class="vue-r">.</span>Очистить<span class="vue-r">();</span></span>

            <span class="vue-g">//обход массива в цикле</span>
            <span class="vue-g">//в переменную Элемент попадает значение элемента массива, а не ключ</span>
            <span class="vue-b">МассивЧисел <span class="vue-r">= Новый</span> Массив<span class="vue-r">(</span>4<span class="vue-r">);</span></span>
            <span class="vue-b">МассивЧисел[0]<span class="vue-r"> = 9;</span></span>
            <span class="vue-b">МассивЧисел[1]<span class="vue-r"> = "Строка";</span></span>
            <span class="vue-b">МассивЧисел[2]<span class="vue-r"> = Истина;</span></span>
            <span class="vue-b">МассивЧисел[3]<span class="vue-r"> = 23;</span></span>
            <span class="vue-r">Для каждого</span> <span class="vue-b">ЗначениеМассива</span> <span class="vue-r">Из</span> <span class="vue-b">МассивЧисел</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Сообщить<span class="vue-r">(</span>ЗначениеМассива<span class="vue-r">);</span></span>
                <span class="vue-g">//определяем индекс для каждого значения массива</span>
                <span class="vue-b">Индекс = МассивЧисел.Найти(ЗначениеМассива);</span>
            <span class="vue-r">КонецЦикла;</span>
            Вывод: 
                9
                Строка
                Да
                23
        </pre>
    </div>
    <p>Если что то по массивам будет не хватать, то во тут побольше описано - https://helpme1s.ru/massivy-v-yazyke-1s-8-v-primerax</p>
    <p><b>Типовые ошибки массивов</b></p>
    <img src="../img/1С-1/2022-10-21_10-03-43-2.png" class="screen" alt="">
    <p>В первом случае ошибка говорит о том, что нет такого индекса в массиве. И поэтому лучше делать условные проверки на наличии в массиве количество значений, а уже потом делать обращение к массиву, дабы избежать ошибок. Во втором случае похожая картина, но только встречается она когда пытаются удалить из массива несуществующий индекс. И опять же нужно проверять на наличие такого индекса, а потом удалять.</p>















    <h3 class="header-style2" id="structure">Тип данных - Структура(объект)</h3>
    <img src="../img/1С-1/2022-10-21_10-04-58.png" class="screen" alt="">
    <p>Структура доступна и на клиенте и на сервере.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//структура в отличии от массива позволяет использовать строковый ключ
            //именно строковый, никакой больше ключ там не подойдёт. Эта строка должна начинаться со знака _, либо
            //с буквы, и не должна содержать спец. символов: пробелы, запятые и прочее</span>

            <span class="vue-g">//структура как и массив доступна и на клиенте и на сервере</span>    

            <span class="vue-g">//как создать структуру(1й способ)</span>
            <span class="vue-b">ЛичныеДанные<span class="vue-r"> = Новый</span> Структура<span class="vue-r">;</span></span>
            <span class="vue-b">ЛичныеДанные<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>"Фамилия", "Иванов"<span class="vue-r">);</span></span>
            <span class="vue-b">ЛичныеДанные<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>"Имя", "Иван"<span class="vue-r">);</span></span>
            <span class="vue-b">ЛичныеДанные<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>"ДатаРождения", '19800802'<span class="vue-r">);</span></span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>ЛичныеДанные<span class="vue-r">.</span>Фамилия<span class="vue-r">);</span></span>//<span class="vue-g">Иванов</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>ЛичныеДанные<span class="vue-r">[</span>"Фамилия"<span class="vue-r">]);</span></span>//<span class="vue-g">Иванов</span>


            <span class="vue-g">//как создать структуру(2й способ)</span>
            <span class="vue-b">Время<span class="vue-r"> = Новый</span> Структура<span class="vue-r">(</span>"Часы,Минуты,Секунды", 12, 45, 33<span class="vue-r">);</span></span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>"Время " <span class="vue-r">+</span> Время<span class="vue-r">.</span>Часы<span class="vue-r"> + <span class="vue-b">":"</span> + </span>Время<span class="vue-r">.</span>Минуты<span class="vue-r">);</span></span>//<span class="vue-g">Время 12:45</span>



            <span class="vue-g">//как создать структуру(3й способ)</span>
            <span class="vue-b">Человек<span class="vue-r"> = Новый</span> Структура<span class="vue-r">("Фамилия, Имя, Отчество");</span></span>
            <span class="vue-g">//заполняем эти свойства</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Фамилия<span class="vue-r"> = </span>"Пупкин"</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Имя<span class="vue-r"> = </span>"Василий"</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Отчество<span class="vue-r"> = </span>"Иванович"</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Человек<span class="vue-r">.</span>Отчество<span class="vue-r">);</span></span>//<span class="vue-g">Иванович</span>


            <span class="vue-g">//перезапись значения поля "Фамилия"(1й способ)</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>"Фамилия", "Сидоров"<span class="vue-r"></span>);</span></span>
            
            
            <span class="vue-g">//перезапись значения поля "Фамилия"(2й способ</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Фамилия<span class="vue-r"> = </span>"Сидоров"</span>
            <span class="vue-b">Человек<span class="vue-r">[</span>"Фамилия"<span class="vue-r">] = </span>"Сидоров"</span>



            <span class="vue-g">//узнаём количество свойств в структуре</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Человек<span class="vue-r">.</span>Количество()<span class="vue-r">);</span></span>//<span class="vue-g">4</span>




            <span class="vue-g">//ищем в структуре по ключу наличие значения этого ключа, возвращает булево значение</span>
            <span class="vue-g">//и если что то по ключу нашёл, то записывает значение этого ключа в переменную НайденноеЗначение</span>
            <span class="vue-b">НайденноеЗначение <span class="vue-r">=</span> Неопределено<span class="vue-r">;</span></span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Свойство<span class="vue-r">(</span>"Имя", НайденноеЗначение<span class="vue-r">);</span></span>//<span class="vue-g">Да</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>НайденноеЗначение<span class="vue-r">);</span></span>//<span class="vue-g">Василий</span>
            <span class="vue-g">//говорят, что этот способ хорош для получения значения свойства по ключу, потому как</span>
            <span class="vue-g">//если по ключу ничего не будет, то ошибки не будет, просто в НайденноеЗначение запишется Неопределено</span>
            <span class="vue-g">//а вот если получать значение так Человек.Фамилия или так Человек["Фамилия"], то если по ключу ничего нет</span>
            <span class="vue-g">//то выдаст ошибку и надо будет делать дополнительные проверки</span>
            <span class="vue-g">//но на практике всё же чаще пользуются получением через точку и скобки</span>



            <span class="vue-g">//очищаем структуру польностью</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Очистить<span class="vue-r">();</span></span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Человек<span class="vue-r">.</span>Количество()<span class="vue-r">);</span></span>//<span class="vue-g">0</span>



            <span class="vue-g">//удаляем свойство из структуры</span>
            <span class="vue-b">Человек<span class="vue-r">.</span>Удалить<span class="vue-r">(</span>"Отчество"<span class="vue-r"></span>);</span></span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Человек<span class="vue-r">.</span>Отчество<span class="vue-r">);</span></span>//<span class="vue-g">Ошибка! Поле объекта не обнаружено</span>


            <span class="vue-g">//обход элементов структуры в цикле</span>
            <span class="vue-g">//заметим, что в переменную Элемент попадает не значение элемента структуры, а объект</span>
            <span class="vue-g">//у которого есть 2 свойства - Ключ и Значение и вызваем то что нам нужно</span>
            <span class="vue-b"><span class="vue-r">Для Каждого</span> Элемент <span class="vue-r">Из</span> ЛичныеДанные <span class="vue-r">Цикл</span></span>
                <span class="vue-b">Сообщить<span class="vue-r">(</span>Элемент<span class="vue-r">.</span>Ключ <span class="vue-r">+</span> " " <span class="vue-r">+</span> Элемент<span class="vue-r">.</span>Значение</span><span class="vue-r">);</span></span>
            <span class="vue-r">КонецЦикла;</span>
        </pre>
    </div>
    <p><b>Типовые ошибки связанные со структурой</b>.</p>
    <img src="../img/1С-1/2022-10-21_10-04-58-2.png" class="screen" alt="">
    <p><b>В первом случае</b> ошибка возникает при неправильном имени ключа, например, назвали "1Сотрудник", это неправильно, потому что первыми символами должны быть буквы или подчёркивания, имя не должно начинаться с цифр. Приведём пример, часто бывает нужно перевести данные из одной коллекции в другую. Переведём данные из массива в структуру, массив содержит набор чисел:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">
            МассивЧисел = Новый Массив;
            Для Число = 1 По 2000 Цикл
                МассивЧисел.Добавить(Число);
            КонецЦикла;

            СтруктураЧисел = Новый Структура;
            Для каждого Элемент Из МассивЧисел Цикл
                ИмяКлюча = "Число_" + МассивЧисел.Найти(Элемент);
                СтруктураЧисел.Вставить(ИмяКлюча, Элемент);
            КонецЦикла; 
            </span>
        </pre>
    </div>
    <p>Вроде бы всё правильно и должны получить структуру вида: "Число_0: 1", "Число_1: 2", "Число_2: 3" и т.д., но будет ошибка из первого случая, потому что подойдя до 1000 система автоматом разделяет такие числа по 3 символа пробелами и на этом числе у нас будет имя ключа такое - "Число_1 000", а пробелы недопустимы в имени. Исправить ошибку можно форматом чисел, который убирает эти пробелы - Формат(МассивЧисел.Найти(Элемент), "ЧГ=0").</p>
    <p>Представим мы не знаем в чём проблема и на каком круге цикла вознакает проблема. Нам может помочь такая конструкция языка как Попытка ... Исключение. Мы в Попытка вставляем код, где в структуру добавляются ключи с значениями и если добавление какого то ключа вдруг вызовет ошибку, то конструкция сразу перейдёт к выполнению кода в Исключение:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">
            МассивЧисел = Новый Массив;
            Для Число = 1 По 2000 Цикл
                МассивЧисел.Добавить(Число);
            КонецЦикла;

            СтруктураЧисел = Новый Структура;
            Для каждого Элемент Из МассивЧисел Цикл
                ИмяКлюча = "Число_" + МассивЧисел.Найти(Элемент);
                Попытка
                    СтруктураЧисел.Вставить(ИмяКлюча, Элемент);
                Исключение
                    Сообщить(МассивЧисел.Найти(Элемент));
                КонецПопытки;
            КонецЦикла; 
            </span>
        </pre>
    </div>
    <p>Этот код начнёт нам выдавать сообщения начиная с 1 000</p>
    <p><b>Ну и второй случай</b> это когда обращаемся к ключу, которого нет, а занчит опять же нужно делать проверки.</p>
















    <h3 class="header-style2" id="accordance">Соответствие(Map)</h3>
    <img src="../img/1С-1/2022-10-21_10-05-59.png" class="screen" alt="">
    <p>В отличии от Структуры в коллекции Соответствие в ключах можно использовать любые типы данных(число, строка, дата, ссылка и т.д.). Дата и ссылка частые ключи для соответствия. Даже в ключе можно использовать строку внутри с пробелами, чего нельзя делать в ключе Структуры. Точно также как и массив и структура, соответствие доступно и на клиенте и на сервере. В Соответствии тяжелей получить ошибку в работе с элементами.</p>
    <p><b>Создание Соответствия</b>. В отличии от Массива и Структуры создание Соответствия происходит одним способом указаном ниже в примере.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СоответствиеРазмеров <span class="vue-r">= Новый</span> Соответствие;</span>
        </pre>
    </div>
    <p><b>Вставить ключ с значением</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СоответствиеРазмеров <span class="vue-r">.</span>Вставить<span class="vue-r">(</span>36, "XS"<span class="vue-r">);</span></span>
            <span class="vue-b">СоответствиеРазмеров <span class="vue-r">.</span>Вставить<span class="vue-r">(</span>38, "S"<span class="vue-r">);</span></span>
            <span class="vue-b">СоответствиеРазмеров <span class="vue-r">.</span>Вставить<span class="vue-r">(</span>40, "М"<span class="vue-r">);</span></span>
        </pre>
    </div>
    <p><b>Количество элементов</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">КоличествоЭлементов <span class="vue-r">=</span> СоответствиеРазмеров<span class="vue-r">.</span>Количество<span class="vue-r">();</span></span>
        </pre>
    </div>
    <p><b>Получить элемент</b>. Если элемент не найден по ключу, то вернёт Неопределено. Желательно делать проверку на Неопределено и выводить уже затем ответ. Ошибки не будет, если по ключу ничего не найдено.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">Размер36 <span class="vue-r">=</span> СоответствиеРазмеров<span class="vue-r">.</span>Получить<span class="vue-r">(</span>36<span class="vue-r">);</span><span class="vue-g">// XS</span>
            <span class="vue-r">Если</span> Размер36 <span class="vue-r">&lt;></span> Неопределено <span class="vue-r">Тогда</span>
                Сообщить<span class="vue-r">(</span>Размер36<span class="vue-r">)</span>;
            <span class="vue-r">КонецЕсли;</span></span>
            <span class="vue-g">//или</span>
            <span class="vue-b">Размер40 <span class="vue-r">=</span> СоответствиеРазмеров<span class="vue-r">[</span>40<span class="vue-r">];</span></span><span class="vue-g">// M</span>
        </pre>
    </div>
    <p><b>Изменить элемент</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СоответствиеРазмеров<span class="vue-r">[</span>40<span class="vue-r">] =</span> "MM"<span class="vue-r">;</span></span>
        </pre>
    </div>
    <p><b>Обход элементов</b>. Из за того что в ключе могут быть любые типы, то при сложении со строкой ключа следует перерд ним указать строку - ("" +) или ключ привести к строке. Тут также как и в структуре в переменную Элемент попадает тип КлючИЗначение, т.е. содержит и ключ и значение.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><span class="vue-r">Для Каждого</span> Элемент <span class="vue-r">Из</span> СоответствиеРазмеров <span class="vue-r">Цикл</span></span>
                <span class="vue-b">Сообщить<span class="vue-r">(</span>"" + Элемент<span class="vue-r">.</span>Ключ <span class="vue-r">+</span> " " <span class="vue-r">+</span> Элемент<span class="vue-r">.</span>Значение</span><span class="vue-r">);</span></span>
            <span class="vue-r">КонецЦикла;</span>
        </pre>
    </div>
    <p><b>Удалить элемент</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СоответствиеРазмеров<span class="vue-r">.</span>Удалить<span class="vue-r">(</span>36<span class="vue-r">);</span></span>
        </pre>
    </div>
    <p><b>Очистить коллекцию</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СоответствиеРазмеров<span class="vue-r">.</span>Очистить<span class="vue-r">(</span><span class="vue-r">);</span></span>
        </pre>
    </div>
    <p><b>Узнать тип коллекции</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><span class="vue-r">Если</span> ТипЗнч<span class="vue-r">(</span>СоответствиеРазмеров<span class="vue-r">)</span> <span class="vue-r">=</span> Тип<span class="vue-r">(</span>"Соответствие"<span class="vue-r">)</span> <span class="vue-r">Тогда</span>
                Сообщить<span class="vue-r">(</span><span style="color:black;">"Это коллекция Соответствие"</span><span class="vue-r">)</span>;
            <span class="vue-r">КонецЕсли;</span></span>
        </pre>
    </div>
    <p>Если тут также обратиться к ключу, которого нет в соответствии, как и в структуре, то ошибки тут не будет, в отличии от структуры. Просто выведет пустое значение, а тип будет Неопределено.</p>














    <h3 class="header-style2" id="list">Тип данных - Список значений</h3>
    <img src="../img/1С-1/2022-10-21_10-01-13.png" class="screen" alt="">
    <p>Если чего то тут нет, может будет тут - https://helpme1s.ru/spisok-znachenij-v-yazyke-1s-8-v-primerax</p>
    <p>Список значений уместно использовать вместо массива в случаях, когда требуется взаимодействие с пользователем в части выбора элементов из этого списка в окне и если требуются какие-то особые возможности(например, сортировка). Доступен и на клиенте и на сервере. Так как он нужен и для работы с пользователем, то тогда надо использовать на клиенте.</p>
    <p><b>Создание списка</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СписокДней<span class="vue-r"> = Новый</span> СписокЗначений<span class="vue-r">;</span></span>
        </pre>
    </div>
    <p><b>Добавлениеи и вставка элементов</b>. При добавлении элемент ставится в конец списка, при вставке по индексу элементы справа сдвигаются вправо. Важно также помнить, что в ключах у списка мы тоже можем писать разные типы данных.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>Значение, Представление, Пометка, Картинка<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>Индекс, Значение, Представление, Пометка, Картинка<span class="vue-r">);</span></span>

            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Пн", "Понедельник"<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Вт", "Вторник"<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Ср", "Среда"<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Чт", "Четверг"<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Пт", "Пятница"<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Сб", "Суббота"<span class="vue-r">);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Вс", "Воскресенье"<span class="vue-r">);</span></span>
        </pre>
    </div>
    <p>Вот так выглядить список занчений в отладчике, который мы только создали:</p>
    <img src="../img/1С-1/2023-01-17_13-44-56.png" class="screen" alt="">
    <p><b>Добавление картинки</b>.</p>
    <p>Чтобы добавить картинку будем пользоваться стандартными картинками, которые можно получить из глобального подтекста через объект <span class="vue-b">БибилиотекаКартинок</span>. Ставим точку после этого объекта и нам вылетет целый список с названиями стандартных картинок:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗапуститьСписокЗначений(Команда)
                СписокДней = Новый СписокЗначений;
                СписокДней.Добавить("Пн", "Понедельник", , БиблиотекаКартинок.АктивироватьЗадачу);
                СписокДней.Добавить("Вт", "Вторник", , БиблиотекаКартинок.БизнесПроцесс);
                СписокДней.Добавить("Ср", "Среда", , БиблиотекаКартинок.АктивныеПользователи);
                СписокДней.Добавить("Чт", "Четверг", , БиблиотекаКартинок.БизнесПроцессОбъект);
                СписокДней.Добавить("Пт", "Пятница", , БиблиотекаКартинок.ВводНаОсновании);
                СписокДней.Добавить("Сб", "Суббота", , БиблиотекаКартинок.ВидРасчета);
                СписокДней.Добавить("Вс", "Воскресенье", , БиблиотекаКартинок.ВложеннаяТаблица); 
                
                ВыбранныйЭлемент = СписокДней.ВыбратьЭлемент("Выберите день");
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2023-01-18_10-16-24.png" alt="">
    <p><b>Количество элементов</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">КоличествоЭлементов <span class="vue-r">=</span> СписокДней<span class="vue-r">.</span>Количество<span class="vue-r">();</span></span>
        </pre>
    </div>
    <p><b>Поиск элементов</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>НайтиПоЗначению<span class="vue-r">(</span>"Пн"<span class="vue-r">);</span></span><span class="vue-g">// ЭлементСпискаЗначений</span>
            <span class="vue-g">// ЭлементСпискаЗначений это как бы объект, который содержит все поля выбранного элемента</span>
            <span class="vue-g">// это и индекс и значение и представление и пометка и картинка</span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>НайтиПоИдентификатору<span class="vue-r">(</span>2<span class="vue-r">);</span></span><span class="vue-g">// ЭлементСпискаЗначений</span>

            <span class="vue-g">// если вывести через Сообщить() или ОткрытьЗначение(), то автоматом будет </span>
            <span class="vue-g">// вызвано свойство Представление и мы увидим Понедельник в 1м случае и Среда во втором</span>
        </pre>
    </div>
    <p><b>Получение элементов</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Получить<span class="vue-r">(3);</span></span><span class="vue-g">// Четверг</span>
            <span class="vue-b">СписокДней<span class="vue-r">[</span>3<span class="vue-r">];</span></span><span class="vue-g">// Четверг</span>
            <span class="vue-b">СписокДней<span class="vue-r">[</span>3<span class="vue-r">].</span>Значение<span class="vue-r">;</span></span><span class="vue-g">// Чт</span>
        </pre>
    </div>
    <p><b>Обход в цикле</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">Для каждого</span> <span class="vue-b">Элемент</span> <span class="vue-r">Из</span> <span class="vue-b">СписокДней</span> <span class="vue-r">Цикл</span>
                    <span class="vue-b">Сообщить<span class="vue-r">(</span>Элемент<span class="vue-r">.</span>Значение<span class="vue-r">);</span></span>
                    <span class="vue-b">Сообщить<span class="vue-r">(</span>Элемент<span class="vue-r">.</span>Представление<span class="vue-r">);</span></span>
                    <span class="vue-b">Сообщить<span class="vue-r">(</span>Элемент<span class="vue-r">.</span>Пометка<span class="vue-r">);</span></span>
                    <span class="vue-b">Сообщить<span class="vue-r">(</span>Элемент<span class="vue-r">.</span>Картинка<span class="vue-r">);</span></span>
            <span class="vue-r">КонецЦикла;</span>
        </pre>
    </div>
    <p>В обычном массиве в переменной Элемент лежали бы сразу значения элемента, но в списке значений в переменной Элемент лежит объект с полями(Значение(может иметь произвольный тип) и Представление(тип Строка)), Пометка и Картинка.</p>
    <p><b>Метод ВыбратьЭлемент для выбора одного значения</b>. В этом и состоит главное отличие от массива. Это делает список значений удобным для взаимодействия с пользователем. Список с помощью метода ВыбратьЭлемент() выводит пользователю окно со списком событий описанных в сво-ве Представление(2й парметр при добавлении события), выбирая событие метод возвращает объект с типом "ЭлементСпискаЗначений" или возвращает Неопределено при отмене:</p>
    <div class="code-style">
        <pre>
            Список = Новый СписокЗначений;
            Список.Добавить(1861, "Отмена рабства");
            Список.Добавить(1961, "Полёт в космос");

            <span class="vue-r">//при использовании модальности в конфигурации</span>
            ВыбранныйЭлемент = <span class="vue-b">Список<span class="vue-r">.</span>ВыбратьЭлемент<span class="vue-r">(</span>"Выберите событие"<span class="vue-r">);</span></span>

            Если ВыбранныйЭлемент &lt;> Неопределено Тогда
                Сообщить("Это событие произошло в " + ВыбранныйЭлемент.Значение);
            КонецЕсли;

            //<span class="vue-g">ответом при выборе одного из событий будет год, но год выведется так - 1 961, это из за форматирования чисел по умолчанию, 1С ставит пробел через каждые 3 разряда, начиная справа</span>
            //<span class="vue-g">можно исправить так</span>
            Если ВыбранныйЭлемент &lt;> Неопределено Тогда
                Сообщить("Это событие произошло в " + Формат(ВыбранныйЭлемент.Значение, "ЧГ=0"));
            КонецЕсли;


            <span class="vue-r">//при НЕ использовании модальности у конфигурации</span>
            <span class="vue-g">//что тут ниже просиходит можно посмотреть в этом видео https://www.youtube.com/watch?v=RU2LyuhgWNo&t=3526s с 01:23:00</span>
            ЧтоДелатьПослеВыбора = Новый ОписаниеОповещения("ПослеВыбораЗначения", ЭтотОбъект);
            ВыбранныйЭлемент = Список.ПоказатьВыборЭлемента(ЧтоДелатьПослеВыбора, "Выберите событие");

            <span class="vue-g">//эта процедура выполнится если запущен способ при НЕ использовании модальности у конфигурации</span>
            &НаКлиенте
            Процедура ПослеВыбораЗначения(ВыбранныйЭлемент, ДополнительныеПараметры)
                Если ВыбранныйЭлемент = Неопределено Тогда
                    Возврат;
                КонецЕсли;
                Сообщить("Это событие случилось в " + ВыбранныйЭлемент + " году");
            Конецпроцедуры
        </pre>
    </div>
    <p><b>Метод ОтметитьЭлементы() для выбора нескольких элементов</b>. </p>
    <div class="code-style">
        <pre>
            <span class="vue-r">//этот модальный</span>
            <span class="vue-g">//для выбора нескольких элементов из списка пользователю предоставляет метод ОтметитьЭлементы()
            //очень важно!!! метод ОтметитьЭлементы() не возвращает список отмеченных элементов
            //он возвращает булево значение - Истина, если отмечен хоть 1 элемент и Ложь при не отмеченных или Отмене
            //но перебирать же что то надо, чтобы понять что выбрано, а перебирать будем наш Список
            //при переборе проверяем Элемент.Пометка, вот в этом сво-ве и будет стоять пометка выбран он или нет</span>
            ВыбранныеЭлементы = Список.ОтметитьЭлементы("Выберите несколько событий");
            ГодаВыбранныхСобытий = "";
            Если ВыбранныеЭлементы &lt;> Неопределено Тогда
                Для каждого Элемент из Список Цикл
                    Если Элемент.Пометка Тогда							
                        ГодаВыбранныхСобытий = ГодаВыбранныхСобытий + Элемент.Значение + " ";		
                    КонецЕсли;		
                КонецЦикла;
                Сообщить("Выбранные события случились в " + ГодаВыбранныхСобытий + " годах");
            КонецЕсли;


            <span class="vue-r">//а это не модальный</span>
            <span class="vue-g">//ЧтоДелатьПослеОтметки = Новый ОписаниеОповещения("ПослеОтметкиЗначения", ЭтотОбъект);
            //ВыбранныйЭлемент = Список.ПоказатьВыборЭлемента(ЧтоДелатьПослеОтметки, "Выберите несколько событий");</span>
            &НаКлиенте
            Процедура ПослеОтметкиЗначения(Список, ДополнительныеПараметры)
                Если Список = Неопределено Тогда
                    Возврат;
                КонецЕсли;
                ГодаВыбранныхСобытий = "";
                Для каждого Элемент из Список Цикл
                    Если Элемент.Пометка Тогда							
                        ГодаВыбранныхСобытий = ГодаВыбранныхСобытий + Элемент.Значение + " ";		
                    КонецЕсли;		
                КонецЦикла;
                Сообщить("Выбранные события случились в " + ГодаВыбранныхСобытий + " годах");
            Конецпроцедуры

        </pre>
    </div>
    <p><b>Удаление и очищение элементов</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Удалить<span class="vue-r">(2);</span></span>
            <span class="vue-b">СписокДней<span class="vue-r">.</span>Очистить<span class="vue-r">();</span></span>
        </pre>
    </div>
    <p>Так выглядит список значений у пользователя:</p>
    <img src="../img/1С-1/2023-01-18_09-17-58.png" class="screen" alt="">

    <p><b>Список значений можно использовать в качестве реквизита формы</b>.</p>
    <p>Это нужно, чтобы пользователь видел сам этот список у себя в 1с предприятии. Сделаем, например, форму у любого прикладного объекта, у той же внешней обработки и создадим у него реквизит "ДниНедели" с типом "Список значений". После этого сразу реквизит станет списком со своими свойствами, можно нажать на "+" и посмотреть свойства. Перенесём этот реквизит в элементы формы слева куда нам надо и система спросит нас как отображать этот список: таблицей или полем. Выберем сначало Таблица. Видим появиласт таблица похожая на табличную часть с 2мя кнопками "Добавить" и "Подбор". Кнопка "Добавить" понятно что делает, добавляет новое значение, а кнопка "Подбор" будет работать только если у нас есть значения ссылочного типа, когда нужно будет подобрать значения из справочника, документов и т.д. Также можно перетащить ещё раз этот реквизит, теперь уже в виде поля.В поле спрва будет кнопка с ..., по нажатию на которую откроется список со значениями и можно выбирать их там.</p>
    <p>Если в пользовательской части попробовать добавить значение, то выведется список типов нового значения из него выбираем какой тип нам нужен, а можно в форме реквизиту зразу задать "Тип значения" какой нам нужен, например выбор из какого-нибудь справочника(СправочникСсылка.Имя). Тепер при добавлении значения откроется список элементов из установленного справочника. И теперь кнопка "Подбор" также заработае, она позволяет не закрывая справочник выбирать много элементов тыкая по ним и они один за другим добавляются в наш список значений. Вот показан один из способов заполнить список значений, можно заполнять список и программно.</p>
    
    <p><b>Умеет сортировать</b>. Список может сам отсортировать свои значения - <span class="vue-b">Список.СортироватьПоЗначению(НаправлениеСортировки.Возр/НаправлениеСортировки.Убыв);</span>. Как я заметил отсортируются по возрастанию лет, указанных 1м параметром при добавлении. В случае с обычным массивом нам бы пришлось делать сортировку по алгоритму "пузырёк".</p>
    <p><b>Умеет искать</b>. Также как и массив, список умеет сам искать свои элементы. Например, мы хотим выяснить, присутствует ли введёное пользователем число в нашем списке:</p>
    <div class="code-style">
        <pre>
            Список = Новый СписокЗначений;
            Список.Добавить(1861, "Отмена рабства");
            Список.Добавить(1961, "Полёт в космос");

            Число = 0;
            ВвестиЧисло(Число);

            <span class="vue-b"></span>НайденныйЭлемент <span class="vue-r">=</span> Список<span class="vue-r">.</span>НайтиПоЗначению<span class="vue-r">(</span>Число<span class="vue-r">);</span></span>

            Если <span class="vue-b">НайденныйЭлемент</span> = <span class="vue-r">Неопределено</span> Тогда
                ОткрытьЗначение("Список не содержит такое число");
            Иначе
                ОткрытьЗначение("Число " + Число + " присутствует в списке. Вот оно: " + <span class="vue-b">НайденныйЭлемент<span class="vue-r">.</span>Значение</span>);
            КонецЕсли;
        </pre>
    </div>
    <p><b>Поддерживает вставку и удаление</b>. Список также как и массив поддерживает вставку и удаление элементов:</p>
    <div class="code-style">
        <pre>
            //<span class="vue-g">втавляем 1000 в начало списка</span>
            <span class="vue-b">Список<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>0, 1000<span class="vue-r">);</span></span>

            //<span class="vue-g">и тут же удаляем её из списка</span>
            <span class="vue-b">Список<span class="vue-r">.</span>Удалить<span class="vue-r">(</span>0<span class="vue-r">);</span></span>

            //<span class="vue-g">вставляем 13 в конец списка</span>
            <span class="vue-b">Список<span class="vue-r">.</span>Вставить<span class="vue-r">(</span>Список<span class="vue-r">.</span>Количество<span class="vue-r">(), </span>13<span class="vue-r">);</span></span>

            //<span class="vue-g">выводим последний элемент списка</span>
            <span class="vue-b">Сообщить<span class="vue-r">(</span>Список<span class="vue-r">[</span>Список<span class="vue-r">.</span>Количество<span class="vue-r">()</span> - 1<span class="vue-r">]</span><span class="vue-r">);</span></span>
        </pre>
    </div>
    <p><b>Поддерживает квадратные скобки</b>. Нумерация элементов списка также идёт с нуля и мы можем обратиться к любому элементу по его индексу через квадратные скобки:</p>
    <div class="code-style">
        <pre>
            Сообщить(Список[1].Значение);

            //мы также можем пробежаться по элемента списка через цикл для:
            Для А = 0 По Список.Количество() - 1 Цикл
                Сообщить(Список[А].Значение);
            КонецЦикла;
        </pre>
    </div>
    <p><b>Умеет создавать свою копию</b>. У списка значений есть просто отличная возвожность создавать свою копию.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">КопияСписка <span class="vue-r">=</span> Список<span class="vue-r">.</span>Скопировать<span class="vue-r">();</span></span>

            //<span class="vue-g">теперь у нас есть копия КопияСписка, мы можем делать с ней что хотим, при этом оригинал не изменится</span>
        </pre>
    </div>
    <p><b>Умеет превращаться в массив</b>. Ну и наконец мы можем легко выгрузить все значения элементов списка в массив:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">МассивЧисел <span class="vue-r">=</span> Список<span class="vue-r">.</span>ВыгрузитьЗначения<span class="vue-r">();</span></span>
            //<span class="vue-g">теперь МассивЧисел является массивом</span
        </pre>
    </div>
    <p><b>Использование списка значений на форме, начинается в видео с 01:35:00</b></p>











    
    <h3 class="header-style2" id="table">Таблица занчений</h3>
    <img src="../img/1С-1/2023-01-18_11-16-33.png" class="screen" alt="">
    <p>Таблица значений используется в том случае если нужно в коде работать с табличными данными. Например, запрос к виртуальной таблице остатков товаров вернёт таблицу с типом "ТаблицаЗначений" и т.д.</p>
    <p>При создании таблицы значений нужно определить какие колонки в этой таблице будут. Имя колонки указываются в виде строки. У каждой строки есть индекс, а в значениях колонок может быть произвольный тип данных. Таблица значений как коллекция довольна тяжела в смысле использования ею ресурсов компьютера, поэтому она <b>не доступна на клиенте</b>, поэтому когда я для тренировки создавал внешнюю обработку с формой и на форме размещал кнопку для запуска примеров с таблицей значений, то действие для этой кнопки будет процедура на клиенте с запуском процедуры на сервере. Таблица значений это как массив содержащий структуры. Рассмотрим как работать с таблицей значений.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗапуститьТаблицуЗначений(Команда)
                ЗапуститьТаблицуЗначенийНаСервере();
            КонецПроцедуры


            &НаСервере
            Процедура ЗапуститьТаблицуЗначенийНаСервере()
                <span class="vue-g">//тут будет весь код по созданию таблицы</span>
            КонецПроцедуры
        </pre>
    </div>
    <p>Будем создавать таблицу с товарами, в которой будут поля Артикул, Наименование, Количество, ЦенаЗакупки, ЦенаПродажи и Сумма.</p>

    <p><b>Создаём таблицу значений</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r"> = Новый</span> ТаблицаЗначений<span class="vue-r">;</span></span>
        </pre>
    </div>

    <p><b>Добавляем колонки таблицы</b>. У созданной таблицы есть свойство Колонки, это свойство содержит коллекцию колонок данной таблицы(что то типо набора записей у регистра). Эта коллекция колонок имеет ряд методов работы с колонками. Нам нужно добавить колонки:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//все параметры метода Добавить необязательны</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>&lt;Имя>,&lt;Тип>,&lt;Заголовок>,&lt;Ширина><span class="vue-r">)</span>;</span>

            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Группа"<span class="vue-r">)</span>;</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Артикул"<span class="vue-r">)</span>;</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Наименование"<span class="vue-r">)</span>;</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Количество"<span class="vue-r">)</span>;</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"ЦенаЗакупки"<span class="vue-r">)</span>;</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"ЦенаПродажи"<span class="vue-r">)</span>;</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Колонки<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Сумма"<span class="vue-r">)</span>;</span>
        </pre>
    </div>
    <p><span class="vue-r">Важно!!!</span>. Для колнок также обязательно нужно установить 2м параметром тип колонок, как это делать описано <a href="#typeColumn">ниже</a>.</p>

    <p><b>Добавляем/вставляем элементы(строки) в таблицу значений</b>. Метод Добавить() добавляет строку в конец таблицы, не имеет параметров и возвращает объект с типом "СтрокаТаблицыЗначений"</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//добавляем первую строку</span>
            <span class="vue-b">НоваяСтрока <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Добавить<span class="vue-r">(</span><span class="vue-r">)</span>;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Группа <span class="vue-r">=</span> "Компьютерные комплектующие";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Артикуль <span class="vue-r">=</span> "А12344";</span> <span class="vue-g">//или</span> <span class="vue-b">НоваяСтрока<span class="vue-r">[</span>"Артикуль"<span class="vue-r">]</span> <span class="vue-r">=</span> "А12344";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Наименование <span class="vue-r">=</span> "Мышь Logitec";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Количество <span class="vue-r">=</span> 3;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>ЦенаЗакупки <span class="vue-r">=</span> 120;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>ЦенаПродажи <span class="vue-r">=</span> 350;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Сумма <span class="vue-r">=</span> 1050;</span>

            <span class="vue-g">//добавляем вторую строку</span>
            <span class="vue-b">НоваяСтрока <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Добавить<span class="vue-r">(</span><span class="vue-r">)</span>;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Группа <span class="vue-r">=</span> "Компьютерные комплектующие";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Артикуль <span class="vue-r">=</span> "А32112";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Наименование <span class="vue-r">=</span> "Клавиатура Logitec";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Количество <span class="vue-r">=</span> 1;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>ЦенаЗакупки <span class="vue-r">=</span> 2000;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>ЦенаПродажи <span class="vue-r">=</span> 4500;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Сумма <span class="vue-r">=</span> 4500;</span>

            <span class="vue-g">//добавляем третью строку</span>
            <span class="vue-b">НоваяСтрока <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Добавить<span class="vue-r">(</span><span class="vue-r">)</span>;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Группа <span class="vue-r">=</span> "Микрофоны";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Артикуль <span class="vue-r">=</span> "Б36712";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Наименование <span class="vue-r">=</span> "Микрофон Rode NT-32";</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Количество <span class="vue-r">=</span> 2;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>ЦенаЗакупки <span class="vue-r">=</span> 3000;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>ЦенаПродажи <span class="vue-r">=</span> 5500;</span>
            <span class="vue-b">НоваяСтрока<span class="vue-r">.</span>Сумма <span class="vue-r">=</span> 11000;</span>

            <span class="vue-g">//добавление строк конечно нужно делать в цикле</span>
        </pre>
    </div>

    <p><b>Получение количества элементов(строк) в таблице значений</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">КоличествоСтрок <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Количество<span class="vue-r">(</span><span class="vue-r">)</span>;</span>
        </pre>
    </div>

    <p><b>Поиск элемента/элементов(строки/строк) в таблице значений</b>. Для этого есть 2 метода Найти(&lt;Значение>, &lt;Колонки>), который ищет один элемент таблицы, и НайтиСтроки(&lt;ПараметрыОтбора>) ищущий несколько строк. Метод Найти() возвращает объект строки с типом "СтрокаТаблицыЗначений", либо Неопределено.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//найдём одну строку с наименованием "Мышь logitec"</span>
            <span class="vue-b">Мышь <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Найти<span class="vue-r">(</span>"Мышь logitec", "Наименование"<span class="vue-r">)</span>;
            <span class="vue-r">Если</span> Мышь <span class="vue-r">=</span> Неопределено <span class="vue-r">Тогда</span>
                Сообщить<span class="vue-r">(</span>"Товар Мышь не найдена в таблице"<span class="vue-r">)</span>;
            <span class="vue-r">КонецЕсли;</span></span>

            <span class="vue-g">//если мы пытаемся найти по значению колонки и это значение повторяется
            //у нескольких строк, то будет возвращена строка найденая первая с таким значением
            //ну например мы ищем по значению "Компьютерные комплектующие" колонки Группа
            //такое значение колонки есть у нескольких строк, поэтому чтобы получить все строки с таким значением
            //нужно использовать другой метод НайтиСтроки(). Этот метод принимает ПараметрОтбора
            //в виде структуры. Структура вообще часто выступает параметром отбора для разных методов,
            //потому что у неё удобное хранение данных(Ключ-Значение) для таких отборов</span>
            <span class="vue-b">ПараметрОтбора <span class="vue-r">= Новый</span> Структура<span class="vue-r">(</span>"Группа", "Компьютерные комплектующие"<span class="vue-r">)</span>;
            ВсеКомплектующие <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>НайтиСтроки<span class="vue-r">(</span>ПараметрОтбора<span class="vue-r">)</span>;</span>
            <span class="vue-g">//метод НайтиСтроки() возвращает массив объектов с типом 
            //"СтрокаТаблицыЗначений"</span>
            <span class="vue-b"><span class="vue-r">Если</span> ВсеКомплектующие<span class="vue-r">.</span>Количество<span class="vue-r">() =</span> 0 <span class="vue-r">Тогда</span>
                Сообщить<span class="vue-r">(</span>"Элементов таблицы не найдены с таким значением"<span class="vue-r">)</span>;
            <span class="vue-r">КонецЕсли;</span>
            <span class="vue-r">Для каждого</span> СтрокаТаблицы <span class="vue-r">Из</span> ВсеКомплектующие <span class="vue-r">Цикл</span>
                <span class="vue-g">//в переменной СтрокаТаблицы на каждом круге будет объект
                //у этого объекта доступны все колонки таблицы через точку или скобки</span>
                Сообщить<span class="vue-r">(</span>СтрокаТаблицы<span class="vue-r">.</span>Артикул<span class="vue-r">)</span>;
            <span class="vue-r">КонецЦикла;</span></span>
        </pre>
    </div>

    <p><b>Создание копии таблицы значений</b>. Ну например нам нужно с пришедшей таблицей что то сделать, но при этом не трогая исходную таблицу. Для этого есть 2 способа копирования: 1)Целиком вместе с данными, 2)Можно копировать в части описания колонок, без данных. Для первого случая есть метод Скопировать(&lt;Строки>, &lt;Колонки>), этот метод может даже отфильтровать какие строки мы можем скопировать, например мы хотим не всю таблицу скопировать, а только те строки, где есть значения "Компьютерные комплектующие" колонки Группа. В параметр &ltСтроки> нужно передать массив строк, выше мы уже отобрали такие строки и они лежат в переменной ВсеКомплектующие, вот их и передадим для копирования. Если ничего не передавать, будут скопированы все строки. Также если вторым параметром указать в строке перечисленные названия колонок, то будут добавлены только эти колонки, а не все. Давайте добавим только колонку Наименования скопированных комплектующих.</p>
    <p>Для второго случая есть метод СкопироватьКолонки(&lt;Колонки>), тут указываются в виде строки названия колонок, копирование идёт без значений колонок.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//1й способ</span>
            <span class="vue-b">ТаблицаКомплектующих <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Скопировать<span class="vue-r">(</span>ВсеКомплектующие, "Наименование, ЦенаПродажи"<span class="vue-r">)</span>;</span>

            <span class="vue-g">//2й способ</span>
            <span class="vue-b">ПолнаяКопияБезДанных <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>СкопироватьКолонки<span class="vue-r">(</span><span class="vue-r">)</span>;</span>
            <span class="vue-g">//теперь в переменной ПолнаяКопияБезДанных лежит таблица значений, у которой
            //есть свойство Колонки(КоллекцияКолонокТаблицыЗначений), эта коллекция содержит объекты колонок
            //из этих объектов колонок можно получить имена колонок и т.д.
            //для чего такая копия нужна пока не знаю. 
            </span>
        </pre>
    </div>

    <p><b>Выполняем сортировку в таблице значений</b>. Если мы запросили остатки товаров, то к нам приходит ТаблицаЗначений, вот мы её можем на месте отсортировать по убыванию или возрастанию, если это не сделано в запросе. Для этого есть метод Сортировать(&lt;Колонки>, &lt;ОбъектСравнения>). Второй параметр используется не часто, чаще первый. У нас есть скопированная таблица комплектующих с 2мя колонками - Наименование и ЦенаПродажи, отсортируем по ЦенаПродажи по убыванию:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//по возрастанию ЦенаПродажи, стоит по умолчанию</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Сортировать<span class="vue-r">(</span>"ЦенаПродажи"<span class="vue-r">)</span>;</span>

            <span class="vue-g">//по убыванию ЦенаПродажи</span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Сортировать<span class="vue-r">(</span>"ЦенаПродажи Убыв"<span class="vue-r">)</span>;</span>
        </pre>
    </div>

    <p><b>Получение итогов по числовой колонке</b>. Для этих целей есть метод Итог(&lt;Колонка>). В параметр передаётся имя колонки, по которой необходимо посчитать итог. Можно конечно и в цикле обойти строки и просуммировать значения колонки, но есть способ проще, просто метод Итог():</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//как помним в ТаблицаКомплектующих лежит скопированная таблица строк
            //только комплектующих товаров с 2 мя колонками "Наименование" и "ЦенаПродажи"
            </span>
            <span class="vue-b">ИтогЦеныПродажи<span class="vue-r"> = </span>ТаблицаКомплектующих<span class="vue-r">.</span>Итог<span class="vue-r">(</span>"ЦенаПродажи"<span class="vue-r">)</span>;</span>
        </pre>
    </div>

    <p><b>Свёртывание(Группировка) строк таблицы значений</b>. Есть метод Свернуть(), он такой же как в запросах мы групируем по одному полю и например суммируем по другому. Насколько я заметил, то тут есть одно отличие от группировки в запросах. Мы укажем по какой колонке надо свернуть, а другая колонка, ну например Договор из картинки ниже сама исчезнет из результатирующей таблицы. В запросах я точно не помню, но там если есть такое поле как Договор, то с ним тоже надо что то делать, сам по себе он не пропадёт, его надо будет тоже в группирующее поле помещать.</p>
    <img src="../img/1С-1/2023-01-19_10-41-18.png" class="screen" alt="">
    <div class="code-style">
        <pre>
            <span class="vue-g">//важно помнить, что мы сворачиваем основную таблицу товаров и после
            //свёртки она изменится, ну во-первых колонки останутся только 2(Группа, Сумма) 
            //и второе они будут свёрнуты
            </span>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Свернуть<span class="vue-r">(</span>"Группа", "Сумма"<span class="vue-r">)</span>;</span>
        </pre>
    </div>

    <p><b>Обход всех строк(элементов) таблицы значений</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//из за того что мы выше свернули основную таблицу и поля в ней урезались
            //то часто быввает что об этом забывают и пытаются при переборе получить поля, которых нет
            //об этом надо помнить, либо копировать всю таблицу и уже копированнную свёртывать
            //чтобы основная была не тронута
            </span>
            <span class="vue-r">Для каждого</span> <span class="vue-b">СтрокаТаблицы</span> <span class="vue-r">Из</span> <span class="vue-b">ТаблицаТоваров</span> <span class="vue-r">Цикл</span>
                <span class="vue-b">Сообщить<span class="vue-r">(</span>Элемент<span class="vue-r">.</span>Значение<span class="vue-r">);</span></span>
            <span class="vue-r">КонецЦикла;</span>
        </pre>
    </div>

    <p><b>Удалить строку из таблицы значений</b>. Есть 2 способа удаления: 1)по объекту, указываем в параметре объект строку, 2)по индексу, указываем индекс.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//1й способ по объекту. При удалении по объекту нужно найти этот объект
            //ещё раз напомню основная таблица свёрнута и не имеет поля Наименование
            </span>
            <span class="vue-b">Мышь <span class="vue-r">=</span> ТаблицаТоваров<span class="vue-r">.</span>Найти<span class="vue-r">(</span>"Мышь logitec", "Наименование"<span class="vue-r">)</span>;
            <span class="vue-r">Если</span> Мышь <span class="vue-r">&lt;></span> Неопределено <span class="vue-r">Тогда</span>
                <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Удалить<span class="vue-r">(</span>Мышь<span class="vue-r">)</span>;</span>
            <span class="vue-r">КонецЕсли;</span></span>

            <span class="vue-g">//удаление по индексу, важно тоже проверять на наличие удаляемого      
            //индекса, можно проверить количеством строк
            </span>
        </pre>
    </div>

    <p><b>Очиска таблицы значений</b>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Очистить<span class="vue-r">(</span><span class="vue-r">)</span>;</span>
        </pre>
    </div>

    <p><b>Особенности работы с таблицей значений</b>. 
    <p><b>1 особенность</b></p>
    <p>Часто таблицы значений могут быть большими(1000, 10000, 1000000 строк) и поиск по такой таблице может затянуться. Чтобы избежать затяжного поиска у таблицы есть свойство Индексы. Это свойство содержит коллекцию индексов таблицы значений. Что это такое? Возьмём например толстую книгу и нам нужно найти какой то текст в этой книге, мы можем листая каждую страницу просматривать на совпадение с искомым текстом, это займёт очень много времени. А можно просто посмотреть в оглавление и узнать на какой странице наш искомый текст. Вот также работает свойство Индексы. У этой коллекции есть методы Добавить(&lt;Колонки>), Удалить(), Количество() и Очистить(). Мы например знаем по каким колонкам мы будем искать, пусть мы ищем по Артикулам, значит нам надо перед поиском провести индексацию по полю Артикул:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b">ТаблицаТоваров<span class="vue-r">.</span>Индексы<span class="vue-r">.</span>Добавить<span class="vue-r">(</span>"Артикул"<span class="vue-r">)</span>;</span>

            <span class="vue-g">//ну и далее уже можно искать</span>
        </pre>
    </div>
    <p><b>2 особенность</b></p>
    <p id="typeColumn">Работа с таблицей значений, созданной в тексте программы, в запросе. Часто бывают ситуации, когда нашу таблицу значений, лежащей в оперативной памяти нужно перенести в запрос, для того чтобы в запросе выполнить соединение нашей таблицы с таблицей из запроса. Открываем к коде конструктор запросов и выше центральной колонки есть кнопка "Создать описание временной таблицы", как я понял это кнопка служит для того чтобы в конструктор ввести описание внешней таблицы для помещения её во временную таблицу и эта таблица уже будет доступна в конструкторе для дальнейшей работы с ней. Итак открываем окно описания и вносим имя таблицы "ТаблицаТоваров" и также вносим все поля, которые у нас есть в таблице значений - Артикул, Наименование, Количество, ЦенаЗакупки, ЦенаПродпжи, Сумма. Нажимаем ОК и у нас в центральной колонке появилась наша таблица, из неё выносим получение полей в правую колонку и теперь надо поместить её во временную таблицу на вкладке Дополнительно. Дадим имя временной таблице ВТ_Товары и далее во вкладке "Пакет запросов" жмём создать второй запрос по плюсику и уже можно писать новый запрос используя временную нашу таблицу. Мы можем соединить нашу временную таблицу с таблицей из БД и т.д. Когда конструктор собрал запрос и мы увидели этот запрос в тексте программы, то запрос пока ещё не понимает как ему взять в запрос нашу таблицу значений ТаблицаТоваров, для этого нужно указать в запросе, что ТаблицаТоваров это параметр и надо дописать строку с установкой параметра для ТаблицыТоваров, на примере будет всё понятно:</p>
    <img src="../img/1С-1/2023-01-20_09-28-19.png" class="screen" alt="">
    <p>На запрос особо нечего засматриваться, там ничего интересного, просто показано как таблицу из кода внести в запрос для работы.</p>
    <p><span class="vue-r">Ошибка!!!</span>. Если запустить этот код, то будет ошибка, что поле Артикул не может быть найдено, это происходит потому, что наши колонки в таблице значений не типизированны, а у них должно быть обязательно указаны типы, иначе такой запрос ситема выполнить не моджет. Выход следующий, когда мы добавляли колонки в таблицу, то 2й параметр у метода Добавить() это Тип, нужно добавить типы колонок. Чтобы описать тип используется объект <span class="vue-b">ОписаниеТипов</span>. В этом видео про это рассказывается с 02:25:00 - https://www.youtube.com/watch?v=RU2LyuhgWNo&list=PLnhTnXRFDQ7en_MVaepKmkL2g23zOXQMx&index=8:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//опишем тип число
            //квалификаторы какого то типа это, например для числа это описание лоп. настроек как 
            //длина, точность, отрицательное или нет</span>
            <span class="vue-b">
            КвалификаторыЧисла = Новый КвалификаторыЧисла(10, 2);
            ОписаниеТипаЧисло = Новый ОписаниеТипов("Число", , , КвалификаторыЧисла)</span>

            <span class="vue-g">//опишем тип строка
            //квалификаторы для строки такие как длина строки, допустимая длина
            //важно заметить что квалификатор для строки в описании типов будет стоять 5м параметром
            </span>
            <span class="vue-b">
            КвалификаторыСтроки = Новый КвалификаторыСтроки(100);
            ОписаниеТипаСтрока = Новый ОписаниеТипов("Строка", , , , КвалификаторыСтроки)</span>

            <span class="vue-g">//когда мы создаём какой то объект конфигурации, то там мы указываем типы и квалификаторы
            //для реквизитов просто выбирая из списка типов или ставя галочки, вот тут то же самое
            //только в программном виде</span>
        </pre>
    </div>
    <p>Мы создали типы для наших колонок, вот их и надо добавить 2м параметом в метод Добавить() коллекции Колонки -> ТаблицаТоваров.Колонки.Добавить("Артикуль", ОписаниеТипаСтрока); и так далее для всех колонок.</p>
    <p>Колонки должны быть типизированы, если мы хотим использовать нашу таблицу значений в запросе.</p>
    <img src="../img/1С-1/2023-01-20_10-14-22.png" class="screen" alt="">

    <p id="table-1"><b>Работа с таблицей значений на форме</b>. Точно так как и список значений мы можем разместить на форме реквизит с типом "ТаблицаЗначений". Например создадим реквизит "ТаблицаОстатки" и укажем ей этот тип. Как только мы этому реквизиту указали тип "ТаблицаЗначений", то сверху в панельке кнопок стала доступка кнопка "Добавить колонку реквизита". Нажав на неё внутри реквизита появится колонка реквизит, ей зададим имя такое как и у регистра накопления называются измерения и русурс. Мы хотим показывать в этой таблице какую нибудь таблицу регистра накопления "ОстаткиНоменклатуры". У регистра есть 2 измерения Товар и Склад и ресурс Количество, значит называем реквизит колонку Товар с типом СправочникСсылка.Номенклатура, затем добавим реквизит колонку Склад, с типом СправочникСсылка.Склад и колонку Количество с типом Число. Перетаскиваем реквизит "ТаблицаОстатки" влево на элементы формы. Смотрим что получилось, пока это просто таблица, в которую можно добавлять товары и склады из справочников. Мы же хотим при открытии этой формы заполнения остатками из регистра. Для этого для события формы "ПриСозданииНаСервере" напишем обработчик. В обработчике конструируем запрос из таблицы регистра накопления ОстаткиНоменклатуры.Остатки. Обход результата запроса нам не нужен, а нужен метод РезультатЗапроса.Выгрузить();. Как известно этот метод выгружает результат в таблицы. Но просто так выгрузить в реквизит "ТаблицаОстатки" не получится, потому что у реквизита с типом таблица значений есть свой метод Загрузить(). Поэтому сначала выгружаем из результата во временную переменную, а потом в "ТаблицаОстатки" загружаем из этой временной переменной.</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)	
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	ОстаткиНоменклатурыОстатки.Номенклатура КАК Номенклатура,
                    |	ОстаткиНоменклатурыОстатки.Склад КАК Склад,
                    |	ОстаткиНоменклатурыОстатки.КоличествоОстаток КАК Количество
                    |ИЗ
                    |	РегистрНакопления.ОстаткиНоменклатуры.Остатки КАК ОстаткиНоменклатурыОстатки";
                
                РезультатЗапроса = Запрос.Выполнить();
                ТаблицаЗапроса = РезультатЗапроса.Выгрузить();
                ТаблицаОстатки.Загрузить(ТаблицаЗапроса);
            КонецПроцедуры
        </pre>
    </div>
    <p>Хотя если посмотреть в форме какой тип показывает у реквизита "ТаблицаОстатки", то там в скобках написано (ТаблицаЗначений), если в таких скобках, значит это не совсем таблица значений, хотя методы у неё такие как и у таблицы занчений, но не все, например, метода Свернуть() нет. Посмторел в отладчике, тип на самом деле у этого реквизита  - ДанныеФормыКоллекция. Чтобы получить таблицу значений из этого реквизита, есть такой метод как <span class="vue-b">РеквизитФормыВЗначение("ТаблицаОстатки")</span> аернёт таблицу значений.</p>
    <p>Таким не хитрым способом можно отображать регистры(и не только) в формах обработки, документа или ещё где то.</p>










    <h3 class="header-style2" id="tree">Дерево занчений</h3>
    <p>Дерево значений это коллекция, которая позволяет хранить данные почти в таком же виде как и таблица значений, за исключением того, что в таблице значений у нас все строки равнозначны. Дерево же значений позволяет работать со строками таблицы в режиме подчинения одной строки другой, т.е. присутствие иерархии. У нас появилось новое поле "Родитель", которое указывает на строку-родитель текущей строки. На картинке ниже строка с индексом 0 является родителем строк с индексами 1 и 2. Пример дерева значений это справочник Номенклатура с иерархией по группам и элементам. Даже в пользовательской части при просмотре этого справочника есть возможность включить режим просмотра "Дерево". Вот это и есть дерево значений. Теперь нужно научиться программно такое создавать. Дерево значений доступно только на сервере.</p>
    <img src="../img/1С-1/2023-01-21_08-29-27.png" class="screen" alt="">
    <p>На примере создадим дерево значений хранящее данные об остатках товаров.</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">Создание</span>
            ДеревоОстатки = Новый ДеревоЗначений;

            <span class="vue-r">Добавление колонок в дерево значений</span>
            ДеревоОстатки.Колонки.Добавить("Товар");
            ДеревоОстатки.Колонки.Добавить("Склад");
            ДеревоОстатки.Колонки.Добавить("Количество");

            <span class="vue-r">Добавление элементов(строк) в дерево значений</span>
            <span class="vue-g">//у дерева значений есть свойство Строки, это свойство содержит КоллекциюСтрокДереваЗначений
            //только 1го уровня, остальные уровни строк можно получить обращаясь к уже имеющимся строкам
            //создадим 1й уровень строк остатки по складам</span>
            <span class="vue-g">//добавим 1го уровня по основному складу</span>
            ОстаткиПоОсновномуСкладу = ДеревоОстатки.Строки.Добавить();
            ОстаткиПоОсновномуСкладу.Склад = "Основной";
            ОстаткиПоОсновномуСкладу.Количество = 160;

            <span class="vue-g">//Далее добавляем детальные строки по складу Основной. Эти строки уже имеют 2й уровень</span>
            ДетальнаяСтрока = ОстаткиПоОсновномуСкладу.Строки.Добавить();
            ДетальнаяСтрока.Склад = "Основной";
            ДетальнаяСтрока.Товар = "Груши";
            ДетальнаяСтрока.Количество = 10;

            ДетальнаяСтрока = ОстаткиПоОсновномуСкладу.Строки.Добавить();
            ДетальнаяСтрока.Склад = "Основной";
            ДетальнаяСтрока.Товар = "Яблоки";
            ДетальнаяСтрока.Количество = 50;

            ДетальнаяСтрока = ОстаткиПоОсновномуСкладу.Строки.Добавить();
            ДетальнаяСтрока.Склад = "Основной";
            ДетальнаяСтрока.Товар = "Арбуз";
            ДетальнаяСтрока.Количество = 100;

            <span class="vue-g">//добавим 1го уровня по доп. складу</span>
            ОстаткиПоДопСкладу = ДеревоОстатки.Строки.Добавить();
            ОстаткиПоДопСкладу.Склад = "Дополнительный";
            ОстаткиПоДопСкладу.Количество = 100;

            <span class="vue-g">//Далее добавляем детальные строки по складу Дополнительный. Эти строки уже имеют 2й уровень</span>
            ДетальнаяСтрока = ОстаткиПоДопСкладу.Строки.Добавить();
            ДетальнаяСтрока.Склад = "Дополнительный";
            ДетальнаяСтрока.Товар = "Арбуз";
            ДетальнаяСтрока.Количество = 30;

            ДетальнаяСтрока = ОстаткиПоОсновномуСкладу.Строки.Добавить();
            ДетальнаяСтрока.Склад = "Дополнительный";
            ДетальнаяСтрока.Товар = "Апельсины";
            ДетальнаяСтрока.Количество = 70;

            <span class="vue-r">Получение количества строк в дереве значений. Тут немного всё по сложней</span>
            <span class="vue-g">//общее количество не так просто получить, потому что нет метода Количество()
            //у дерева значений, но есть такой метод у строк</span>
            КоличествоСтрокВерхнегоУровня = ДеревоОстатки.Строки.Количество(); -> 2(Основной, Дополнительный)
            КоличествоСтрокОсновногоСклада = ОстаткиПоОсновномуСкладу.Строки.Количество(); -> 2(детальные)
            КоличествоСтрокДопСклада = ОстаткиПоДопСкладу.Строки.Количество(); -> 2(детальные)
            <span class="vue-g">//в сумме получается 6 строк. Но как правило получать общее количество
            //и не нужно, хватает понимания количества на каком то конкретном уровне</span>

            <span class="vue-r">Находим один элемент в дереве значений</span>
            <span class="vue-g">//есть метод Найти(&lt;Значение>,&lt;Колонки>,&lt;ВключатьПодчиненные>)
            //не у дерева, а у строк. В Значение указывем Что иы ищем, а в Колонки - Где, ВключатьПодчиненные
            //это Истина или Ложь, указываем искать во вложенных строках или нет
            //найдём, например, строку с товаром Арбуз
            //вернёт Неопределено, потому что Арбуз находится в подчиненных строках
            //а параметр ВключатьПодчиненные по умолчанию стоит в положении Ложь</span>
            СтрокаСАрбузом = ДеревоОстатки.Строки.найти("Арбуз", "Товар");

            <span class="vue-g">//а так вернёт объект СтрокаДереваЗначений у которого через точку можно получить товар
            //так как у нас есть 2 товара арбуз на разных складах, то этот метод найдёт первую попавшую строку
            </span>
            СтрокаСАрбузом = ДеревоОстатки.Строки.Найти("Арбуз", "Товар", Истина);
            Если СтрокаСАрбузом &lt;> Неопределено Тогда
                Сообщить(СтрокаСАрбузом.Товар);
                Сообщить(СтрокаСАрбузом.Количество);
            Иначе
                Сообщить("Такой строки нет");
            КонецЕсли;

            <span class="vue-r">Находим все строки дерева значений, которые удовлетворяют условию поиска</span>
            <span class="vue-g">//для этого есть метод у строк НайтиСтроки(&lt;ПараметрыОтбора>, &lt;ВключатьПодчиненные>)
            //параметр Параметрыотбора это структура, 2й параметр уже известено что значит. Метод возвращает массив</span>
            Отбор = Новый Структура("Товар", "Арбуз");
            ВсеСтрокиСАрбузами = ДеревоОстатки.Строки.НайтиСтроки(Отбор, Истина);
            Если ВсеСтрокиСАрбузами.Количество() &lt;> 0 Тогда
                Сообшить("Найдено строк: " + ВсеСтрокиСАрбузами.Количество());
            КонецЕсли;

            <span class="vue-r">Создаём копию дерева значений с данными</span>
            <span class="vue-g">//ни у самого дерева значений, ни у его строк нет метода, который бы копировал
            //всю таблицу, поэтому чтобы сделать копию придётся создать новую таблицу дерево значений 
            //и в цикле обойти всю таблицу и перекопировать все строки</span>



            <span class="vue-r">Удаление строки дерева значений</span>
            <span class="vue-g">//удаление есть у строк и их 2 способа</span>
            <span class="vue-g">//метод Удалить(&lt;Строка>). Чтобы удалить, строку нужно найти. Удалим, например 
            //строку с товаром Арбуз, выше в примере мы уже находили эту строку и объект этой строки лежит
            //в переменной СтрокаСАрбузом, в которой лежит первая попавшаяся строка с товаром Арбуз
            //Важно!!! Удалить можно только строку из того же уровня данной коллекции строк
            //т.е. удалить из коллекции строк 1 уровня нельзя строку 2 уровня</span>
            ОстаткиПоОсновномуСкладу.Строки.Удалить(СтрокаСАрбузом);

            <span class="vue-g">//у нас есть 2 товара Арбуз в разных складах. А что если мы хотим удалить
            //не первый попавшийся, а конкретную строку товара Арбуз? Тогда используем метод НайтиСтроки()
            //чем он нам поможет? А тем, что мы в него можем передавать Отбор, а в отборе мы можем указать
            //товар и склад. Из за того, что метод возвращает массив, обходим в цикле и удаляем
            //тут также, раз мы нашли товар в коллекции ОстаткиПоДопСкладу, то и удалять нужно из этой коллекции
            </span>
            Отбор = Новый Структура("Товар, Склад", "Арбуз", "Дополнительный");
            АрбузСДопСклада = ДеревоОстатки.Строки.НайтиСтроки(Отбор, Истина);
            Для каждого Строка Из АрбузСДопСклада Цикл
                ОстаткиПоДопСкладу.Строки.Удалить(Строка);
            КонецЦикла;

            <span class="vue-r">Сортировка в дереве значений</span>
            <span class="vue-g">//для этого есть метод Сортировать(&lt;СтрокаСортировки>, &lt;ВключатьПодчиненные>, &lt;ОбъектСравнения>)
            //1й параметр это список имен колонок, разделенных запятыми</span>
            ДеревоОстатки.Строки.Сортировать("Количество Убыв", Истина);

            <span class="vue-r">Обход элементов дерева значений</span>
            <span class="vue-g">//из-за того, что мы заранее не знаем сколько уровней в дереве нам сложно определить
            //как в цикле обойти всё дерево, поэтому тут логично использовать такой цикл как рекурсия
            //сделаем отдельно процедуру, которой передадим строки верхнего уровня, а внутри процедура
            //будет проверять есть ли что то в строке верхнего уровня и если да, то для неё опять запускается
            //эта же процедура</span>
            ОбходДереваЗначений(ДеревоОстатки.Строки);
            
            <span class="vue-r">Очистка дерева значений</span>
            ДеревоОстатки.Строки.Очистить();


            Процедура ОбходДереваЗначений(КоллекцияСтрок)
                Для каждого Строка Из КоллекцияСтрок Цикл
                    <span class="vue-g">//у строки есть метод Уровень(), который покажет в виде числа уровень строки
                    //важно, не у коллекции строк есть такой метод, а у отдельной строки
                    //уровень мы будем показывать просто для того чтобы показать обход всех строк</span>
                    Сообщить("Уровень: " + Строка.Уровень() + "; " + Строка.Товар + "; " + Строка.Склад + "; " + Строка.Количество);
                    <span class="vue-g">//проверяем, есть ли в строке подчинённые строки</span>
                    Если Строка.Строки.Количество() > 0 Тогда
                        ОбходДереваЗначений(Строка.Строки);
                    КонецЕсли;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>

    <p><b>Работа с деревом значений на форме</b>. Как правило создавать дерево значений с нуля нужно не часто, обычно его получают в результате какого то метода. И самый частый способ получения такого дерева это запрос. В форме создадим реквизит "ДеревоОстатков" в типом "ДеревоЗначений" и в него будем выводить остатки Товаров подчинённые складам. Также как и для таблицы значений вверху используем кнопку добавления колонок для реквизита. Добавим 3 колонки - Товар(с типом СправочникСсылка.Номенклатура), Склад(с типом справочникСсылка.Склады) и Количество(с типом число и квалификаторами длина 15, точность 3). Переносим реквизит "ДеревоОстатков" влево куда нам нужно.</p>
    <p>Также будем использовать обработчик события формы "ПриСозданииНаСервере". В нём напишем запрос к виртуальной таблице регистра накопления Остатки по номенклатуре. Нам нужны подсчёты количества товаров по складам, поэтому в запросе будем использовать итоги. В конструкторе создали запрос и вывели в код. В метод Выбрать() из результата запроса конструктор подставил параметр "ОбходРезультатаЗапроса.ПоГруппировкам". Этот параметр, как я понял, в выборку добавляет записи с группой помимо детальных. Чтобы выгрузить данные из запроса в наше дерево значений используем метод Выгрузить() и передаём также в него ТипОбхода такой же, как и для выборки. Здесь будет отличие в выгрузке в дерево значений от выгрузки в таблицу значений. Как мы видим в форме в окне реквизитов, ДеревоОстатков имет тип в скобках (ДеревоЗначений), что нам говорит о том, что это её не настоящий тип, настоящий тип <b>ДанныеФормыДерево</b>. Если для реквизита "ТаблицаОстатки", с ненастоящим типом (ТаблицаЗначений), был метод Загрузить(), он загружал выгруженную таблицу с данными запроса в этот реквизит, то для реквизита "ДеревоОстатки" такого метода нет. Если мы напрямую выгрузим в этот рекизит результат запроса, то будет ошибка, потому что выгрузка из результата запроса будет иметь настоящий тип "ДеревоЗначений", а реквизит "ДеревоОстатков" имеет тип ДанныеФормыДерево. Тут нужно вспомнить метод РеквизитФормыВЗначение(), переведём реквизит "ДеревоОстатков" в настоящий тип "ДеревоЗначений", запишем в него данные запроса и переведём обратно в ДанныеФормыДерево</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)		
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	ОстаткиНоменклатурыОстатки.Номенклатура КАК Товар,
                    |	ОстаткиНоменклатурыОстатки.Склад КАК Склад,
                    |	ОстаткиНоменклатурыОстатки.КоличествоОстаток КАК Количество
                    |ИЗ
                    |	РегистрНакопления.ОстаткиНоменклатуры.Остатки КАК ОстаткиНоменклатурыОстатки
                    |ИТОГИ
                    |	СУММА(Количество)
                    |ПО
                    |	Склад";
                
                РезультатЗапроса = Запрос.Выполнить(); 
                ДеревоОбъект = РеквизитФормыВЗначение("ДеревоОстатков");
                ДеревоОбъект = РезультатЗапроса.Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
                ЗначениеВРеквизитФормы(ДеревоОбъект, "ДеревоОстатков");
            КонецПроцедуры
        </pre>
    </div>
    <p>Ctrl + Shift + Плюс - развернуть дерево значений в пользовательском режиме, + Минус - свернуть.</p>














    <h3 class="header-style2" id="7">Процедуры и функции</h3>
    <div class="code-style">
        <pre>
            <span class="vue-r">Процедура <span class="vue-b">ИмяПроцедуры</span>()
                //код...
            КонецПроцедуры
            </span>

            <span class="vue-r">Функция <span class="vue-b">ИмяФункции</span>()
                <span class="vue-b">ЧислоА = 12;
                ЧислоБ = 4;
                СуммаЧисел = ЧислоА + ЧислоБ;</span>
                Возврат <span class="vue-b">СуммаЧисел</span>;
            КонецФункции
            </span>

            <span class="vue-b">Результат <span class="vue-r">=</span> ИмяФункции<span class="vue-r">(</span><span class="vue-r">);</span></span>
        </pre>
    </div>
    <p>Задача процедуры как и функции обернуть в себя какой то код и вызывать его в любом месте программы. Функция в отличии от процедуры может возвращать результат выполнения функции через оператор <b>Возврат</b>. Процедуры тоже могут использовать оператор Возврат, но только для досрочного завершения процедуры, ничего возвращать из процедуры они не могут, а используются одиночно.</p>
    <p>Если в процедуре или в функции объявлены параметры, то при вызове их нужно обязательно передавать эти параметры, иначе ошибка. Здесь построже чем в js, там можно и не передавать параметры, просто там параметрам присвоится undefined и всё. Но можно и не передавать праметры в функцию если в этой функции параметрам заранее прописать значения по умолчанию, они здесь задаются также как и в js. Те параметры, которым не указалось значения по умолчанию, должны быть переданы:</p>
    <div class="code-style">
        <pre>
            Функция ПосчитатьЗначения(Парам1, Парам2 = 2, Парам3 = 5)
                СуммаЧисел = Парам1 + Парам2 + Парам3;
                Возврат СуммаЧисел;
            КонецФункции

            Сообщить(ПосчитатьЗначения(53)); // 60
        </pre>
    </div>
    <p>Те параметры, которые передаются пишем левее, а с значениями по умолчанию пишем правее. Мы можем передать все 3 параметра и тогда они станут в то значение, которые им присвоится при передаче, а не то, которое у них стоит по умолчанию.</p>
    <p>Парметр по умолчанию часто используеся при доработке чужой функции, она уже имеет какие то параметры и во многих местах вызывается с этими параметрами, а нам нужно ввести ещё какой то параметр, тут то мы в функцию и дописываем свой параметр и стаим ему значение по умолчанию и внутри самой функции например добавляем наш параметр в какую-нибудь формулу, и она отработает спокойно не переделывая её полностью. Если мы поставим свой параметр не по умолчанию, то он станет обязательным и вот тогда может всё нарушиться.</p>








    <h3 class="header-style2" id="7a">Переменные передаются по ссылке в процедуры и функции. Оператор</h3>
    <p>Есть такой код:</p>
    <div class="code-style">
        <pre>
            Процедура ПроверитьЧисло(Число)
                Если  Число > 0 Тогда
                    Сообщить("Число положительное");
                Иначе
                    Сообщить("Число отрицательное"); 
                КонецЕсли;  
                Число = 1;
            КонецПроцедуры  

            А = -1;

            ПроверитьЧисло(А);
            Сообщить(А);
            ПроверитьЧисло(А);

            //ответом будет 3 сообщения
            Число отрицательное
            1
            Число положительное

            //Как видно в первую процедуру мы передали переменную по ссылке, теперь А и Число ссылаются на одну и ту же переменную
            //Число проверяется и выводится результат, затем в Число пишется новое значение, а значит по ссылке А также теперь ссылается
            //на новое значение 1. Короче точно так же как в JS объекты передаются по ссылке, а не копируются.
            //Если често то это вводит немного в ступор, вот так легко можно поменять глобальную переменную А внутри процедуры и не заметить этого.
        </pre>
    </div>
    <p>Может быть далее по изучению я узнаю почему так сделано. Узнал. Оказывается в параметр процедуры рядом можно вписать слово Знач и теперь переменная А будет копироваться в переменную Число не по ссылке, а именно копироваться и теперь поведение будет как в JS. Официально слово Знач означает запрет на изменение передаваемой переменной А:</p>
    <div class="code-style">
        <pre>
            Процедура ПроверитьЧисло(<span class="vue-b">Знач</span> Число)
                Если  Число > 0 Тогда
                    Сообщить("Число положительное");
                Иначе
                    Сообщить("Число отрицательное"); 
                КонецЕсли;  
                Число = 1;
            КонецПроцедуры 

            А = -1;

            ПроверитьЧисло(А);
            Сообщить(А);
            ПроверитьЧисло(А);

            //ответом будет 3 сообщения
            Число отрицательное
            -1
            Число отрицательное
        </pre>
    </div>















    <h3 class="header-style2" id="10">Не срабатывает метод Сообщить</h3>
    <p>Если в нашей программе вызывается одна из следующих команд ВвестиЧисло, ВвестиДату, ВвестиСтроку, то следующие команды Сообщить мы просто не успеваем увидеть. Вызов перечисленных команд приводит к тому, что перед пользователем появляется отдельное окно (для ввода информации), которое ломает стандартный механизм вывода сообщений через команду Сообщить. В этом случае результаты команды Сообщить выводятся не в главное, а в диалоговое окно, которое закрывается сразу после ввода значения.</p>
    <p><b>Простой способ решения</b></p>
    <p>Если в нашем коде встречается одна из команд ВвестиЧисло, ВвестиДату, ВвестиСтроку, вместо Сообщить используем команду ОткрытьЗначение.</p>
    <p><b>Правильный способ решения</b></p>
    <p>Поместите в модуль управляемого приложения событие ПриНачалеРаботыСистемы и пишите весь код в нём. Это событие вызывается уже после того как создано главное окно 1С.</p>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                //код;
            КонецПроцедуры
        </pre>
    </div>
















    <h3 class="header-style2" id="11">Объекты конфигурации</h3>
    <p><b>Виды данных</b>.</p>
    <ul class="list">
        <li><b>"Общие" - "общие модули"</b> - Общие модули это те модули, в которые мы добавляем свои процедуры и функции с указанием ключевого слова "Экспорт". Получается своеобразная библиотека, процедуры и функции которой в дальнейшем можно вызывать из различных мест конфигурации. Создадим общий модуль и назовём его, например, "Библиотека" и напишем там процедуру, затем из любого места конфигурации вызываем эту процедуру - <span class="vue-b"><b>Бибилиотека.НазваниеПроцедуры();</b></span></li>
        <li><b>Константы</b> - один из самых простых объектов конфигурации, который позволяет сохранить в инфобазе какое-то одно постоянное или условно-постоянное значение. Например, создадим постоянное значение и назовём его "НазваниеОрганизации", в режиме предприятия появится команда "Сервис", в котрой мы найдём название, котрое ввели, кликнем по нему и откроется форма для ввода названия организации. Ну или например можно добавить постоянное значение "ИНН", чтобы вводить ИНН организации или "ДатаРегистрации" и т.д.</li>
        <li><b>"Справочники"</b> - Справочники позволяют хранить данные, имеющие одинаковую структуру и списочный характер. Это может быть, например, список сотрудников, перечень товаров, список поставщиков или покупателей. Каждый элемент справочника в обязательном порядке имеет поля КОД и НАИМЕНОВАНИЕ, но к ним могут добавляться и любые другие поля.</li>
        <li><b>"Документы"</b> - Документы позволяют хранить информацию о совершённых операциях или о событиях, произошедших в "жизни" предприятия вообще. Это могут быть, например, приходные накладные, приказы о приёме на работу, счета, платёжные поручения и т.д. Каждый документ в обязательном порядке имеет поля НОМЕР, ДАТА и ВРЕМЯ</li>
        <li><b>"Отчёты"</b> - Отчёты обрабатывают и выводят накопленную информацию в удобном для просмотра и анализе виде. Это может быть отчёт, который выводит остатки товара на складе или продажи за период. Каждый отчёт в обязательном порядке имеет некоторую печатную форму, которую можно не только посмотреть, но и вывести на принтер.</li>
        <li><b>"Обработки"</b> - Обработки предназначены для выполнения различных действий над информацией в базе. Например, с их помощью можно выполнить удаление из системы устаревших данных, импорт информации из других систем и многое другое. В результате действия обработки информация, хранящаяся в системе, претерпевает какие-либо изменения.</li>
        <li><b>"Перечисления"</b> - Перечисления - это прикладной объект, это особенный объект. В отличии от справочников и документов все возможные значения перечислений задаются на этапе конфинурирования и не могут быть в дальнейшем изменены в пользовательском режиме. Неизменность - это их главный козырь. Это своего рода константы БД. И если программист в режиме конфигурирования создал перечисление с именем Пол и значениями Мужской и Женский, то при написании программыон может быть уверен, что в дальнейшем значения этого перечисления не изменятся. Поэтому он может смело обращаться к этим значениям из кода. Представьте, что будет, если он для этого использует справочник? Во первых пользователь может легко изменить значения справочника, а другой пользователь может удалить один из полов. Программа от этого сломается. Вот для этого и существуют перечисления, чтобы один раз на этапе конфигурирования жёстко задать все возможные варианты значений и в дальнейшем использовать их в коде программы.</li>
        <li><b>Регистры накопления</b> - слово регистр переводится как запись, записаться, отметиться. Я бы перевёл его как объект записывальщик данных в данном случае для их накопления. 
        </li>
    </ul>















    <h3 class="header-style2" id="11a">Отдельно об регистре накопления</h3>
    <p>Регистр накопления предназначен для описания структуры накопления данных. На основе объекта конфигурации Регистр накопления платформа создает в базе данных таблицы, в которых будут накапливаться данные, поставляемые различными объектами базы данных. Эти данные будут храниться в таблицах в виде отдельных записей, каждая из которых имеет одинаковую заданную в конфигураторе структуру:</p>
    <img src="../img/1С-1/2022-11-10_16-50-07.png" class="screen" alt="">
    <p>Отличительной особенностью регистра накопления является то, что он не предназначен для интерактивного редактирования пользователем. Предназначение регистра накопления заключается в том, чтобы его изменение(модификация) производилось на основе алгоритмов работы других объектов базы данных, а не в результате непосредственных действий пользователя.</p>
    <p>Основным назначением регистра накопления является накопление числовой информации в разрезе нескольких <b>измерений</b>, которые описываются разработчиком в соответствующем объекте конфигурации Регистр накопления и являются подчиненными объектами конфигурации.</p>
    <p>Виды числовой информации, накапливаемой регистром накопления, называются <b>ресурсами</b>, также являются подчиненными объектами и описываются в конфигураторе.</p>
    <p>Например, регистр накопления может накапливать информацию о количестве и сумме товаров на складах. В этом случае он будет иметь измерения Товар и Склад и ресурсы Количество и Сумма.</p>
    <p>Изменение состояния регистра накопления происходит, как правило, при проведении документа и заключается в том, что в регистр добавляется некоторое количество записей. Каждая запись содержит значения измерений, значения приращений ресурсов, ссылку на документ, который вызвал эти изменения (регистратор), и «направление» приращения (приход или расход). Такой набор записей называется <i>движениями</i> регистра накопления. Каждому движению регистра накопления всегда должен соответствовать <i>регистратор</i> – объект информационной базы (как правило, документ), который произвёл эти движения. </p>
    <p>Кроме этого, регистр накопления может хранить дополнительную информацию, описывающую каждое движение. Набор такой дополнительной информации задаётся разработчиком при помощи <i>реквизитов</i> объекта конфигурации Регистр накопления.</p>

    <p><b>Рассмотрим пример</b>.</p>
    <p>Прежде всего, нас интересует информация о том, сколько и каких материалов есть у нас на складах. Для накопления такой информации мы создадим регистр "ОстаткиМатериалов". В окне редактирования также зададим и Расширенное представление списка как "Движения по регистру Остатки материалов". Этот заголовок будет отображаться в окне списка записей регистра. Укажем в каких подсистемах должна отображаться. Далее в закладке Данные перейдём к созданию стрктуры регистра. Создадим измерения регистра:</p>
    <ul class="list">
        <li>Материал, тип СправочникСсылка.Номенклатура</li>
        <li>Склад, тип СправочникСсылка.Склады</li>
    </ul>
    <p>Затем создадим ресурс Количество с длиной 15 и точностью 3.</p>
    <p>Если сейчас попытаетесь запустить «1С:Предприятие» в режиме отладки, то система выдаст сообщение об ошибке: «РегистрНакопления.ОстаткиМатериалов: Ни один из документов не является регистратором для регистра». Документ регистратор, это та сущность, которая даёт данные регистру накопления при проведении документа. Это сообщение еще раз подтверждает тот факт, что назначение регистра накопления в том, чтобы накапливать данные, поставляемые различными документами. Поэтому мы сформируем движения регистра накопления ОстаткиМатериалов в процессе проведения двух созданных нами документов ПриходнаяНакладная и ОказаниеУслуг. Эти документы создавались из книги Хрусталёвой, поэтому не обращаем внимание.</p>

    <p><b>Движения документа</b>.</p>
    <p>Движения документа – это записи в регистрах, которые создаются в процессе проведения документа и отражают изменения, производимые документом. Откроем окно редактирования объекта конфигурации Документ ПриходнаяНакладная. Перейдем на закладку Движения, раскроем список Регистры накопления и отметим регистр накопления ОстаткиМатериалов. Откроем конструктор движения. В списке Регистры перечислены регистры, в которых документ может создавать движения. В нашем случае там пока один регистр ОстаткиМатериалов. В списке Реквизиты документа должны находиться исходные данные для создания движений – реквизиты документа ПриходнаяНакладная. А в таблице Поле – Выражение должны быть заданы формулы, по которым будут вычисляться значения измерений и ресурсов регистра при записи движений.</p>
    <p>Обратим внимание, что по умолчанию конструктор предлагает нам создавать движения прихода (Тип движения регистра – Приход, символ + рядом с названием регистра) по регистру ОстаткиМатериалов. Это нас вполне устраивает, ведь документ ПриходнаяНакладная и должен приходовать материалы. В поле выбора Табличная часть выберем табличную часть нашего документа – Материалы. Список реквизитов документа, который уже заполнен реквизитами шапки документа, автоматически дополнится реквизитами нашей табличной части. Теперь нажмем кнопку Заполнить выражения. В нижнем окне сформируется соответствие полей (измерений и ресурсов) регистра и выражений для их расчета.</p>
    <p>Как видите, конструктор движений установил соответствия подходящим образом: в качестве материала в регистр будет записан материал из табличной части документа, в качестве склада – склад, указанный в шапке документа, а в качестве количества – количество из табличной части документа. Нажмем кнопку OK и посмотрим, какой текст сформировал конструктор в модуле документа ПриходнаяНакладная.</p>
    <div class="code-style">
        <pre>
            Процедура ОбработкаПроведения(Отказ, Режим)
                <span class="vue-g">//Отказ это параметр в котором лежит булево значение Ложь и если мы в него установим Истина по какому то условию, то документ не будет
                //проведён, но код продолжит выполнение, чтобы и код остановить, чтобы не тратить ресурсы на исполнение, напишем слово Возврат
                //это как return у JS, т.е. код прервётся и процедура прекратит исполняться. В процедуре можно использовать это слово
                //только это слово, без возврата чего либо. Ну и сделаем проверку на наличие в документе в табличной части строк.
                //Если строк нет, то и документ проводить не надо и стоит вообще остановить код.</span>
                Если Материалы.Количество() = 0 Тогда
                    Отказ = Истина;
                    Возврат;
                КонецЕсли;



                <span class="vue-g">//Бывает что вносится в документ поступления товаров несколько строк одного и того же товара и при проведении в регистр также вносится один и тот же товар
                //в нескольких записях. Такой подход быстро затормозит БД. Нужно один и тот же товар подсчитать и занести его одной строкой. Есть способ, который предложил
                //человек из курса Техподдержка. Этот способ через запрос в БД к таблице(табличной части документа). В запросе группируем одинаковый товар подсчитывая его количество
                //и сумму цен товара, потом запрос возвращает уже сгруппированные данные и записывает эти данные в регистр.
                //Я придкмал второй споособ без запроса. Сразу на месте получаем строки табличной части и подсчитываем сумму и количество одинакового товара и записываем в регистр.
                //Будет ли мой способ работать нормально в дальнейшем пока не знаю, оставлю его и буду проверять на деле. И какой сособ работает быстрее тоже пока не знаю.
                
                //мой способ</span>
                СтруктураДляПродукта = Новый Структура;
                МассивНаименованийПродуктов = Новый Массив;
                
                Для каждого ТекСтрокаПродукты Из Продукты Цикл
                    СтруктураДляПродукта.Вставить("Продукт", ТекСтрокаПродукты.Продукт);
                    СтруктураДляПродукта.Вставить("Количество", ТекСтрокаПродукты.Количество);
                    СтруктураДляПродукта.Вставить("СуммаЦенПродукта", ТекСтрокаПродукты.Количество * ТекСтрокаПродукты.Цена);
                    
                    Если МассивНаименованийПродуктов.Найти(СтруктураДляПродукта.Продукт) = Неопределено Тогда
                        
                        Для каждого ТекСтрокаПродукты2 Из Продукты Цикл
                            Если ТекСтрокаПродукты.НомерСтроки >= ТекСтрокаПродукты2.НомерСтроки Тогда
                                Продолжить;	
                            КонецЕсли;
                            Если ТекСтрокаПродукты.Продукт = ТекСтрокаПродукты2.Продукт Тогда
                                СтруктураДляПродукта.Количество = СтруктураДляПродукта.Количество + ТекСтрокаПродукты2.Количество;
                                СтруктураДляПродукта.СуммаЦенПродукта = СтруктураДляПродукта.СуммаЦенПродукта + (ТекСтрокаПродукты2.Количество * ТекСтрокаПродукты2.Цена);
                            КонецЕсли;
                        КонецЦикла;
                    
                    
                        МассивНаименованийПродуктов.Добавить(СтруктураДляПродукта.Продукт);
                        
                        Движения.Продукты.Записывать = Истина;	
                        Движение             = Движения.Продукты.Добавить();
                        Движение.ВидДвижения = ВидДвиженияНакопления.Приход;
                        Движение.Период      = Дата;
                        Движение.Продукт     = СтруктураДляПродукта.Продукт;
                        Движение.Количество  = СтруктураДляПродукта.Количество;
                        Движение.Сумма       = СтруктураДляПродукта.СуммаЦенПродукта;	
                    КонецЕсли;
                КонецЦикла;


                <span class="vue-g">//Бывает такая ситуация. К нам пришёл материал в ПриходнойНакладной, позже ещё пришёл тот же материал, и ещё позже пришёл опять такой же материал
                //при проведении такого документа мы в регистр запишем 3 строки с приходом одинакого материала, так мы забиваем быстро базу записями и она
                //начинает тормозить, поэтому нам бы записать вместо 3 строк в регистр одну, но с просуммированным количеством. Это можно сделать через 
                //запрос в БД для конкретного документа и сгруппировать одинаковый материал просуммировав количество через агрегатную функцию, вот так
                
                //второй способ через запрос
                //Запрос = Новый Запрос;
                //Запрос.Текст = 
                //    "ВЫБРАТЬ
                //    |	Материалы.Материал КАК Материал,
                //    |	СУММА(Материалы.Количество) КАК Количество,
                //    |	СУММА(Материалы.Количество * Материалы.Цена) КАК ОбщаяСумма
                //    |ИЗ
                //    |	Документ.ПриходнаяНакладная.Материалы КАК Материалы
                //    |ГДЕ
                //    |	Материалы.Ссылка = &Ссылка
                //    |
                //    |СГРУППИРОВАТЬ ПО
                //    |	Материалы.Материал";
                //
                //Запрос.УстановитьПараметр("Ссылка", Ссылка);
                //
                //РезультатЗапроса = Запрос.Выполнить();
                //
                //ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();</span>


                <span class="vue-g">//Если не поставить Истина, то мы не увидем записей в регистре(не знаю как насчёт БД, наверно и там их не будет)</span> 
                Движения.ОтстаткиМатериалов.Записывать = Истина;

                Для Каждого ТекСтрокаМатериалы Из Материалы Цикл

                    <span class="vue-g">//Когда мы проводим документ, срабатывает событие ОбработкаПроведения, которое вызывает этот одноимённый обработчик. Документ, который мы проводим
                    //во встроенном языке представлен в виде ДокументОбъект или ЭтотОбъект. У этого объекта есть свойство Движения, которое является коллекцией регистров накопления
                    //со своим наборами записей. Через точку можно указать имя регистра и выбрать его - Движения.ОстаткиМатериалов, далее у регистра есть метод Добавить(), 
                    //который добавляет в свой набор записей новую запись(новую строку). Мы находимся в цикле и перебираем табличную часть документа, поэтому добавив новую запись
                    //мы заполняем её поля значениями реквизитов документа и табличной части.
        
                    //Меня смущало то что мы создаём объект-запись через метод Добавить() и возвращаем его в переменную Движение, заполняем этот объект
                    //полями документа и на этом всё. Казалось бы нужно теперь этот объект Движение добавить к набору записей, но мы тут этого не делаем.
                    //Скорее всего когда вызываем метод Добавить(), то внутри он создаёт объект-запись, сразу добавляет эту запись к набору записей данного регистра и 
                    //возвращает объект в переменную Движение. В 1С скорее всго как и в JS объекты копируются через ссылку, т.е. объект один, а вот в разных переменных
                    //могут быть ссылки на один и тот же объект. Так и тут объект создан, добавлен в набор записей и тут же ссылка на этот объект возвращена в
                    //переменную Движение, мы добавляем этой переменной поля, а значит эти поля записались в объект и запись в наборе записей также получила эти поля.</span>

                    Движение = Движения.ОтстаткиМатериалов.Добавить();
                    Движение.ВидДвижения   = ВидДвиженияНакопления.Приход;
                    Движение.Период        = Дата;
                    Движение.Материал      = ВыборкаДетальныеЗаписи.Материал;
                    Движение.Склад         = Склад;
                    Движение.Количество    = ВыборкаДетальныеЗаписи.Количество;
                    Движение.Сумма         = ВыборкаДетальныеЗаписи.ОбщаяСумма;
                КонецЦикла;

            КонецПроцедуры
        </pre>
    </div>
    <p>Конструктор создал обработчик события <i>ОбработкаПроведения</i> объекта конфигурации Документ ПриходнаяНакладная, поместил его в модуль объекта и открыл текст модуля. Событие ОбработкаПроведения является одним из важнейших событий, связанных с документом. Это событие возникает при проведении документа. Основное назначение обработчика данного события – создание движений по документу. Выполнение различных операций с данными в процедуре обработчика влияет на состояние учёта. Таким образом, именно в эту процедуру разработчик должен поместить собственные алгоритмы преобразования данных, выполняемые в момент проведения документа.</p>
    <p>Поясним текст процедуры обработчика. Объект встроенного языка <b>ДокументОбъект</b>(это как раз объект документа ПриходнаяНакладная, получить этот объект можно написав в этом модуле  - ЭтотОбъект) имеет свойство <b>Движения</b>. Оно возвращает объект <b>КоллекцияДвижений</b>, содержащий коллекцию наборов записей регистров, по которым этот документ может формировать движения. К конкретному набору записей этой коллекции можно обратиться, указав через точку имя регистра, которому принадлежит этот набор записей. Например, <b>Движения.ОстаткиМатериалов</b>. Затем через точку можно использовать различные методы набора записей регистра, например, <b>Движения.ОстаткиМатериалов.Добавить()</b>. Метод Добавить() добавляет новую запись в набор записей. В первой строке процедуры мы устанавливаем свойство <b>Записывать</b> набора записей регистра в значение Истина. То есть в явном виде указываем, что после завершения обработки проведения платформа должна будет записать этот набор записей в базу данных.</p>
    <p>Внутри обработчика расположен цикл Для Каждого … Из … Цикл. Он предназначен для перебора строк табличной части(Материалы) нашего документа . В цикле обращение к табличной части документа происходит по имени (Материалы). Переменная ТекСтрокаМатериалы содержит объект с данными текущей строки табличной части документа. Эта переменная создается в начале цикла и меняется по мере его прохождения. </p>
    <p>В первой строке тела цикла, используя метод <b>Добавить()</b>, мы добавляем к набору записей, который создает наш документ в регистре, новую запись. Тем самым мы создаем объект <b>РегистрНакопленияЗапись</b> и сохраняем его в переменной Движение.</p>
    <p>Используя этот объект, мы можем обратиться к полям этой записи, указав имя поля через точку от этой переменной (например, Движение.Количество). Причем Движение.Материал, Движение.Склад – это измерения регистра, Движение.Количество – это ресурс регистра, а Движение.ВидДвижения и Движение.Период – стандартные реквизиты регистра, которые создаются автоматически.</p>
    <p>Чтобы присвоить полям новой записи регистра соответствующие значения полей документа, мы обращаемся к полям табличной части, указав имя поля через точку от переменной ТекСтрокаМатериалы (например, ТекСтрокаМатериалы.Материал). Заметим, что Склад – это реквизит шапки документа, а Дата – стандартный реквизит документа, который создается автоматически. Причем в цикле меняются только значения полей табличной части документа – ТекСтрокаМатериалы.Материал и ТекСтрокаМатериалы.Количество. Остальные поля не меняются, так как относятся к документу в целом и не зависят от текущей строки табличной части документа. <b>ВидДвиженияНакопления.Приход</b> – это значение системного перечисления, которое определяет вид движения регистра накопления как Приход.</p>
    <p>Таким образом, мы присваиваем нужные значения всем полям новой записи. После перебора всех строк документа (после завершения цикла) в этом наборе записей (Движения.ОстаткиМатериалов) будет содержаться столько записей, сколько строк в табличной части проводимого документа.</p>
    <p>Если мы теперь откроем окно редактирования объекта конфигурации Регистр накопления ОстаткиМатериалов и перейдем на закладку Регистраторы, то в списке документов, созданных в конфигурации, мы увидим отмеченный документ ПриходнаяНакладная, так как мы задали в модуле этого документа формирование движений в регистре ОстаткиМатериалов.</p>
    <p>В заключение отредактируем командный интерфейс, чтобы в разделах Бухгалтерия, Оказание услуг и Учет материалов была доступна ссылка для просмотра записей нашего регистра накопления. Дело в том, что команды открытия регистров также добавляются в панель команд разделов, но по умолчанию они невидимы, в отличие от команд открытия справочников и документов. Отметим галочкой в Панель Навигации.Обычное ОстаточныеМатериалы и мышью перетащим ее в группу Панель навигации.См.также. Тем самым мы переносим команды открытия списка регистров накопления в конец списка подобных команд раздела, так как эти команды не так часто используются и их приоритет невысок.</p>
    <p>Далее можно провести документы в пользовательской части и посмотреть движение в регистре накопления нажав на команду ОстаткиМатериалов.</p>

    <p><b id="11a-baseTable">Основная таблица регистра накопления в БД</b>.</p>
    <p>У этой таблицы есть такие стандартные реквизиты как ВидДвижения, Активность и др. ВидДвижения для каждой записи содержит слово Приход или Расход. Активность говорит системе о том, будет ли запись, у которой Активность стоит ДА учавствовать в построении виртуальных таблиц этого регистра. Иногда проще поставить записи значение НЕТ в поле Активность  чем её удалять.</p>

    <p><b id="11a-vTableOstatki">Виртуальная таблица регистра накопления Остатки</b>.</p>
    <p>Эта таблица не содержит уже левых полей, в полях только измерения и ресурсы. Ресурсы подсчитываются и вычисляется остаток заданного ресурса(количество, сумма и т.д.). Вирт. таб. <span class="vue-b">Остатки имеет всего 2 параметра: Период и Условие</span>.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>ВЫБРАТЬ
                *
            ИЗ
                РегистрНакопления.ОстаткиНоменклатуры.Остатки(
                    &Период,
                    Номенклатура = &Товар
                    //Номенклатура В ИЕРАРХИИ(&Номенклатура)
                )
            </b></span>
        </pre>
    </div>

    <p><b id="11a-vTableOboroti">Виртуальная таблица регистра накопления Обороты</b>.</p>
    <p>Вирт. таблица Обороты подсчитывает ресурс в возрастающем направлении. Обычно считают деньги потраченные на закупку товаров или заработанные с продажи. Обороты отбираются за какой-то отрезок времени, т.е. нужно начало даты и конец даты. <span class="vue-b">Обороты имеет 4 параметра: начало периода, конец периода, периодичность и условие</span>. Периодичность задаёт отезки, на которые будут биться обороты, например, Месяц, тогда появится дополнительное поле Период, в котором будут по месяцам разбиты обороты ресурса. Условие как и у всех таблиц такое же. Все эти параметры необязательны.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>ВЫБРАТЬ
            	*
            ИЗ
                РегистрНакопления.Продажи.Обороты(
                    &НачалоПериода,
                    &КонецПериода,
                    Месяц,
                    Номенклатура = &Товар
                )
            </b></span>
        </pre>
    </div>
    <p>Если параметр Периодичность задать Авто, то тогда периодичность оборотов будет зависить от полей отбора. Там есть такие поля как ПериодГод, ПериодДекада, ПериодДень и т.д. Виртуальные таблицы не нужно группировать, там уже предусмотрено системой такое поведение. Например если мы хотим получить только поле КоличествоОборот, то указываем в отборе только это поле и система сама сгруппирует и просуммирует записи этого поля и выдастся одна колонка с одной записью - какое то число.</p>

    <p><b id="11a-vTableOborotiIOstatki">Виртуальная таблица регистра накопления ОстаткиИОбороты</b>.</p>
    <p>Хочу отметить, что тут КоличествоОборот отличается от КоличествоОборот в вирт. таблице Оборот. Потому что в этой таблице КоличествоОборот подсчитывает оборот оставшегося количества товаров, тогда как в таблице Оборот подсчитывается количество проданных, поступивших и т.д. товаров.</p>
    <p>Эта таблица имеет уже 5 параметров: НачалоПериода, КонецПериода, Периодичность, Метод дополнения периодов, Условие. Не буду описывать все параметры, можно посмотреть это в справочнике. Эту таблицу используют когда нужны остатки на начало и конец периода и обороты за этот период.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>ВЫБРАТЬ
            	*
            ИЗ
                РегистрНакопления.ОстаткиНоменклатуры.ОстаткиИОбороты(
                    &НачалоПериода,
                    &КонецПериода,
                    Месяц,
                    Движения,
                    Номенклатура = &Товар
                )
            </b></span>
        </pre>
    </div>


















    <h3 class="header-style2" id="11aa">Отдельно об регистре сведений</h3>
    <p><b id="11aa1">Рассмотрим переодический регистр сведений</b>.</p>
    <p>Предположим наше предприятие оказывает услуги. У нас имеется справочник Номенклатура, в котором описаны товары и услуги. У наших услуг должны быть цены. Казалось бы логично разместить цены как реквизит у каждой услуги в справочнике, однако стомиость услуг имеет особенность меняться со временем. И может сложиться такая ситуация, когда нам потребуется внести изменения или уточнения в один из ранее проведенных документов Оказание услуги. В этом случае мы не сможем получить правильную стоимость услуги, поскольку в реквизите справочника будет храниться последнее введенное значение. Что это значит? Приведу пример. Вот завели мы в спрвочнике Номенклатура реквизит Цена и указали стоимость для услуги Диагностика - 5000 руб. Затем мы создали документ Оказание услуги и начали заполнять его. Указали в документе сотрудника(Иванов), который выполнял диагностику, указали цену из справочника - 5000, провели документ. Проходит время, у нас на предприятии поменялась цена на диагностику и теперь услуга стоит 6000 руб.. мы идём в справочник и меняем стоимость с 5000 на 6000. Опять проходит время и мы вдруг понимаем, что когда то мы проводили документ, где Иванов оказал услугу Диагностика, а на самом деле услугу как оказалось выполнил Петров и мы идём в документ и меняем Иванова на Петрова. Нам снова нужно провести документ, но при заполнении документа автоматически возьмётся последняя цена из справочника - 6000 руб. Но нам так нельзя, нам нужна та старая цена в 5000 руб., а её уже не существует ни в каких БД и хранилищах. Вот для этих случаев цены и заполняются в регистрах сведений, которые могут хранить цены на одну и туже услугу для разного времени.</p>
    <p>Также предприятие вдруг захочет видеть зависимость прибыли от изменения стоимость услуг, то тогда спрвочники опять же не помогут, а помогут регистры сведений, которые позволяют анализировать изменение стоимости услуг во времени.</p>

    <p><b id="11aa2">Что такое регистр сведений</b>.</p>
    <p>Объект конфигурации Регистр cведений предназначен для описания структуры хранения данных в разрезе нескольких измерений. На основе объекта конфигурации Регистр сведений платформа создает в базе данных таблицу, в которой может храниться произвольная информация, «привязанная» к <b>набору измерений</b>.</p>
    <img src="../img/1С-1/2022-12-06_08-23-15.png" class="screen" alt="">
    <p>Принципиальное отличие регистра сведений от регистра накопления заключается в том, что каждое движение регистра сведений устанавливает новое значение ресурса, в то время как движение регистра накопления изменяет существующее значение ресурса. По этой причине регистр сведений может хранить любые данные (а не только числовые, как регистр накопления).</p>
    <p>Следующей важной особенностью регистра сведений является его способность (при необходимости) хранить данные с привязкой ко времени. Благодаря этому регистр сведений может хранить не только актуальные значения данных, но и историю их изменения во времени. Регистр сведений, использующий привязку ко времени, называют <b>периодическим регистром сведений</b>.</p>
    <p>Периодичность регистра сведений можно определить одним из следующих значений:</p>
    <ul class="list">
        <li>в пределах секунды;(в на какую дату и время создали цену, такая дата с временем и будет стоять, не сбрасываясь никуда)</li>
        <li>в пределах дня;(вводим дату и время и она сбрасывается на начало заданного дня)</li>
        <li>в пределах месяца;(сбрасывается на начало заданного месяца)</li>
        <li>в пределах квартала;(сбрасывается на начало квартала заданной даты, например добавил цену 04.03.2022, а сбросится до 01.01.2022)</li>
        <li>в пределах года;(ну тут будет сбрасываться всё на 1 января)</li>
        <li>в пределах регистратора (если установлен режим записи Подчинение регистратору).</li>
    </ul>
    <p>Периодический регистр сведений всегда содержит служебное поле Период, добавляемое системой автоматически. Оно имеет тип Дата и служит для указания факта принадлежности записи к какому-либо периоду. При записи данных в регистр платформа всегда приводит значение этого поля к началу того периода, в который он попадает. Например, если в регистр сведений с периодичностью в пределах месяца записать данные, в которых период указан как 08.04.2022, то регистр сохранит эти данные со значением периода, равным 01.04.2022.</p>
    <p>Как и для других регистров, система контролирует уникальность записей для регистра сведений. Однако если для прочих регистров уникальным идентификатором записи является регистратор и номер строки, то для регистра сведений применяется другой принцип формирования ключевого значения.</p>
    <p>Ключом записи, однозначно идентифицирующим запись, является в данном случае совокупность значений <b>измерений</b> регистра и <b>периода</b> (в случае, если регистр сведений периодический). Например, для периодического регистра сведений с измерением Товар и ресурсом Цена ключом записи будет набор значений полей Период и Товар. Регистр сведений не может содержать несколько записей с одинаковыми ключами.</p>
    <p>Если продолжать сравнение с регистром накопления, то можно сказать, что регистр сведений предоставляет больше свободы в редактировании хранимых данных. Наряду с возможностью использования в режиме подчинения регистратору (когда записи регистра сведений «привязаны» к документу-регистратору) регистр сведений может применяться и в независимом режиме, в котором пользователю предоставляется полная свобода интерактивной работы с данными регистра. Регистр сведений, не использующий подчинение регистратору, называют независимым регистром сведений.</p>

    <p><b id="11aa3">Добавление переодического регистра сведений</b>.</p>
    <p>Приступим к созданию периодического регистра сведений, который будет хранить развернутые во времени розничные цены материалов и стоимости услуг, оказываемых нашим предприятием.</p>
    <p>Добавим в конфигураторе новый регистр сведений с именем Цены, установим преодичность - В пределах секунды. Такую периодичность мы выбрали для того, чтобы иметь возможность отслеживать цены несколько раз в течение дня. Если же так часто не предполагается изменять цены, то можно выбрать в пределах дня.</p>
    <p>Обратим внимание на свойство Режим записи. По умолчанию оно имеет значение – Независимый, то есть мы создаем независимый регистр сведений и сможем в дальнейшем вводить в него данные без использования регистратора, вручную.</p>
    <p>Далее перейдём на закладку Данные и создадим измерение Номенклатура с типом СправочникСсылка.Номенклатура. В свойствах этого измерения укажем, что оно будет Ведущим, поставив галочку. Свойство <b>Ведущее</b> имеет смысл использовать лишь тогда, когда измерение имеет тип ссылки на объект базы данных. Установка свойства Ведущее будет говорить о том, что запись регистра сведений представляет интерес, пока существует тот объект, ссылка на который выбрана в качестве значения этого измерения в этой записи. При удалении объекта все записи регистра сведений по этому объекту тоже будут автоматически удалены. Проще говоря, если мы из справочника удалим услугу или товар, то и в регистре удалятся записи связанные с этой услугой и товаром, конечно если такая связь существует с помощью свойства Ведущий.</p>
    <p>Также в результате того, что это измерение регистра мы сделали ведущим, в форме элемента справочника Номенклатура, в панели навигации в группе Перейти появится ссылка. По ней возможен переход к записям этого регистра, которые содержат в измерении Номенклатура ссылку на этот элемент справочника.</p>
    <p>Затем создадим ресурс Цена, тип Число, длина 15, точность 2, неотрицательное.</p>

    <p><b id="11aa4">Создание записей в регистре сведений</b>.</p>
    <p>В пользовательском режиме выберем наш регистр сведений и надмём команду Создать. Какой укажем период? Если у нас уже есть проведённые раньше документы по оказанию услуг, то надо задать дату задним числом,т.е. чтобы она была меньше(раньше) или равна дате документа.</p>
    <img src="../img/1С-1/2022-12-06_09-12-23.png" alt="">
    <p>Итак, мы с вами имеем очень полезную возможность в нашей программе – установка цен на услуги и материалы. Поскольку цены хранятся с привязкой к дате, мы можем заранее установить новые цены и быть уверены в том, что новые цены вступят в действие не раньше указанного для них времени. Например, создам новую запись для услуги Диагностика с новой ценой 300 руб. Укажу дату 4 января 2023 года, так как у меня стоит в пределах месяца, то дата сбросится на 01.01.2023. И теперь когда услуга Диагностика будет выполнена в январе, то уже возьмётся стоимость этой услуге равной 300 р.</p>

    <p><b id="11aa5">Автоматическая подстановка цены в документ при выборе номенклатуры. Используется объектная модель запроса</b>.</p>
    <p>Наша задача заключается в следующем. Цена номенклатуры у нас теперь хранится в отдельном регистре сведений. Когда мы создаем или изменяем документ ОказаниеУслуги и добавляем в табличную часть какую-либо номенклатуру, нам хочется, чтобы одновременно с этим в документ подставлялась бы сразу и актуальная цена этой номенклатуры, полученная из регистра сведений и соответствующая дате документа. Для этого сделаем 2 вещи. Напишем функцию, которая будет нам возвращать цену номенклатуры и процедуру, которая будет вызывать эту функцию, когда мы будем вносить название номенклатуры в табличную часть. И 2 вешь это внесение нашего кода в общий модуль, потому что он понадобится скорее всего в других частях конфигурации.</p>
    <p>Создадим Общий модуль "РаботаСоСправочниками" и в нём создадим функцию ПолучитьРозничнуюЦену. В палитре совйств этого модуля мы видим, что стоит по умлчанию галочка Сервер, это значит что объекты данного модуля будут собраны и выполнены на стороне сервера. <b>(ВАЖНО)</b> Кроме этого, установим флажок Вызов сервера для того, чтобы экспортные процедуры и функции этого модуля можно было вызывать с клиента.</p>
    <img src="../img/1С-1/2022-12-06_10-04-16.png" alt="">
    <p>Вот такой код будет в функции ПолучитьРозничнуюЦену():</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>Функция ПолучитьРозничнуюЦену(УказаннаяДата, ЭлементНоменклатуры) Экспорт
                <span class="vue-g">//создаём структуру Отбор, в которую поместим реквизиты измерения с их значениями, чтобы произвести
                //нужный нам отбор записей</span>
                Отбор = Новый Структура("Номенклатура", ЭлементНоменклатуры);

                <span class="vue-g">// Получить значения ресурсов регистра.</span>
                <span class="vue-g">// Регистр всегда по запросу возвращает значения ресурсов, не измерений</span>
                <span class="vue-g">//Также есть метод Получить(УказаннаяДата, Отбор). В чём разница? В том что есть запись</span>
                <span class="vue-g">//на дату 01.12.2022, а мы указываем Получить('03.12.2022', Отбор), нам не вернётся ничего, потому что конкретно на эту дату нет ничего</span>
                <span class="vue-g">//а метод ПолучитьПоследнее('03.12.2022', Отбор) вернёт последнее значение цены, которое там вообще есть до этой даты</span>
                ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(УказаннаяДата, Отбор);

                Возврат ЗначенияРесурсов.Цена;
            КонецФункции</b></span>
        </pre>
    </div>
    <p>Имя ключа структуры («Номенклатура») должно совпадать с именем измерения регистра, заданного в конфигураторе, а значение элемента структуры (ЭлементНоменклатуры) задает отбираемое по данному измерению значение. Во второй строке мы обращаемся к менеджеру регистра сведений Цены (РегистрыСведений.Цены) и выполняем метод ПолучитьПоследнее(), который возвращает нам значения ресурсов самой поздней записи регистра, соответствующей передаваемой в функцию дате (УказаннаяДата) и значениям измерений регистра (Отбор).</p>
    <p>Метод ПолучитьПоследнее возвращает структуру, содержащую значения ресурсов, которая сохраняется в переменной ЗначенияРесурсов. Вообще говоря, у регистра может быть несколько ресурсов. В нашем регистре ресурс один, но все равно будет возвращена структура, содержащая единственный элемент. Поэтому в следующей строке мы получаем искомую нами розничную цену, просто указав имя нужного нам ресурса регистра через точку (ЗначенияРесурсов.Цена), и возвращаем ее при выполнении функции.</p>
    <p>Теперь эту функцию нужно вызвать в некоторый момент работы документа.</p>
    <p>Откроем форму документа ОказаниеУслуги и для поля Номенклатура табличной части ПереченьНоменклатуры задаим обработчик для события ПриИзменении на клиенте. В модeле формы появится процедура, внесём в неё такой код:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b><span class="vue-g">// Получить текущую строку табличной части.</span>
            СтрокаТабличнойЧасти = Элементы.ПереченьНоменклатуры.ТекущиеДанные;

            <span class="vue-g">// Установить цену.</span>
            СтрокаТабличнойЧасти.Цена = 
                РаботаСоСправочниками.ПолучитьРозничнуюЦену(Объект.Дата, СтрокаТабличнойЧасти.Номенклатура);

            <span class="vue-g">// Пересчитать сумму строки табличной части</span>
            РаботаСДокументами.РассчитатьСумму(СтрокаТабличнойЧасти);</b></span>
        </pre>
    </div>
    <p>Думаю тут код понятен и не буду его расписывать.</p>

    <p><b id="11aa6">Запись в регистр сведений из документа числовых значений</b></p>
    <p>Создадим регистр сведений "ЦеныПоставщиков", укажем переиодичность "в течении секунды" и укажем регистратором документ "ПоступлениеТоваров". Затем в документе во вкладке Движения через констркутор напишем код движений.</p>
    <div class="code-style">
        <pre>
            Процедура ОбработкаПроведения(Отказ, Режим)
            <span class="vue-b"><b><span class="vue-g">// регистр ЦеныПоставщиков 
            //Свойство Записывать указывает записать новую запись в инфобазу или нет</span>
            Движения.ЦеныПоставщиков.Записывать = Истина;
            Для Каждого ТекСтрокаТовары Из Товары Цикл
                <span class="vue-g">//Движения это коллекция наборов записей регистров
                //ЦеныПоставщиков это набор записей регистра с данным именем
                //Метод Добавить() добавляет в набор записей новую запись и возвращает ссылку на неё
                //Ну а далее мы заполняем эту новую запись Движение значениями</span>
                Движение = Движения.ЦеныПоставщиков.Добавить();
                Движение.Период = Дата;
                Движение.Номенклатура = ТекСтрокаТовары.Товар;
                Движение.Контрагент = Контрагент;
                Движение.Цена = ТекСтрокаТовары.Цена;
            КонецЦикла;
        КонецПроцедуры</b></span>
        </pre>
    </div>

    <p><b id="11aa7">Запись в регистр сведений из документа не числовых значений</b></p>
    <p>Бывает когда переодические регистры используют не только для установления новых ЧИСЛОВЫХ значений во времени, но и других значений. Как пример, у нас есть сотрудники в справочнике Сотрудники и есть справочник Подразделения. Мы могли бы установить в Сотрудники реквизит Подразделения и указывать для каждого сотрудника где он работает, но сотрудники могут перемещаться внутри производства по разным подразделениям и тогда в справочнике мы сможем отследить только последние нахождение сотрудника в подразделении и будем лишены возможности проследить в каких подразделениях он работал в течении, например, месяца, что повлияет на зарплату и драугие отчёты. Поэтому нам нужна возможность отследить его перемещения во времени по подразделениям. Для этого можно завести новый регистр сведений и в Измерение добавить Сотрудник, а в ресурс добавить Подразделение и можно ещё в ресурс добавить Оклад. Также заводится документ, например, КадровыйПриказ, который записывает перемещение сотрудника и делает записи в регистре сведений. Добавим этому документу рекизиты - Сотрудник, Подразделение, Оклад, и ДатуПриёма(дата когда сотрудник перевёлся в новое подразделение). Чтобы делать записи в регистр сведений, в этом регистре нужно выбрать режим записи "подчинение регистратору" на вкладке Основные. Режим записи "независимый" позволяет пользователю открыть регистр и заполнять его от руки.</p>
    <p>Далее либо через конструктор , либо сам надо добавить код движения в модуле объекта документа. Там будет запись одного движения(записи). В пользовательской части мы теперь не увидим регистр, потому что режим "подчинение регистратору" скрыл его. Чтобы увидеть регистр откроем в подсистемах ту подсистуму, куда я установил регистр и правой кнопкой по полсистеме и выбираем "открыть командный интерфейс". В окне поставим галочку видимости нашего регистра.</p>
    <p>В регистре появились новые 2 поля - "Регистратор" и "Номер строки". Пока всё.</p>

    <p><b id="11aa8">Запись в регистр сведений программно из обработки</b></p>
    <p>Допустим у нас есть Справочник Валюты, где перечисляются названия заграничных денег. И есть регистр сведений, где мы храним курсы и кратности этих денег во времени(переодический). Нам нужно как то читать и писать в этот регистр.Мы можем писать в него из пользовательской части, можем писать с помощью документа, а бывает нужно писать в него программно, например, из обработки, чтобы загрузить из инета курсы валют и записать в регистр. Создадим обработку, добавим в неё кнопку и по кнопке будем писать в регистр. Код находится в модуле формы обработки.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//эти 2 процедуры обработчики кнопки ЗаписатьКурс</span>
            <span class="vue-b"><b>&НаКлиенте
            Процедура ЗаписатьКурс(Команда)
                ЗаписатьКурсНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ЗаписатьКурсНаСервере()
                <span class="vue-g">//НаборЗаписей теперь содержит некую коллекцию, которая содержит описание каждой записи регистра</span>
                НаборЗаписей = РегистрыСведений.КурсыВалют.СоздатьНаборЗаписей();

                <span class="vue-g">//метод Добавить() создаёт запись в этом наборе и возвращает ссылку на эту запись</span>
                Запись = НаборЗаписей.Добавить();

                <span class="vue-g">//заполняем запись</span>
                Запись.Период = Период;
                Запись.Валюта = Валюта;	
                Запись.Курс = Курс;
                Запись.Кратность = Кратность;

                <span class="vue-g">//даём команду записать запись в БД. У метода Записать() по умолчанию стоит</span>
                <span class="vue-g">//булево значение Истина(Замещать), т.е. при добавлении записи мы замещаем предыдущую запись</span>
                <span class="vue-g">//а нам надо добавлять, поэтому ставим Ложь</span>
                НаборЗаписей.Записать(Ложь);
            КонецПроцедуры</b></span>
        </pre>
    </div>

    <p><b id="11aa9">Читаем данные из регистра сведений с помощью табличной модели(пишем запрос)</b></p>
    <p>Выше я уже описывал как читать данные из регистра через объектную модель, теперь тут опишу как с помощью запросов получить данные. Вот такой код всё для тех же курсов валют:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>&НаКлиенте
            Процедура ПолучитьКурсЗапросом(Команда)
                ПолучитьКурсЗапросомНаСервере();
            КонецПроцедуры


            &НаСервере
            Процедура ПолучитьКурсЗапросомНаСервере()
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	КурсыВалютСрезПоследних.Курс КАК Курс,
                    |	КурсыВалютСрезПоследних.Кратность КАК Кратность
                    |ИЗ
                    |	РегистрСведений.КурсыВалют.СрезПоследних(&Период, Валюта = &Валюта) КАК КурсыВалютСрезПоследних";
                
                Запрос.УстановитьПараметр("Валюта", Валюта);
                Запрос.УстановитьПараметр("Период", Период);
                РезультатЗапроса = Запрос.Выполнить();
                ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
                
                ВыборкаДетальныеЗаписи.Следующий();
                Курс = ВыборкаДетальныеЗаписи.Курс;
                Кратность = ВыборкаДетальныеЗаписи.Кратность;
            КонецПроцедуры</b></span>
        </pre>
    </div>
    <p>Для регистра сведений в БД вычисляются ещё 2 виртуальные таблицы: а)СрезПервых, б)СрезПоследних. Эти таблицы соответствуют методам объектной модели ПолучитьПервое() и ПолучитьПоследнее(). У виртуальных таблиц есть свои параметры и условия, задаются в скобках.</p>

    <p><b id="11aa10">Дополнение от меня.</b></p>
    <p>Как я заметил, уникальность записей в непереодическом регистре сведений основывается только на полях измерения. Например есть 2 измерения: Номенклатура и Контрагент и ресурс Цена. Мы можем задать 2 записи: Холодильник от Поставщика1 и Холодильник от Поставщика2 и всё будет нормально, уникальность записей обеспечивается 2мя полями  - Номенклатура и Контрагент. А вот если взять и перенести Контрагент в ресурс и попробовать снова задать эти 2 записи, то уже не получится, потому что теперь уникальность записей обеспечивает только одно поле измерения Номенклатура. Мы в первой записи зададим Холодильник от Поставщика1, а на второй записи нам скажут, что запись с именем Холодильник уже есть.</p>
    <p>В переодическом регистре сведений такое прокатит(когда контрагента перенесу в ресурс)только если период выбран в "В пределах секунды", потому что тут уже уникальность записи обеспечивается датой(а дата будет каждую секунду разная) и полем измерения. Поэтому наверное измерений должно быть как минимум 2.</p>

    <p><b id="11aa11">Виртуальная таблица РегистраСведений - СрезПервых и СрезПоследних</b>.</p>
    <p>Эта виртуальная таблица(будем брать СрезПоследних, потому что СрезПервых встречается крайне редко) возвращает данные на последнюю дату то, что мы запрашиваем. Таблица умеет принимать свои собственные параметры. <span class="vue-b">У этой вирт. таблицы всего 2 параметра - Период и Условие</span>.</p> 
    <p>Период имеет тип параметра: Дата, МоментВремени, Граница. Указывается дата, момент времени или граница, на которые будут получены сведения. Если параметр не задан, будут выбираться наиболее поздние записи, без ограничения по дате.</p>
    <p>По условию мы ограничиваем отбор записей по аргументу. Оба параметра не обязательны. Желательно для витруальных таблиц параметры задавать именно для них, потому что если параметры задавать через слово ГДЕ, то будет делаться лишняя работа. Сначала вирт. таблица построится, а потом к ней будут применены ограничения отбора и она снова будет перестраиваться. Вот пример такой таблицы.</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>ВЫБРАТЬ
                Номенклатура,
                Контрагент,
                Цена,
                Период
            ИЗ
                РегистрСведений.ЦеныПоставщиков.СрезПоследних(
                    &Период,
                    Номенклатура = &Товар
                    //Контрагент = &Поставщик
                )</b></span>
        </pre>
    </div>



















    <h3 class="header-style2" id="11b">Крестики-нолики</h3>
    <p><b>Крестики-нолики</b></p>
    <p>Когда создаём форму мы добавляем в неё Команды, которые становятся кнопками при переносе команды в элементы формы. При клике по кнопке обычно выполняется код. Код пишется в модуле формы(правая вкладка снизу формы). Вот такой код говорит, что обращаемся к текущей нажатой кнопке и тут же меняем заголовок кнопки при нажатии:</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">&НаКлиенте
            Процедура <span class="vue-b">НажатиеНаКнопку</span>()
                <span class="vue-g">//как только будет нажата кнопка с которой свазяна эта процедура
                //то процедура отработает и мы можем тут же обратиться к нажатому
                //элементу формы(кнопке) по объекту "ТекущийЭлемент" и запишем в кнопку новый заголовок
                //, это что то по типу this в js при срабатывании обработчика события</span>
                <span class="vue-b">ТекущийЭлемент</span>.<span class="vue-b">Заголовок</span> = <span class="vue-b">"0"</span>;
                

                <span class="vue-g">//чтобы обратиться к любому элементу-кнопке формы есть
                //такая коллекция как "Элементы" и в эту коллекуию как к массиву 
                //обращаемся к элементу через [] по имени элемента или через точку</span>
                <span class="vue-b">Элементы</span>[<span class="vue-b">ИмяЭлемента</span>].<span class="vue-b">Заголовок</span> = <span class="vue-b">"0"</span>;

                <span class="vue-g">//например у кнопки во вкладке "Элементы формы" имя "Кнопка1"
                //тогда обращение будет таким</span>
                <span class="vue-b">ИмяЭлемента <span class="vue-r">=</span> "Кнопка1"</span><span class="vue-r">;</span>
                <span class="vue-b">Элементы</span>[<span class="vue-b">ИмяЭлемента</span>].<span class="vue-b">Заголовок</span> = <span class="vue-b">"0"</span>;
            КонецПроцедуры</span>
        </pre>
    </div>
    <p>Вот пример обработчиков для кнопок крестики-нолики. На всех элементах кнопках висит один обработчик - НажатиеНаКнопку:</p>
    <img src="../img/1С-1/2022-10-19_11-25-06.png" class="screen" alt="">
    <p>Модуль формы</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Перем Поле;//тут хранятся наши ячейки


            &НаКлиенте
            Процедура ПриОткрытии(Отказ)
                //когда обработка "Крестики-нолики" откроется у пользователя
                //наступит событие и сработает этот обработчик
                
                //итак, присвоим начальное значение для переменной Поле
                //установим двухмерный массив 3х3
                Поле = Новый Массив;
                Поле.Добавить(Новый Массив(3));
                Поле.Добавить(Новый Массив(3));
                Поле.Добавить(Новый Массив(3));
                
                //пробежимся по массиву и в каждую его ячейку установим " "
                //это будет сигналом того, что ячейки свободны
                Для Шаг1 = 0 По 2 Цикл
                    Для Шаг2 = 0 По 2 Цикл
                        Поле[Шаг1][Шаг2] = " ";
                    КонецЦикла;
                КонецЦикла;
            КонецПроцедуры

            &НаКлиенте
            Процедура НажатиеНаКнопку(Команда)
                //эта процедура сработает как только будет нажата любая кнопка
                //связанная с этой процедурой, это 9 кнопок для крестиков-ноликов
                ТекущийЭлемент.Заголовок = "0";
                ИмяЭлемента = ТекущийЭлемент.Имя;
                Позиция1 = Сред(Прав(ИмяЭлемента, 2), 1, 1);
                Позиция2 =  Прав(ИмяЭлемента, 1);
                Поле[Число(Позиция1)][Число(Позиция2)] = "0";
                
                Если ИграОкончена() Тогда
                
                    Сообщить("Вы победили компьютер");
                
                Иначе
                    ХодКомпьютера();
                    Если ИграОкончена() Тогда
                        Сообщить("Компьютер победил");
                    КонецЕсли;
                КонецЕсли;
            КонецПроцедуры

            &НаКлиенте
            Процедура ХодКомпьютера()
                //тут 2 способа работы компа, это первый, он просто проверяет 
                //поле на пустоту и заполняет её, идёт последовательно
                //сделаем обход всех ячеек массива Поле
                //КомпПоходил = Ложь;
                //Для Шаг1 = 0 По 2 Цикл
                //	Если КомпПоходил Тогда
                //		Прервать
                //	КонецЕсли;
                //
                //	Для Шаг2 = 0 По 2 Цикл
                //		 //если в очередной ячейке массива хранится пустая строка
                //		 Если Поле[Шаг1][Шаг2] = " " Тогда
                //		    //это значит, что ячейка свободна и комп может 
                //			//в неё походить, записав "Х"
                //			Поле[Шаг1][Шаг2] = "Х";
                //			
                //			//составим имя кнопки прибавив текущий элемент массива
                //			ИмяКнопки = "Кнопка" + Шаг1 + Шаг2;
                //		 	Элементы[ИмяКнопки].Заголовок = "Х";
                //			КомпПоходил = Истина;
                //		    Прервать;
                //		 КонецЕсли;
                //	
                //	КонецЦикла;
                //
                //КонецЦикла;
                //КомпПоходил = Ложь;
                
                
                //это 2й способ работы компа, выбираются элементы поля случайно
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                
                Пока Истина Цикл
                    СЧСтроки = ГСЧ.СлучайноеЧисло(0, 2);
                    СЧСтолбца = ГСЧ.СлучайноеЧисло(0, 2);
                    ИмяЭлемента = "Кнопка" + СЧСтроки + СЧСтолбца;
                    
                    Если Поле[СЧСтроки][СЧСтолбца] = " " Тогда
                        Поле[СЧСтроки][СЧСтолбца] = "Х";
                        Элементы[ИмяЭлемента].Заголовок = "Х";
                        Прервать;
                    КонецЕсли;
                КонецЦикла;	
            КонецПроцедуры


            &НаКлиенте
            Функция ИграОкончена()

                Если
                    Поле[0][0] &lt;> " " И
                    Поле[0][0] = Поле[0][1] И
                    Поле[0][0] = Поле[0][2]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[1][0] &lt;> " " И
                    Поле[1][0] = Поле[1][1] И
                    Поле[1][0] = Поле[1][2]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[2][0] &lt;> " " И
                    Поле[2][0] = Поле[2][1] И
                    Поле[2][0] = Поле[2][2]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[0][0] &lt;> " " И
                    Поле[0][0] = Поле[1][0] И
                    Поле[0][0] = Поле[2][0]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[0][1] &lt;> " " И
                    Поле[0][1] = Поле[1][1] И
                    Поле[0][1] = Поле[2][1]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[0][2] &lt;> " " И
                    Поле[0][2] = Поле[1][2] И
                    Поле[0][2] = Поле[2][2]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[0][0] &lt;> " " И
                    Поле[0][0] = Поле[1][1] И
                    Поле[0][0] = Поле[2][2]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[0][2] &lt;> " " И
                    Поле[0][2] = Поле[1][1] И
                    Поле[0][2] = Поле[2][0]
                Тогда
                    Возврат Истина;
                ИначеЕсли
                    Поле[0][1] &lt;> " " И
                    Поле[0][1] = Поле[1][0] И
                    Поле[0][1] = Поле[2][0]
                Тогда
                    Возврат Истина;
                Иначе
                    Возврат Ложь;
                КонецЕсли;
            КонецФункции
        </pre>
    </div>











    <h3 class="header-style2" id="12">Объектная модель запросов к БД</h3>
    <p>Существует 2 способа сделать запрос к БД. Это через объектную модель и через табличную модель. Тут про объектную модель.</p>
    <p>Если в конфигураторе зайти в синтакс помошник и набрать в поиске ДокументыМенеджер.ИмяДокумента или СправочникиМенеджер.ИмяСпраовчника, то найдём целую пачку методов запроса данных из этих объектов конфигурации.</p>
    <p>У объектной модели запросов есть существенные недостатки.</p>
    <ul class="list">
        <li>Нельзя с помощью одного метода получить данные из нескольких таблиц. Например, есть таблица с товарами и есть таблица с ценами этих товаров и нет такого метода, который за одно обращение к БД сможет прочитать данные из 2х этих таблиц. Чтобы получить данные этих таблиц нужно выполнить 2 запроса с выборкой из Справочники.Товары.Выбрать(); и РегистрыСведений.ЦеныТоваров.Выбрать();. И как следствие чем больше запросов к БД, тем долше будет это всё работать.</li>
        <li>Ограниченные возможности фильтрации. Например, в языке запросов есть разные способы выборки с разными условиями. При объектной модели такого не сделать. Вернее фильтры есть кое-какие, но их недостаточно</li>
        <li>Методы не позволяют группировать данные и формировать итоги.</li>
        <li>Избыточность чтения. То есть выборка будет всего что есть по указанному объекту, а нужно было всего лишь вернуть данные какого то реквизита.</li>
    </ul>






    <h3 class="header-style" id="13">Получение данных "Справочника" из базы</h3>
    <p><b id="13a">Получение данных "Справочника" из базы</b></p>
    <p>Для примера создадим внешнюю обработку. Откроем настройку формы этой обработки. В форме обработки создадим кнопку с командой. Создадим команду, перетащим её в элементы формы и назовём её, например, ОбъектнаяМодель, далее нужно привязать обработчик к этой кнопке. При создании обработчика выберем в открывшемся окошке "Создать на клиенте и процедуру на сервере", откроется модуль с 2мя процедурами, одна на клиенте, вторая на сервере. Первая запускаемая с клиента процедура вызывает другую процедуру, которая выполнится на сервере. потому что работа с БД выполняется только на сервере. Итак опишем серверную процедуру, которая получает данные из Справочника "Сотрудники". Для доступа к данным справочника используется управляющий(тот самый СправочникиМенеджер), доступ к которому осуществляется так: Управляющий = Справочники.Сотрудники; "Управляющий" это просто переменная и имя может быть любым, она просто отражает то, что возвращает Справочники.Сотрудники. В переменную "Управляющий" возвращаются ещё не сами данные справочника, а некоторый программный объект, через который мы можем что-либо делать со справочником. Управляющий объект справочника это как бы прослойка между нашим кодом и данными справочника. И получается, что, если мы хотим прочитать все элементы справочника, то мы не можем сделать это напрямую. Мы можем только поросить об этом нашу прослойку между нами и справочником. Чтобы сделать это - необходимо вызвать встроенный в управляющий объект метод "Выбрать". Вызывается он через точку после имени переменной "Управляющий" и возвращает коллекцию элементов справочника:</p>
    <div class="code-style">
        <pre>
        <span class="vue-b"><b>Управляющий = Справочники.Сотрудники;
        Выборка = Управляющий.Выбрать();</b></span>
        //можно сразу написать
        <span class="vue-b"><b>Выборка = Справочники.Сотрудники.Выбрать();</b></span>
        //в выборку возвращается объект с типом "СпрвочникВыборка.&lt;ИмяСправочника>"

        //также есть метод ВыбратьИерархически(), который позволяет выбрать записи внутри указанной группы(папки)
        <span class="vue-b"><b>Выборка = Справочники.Сотрудники.ВыбратьИерархически(&lt;Группа>);</b></span>
        //параметр Группа должен иметь тип СправочникСсылка.&lt;Имя спрвочника>, как получить такую группу
        //допустим у нас есть пол ввода, поле имеет тип СправочникСсылка.&lt;Имя спрвочника>, мы выбираем из списка
        //имя группы из справочника(не эелемента) и передаём это имя в метод. Чтобы иметь возможность выбрать группу из списка
        //для этого поля в форме в свойствах нужно указать в параметре ВыборГруппИЭлементов значение Группа
        //потому что по умолчанию нельзя выбирать группы, только элементы
        </pre>
    </div>
    <p>Что представляет из себя выборка? Выборка представляет из себя коллекцию, но не такую, как массив или список значений. Выборка представляет из себя опять объект. Особенность этого объекта в том, что он умеет перебирать элементы нужного нам справочника. Причём перебирает он их динамически. Это означает, что считывание элементов справочника происходит не сразу, а порциями из базы данных. Такой подход позволяет быстро обходить большие списки справочников, не загружая в память компьютера все сразу.
    Чтобы получить очередную порцию данных из выборки, надо вызывать у выборки встроенный метод "Следующий". Получение порций данных(одна порция соответствует одному элементу справочника) обычно происходит в цикле. Когда данные(элементы справочника) в выборке закончатся, метод "Следующий" вернёт Ложь и цикл остановится. После каждого вызова метода "Следующий"(если он вернул Истина) выборка будет содержать в себе все поля с данными только что считанного элемента справочника:</p>
    <div class="code-style">
        <pre>
        <span class="vue-g">//бывает, что в справочнике строки-элементы лежат в папке
        //и при переборе в цикле папка будет засчитываться как элемент
        //а значит Выборка.Слудующий() вернёт Истина при проходе по самой папке
        //но папка не содержит полей, а значит все поля вернут пустоту
        //для этого делаем проверку Выборка.ЭтоГруппа, если вернёт Истина
        //просто пишем оператор Продолжить и пропускаем круг цикла</span>
        <span class="vue-b"><b>Пока Выборка.Следующий() Цикл
            Если Выборка.ЭтоГруппа Тогда
                Продолжить
            КонецЕсли;
            Сообщение = Новый СообщениеПользователю;
            Сообщение.Текст = 
                Выборка.Наименование + " " + 
                Выборка.ДатаРождения + " " +
                Выборка.НомерПаспорта + " " +
                Выборка.СерияПаспорта + " " +
                Выборка.Должность + " ";
            Сообщение.Сообшить();
        КонецЦикла;</b></span>

        <span class="vue-g">//часто бывает нужно записать какие то данные в полученные объекты справочника
        //объект справочника это запись в БД текущего справочника. Чтобы в объект записать, нужно его получить
        //в цикле мы перемещаемся по объектам(записям) в колекции Выборка, значит если хотим записать во все объекты
        //значит в цикле получаем каждый объект и пишем в него</span>
        <span class="vue-b"><b>Пока Выборка.Следующий() Цикл
            Если Выборка.ЭтоГруппа Тогда
                Продолжить
            КонецЕсли;
            ОбъектСправочника = Выборка.ПолучитьОбъект();
            ОбъектСправочника.&lt;какое то поле> =  &lt;какое то значение>;
            ОбъектСправочника.Записать();
        КонецЦикла;</b></span>
        </pre>
    </div>
    <p>Получается, что в один миг мы можем работать с данными только с одним из элементов справочника. И тут мы можем или сразу их выводить пользователю или можно сложить их в массив и уже из массива потом сразу с ними со всеми что то сделать. Общий код модуля формы выглядит так:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>&НаКлиенте
            Процедура ВыводВсехСотрудников(Команда)
                ВыводВсехСотрудниковНаСервере()
            КонецПроцедуры
    
            &НаСервере
            Процедура ВыводВсехСотрудниковНаСервере()
                Управляющий = Справочники.Сотрудники;
                Выборка = Управляющий.Выбрать();
                Пока Выборка.Следующий() Цикл
                    Сообщить(
                        Выборка.Наименование + " " + 
                        Выборка.ДатаРождения + " " +
                            Выборка.НомерПаспорта + " " +
                        Выборка.СерияПаспорта + " " +
                        Выборка.Должность + " "
                    ); 
                КонецЦикла; 
            КонецПроцедуры</b></span>
        </pre>
    </div>

    <p><b id="13b">Получение данных из справочника через ссылку объектным способом и через запрос</b></p>
    <p>Предположим у нас есть справочник "СтавкиНДС":</p>
    <img src="../img/1С-1/2022-12-04_17-55-18.png" alt="">
    <p>И есть документ "РасходнаяНакладная":</p>
    <img src="../img/1С-1/2022-12-04_18-00-01.png" class="screen" alt="">
    <p>В документе в табличной части есть поле "СуммаНДС", чтобы вычислить это поле, нужно получить процент из поля "СтавкаНДС", чтобы получить число процента, нужно из БД его как то взять. 1й способ это через запрос:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Функция ПолучитьСтавкуНДСЧислом(СтавкаНДС)
                1й способ с запросом ставки, сюда СтавкаНДС приходит строкой
                Запрос = Новый Запрос;
                Запрос.Текст = 
                	"ВЫБРАТЬ
                	|	СтавкиНДС.Ставка КАК Ставка
                	|ИЗ
                	|	Справочник.СтавкиНДС КАК СтавкиНДС
                	|ГДЕ
                	|	СтавкиНДС.Наименование = &СтавкаНДС";
                
                Запрос.УстановитьПараметр("СтавкаНДС", СтавкаНДС);
                РезультатЗапроса = Запрос.Выполнить();
                ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
                ВыборкаДетальныеЗаписи.Следующий();
                Возврат ВыборкаДетальныеЗаписи.Ставка;

                //из РезультатЗапроса можно выбрать, а можно выгрузить в таблицу значений
                //зачем это нужно. Я когда раньше делал выборку из БД, никак не мог понять как можно посмотреть, что я там выбрал
                //вот это как раз то, что я хотел. В отладке смотрим, что выгрузилось из Результата и там в виде таблицы
                //все записи из базы
                Таблица = РезультатЗапроса.Выгрузить();
            КонецФункции
        </pre>
    </div>
    <p>2й способ то через объектную модель:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Функция ПолучитьСтавкуНДСЧислом(СтавкаНДС)
                Возврат СтавкаНДС.Ставка;
            КонецФункции
        </pre>
    </div>
    <p>В обоих случаях мы передаём функции параметр СтавкаНДС. СтавкаНДС мы получаем из текущей строки табличной части - Элементы.Товары.ТекщуиеДанные.СтавкаНДС. В этом поле содержится не строка, а ссылка на элемент списка справочника СтавкиНДС. Чтобы заработал 1й способ с запросом, нужно привести этот реквизит в типу строка вот так - Строка(Элементы.Товары.ТекщуиеДанные.СтавкаНДС) и передать параметром в функцию. Во 2м способе, мы так и оставляем ссылочный тип и передаём эту ссылку в функцию. Функция выполняясь на сервере получает эту ссылку, в ссылке содержится элемент списка справочника СтавкиНДС, а значит нам доступны все поля этого элемента, в том числе и поле Ставка, которое нам вернёт числовое значение ставки.</p>

    <p><b id="13c">Получение ссылки на элемент справочника</b>.</p>
    <p>Чтобы получить ссылку элемента справочника есть несколько путей.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//1. По коду. Этот код в форме обработки.</span>
            <span class="vue-b">&НаКлиенте
            <span class="vue-r">Процедура</span> ОткрытьФормуНоменклатуры<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                СсылкаНаНоменклатуру <span class="vue-r">=</span> ПолучитьНоменклатуруПоКоду<span class="vue-r">(</span><span class="vue-bl">"000000004"</span><span class="vue-r">);</span>
            КонецПроцедуры </span>   

            &НаСервере
            <span class="vue-r">Функция</span> ПолучитьНоменклатуруПоКоду<span class="vue-r">(</span>Код<span class="vue-r">)</span>
                <span class="vue-g">//Возврат Справочники.Номенклатура.НайтиПоНаименованию();</span>
                <span class="vue-g">//Возврат Справочники.Номенклатура.НайтиПоРеквизиту();</span>
                <span class="vue-r">Возврат</span> Справочники<span class="vue-r">.</span>Номенклатура<span class="vue-r">.</span>НайтиПоКоду<span class="vue-r">(</span>Код<span class="vue-r">);
            КонецФункции</span></span>
        </pre>
    </div>












    <h3 class="header-style" id="14">Объект встроенного языка УправляемаяФорма</h3>
    <p>Поскольку мы находимся в модуле формы, то в нём доступны все свойства и методы объекта встроенного языка <b>УправляемаяФорма</b>. Поэтому мы можем обращаться к ним напрямую. Чтобы получить коллекцию элементов формы, используем одно из свойств объекта УправляемаяФорма – свойство <b>Элементы</b>. Свойство Элементы содержит коллекцию всех элементов управляемой формы для прямого доступа вне зависимости от иерархии. Доступно только для чтения. Коллекция имеет тип - ВсеЭлементыФормы, содержащая все элементы формы. То есть это программный аналог корня дерева элементов формы. Каждый элемент формы можно получить, указав его имя в качестве свойства этого объекта, то есть через точку от него.</p>
    <p>Назначение обработчика для формы и её элементов может выполняться интерактивно, при работе с формой в конфигураторе, или программно, используя методы формы и ее элементов – <b>УстановитьДействие()</b>.</p>
    <p>Помимо того что форма внутри своего модуля предоставляет доступ к различным частям конфигурации, она также доступна из других частей конфигурации как программный объект. Например, если в модуле формы ФормаДокумента(имя созданной формы документа) документа ПриходнаяНакладная описана экспортируемая процедура ИмяПроцедуры(), то мы можем вызвать эту процедуру из других частей конфигурации. Ну например, откроем модуль управляемого приложения и там напишем вызов этой процедуры:</p>
    <p>Помимо описания переменных и основной программы, модуль формы может содержать описание процедур – обработчиков событий, связанных с формой. Основными событиями, которые могут обрабатываться в модуле формы, являются события открытия и закрытия окна формы.</p>
    <div class="code-style">
        <pre>
            //в переменную Форма вернётся объект УправляемаяФорма
            //и у этого объекта мы можем вызвать нашу пользовательскую процедуру, описанную в модуле формы
            <span class="vue-b"><b>Форма = ПолучитьФорму("Документ.ПриходнаяНакладная.Форма.ФормаДокумента");
            Форма.ИмяПроцедуры();
            </b></span>
        </pre>
    </div>
    <p>В примере ниже мы выбираем из коллекции элементов(сво-во Элементы объекта УправляемаяФорма) табличную часть и считываем из неё данные для работы с ними.</p>

    <p><b id="14a">Получение данных полей табличной части из элементов формы документа</b></p>
    <p>Табличная часть документа представляет собой объект встроенного языка <b>ТаблицаФормы</b>. Получить ту строку, в которой в настоящее время осуществляется редактирование, можно при помощи свойства программного объекта ТаблицаФормы – <b>ТекущиеДанные</b>.</p>
    <p>Допустим создали объект конфигурации документ ПоступлениеТоваров. В пользовательской части мы хотели бы создать документ пришедшего товара, откуда и куда, его стоимость и количество, а также общая сумма. Таких полей у нас в форме документа пока нет. Идё во вкладку "Данные" и создадим 2 реквизита - Фирма(откуда) и Подразделение(Куда), ниже реквизитов добавим табличную часть и в ней добавим также поля - Товар, Цена, Количнство, Сумма. Всё, идём в пользовательскую часть и заполним первый товар. При заполнении табличной части мы указали Цена и Количество, но при заполнении Сумма нужно самому посчитать общую сумму товаров, т.е. цену нужно умножить на количество. Мы хотим автоматизировать этот участок, чтобы при изменении либо Цены, либо Количества Сумма менялась и подсчитывалась автоматом. Для этого идё в форму редактирования документа(не в форму списка документа) и во вкладке "Элементы" Находим нашу табличную часть, которая называется "ПереченьТоваров" и в ней находим элемент ПереченьТоваровКоличество(название поля табличной части автоматом добавляется именем табличной части), заходим в свойства этого элемента и в самом низу будут события элемента. Надо найти событие "ПриИзменении" и жмём лупу у него, откроется модуль формы.В процедуре на клиенте нужно получить данные поля Цена и Количества, посчитать их и записать в поле Сумма. Вот 2 способа найти эти данные:</p>
    <div class="code-style">
        <pre>
            <span class="vue-r">&НаКлиенте</span>
            <span class="vue-b"><b>Процедура ПереченьТоваровКоличествоПриИзменении(Элемент)
                <span class="vue-g"><b>//первый способ получение данных через элементы формы
                //в элементах есть табличная часть ПереченьТоваров, в этой таблице есть строки
                //с данными товара, при срабатывании события "ПриИзменении" мы будем находиться
                //на одной из этих строк, а значит нам надо получить данные текущей строки
                //и для этого есть свойство ТекущиеДанные
                //в итоге возвращается объект, который имеет тип ДанныеФормыЭлементКоллекции
                //Элементы.Материалы вернёт объект ТаблицаФормы, у которой вызываем свойство Текущие данные
                //какие ещё есть свойства и методы у ТаблицаФормы смотрим с помошнике</b></span>
                СтрокаТабЧасти = Элементы.ПереченьТоваров.ТекущиеДанные;
                СтрокаТабЧасти.Сумма = СтрокаТабЧасти.Цена * СтрокаТабЧасти.Количество;
                
                
                <span class="vue-g"><b>//второй способ через реквизиты	
                //Объект.ПереченьТоваров[0] также возвращает ДанныеФормыЭлементКоллекции
                //ВАЖНО!!! Этот способ не совсем верный. Как оказалось при добавлении в табличную
                //часть ещё одного товара и заполнении Цены и Количества Сумма уже автоматом не 
                //считается, потому как я получаю только первую строку из таблицы и считываю только в ней
                //можно конечно сделать цикл и пробежать по всем элементам и посчтитать
                //Для каждого СтрокаТабЧасти Из Объект.ПереченьТоваров Цикл
                //    СтрокаТабЧасти.Сумма = СтрокаТабЧасти.Количество * СтрокаТабЧасти.Цена;	
                //КонецЦикла;
                //Кстати у табличной части есть метод <span class="vue-b">Итог(колонка)</span>, который подсчитывает сумму значений переданной колонки.
                //Например, есть у нас колонка Количество или Цена и передав имя колонки нам метод сам подсчитает их сумму</b></span>
            КонецПроцедуры</b></span>
        </pre>
    </div>
    <p>Также не забываем повесить на элемент таблицы ПереченьТоваровЦена обработчик, который выше в процедуре по событию "ПриИзменении". Согласно стандартам 1С, то на каждое событие ннужно вешать свой обработчик, поэтому для поля Цена повесим также отдельный обработчик, но внутри у этой процедуры будет тоже что и для Количества.</p>

    <p><b id="14b">Выносим процедуру подсчёта суммы в Общие Модули</b></p>
    <p>Так как такая процедура, подсчитывающая сумму может понадобиться не только для документа ПоступлениеТоваров, но также и для других объектов, то лучше всего вынести эту процедуру в Общие Модули.</p>
    <p>Зайдём в Общие Модули и добавим Общий Модуль, дадим имя ему "РаботаСДокументами", поставим галочку "Клиент(управляемое приложени)", а с "Сервер" галочку снимем. Это означает, что объекты этого модуля будут собраны в контексте тонкого клиента и веб-клиента(что это значит, пока не знаю, из учебника предложение взял). Напишем нашу процедуру:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>
                Процедура РассчитатьСумму(СтрокаТабЧасти) Экспорт
                    СтрокаТабЧасти.Сумма = СтрокаТабЧасти.Количество * СтрокаТабЧасти.Цена;
                КонецПроцедуры
            </b></span>
        </pre>
    </div>
    <p>Теперь перепишем нашу процедуру в форме документа:</p>
    <div class="code-style">
        <pre>
            <span class="vue-b"><b>
                &НаКлиенте
                Процедура ПереченьТоваровКоличествоПриИзменении(Элемент)
                    СтрокаТабЧасти = Элементы.Материалы.ТекущиеДанные;
                    РаботаСДокументами.РассчитатьСумму(СтрокаТабЧасти);
                КонецПроцедуры

                &НаКлиенте
                Процедура ПереченьТоваровЦенаПриИзменении(Элемент)
                    СтрокаТабЧасти = Элементы.Материалы.ТекущиеДанные;
                    РаботаСДокументами.РассчитатьСумму(СтрокаТабЧасти);
                КонецПроцедуры

            </b></span>
        </pre>
    </div>

    <p><b id="14c">Свойства и методы управляемой формы</b></p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//делает доступным или нет поле Контрагент</span>
            <span class="vue0b"><b>Элементы.Контрагент.Доступность = Истина</b></span>

            <span class="vue-g">//делает видимым или нет поле Контрагент</span>
            <span class="vue0b"><b>Элементы.Контрагент.Видимость = Истина</b></span>
        </pre>
    </div>



















    <h3 class="header-style" id="15">Модули</h3>
    <p>В конфигурации существуют различные виды модулей. Они могут принадлежать некоторым объектам конфигурации (например, формам), а могут существовать сами по себе (принадлежать всей конфигурации в целом). Текст программы, содержащийся в модулях, будет использоваться платформой в заранее известные моменты работы системы «1С:Предприятие»</p>

    <p><b id="15a">Модуль управляемого приложения.</b></p>
    <p>Модуль управляемого приложения выполняется при начале и окончании работы системы «1С:Предприятие» в режимах тонкого клиента и веб-клиента.</p>
    <p>В нем возможно объявление переменных, а также объявление и описание процедур и функций, которые будут доступны в любом модуле конфигурации (кроме модуля внешнего соединения). Их доступность также обеспечивается для неглобальных общих модулей с установленным свойством Клиент (управляемое приложение). В контексте модуля управляемого приложения доступны экспортируемые процедуры и функции общих модулей.</p>

    <p><b id="15b">Общие модули.</b></p>
    <p>В общих модулях хранятся процедуры и функции, которые вызываются из других модулей системы. Сам по себе общий модуль не исполняется. Исполняются отдельные его процедуры и функции в момент их вызова из других модулей.</p>

    <p><b id="15c">Модули объектов. Что такое ДокументМенеджер и ДокументОбъект</b></p>
    <p>Модули объектов – это, например, модуль элемента справочника или модуль документа. Эти модули вызываются тогда, когда программно создается этот объект средствами встроенного языка, например, методами <span class="vue-b"><b>СоздатьЭлемент()</b></span> менеджеров справочников или <span class="vue-b"><b>СоздатьДокумент()</b></span> менеджеров документов, либо когда пользователь создает новый элемент справочника или документ интерактивно нажавав кнопку Создать(имеется ввиду создать новый документ или справочник). Также модуль запускается при открытии уже созданного документа, пометке/снятии документа на удаление в форме списка документа. Когда модуль вызывается и если в нём есть обработчики событий написанные нами, то они вешаются на разные кнопки, поля и прочее. Например у документа есть кнопка "Провести и закрыть" или "Записать" или просто "Провести", так вот эти кнопки по нажатию по умолчанию запускают события, и если в модуле есть обработчики этих событий, то обработчики при запуске модуля вешаются на эти кнопки и потом запускаются по клику на кнопки.</p>
    <p id="modulObj">Также в модуле объекта документа мы можем просто описывать свои процедуры и функции. Указав этим процедурам ключевое слово Экспорт, эти процедуры становятся методами данного документа, который и вызвал этот модуль. Пока я понял это так, если не прав перепишу. Чтобы вызывать эти процедуры и функции из модуля, ну например, из формы документа, нам нужен сам документ объект. Как его получить в форме? Есть встроенный метод, который позволяет это сделать. Этому методу нужно передать в строке реквизит формы - Объект. Если в форме во вкладке реквизиты посмотреть тип реквизита Объект(справа написан), то там в скобках написано(почему в скобках? потому что по факту этот объект имеет тип ДанныеРеквизитаСтруктура, но по форме похож на ДокументОбъект, потому что содержит все поля с данными как и ДокументОбъект), что это ДокументОбъект.&lt;ИмяДокумента>, но это не так. На самом деле тип у этого реквизита - ДанныеРеквизитаСтруктура. Почему разработчики указали в скобках другой тип я не знаю(кто то объяснял, но не помню, узнаю допишу). Так вот мы с помощью метода можем перевести этот реквизит Объект в тип ДокументОбъект:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//переводим ревизит в другой тип</span>
            <span class="vue-b"><b>ДокументОбъект = РеквизитФормыВЗначение("Объект");

            <span class="vue-g">//затем вызываем нашу процедуру из модуля объекта</span>
            ДокументОбъект.ЗаполнитьЦеныТоваровПоПоставщику();

            <span class="vue-g">//в данной задаче мы изменили табличную часть документа и нам нужно вернуть изменёные данные</span>
            <span class="vue-g">//для этого серверу нужен реквизит Объект со старым типом, поэтому обратно его переводим</span>
            ЗначениеВРеквизитФормы(ДокументОбъект, "Объект");</b></span>
        </pre>
    </div>
    <p>Когда ещё появляется ДокументОбъект? Вроде на первый мой взгляд казалось, что можно получить ДокументОбъект через Документы.&lt;ИмяДокумента>, но возвращается объект типа ДокументМенеджер. Что такое ДокументМенеджер? Описываю как я пока понимаю. Вот создали мы новый объект конфигурации - документ "ПоступлениеТоваров", мы создали, если можно так выразиться, оболочку, которая называется ДокументМенеджер. Эта оболочка содержит свойства и методы для управления внутри себя уже документ объектами. Можно сказать, что ДокументМенеджер это таблица в целом, а документ объекты это записи(строки) в этой таблице. Отсюда вывод, что можно создать программно ДокументОбъект через встроенный метод ДокументМенеджера:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//этот ДокументОбъект, в отличии от примера выше, пустой и его можно заполнять</span>
            <span class="vue-b"><b>ДокументОбъект = Документы.ПоступлениеТоваров.СоздатьДокумент();
            ДокументОбъект.Дата = ТекущаяДата();
            ДокументОбъект.Номер = "000000001";
            и т.д.
            ДокументОбъект.ЗаполнитьЦеныТоваровПоПоставщику();
            ДокументОбъект.Записать();  - если хотим просто записать в базу
            ДокументОбъект.Движения...;  -  если хотим начать записывать в регистр
            </b></span>
        </pre>
    </div>
    <p>Чтобы открыть модуль объекта, нужно в окне редактирования объекта конфигурации перейти на закладку Прочее и нажать кнопку Модуль объекта. Или, выделив нужный объект в дереве объектов конфигурации, вызвать из контекстного меню команду Открыть модуль объекта.</p>

    <p><b id="15d">Модули форм.</b></p>
    <p>Каждая форма, определенная в конфигурации, имеет свой собственный модуль. Этот модуль исполняется при создании объекта <b>УправляемаяФорма</b> встроенного языка. Этот объект создается системой в режиме 1С:Предприятие в тот момент, когда мы программно (методами  <b>ПолучитьФорму()</b> или <b>ОткрытьФорму()</b>) или интерактивно открываем форму некоторого элемента.</p>

    <p><b id="15e">Модуль сеанса</b>.</p>
    <p>Модулем сеанса называется модуль, который автоматически выполняется при старте системы «1С:Предприятие» в момент загрузки конфигурации. Модуль сеанса предназначен для инициализации параметров сеанса и отработки действий, связанных с сеансом работы. Модуль сеанса не содержит экспортируемых процедур и функций и может использовать процедуры из общих модулей конфигурации.</p>

    <p><b id="15f">Модуль внешнего соединения</b></p>
    <p>Предназначен для размещения в нем текстов функций и процедур, которые могут вызываться в сессии внешнего соединения.</p>

    <p><b id="15g">Модуль менеджера</b></p>
    <p> Для каждого прикладного объекта существует менеджер, предназначенный для управления этим объектом как объектом конфигурации. С помощью менеджера можно создавать объекты, работать с формами и макетами. Модуль менеджера позволяет расширить функциональность менеджеров, предоставляемых системой, за счет написания процедур и функций на встроенном языке.</p>
    <p>Фактически это позволяет описать собственные методы для объекта конфигурации (например, справочника), которые относятся не к конкретному экземпляру объекта базы данных, а к самому объекту конфигурации. Например, в модуле менеджера можно задать произвольное представление объекта в интерфейсе «1С:Предприятия».</p>
    <p>Открыть этот модуль можно там же где и модуль объекта - Прочее - Модуль менеджера.</p>
    <p>Тут ещё немного объясняется про модуль менеджера, прочитать там надо всё, чтобы понять. <a href="#21">Тут</a>.</p>

    <p><b id="15h">Модуль команды</b>.</p>
    <p>Как в самой конфигурации, так и у многих прикладных объектов, могут существовать подчиненные объекты конфигурации – Команды. У каждой команды существует модуль команды, в котором можно написать предопределенную процедуру ОбработкаКоманды() для выполнения этой команды. Чтобы открыть модуль команды, подчиненной некоторому объекту конфигурации, нужно в окне редактирования объекта конфигурации перейти на закладку Команды и дважды щелкнуть мышью на нужной команде. Или, выделив нужную команду в дереве объектов конфигурации, вызвать из контекстного меню команду Добавить.</p>
















    <h3 class="header-style" id="16">Контекст модуля формы</h3>
    <p>Каждый модуль связан с остальной частью конфигурации. Эта связь называется <b>контекстом модуля</b>. Контекст модуля определяет набор доступных во время выполнения модуля объектов, переменных, процедур и функций. Контекст модуля формы образуется:</p>
    <ul class="list">
        <li>локальным контекстом самого модуля формы</li>
        <li>реквизитами этой формы</li>
        <li>свойствами и методами объекта УправляемаяФорма встроенного языка</li>
        <li>свойствами и методами расширения формы, определяемого типом того объекта, данные которого содержатся в основном реквизите формы</li>
        <li>глобальным контекстом, в том числе неглобальными общими модулями и экспортируемыми функциями и процедурами глобальных общих модулей</li>
        <li>экспортируемыми переменными, процедурами и функциями модуля управляемого приложения.</li>
    </ul>
    <p>Рассмотрим подробнее, что собой представляет каждая из перечисленных составляющих.</p>

    <p><b>1. Локальный контекст модуля формы.</b></p>
    <p>Локальный контекст модуля формы – это переменные, процедуры и функции, объявленные в этом модуле. </p>

    <p><b>2. Реквизиты формы, которой «принадлежит» модуль.</b></p>
    <p>Например, если у формы существует реквизит СлужебныйРеквизит, то к нему можно непосредственно обращаться по имени в модуле формы.</p>

    <p><b>3. Свойства и методы объекта «УправляемаяФорма».</b></p>
    <p>Свойства и методы объекта встроенного языка УправляемаяФорма описаны в синтакс-помощнике:  Интерфейс(управляемый) > УправляемаяФорма. К ним можно обращаться непосредственно по имени. Например, можно задать заголовок формы.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Команда1()
                <span class="vue-b"><b>Заголовок</b></span> = "Новый заголовок формы";
            КонецПроцедуры

            //или можно закрыть форму
            &НаКлиенте
            Процедура Команда2()
                <span class="vue-b"><b>Закрыть()</b></span>;
            КонецПроцедуры
        </pre>
    </div>

    <p><b>4. Свойства и методы расширения формы, определяемого типом того объекта, данные которого содержатся в основном реквизите формы.</b></p>
    <p>Один из реквизитов формы может быть основным, в списке реквизитов он выделяется жирным. Как правило, основной реквизит формы содержит данные того объекта, который отображается в форме. Например, если это форма справочника, то основной реквизит будет содержать данные объекта СправочникОбъект.&lt;имя>. А если это форма документа, то основной реквизит формы будет содержать данные объекта ДокументОбъект.&lt;имя></p>
    <p>Тут следует пояснить, почему в списке реквизитов тип основного реквизита указан в скобках: (ДокументОбъект.Документ1). Дело в том, что это «ненастоящий» тип реквизита формы. Настоящий тип в данном случае будет ДанныеФормыСтруктура. Но ДанныеФормыСтруктура – это универсальный тип, который может содержать данные различных прикладных объектов. Поэтому, чтобы в редакторе формы можно было «ориентироваться», данные какого же именно прикладного объекта отображает эта форма, в колонке Тип редактора показывается не тип реквизита формы (ДанныеФормыСтруктура), а тип того объекта, данные которого содержатся в этом реквизите. И этот «ненастоящий» тип показывается в скобках.</p>
    <p>От типа объекта, данные которого содержатся в основном реквизите формы, зависят некоторые особенности в поведении формы. Например, если основной реквизит формы будет содержать данные документа, то при закрытии такой формы система будет запрашивать подтверждение записи и проведения этого документа. Если же основной реквизит формы будет содержать данные справочника, то подобного запроса подтверждения при закрытии формы возникать не будет. В зависимости от того, какой тип имеет объект, данные которого содержатся в основном реквизите, к контексту программного объекта УправляемаяФорма добавляется контекст соответствующего расширения.</p>
    <p>Например, если основной реквизит – СправочникОбъект.&lt;имя>, то в модуле формы становятся доступны свойства, методы объекта встроенного языка Расширение управляемой формы для справочника (синтакс-помощник – Интерфейс (управляемый) > Форма клиентского приложения > Расширение
    справочника). А если основной реквизит – ДинамическийСписок, то в модуле формы становятся доступны свойства, методы объекта встроенного языка Расширение управляемой формы для динамического списка (синтакс-помощник – Интерфейс (управляемый) > Форма клиентского приложения > Расширение динамического списка).</p>
    <p>Проще говоря в зависимости от объекта основного реквизита модуль формы расширяется дополнительными методами и свойствами.</p>

    <p><b>5. Глобальный контекст, в том числе неглобальные общие модули и экспортируемые функции и процедуры глобальных общих модулей.</b></p>
    <p>В модуле формы можно:</p>
    <div class="code-style">
        <pre>
            //получить системную дату
            &НаКлиенте
            Процедура Команда1()
                МояДата = <span class="vue-b"><b>ТекущаяДата()</b>;</span>
            КонецПроцедуры

            //или получить историю работы пользователя
            &НаКлиенте
            Процедура Команда1()
                История = <span class="vue-b"><b>ИсторияРаботыПользователя.Получить()</b>;</span>
            КонецПроцедуры
        </pre>
    </div>
    <p>Если в глобальном общем модуле (например, ОбменДанными) определена экспортная процедура ПолучитьПрефиксНомера(), то в модуле формы можно обращаться к ней по имени.</p>
    <div class="code-style">
        <pre>
            //заметим, что обращение идёт без указания имени общего модуля
            &НаКлиенте
            Процедура Команда1(Префикс)
                Префикс = <span class="vue-b"><b>ПолучитьПрефиксНомера()</b>;</span>
            КонецПроцедуры 
        </pre>
    </div>
    <p>Если такой общий модуль – неглобальный (например, РаботаСДокументами), то при обращении к процедуре ее имя нужно указывать через точку от имени модуля.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура КоличествоПриИзменении(Элемент)
                <span class="vue-b"><b>РаботаСДокументами.РассчитатьСумму(СтрокаТабличнойЧасти);</b></span>
            КонецПроцедуры
        </pre>
    </div>
    <p>Второй способ предпочтительнее, так как неглобальные общие модули компилируются по мере обращения к ним, а не при запуске системы, как глобальные. Естественно, при этом нужно обеспечивать согласованность того, как описана процедура в модуле формы (&НаКлиенте, &НаСервере и т.д.), и того, какие флажки проставлены у общего модуля (клиент (управляемое приложение), сервер и т.д.).</p>

    <p><b>6. Экспортируемые переменные, процедуры и функции модуля управляемого приложения.</b></p>
    <p>Если в модуле приложения определена экспортная процедура ТестовоеСообщение(), то в модуле формы можно обращаться к ней по имени. По описанию модуль управляемого приложения предоставляет доступ к своим процедурам и функциям также как и глобальный общий модйль. В чём разника пока не знаю. экспортировать переменную можно так:</p>
    <div class="code-style">
        <pre>
            Перем МояПеременная Экспорт;
        </pre>
    </div>
















    <h3 class="header-style" id="17">Анализ кода с помощью синтакс-помощника</h3>
    <p>На странице 177 учебника Хрусталёвой есть описание того, как если бы мы увидели незнакомый код и как в нём разобраться с помощью синтакс помошника</p>









    <h3 class="header-style" id="18">Анализ кода с помощью отладчика</h3>
    <p>В том же учебнике, страница 192</p>







    <h3 class="header-style" id="19">Заметки из видеокурса 1С</h3>
    <p><b>Делаем резервные копии</b>. В этом видео с 00:23:53 - <a href="https://www.youtube.com/watch?v=WMlpg2Kx-ZI">тут</a></p>
    <p><b>Как удалять данные из справочника в режиме пользователя и что такое ссылочная целостность</b>. В этом видео с 00:23:00 - <a href="https://www.youtube.com/watch?v=XJuF4-9QH7Q">тут</a></p>









    
    <h3 class="header-style" id="20">Обработка, которая выводит по клику в табличный документ данные из БД. Присутствует макет.</h3>
    <p>Создадим внутреннюю обработку ТабличныйДокумент, добавим форму. В форме добавим команду ВыполнитьЗапрос, также добавим реквизит ТабДок(назвали так потому что по умолчанию конструктор выводит в поле с таким именем) с типом Табличный документ. На команду вешаем обработчик с процедурой на клиенте и на сервере. Открываем конструктор запроса и выбираем Тип обработки - Вывод в табличный документ. Всё, составляем запрос и выводим код. Автомато раскроется код с запросом и выводом его ответа в табличный документ, ещё и макет будет доступен для редактирования табличного документа:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ВыполнитьЗапрос(Команда)
                ВыполнитьЗапросНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ВыполнитьЗапросНаСервере()	
                Макет = Обработки.ТабличныйДокумент.ПолучитьМакет("Макет1");
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	ПоступлениеТоваровТовары.Товар КАК Товар,
                    |	ПРЕДСТАВЛЕНИЕ(ПоступлениеТоваровТовары.Товар) КАК ТоварПредставление,
                    |	СУММА(ПоступлениеТоваровТовары.Количество) КАК Количество,
                    |	СУММА(ПоступлениеТоваровТовары.Сумма) КАК Сумма
                    |ИЗ
                    |	Документ.ПоступлениеТоваров.Товары КАК ПоступлениеТоваровТовары
                    |
                    |СГРУППИРОВАТЬ ПО
                    |	ПоступлениеТоваровТовары.Товар";
                
                РезультатЗапроса = Запрос.Выполнить();
                
                ОбластьЗаголовок = Макет.ПолучитьОбласть("Заголовок");
                ОбластьПодвал = Макет.ПолучитьОбласть("Подвал");
                ОбластьШапкаТаблицы = Макет.ПолучитьОбласть("ШапкаТаблицы");
                ОбластьПодвалТаблицы = Макет.ПолучитьОбласть("ПодвалТаблицы");
                ОбластьДетальныхЗаписей = Макет.ПолучитьОбласть("Детали");
                
                ТабДок.Очистить();
                ТабДок.Вывести(ОбластьЗаголовок);
                ТабДок.Вывести(ОбластьШапкаТаблицы);
                ТабДок.НачатьАвтогруппировкуСтрок();
                
                ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
                
                Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
                    ОбластьДетальныхЗаписей.Параметры.Заполнить(ВыборкаДетальныеЗаписи);
                    ТабДок.Вывести(ОбластьДетальныхЗаписей, ВыборкаДетальныеЗаписи.Уровень());
                КонецЦикла;
                
                ТабДок.ЗакончитьАвтогруппировкуСтрок();
                ТабДок.Вывести(ОбластьПодвалТаблицы);
                ТабДок.Вывести(ОбластьПодвал);    
            КонецПроцедуры
        </pre>
    </div>
    <p>Это в принципе и всё, запросы можно любые составлять.</p>









    
    <h3 class="header-style" id="21">Запись в регистр накопления из формы списка документа. Получение выделенных строк списка. Работа с процедурой из модуля менеджера документа.</h3>
    <p>До этого мы бронировали товары из формы самого документа, теперь будем решать задачу бронирования из списка документа. Описывать решение с формой документа не стану, потому что вроде уже понятно как это делать. Если вдруг забыл, то напомню, что мы в форме документа вызывали процедуру из модуля объекта документа. Как мы это делали примерно описано <a href="#modulObj">тут</a>.</p>
    <p>Стоит такая задача. Нужно в списке документа "ПродажаТоваров" в командной панели разместить кнопку "Забронировать", которая будет по клику считывать данные из выделенного элемента(документа) списка и нужные нам данные записывать в регистр накопления "БронированиеТоваров".</p>
    <p>Первое, что нам нужно, это создать свою форму списка документа, создать кнопку и добавить её в командную панель. Затем назначим действие этой кнопке с процедурами на клиенте и на сервере с подтекстом. Чтобы получить выделенные пользователем в списке элементы(документы), у объекта формы Элементы есть подобъект Список, а у этого списка есть свойство ВыделенныеСтроки. Это свойство содержит массив из ссылок на выделенные документы.</p>
    <div class="code-style">
        <pre>
            Модуль формы списка документа

            <span class="vue-b"><b><span class="vue-r">&НаКлиенте
            Процедура</span> Забронировать<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                ЗабронироватьНаСервере();
            <span class="vue-r">КонецПроцедуры</span>

            <span class="vue-r">&НаСервере
            Процедура ЗабронироватьНаСервере()</span>
                Для каждого СсылкаНаДокумент Из Элементы.Список.ВыделенныеСтроки Цикл
                
                КонецЦикла;
            <span class="vue-r">КонецПроцедуры</span></b></span>
        </pre>
    </div>
    <p>В переменной СсылкаНаДокумент на каждом цикле будет лежать ссылка на документ из массива. Ссылка это ещё не сам документ, поэтому нам нужно получить сам документ. Так как процедура выполняется на сервере, то мы по ссылке можем получить сам документ через метод ПолучитьОбъект(). Получив документ мы можем вызвать процедуру "Забронировать", которая описана в модуле объекта документа ПродажаТоваров, эта процедура создаёт набор записей для регистра и мы записываем в регистр данные из табличной части полученного документа. Но тут я хотел описать не ту процедуру, а то как можно из списка получить текущие выделенные ссылки на документы, а из ссылок получить сами документы.</p>
    <div class="code-style">
        <pre>
            Модуль формы списка документа

            <span class="vue-b"><b><span class="vue-r">&НаКлиенте
            Процедура</span> Забронировать<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                ЗабронироватьНаСервере();
            <span class="vue-r">КонецПроцедуры</span>

            <span class="vue-r">&НаСервере
            Процедура ЗабронироватьНаСервере()</span>
                Для каждого СсылкаНаДокумент Из Элементы.Список.ВыделенныеСтроки Цикл
                    ДокументОбъект = СсылкаНаДокумент.ПолучитьОбъект();
                    ДокументОбъект.Забронировать();
                КонецЦикла;
            <span class="vue-r">КонецПроцедуры</span></b></span>
        </pre>
    </div>
    <p>Но этот способ получения документа из ссылок не очень подходит(по мнение Камкова), потому что вернувшийся документ объект содержит массу методов и свойств, что требует много ресурсов для его сборки, да ещё и в цикле мы можем получать не один такой объект. Получается, что процедура Забронировать находится в модуле объекта документа ПродажаТоваров. Чтобы её вызвать, нужно создать документ объект, а мы отказались его создавать. Где нам написать процедуру Забронировать ещё? Можно написать экспортную процедуру в модуле менеджера документа ПродажаТоваров. Как я уже описывал где то, менеджер документов это оболочка для элементов(документов) со своими методами и свойствами управления этими документами внутри него. Модуль менеджера позволяет расширить возможности управления всеми документами внутри него. Модуль менеджера не связан с каким-то конкретным документом, поэтому в процедуру "Забронировать" нужно будет передать какой то документ.</p>
    <p>Итак опишем процедуру Забронировать в модуле менеджера. Как нам получить данные из переданной в эту процедуру ссылки документа? Можно написать запрос, в результате которого получим нужные нам данные. Мы можем написать сразу запрос, который вернёт и данные из шапки документа(Дата, Склад, Проведён) и данные номенклатуры и количества табличной части, но тогда труднее будет проверить проведён ли документ? Поэтому мы получим сначала данные из шапки документа, с помощью метода Следующий() спозиционируемся на единственной записи в выборке и проверим проведён ли документ. А далее сделаем запрос на получение товаров и их количества из табличной части указанного документа:</p>
    <div class="code-style">
        <pre>
            Модуль менеджера документов

            <span class="vue-b"><b><span class="vue-r">Процедура</span> Забронировать<span class="vue-r">(</span>ДокументСсылка<span class="vue-r">)  Экспорт</span>
	
                <span class="vue-b">Запрос = Новый Запрос;
                Запрос.УстановитьПараметр("Ссылка", ДокументСсылка);
                Запрос.Текст =</b></span> 
                    "ВЫБРАТЬ
                    |	ПродажаТоваров.Дата КАК Дата,
                    |	ПродажаТоваров.Склад КАК Склад,
                    |	ПродажаТоваров.Проведен КАК Проведен
                    |ИЗ
                    |	Документ.ПродажаТоваров КАК ПродажаТоваров
                    |ГДЕ
                    |	ПродажаТоваров.Ссылка = &Ссылка";
                
                <span class="vue-b"><b>ДанныеИзШапкиДокумента = Запрос.Выполнить().Выбрать();
                ДанныеИзШапкиДокумента.Следующий(); 
                
                Если ДанныеИзШапкиДокумента.Проведен Тогда
                    Возврат;
                КонецЕсли;
                
                Запрос.Текст =</b></span> 
                    "ВЫБРАТЬ
                    |	ПродажаТоваровТовары.Товар КАК Товар,
                    |	ПродажаТоваровТовары.Количество КАК Количество
                    |ИЗ
                    |	Документ.ПродажаТоваров.Товары КАК ПродажаТоваровТовары
                    |ГДЕ
                    |	ПродажаТоваровТовары.Ссылка = &Ссылка";
                
                <span class="vue-b"><b>Выборка = Запрос.Выполнить().Выбрать();</b></span>

            <span class="vue-r">КонецПроцедуры</span></b></span>
        </pre>
    </div>
    <p>Получили товары и их количество с помощью запроса. Теперь эти данные нужно как то записать в регистр накопления "БронированиеТоваров". Мы находимся в модуле менеджера и нам тут не доступен подтекст документа, т.е. тут нет такого свойсва как Движения. Поэтому мы обратимся к менеджеру регистров накопления и зададим создание нового набора записей для регистра "БронированиеТоваров". Набор создали, а дальше как и всегда добавляем новую запись и заполняем её данными:</p>
    <div class="code-style">
        <pre>
            Модуль менеджера документов

            <span class="vue-b"><b><span class="vue-r">Процедура</span> Забронировать<span class="vue-r">(</span>ДокументСсылка<span class="vue-r">)  Экспорт</span>>
                <span class="vue-b">Запрос = Новый Запрос;
                Запрос.УстановитьПараметр("Ссылка", ДокументСсылка);
                Запрос.Текст =</b></span> 
                    "ВЫБРАТЬ
                    |	ПродажаТоваров.Дата КАК Дата,
                    |	ПродажаТоваров.Склад КАК Склад,
                    |	ПродажаТоваров.Проведен КАК Проведен
                    |ИЗ
                    |	Документ.ПродажаТоваров КАК ПродажаТоваров
                    |ГДЕ
                    |	ПродажаТоваров.Ссылка = &Ссылка";
                
                <span class="vue-b"><b>ДанныеИзШапкиДокумента = Запрос.Выполнить().Выбрать();
                ДанныеИзШапкиДокумента.Следующий(); 
                
                <span class="vue-r">Если</span> ДанныеИзШапкиДокумента.Проведен <span class="vue-r">Тогда</span>
                    Возврат;
                <span class="vue-r">КонецЕсли;</span>
                
                Запрос.Текст =</b></span> 
                    "ВЫБРАТЬ
                    |	ПродажаТоваровТовары.Товар КАК Товар,
                    |	ПродажаТоваровТовары.Количество КАК Количество
                    |ИЗ
                    |	Документ.ПродажаТоваров.Товары КАК ПродажаТоваровТовары
                    |ГДЕ
                    |	ПродажаТоваровТовары.Ссылка = &Ссылка";
                
                <span class="vue-b"><b>Выборка = Запрос.Выполнить().Выбрать();

                НаборЗаписей = РегистрыНакопления.БронированиеТоваров.СоздатьНаборЗаписей(); 
                НаборЗаписей.Отбор.Регистратор.Установить(ДокументСсылка);
	
                <span class="vue-r">Пока</span> Выборка.Следующий() <span class="vue-r">Цикл</span>
                    Движение = НаборЗаписей.Добавить();
                    Движение.ВидДвижения = ВидДвиженияНакопления.Приход;
                    Движение.Период = ДанныеИзШапкиДокумента.Дата;
                    Движение.Номенклатура = Выборка.Товар;
                    Движение.Склад = ДанныеИзШапкиДокумента.Склад;
                    Движение.Количество = Выборка.Количество;
                <span class="vue-r">КонецЦикла;</span>

                НаборЗаписей.Записать();
            <span class="vue-r">КонецПроцедуры</span></b></span>
        </pre>
    </div>
    <p>Когда мы заполняли регистр накопления "БронированиеТоваров" в подтексте документа в модуле объекта, то там, я так понял, в запись(движение) автоматом записывалось такое поле как Регистратор и это поле заполнялось ссылкой на документ в подтексет которого и выполнился этот модуль. Но мы находимся в модуле менеджер документов и тут автоматом это поле не заполняется, его нужно заполнить нам самим. Есть 2 способа записать Регистратор. Можно просто написать <b>Движение.Регистратор = ДокументСсылка</b>, а есть 2й способ, который встречается более чаще, пишем перед циклом такую строку <b>НаборЗаписей.Отбор.Регистратор.Установить(ДокументСсылка);</b>. На мой взгляд 2й способ менее понятен. Как я почитал в справочнике, мы отбираем записи по полю Регистратор с значением ДокументСсылка. Вот только не понятно откуда мы их отбираем, неужели не проще 1м способом сделать? Скорее всего я ещё не понимаю происходящего, как лучше вникну допишу тут. Короче как говорит Камков, если перед циклом для набора записей стоит Отбор по указанному регистратору, то автоматом будут проставлены поля Регистратор в записях в значение указанного регистратора. У набора записей в модуле объекта документа такой отбор уже указан, поэтому там такого делать не надо. Далее после цикла надо записать в БД этот набор записей, поэтому допишем строку <b>НаборЗаписей.Записать();</b></p>
    <p>Теперь когда процедура создана в модуле менеджера, её нам нужно вызвать из формы списка документа.Обратиться можно просто, не надо тут создавать документ объекты, а просто вызываем менеджер документов и у него теперь есть метод Забронировать:</p>
    <div class="code-style">
        <pre>
            Модуль формы списка документа

            <span class="vue-b"><b><span class="vue-r">&НаКлиенте
            Процедура</span> Забронировать<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                ЗабронироватьНаСервере();
            <span class="vue-r">КонецПроцедуры</span>

            <span class="vue-r">&НаСервере
            Процедура ЗабронироватьНаСервере()</span>
                Для каждого СсылкаНаДокумент Из Элементы.Список.ВыделенныеСтроки Цикл
                    Документы.ПродажаТоваров.Забронировать(СсылкаНаДокумент);
                КонецЦикла;
            <span class="vue-r">КонецПроцедуры</span></b></span>
        </pre>
    </div>
    <p><span class="vue-r">Важное замечание!!! Если получение в форме списка документа объекта, по словам Камкова, есть ресурсозатратное действие в цикле, то почему в этом же цикле вызов процедуры Забронировать не такое ресурсозатратное. Ведь мы в цикле будем вызывать эту процедуру, в которой есть аж 2 запроса. А если пользователь выделит, ну пусть строк 10 документов и нажмёт кнопку "Забронировать", то у нас 10 раз вызовется процедура Забронировать, а значит 10 раз будет осуществлёно минимум по 2 запроса к БД, т.е 20 запросов за весь цикл. Очень сомнительное сбережение ресурсов. Нужно на это обратить внимание и искать далее по учёбе подтвержения моим сомнениям или опровержения. Может быть мы так написали, чтобы Камков показал другой способ решения задачи. Тогда нужно интересоваться производительностью тех или иных решений.</span></p>
    <p><span class="vue-r">И ещё вопрос, мы сами добавляем поле Регистратор и заполняем его, а поле Номер строки кто добавляет?</span></p>













    
    <h3 class="header-style" id="22">Новый способ записи напрямую в регистр из формы документа.</h3>
    <p>Создадим документ, который будет бронировать товары. Пользователь в форме документа сможет выбрать какие товары и их количество надо забронировать, а также сможет снять с них бронирование. Наших добавочных реквизитов у документа не будет, только стандартные Номер и Дата. Отмечаем в закладке Движения, что он делает движения по регистру накопления БронированиеТоваров и отмечаем, что документ не проводится. Создаём форму документа, реквизит Объект содержит свойство Движения, вынесем набор движений БронированиеТоваров влево в окно элементов формы и у нас спросят, добавлять ли поля из регистра БронированиеТоваров на форму, отвечаем Да. Откроем пользовательскую часть и откроем документ БронированиеТоваров. Добавим новый документ и войдём в форму документа, там мы увидим 2 стандартных поля документа Дата и Номер и ниже в виде табличной части видим поля такие же как и у регистра, заполняем эти поля. Нажимаем "Записать" документ. Если войти в реигстр накопления БронированиеТоваров, то увидим нашу запись. Получается что при таком способе мы без обработки проведения пишем в регистр, можно сказать напрямую. Далее мы решили упростить для пользователя заполнение полей и в форме удалили поле Период, потому что оно скорее всего будет повторять поле Дата документа, но если попробовать теперь добавить новую запись и Записать, то выдаст исключение, что без периода нельзя записать в регистр. Нужно значит как то поле Период заполнить. Сделать это можно перед записью документа в БД, а для этого у нас в модуле объекта документа есть обработчик события ПередЗаписью, вот там и заполним. Как известно Движения.БронированиеТоваров это набор записей и это не просто название НаборЗаписей это именно коллекция этих записей. Значит эту коллекцию можно перебирать в цикле <b>Для каждого ... Из ... Цикл</b>. Каждый элемент этой коллекции это запись. Отсюда вывод, что когда мы открываем форму документа и начинаем в табличной части заполнять строку значениями и потом переходим к заполнению другой строки, в миг когда мы переходим к заполнению новой строки, предыдущая запись попадает коллекцию Движения.БронированиеТоваров. Да, там в записях этого набора поле Период ещё пока пусто, вернее не пусто, там стоит дата начала времён(01.01.0001 0:00:00). Вот тут то и при нажатии кнопки "Записать" документ сработает вот этот наш обработчик, который пройдёт по всем записям этой коллекции и добавит период:</p>
    <div class="code-style">
        <pre>
            Модуль объекта документа БронированиеТоваров

            <span class="vue-b"><b><span class="vue-r">Процедура</span> ПередЗаписью<span class="vue-r">(</span>Отказ, РежимЗаписи, РежимПроведения<span class="vue-r">)</span>
                <span class="vue-r">Для каждого</span> Движение <span class="vue-r">Из</span> Движения.БронированиеТоваров <span class="vue-r">Цикл</span>
                    Движение.Период = Дата;
                <span class="vue-r">КонецЦикла;</span>
            <span class="vue-r">КонецПроцедуры</span>
            </b></span>
        </pre>
    </div>
    <p>Теперь нужно сделать механизм удаления записей из регистра. Если раньше можно было отменить проведение документа, то запись соответсвующая удалялась из ресгитра. В этом документе такое не получится, у нас нет проведения. Ну или наоборот в предыдущей записи мы проводили документ, чтобы запись из регистра стёрлась.</p>
    <p>Моя первая мысль была добавить кнопку "Удалить", по которой мы будем удалять либо выделенную запись или все сразу записи. Но есть и другие способы. Например, пользователь в списке может пометить документ на удаление и нам нужно что-то сделать с записями в регистре помеченного документа. Можно записи удалять, а можно делать их неактивными. Рассмотрим этот способ, он обычно и используется.</p>
    <p><span class="vue-r">Оказывается, что при пометке документа на удаление происходит ЗАПИСЬ документа в БД, ну или перезапись и также запускается на выполнение модуль объекта документа, пометку на который мы ставим. Записи/перезапись происходит, потому что нужно в таблицу этой группы документов(БронированиеТоваров) в БД в поле ПометкаУдаления, для помеченного документа, установить новое значение. А если происходит запись, то есть и события которые срабатывают при записи, это события - ПередЗаписью, ПриЗаписи, может ещё какие-то есть, не знаю, короче всё то что срабатывает при записи документа в БД.</span> А это значит, что мы можем продолжать писать код в ту же процедуру выше - ПередЗаписью.</p>
    <p>Будем делать неактивными записи в регистре при пометке документа на удаление. Неактивная запись в регистре показывается потухшей картинкой плюсика(Приход) или минуса(Расход).</p>
    <div class="code-style">
        <pre>
            Модуль объекта документа БронированиеТоваров

            <span class="vue-b"><b><span class="vue-r">Процедура</span> ПередЗаписью<span class="vue-r">(</span>Отказ, РежимЗаписи, РежимПроведения<span class="vue-r">)</span>
                <span class="vue-r">Для каждого</span> Движение <span class="vue-r">Из</span> Движения.БронированиеТоваров <span class="vue-r">Цикл</span>
                    Движение.Период = Дата;
                <span class="vue-r">КонецЦикла;</span>
                <span class="vue-r">Если НЕ</span> ПометкаУдаления <span class="vue-r">=</span> Ссылка.ПометкаУдаления <span class="vue-r">Тогда</span>
                    Движения.БронированиеТоваров.Прочитать();
                    <span class="vue-r">Для каждого</span> Движение <span class="vue-r">Из</span> Движения.БронированиеТоваров <span class="vue-r">Цикл</span>
                        Движение.Активность = НЕ ПометкаУдаления;
                    <span class="vue-r">КонецЦикла;</span> 
                    Движения.БронированиеТоваров.Записать();
                <span class="vue-r">КонецЕсли;</span>
            <span class="vue-r">КонецПроцедуры</span>
            </b></span>
        </pre>
    </div>
    <p>Коротко, что мы делаем. Пометка ставится, пользователь подтверждает пометку, значит нам надо пройтись по всем записям регистра, которые принадлежат этому документу, а для этого их надо прочитать из базы и поменять им поле Активность и записать обратно.</p>











    
    <h3 class="header-style" id="23">Показываем остаток выбранного товара в табличной части документа. Использую <b>объектную модель запроса и табличную</b></h3>
    <p>Стоит задача отобразить в поле "надпись", ниже табличной части, остаток выделенного товара в документе "ПродажаТоваров". Для табличной части Товары есть событие "ПриАктивизацииСтроки", это когда мы кликаем по строке и она выделается, срабатывает это событие. Далее вешаем на это событие в модуле формы документа обработчики:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыПриАктивизацииСтроки(Элемент)
                СсылкаНаТовар = Элементы.Товары.ТекущиеДанные.Товар;
                ТоварыПриАктивизацииСтрокиНаСервере(СсылкаНаТовар);
            КонецПроцедуры

            &НаСервере
            Процедура ТоварыПриАктивизацииСтрокиНаСервере(СсылкаНаТовар)
                <span class="vue-g">//объектная модель запроса</span> 
                //так как этот регистр имеет 2 измерения, то их и указываем
                Отбор = Новый Структура("Номенклатура, Склад", СсылкаНаТовар, Объект.Склад);

                //в ТаблицаОстатков вернётся таблица с типом ТаблицаЗначений. Это тип данных из группы типов данных
                //как и Массив, Структура, Соответствие
                ТаблицаОстатков = РегистрыНакопления.ОстаткиНоменклатуры.Остатки(, Отбор); 

                //чтобы получить ресурс Количество нужно вызвать метод Итог у таблицы
                //мы можем получить Количество и не через Итог, а сразу получить значение поля, выбрав строку таблицы и поле в этой строке
                //ОстатокТовара = ТаблицаОстатков.[0].Количество;
                //почему ичпользуем Итог(), потмоу что у нас может не быть остатков, а значит строк
                //не будет в таблице и обращение к строке вызовет ошибку, а метод Итог() не вызовет ошибки
                ОстатокТовара = ТаблицаОстатков.Итог("Количество");
                


                <span class="vue-g">//табличная модель запроса</span>
                //Запрос = Новый Запрос;
                //Запрос.Текст = 
                //	"ВЫБРАТЬ
                //	|	ОстаткиНоменклатурыОстатки.КоличествоОстаток КАК КоличествоОстаток
                //	|ИЗ
                //	|	РегистрНакопления.ОстаткиНоменклатуры.Остатки КАК ОстаткиНоменклатурыОстатки
                //	|ГДЕ
                //	|	ОстаткиНоменклатурыОстатки.Номенклатура = &Номенклатура";
                //
                //Запрос.УстановитьПараметр("Номенклатура", СсылкаНаТовар);
                //РезультатЗапроса = Запрос.Выполнить();
                //ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
                //ВыборкаДетальныеЗаписи.Следующий();
                //ОстатокТовара = ВыборкаДетальныеЗаписи.КоличествоОстаток;
            КонецПроцедуры
        </pre>
    </div>
    <p>Заходим проверяем на работу и всё работает, но нас поджидает ошибка при попытке создать новый документ ПродажаТоваров. Когда мы создадим документ, нам откроется форма документа, где мы будем заполнять поля и событие "ПриАктивизацииСтроки" сразу срабатывает, это событие пытается спозиционироваться на строку в табличной части, но у нас ещё не заполнена табличная часть и потому нет пока строки, на которую это событие указывает, а потому в процедуре строка <b>СсылкаНаТовар = Элементы.Товары.ТекущиеДанные.Товар;</b> вызовет ошибку, в Элементы.Товары.ТекущиеДанные будет лежать Неопределено и попытка прочитать у Неопределено поле Товар и вызовет ошибку. Перепишем процедуру на клиенте:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыПриАктивизацииСтроки(Элемент)
                <span class="vue-g">//при создании нового документа это событие срабатывает и пытается спозиционироваться на строку в табличной части нового документа, но там ничего ещё нет
                //а потому ТекущиеДанные будут содержать Неопределено и поля Товар у него нет, значит будет ошибка. Чтобы ошибки не было вот 2 способа её избежать
                //это 1й способ мой через Попытка ... Исключение</span>
                Попытка
                    СсылкаНаТовар = Элементы.Товары.ТекущиеДанные.Товар;
                Исключение
                    Возврат;
                КонецПопытки;
                ТоварыПриАктивизацииСтрокиНаСервере(СсылкаНаТовар);
                
                <span class="vue-g">//2 способ Камкова через условие
                //ТекущиеДанные = Элементы.Товары.ТекущиеДанные.Товар;
                //Если ТекущиеДанные &lt;> Неопределено Тогда
                //  ТоварыПриАктивизацииСтрокиНаСервере(ТекущиеДанные.Товар);
                //КонецЕсли;</span>
            КонецПроцедуры
        </pre>
    </div>
    <p>Если же нам по какой то причине нужно плучать остатки не актуальные, а на дату документа, то в метод Остатки первым аргументом передаём дату документа или момент времени документа. Можно момент времени передать 2мя способами - 1) у Объект нет такого свойства, зато есть в таблице документа в БД, чтобы его получить обратимся через ссылку - <b>Объект.Ссылка.МоментВремени</b>, 2) и можно создать момент времени самому и передать в него параметры - <b>Новый МоментВремени(Объект.Дата, Объект.Ссылка)</b>.</p>
    <p>Важно не забывать, что при создаднии нового документа и добавления товара остатки не покажутся потому что в данном случае может быть не указан Склад, а это одно из измерений по которому происходит отбор из БД, второе можно добавить вызов процедуры ТоварыПриАктивизацииСтрокиНаСервере где нибудь в процедуре подстановки цены и тогда цена укажется для товара и тут же укажется остатки и мы уже видим сколько количество нужно указать для продажи.</p>
    <p>Ещё может быть ошибка связанная с моментов времени. При создании нового документа в какой то миг событие сработает и Элементы.Товары.ТекущиеДанные вернут не Неопределено, а пустую ссылку. Механиpм Попытка ... Исключение пустую ссылку не отлавливает как ошибку, поэтому я бы проверил в попытке значение на пустую ссылку и если она пустая, то возбудил бы исключение, вот так</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыПриАктивизацииСтроки(Элемент)
                <span class="vue-g">//при создании нового документа это событие срабатывает и пытается спозиционироваться на строку в табличной части нового документа, но там ничего ещё нет
                //а потому ТекущиеДанные будут содержать Неопределено и поля Товар у него нет, значит будет ошибка. Чтобы ошибки не было вот 2 способа её избежать
                //это 1й способ мой через Попытка ... Исключение</span>
                Попытка
                    СсылкаНаТовар = Элементы.Товары.ТекущиеДанные.Товар;
                    Если СсылкаНаТовар.Пустая() Тогда
                        ВызватьИсключение(" ");
                    КонецЕсли;
                Исключение
                    Возврат;
                КонецПопытки;
                ТоварыПриАктивизацииСтрокиНаСервере(СсылкаНаТовар);
                
                <span class="vue-g">//2 способ Камкова через условие
                //ТекущиеДанные = Элементы.Товары.ТекущиеДанные.Товар;
                //Если ТекущиеДанные &lt;> Неопределено Тогда
                //  ТоварыПриАктивизацииСтрокиНаСервере(ТекущиеДанные.Товар);
                //КонецЕсли;</span>
            КонецПроцедуры
        </pre>
    </div>
    <p>Потому что если пустая ссылка пойдёт дальше, то там может случится бесконечный вызов при моменте времени.</p>




</div>
