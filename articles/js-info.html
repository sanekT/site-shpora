<div class="wrap">
    <h2 class="header-style">Различная информация</h2>
    
    
    <ul class="list">
        <li><a href=""></a></li>
    </ul>
    
    
    
    
    <h3 class="header-style2">Что может и что не может js делать в браузере</h3>
    <p><b>Может:</b></p>
    <ul class="list">
        <li>Добавлять новый HTML-код на страницу, изменять существующее содержимое, модифицировать стили.</li>
        <li>Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.</li>
        <li>Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии AJAX и COMET).</li>
        <li>Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.</li>
        <li>Запоминать данные на стороне клиента («local storage»).</li>
    </ul>
    <p><b>Не может:</b></p>
    <ul class="list">
        <li>JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС. Современные браузеры позволяют ему работать с файлами, но с ограниченным доступом, и предоставляют его, только если пользователь выполняет определённые действия, такие как «перетаскивание» файла в окно браузера или его выбор с помощью тега &lt;input>.</li>
        <li>Различные окна/вкладки не знают друг о друге. Иногда одно окно, используя JavaScript, открывает другое окно. Но даже в этом случае JavaScript с одной страницы не имеет доступа к другой, если они пришли с разных сайтов (с другого домена, протокола или порта). Это называется «Политика одинакового источника» (Same Origin Policy). Чтобы обойти это ограничение, обе страницы должны согласиться с этим и содержать JavaScript-код, который специальным образом обменивается данными.</li>
        <li>JavaScript может легко взаимодействовать с сервером, с которого пришла текущая страница. Но его способность получать данные с других сайтов/доменов ограничена. Хотя это возможно в принципе, для чего требуется явное согласие (выраженное в заголовках HTTP) с удалённой стороной. Опять же, это ограничение безопасности.</li>
    </ul>
    <p><b>Если атрибут src у тега script установлен, содержимое тега script будет игнорироваться.</b></p>
    
    
    
    <h2 class="header-style">Основы JS</h2>
    
    <h3 class="header-style2">Типы данных</h3>
    <p>Всего 8 типов данных: </p>
    <ul class="list">
        <li>number</li>
        <li>string</li>
        <li>boolean</li>
        <li>bigInt</li>
        <li>null</li>
        <li>undefined</li>
        <li>object</li>
        <li>Symbol</li>
    </ul>
    <p>Узнать тип данных можно с помощью оператора <b>typeof</b>. Его результатом будет тип данных в строковом виде.</p>
    <p><b>Число.</b></p>
    <p>Числовой тип данных (<b>number</b>) представляет как целочисленные значения, так и числа с плавающей точкой. Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: <b>Infinity, -Infinity и NaN</b>. Infinity можно получить при делении на 0 или объявить явно словом "Infinity". Значение NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Это значение прилипчиво, все операции с ним вернут NaN.</p>
    <p><b>Строка.</b></p>
    <p>Строка (<b>string</b>) в JavaScript должна быть заключена в кавычки('' или "" или ``). Между одинарными и двойными нет разницы, а вот в `` можно страивать переменные или выражения в конструкции ${...}.</p>
    <p><b>Null.</b></p>
    <p>Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно». Если переменной присвоить это значение, то это значит, что переменная объявлена, но она пока пустая.</p>
    <p><b>Undefined.</b></p>
    <p>Оно означает, что «значение не было присвоено». Мы объявили переменную, но ничего ей не присвоили, даже null не присвоили, вот тогда в переменной будет лежать значение undefined.</p>
    
    
    
    <h3 class="header-style2">Преобразование типов</h3>
    <p>Математические операции (/, *, -) преобразуют операнды к <b>числу</b>. Функция <b>alert()</b>выводит результат и сразу его преоразует в строку.</p>
    <p>Также к числу, строке и булеву значению можно привести через функции - String(value), Number(value), Boolean(value)</p>
    <p>К числу также можно привести через унарный +( +true -> 1, +"" -> 0 ), а к строке можно привести через конкатенацию с другой строкой. Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки.</p>
    <p>Если строка не может преобразоваться к числу, то результатом будет NaN. Числовое значение NaN прилипчиво.</p>
    <p><b>Правила численного преобразования</b>:</p>
    <ul class="list">
        <li>undefined -> NaN</li>
        <li>null -> 0</li>
        <li>true/false -> 1/0</li>
        <li>string -> Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.</li>
    </ul>
    <p><b>Правила логического преобразования</b>:</p>
    <ul class="list">
        <li>Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.</li>
        <li>Все остальные значения становятся true</li>
        <li>Заметим, что строчка с нулём "0" — это true</li>
    </ul>
    <p><b>Приоритет операторов</b>:</p>
    <table style="margin-left: 50px">
        <thead>
        <tr>
        <th>Приоритет</th>
        <th>Название</th>
        <th>Обозначение</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>…</td>
        <td>…</td>
        <td>…</td>
        </tr>
        <tr>
        <td>15</td>
        <td>унарный плюс</td>
        <td><code>+</code></td>
        </tr>
        <tr>
        <td>15</td>
        <td>унарный минус</td>
        <td><code>-</code></td>
        </tr>
        <tr>
        <td>14</td>
        <td>возведение в степень</td>
        <td><code>**</code></td>
        </tr>
        <tr>
        <td>13</td>
        <td>умножение</td>
        <td><code>*</code></td>
        </tr>
        <tr>
        <td>13</td>
        <td>деление</td>
        <td><code>/</code></td>
        </tr>
        <tr>
        <td>12</td>
        <td>сложение</td>
        <td><code>+</code></td>
        </tr>
        <tr>
        <td>12</td>
        <td>вычитание</td>
        <td><code>-</code></td>
        </tr>
        <tr>
        <td>…</td>
        <td>…</td>
        <td>…</td>
        </tr>
        <tr>
        <td>2</td>
        <td>присваивание</td>
        <td><code>=</code></td>
        </tr>
        <tr>
        <td>…</td>
        <td>…</td>
        <td>…</td>
        </tr>
        </tbody>
    </table>
    <p><b>Присваивание = возвращает значение</b>. Вызов x = value записывает value в x и возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения: <b>let c = 3 - (a = b + 1);</b>. Однако писать самим в таком стиле не рекомендуется.</p>
    
    
    
    <h3 class="header-style2">Операторы сравнения</h3>
    <p>&lt;, &gt;, &lt;=, &gt;=, ==, !=, ===, !==</p>
    <p>Результат сравнения имеет логический тип.</p>
    <p><b>Сравнение разных типов.</b> При сравнении значений разных типов JavaScript приводит каждое из них к числу. <b>Оператор строгого равенства === проверяет равенство без приведения типов к числу.</b></p>
    <p>Пример:</p>
    <p>0 == false // приводится к числу - 0  == 0 -> true</p>
    <p>0 === false // не приводится к числу - число  === булево -> false</p>
    <p><b>В JS есть только одно значение, которое не равно самому себе и это NaN</b></p>
    <p><b>Сравнение с null и undefined.</b></p>
    <p><b>При строгом равенстве ===</b></p>
    <p>Эти значения различны, так как различны их типы.</p>
    <div class="code-style">
        <pre>
            alert( null === undefined ); // false
        </pre>
    </div>
    <p><b>При не строгом равенстве ==</b></p>
    <p>Эти значения равны друг другу и не равны никаким другим значениям.</p>
    <div class="code-style">
        <pre>
            alert( null == undefined ); // true
        </pre>
    </div>
    <p>Также у этих двух типой есть странности при сравнении, если нужно то надо почитать.</p>





    
    
    
    <h3 class="header-style2">Условный оператор</h3>
    <div class="code-style">
        <pre>
            let accessAllowed =  false;
            if(age > 18){
                accessAllowed = true;
            }
            
            //то же самое
            let accessAllowed = (age > 18) ? true : false;
            
            //то же самое
            let accessAllowed = age > 18;
        </pre>
    </div>
    <p>Смысл оператора «вопросительный знак» ? – вернуть то или иное значение в переменную, в зависимости от условия. Пожалуйста, используйте его именно для этого. Когда вам нужно выполнить разные ветви кода – используйте if.</p>
    
    
    
    
    <h3 class="header-style2">Логические операторы</h3>
    <p>Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип. Если значение не логического типа, то оно к нему приводится в целях вычислений, но значение возвращается в исходном виде, без преобразования:</p>
    <div class="code-style">
        <pre>
            alert( 1 || 0 ); // 1
            alert( false || 'word' );  // 'word'
        </pre>
    </div>
    <p>Цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено. Значение возвращается в исходном виде, без преобразования. Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ»:</p>
    <p>1. Получение первого истинного значения из списка переменных или выражений. Представим, что у нас имеется ряд переменных, которые могут содержать данные или быть null/undefined. С помощью оператора ИЛИ мы можем найти переменную со значением отличную от null и вернуть её.</p>
    <p>2. Сокращённое вычисление. О чём речь? О том, что в операндах могут быть целые выражения и если первый операнд возвращает true, то до вычесления 2го операнда даже не доходит. В таких случаях оператор ИЛИ может заменить if:</p>
    <div class="code-style">
        <pre>
            function simple(arg){
                let a = arg || 'Ни чего не пришло';
            }
        </pre>
    </div>
    <p>С оператором <b>И</b> всё то же самое, только И возвращает первый ложный аргумент или последний в случае если все аргументы true.</p>
    <p>Приоритет оператора && больше, чем у ||. Как и оператор ИЛИ, И && иногда может заменять if.</p>
    <p>Оператор <b>НЕ(!)</b> принимает один аргумент и выполняет следующие действия:</p>
    <p>1. Сначала приводит аргумент к логическому типу true/false.</p>
    <p>2. Затем возвращает противоположное значение.</p>
    <p>В частности, двойное НЕ используют для преобразования значений к логическому типу:</p>
    <div class="code-style">
        <pre>
            alert( !!"non-empty string" ); // true
            alert( !!null ); // false
        </pre>
    </div>
    <p>Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:</p>
    <div class="code-style">
        <pre>
            alert( Boolean("non-empty string") ); // true
            alert( Boolean(null) ); // false
        </pre>
    </div>
    
    
    
    
    <h3 class="header-style2">Оператор ??(Оператор объединения с null)</h3>
    <p>Оператор объединения с null ?? — это быстрый способ выбрать первое «определённое» значение из списка.</p>
    <p>Результат выражения a ?? b будет следующим:</p>
    <p>a, если значение a определено, т.е. не равно null/undefined,</p>
    <p>b, если значение a не определено.</p>
    <div class="code-style">
        <pre>
            let a = 'word';
            alert( a ?? 'default' ); // 'word'
            a = null;
            alert( a ?? 'default' ); // 'default'
            a = undefined;
            alert( a ?? 'default' ); // 'default'
            a = false;
            alert( a ?? 'default' ); // false
        </pre>
    </div>
    <p>Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:</p>
    <div class="code-style">
        <pre>
            result = (a !== null && a !== undefined) ? a : b;
        </pre>
    </div>
    <p>Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.</p>
    <p>Также этот оператор можно использовать в цепочке:</p>
    <div class="code-style">
        <pre>
            let firstName = null;
            let lastName = null;
            let nickName = "Суперкодер";

            // показывает первое определённое значение:
            alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
        </pre>
    </div>
    <p>Если в приведённом выше коде заменить ?? на ||, то будет тот же самый результат. Оператор ?? был добавлен как раз потому, что многие были недовольны оператором ||. Важное различие между ними заключается в том, что:</p>
    <p>1. || возвращает первое истинное значение.</p>
    <p>2. ?? возвращает первое определённое значение.</p>
    <p>Например:</p>
    <div class="code-style">
        <pre>
            let width = 0;
            alert( width ?? 100 ); // 0
            alert( width || 100 ); // 100
        </pre>
    </div>
    <p>На практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.</p>
    <p>УОператор ?? имеет довольно небольшой приоритет, поэтому желательно использовать ():</p>
    <div class="code-style">
        <pre>
            let area = (height ?? 100) * (width ?? 50);
        </pre>
    </div>
    <p>По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с &amp;&amp; и ||, если только приоритет явно не указан в круглых скобках:</p>
    <div class="code-style">
        <pre>
            let x = 1 &amp;&amp; 2 ?? 3; // Синтаксическая ошибка
            let x = (1 &amp;&amp; 2) ?? 3; // Работает без ошибок
        </pre>
    </div>
    
    
    
    
    <h3 class="header-style2">Массивы</h3>
    <p></p>
    <p>Массивы в JS по типу данных это объект. Содержит только нумерованные элементы. Массив при переводе его к строке выдаёт свои элементы через запятую.</p>
    <div class="code-style">
        <pre>
            let arr = []; //создали пустой массив
            let arr = [22, 1, 4]; //заполнили массив
            console.log(arr); //вывели массив в консоль
            let arr = [22, "str", true]; //заполнили массив разными типами
            console.log(arr[1]); //вывели "str" в консоль
            arr[2] = 999;  // перезаписали 3й элемент
            arr[5] = 333;  //добавили 6м элементом 333 и в массиве образовались 2 пустые дырки на месте 3 и 4 элемента, если проверить длину, то длина станет равна 6, учитывая и эти дырки
            console.log(arr);  // [22, "str", 999, empty x 2, 333]
            delete arr[5];
            console.log(arr);  // [22, "str", 999, empty x 3]
            //Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один.
            console.log(arr.length);  // 6
            arr.length = 2; // укорачиваем до двух элементов
            console.log(arr);  // [22, "str"]
            arr.length = 0; // самый быстрый способ очистить массив
            //при преобразовании массива к строке он выводит свои элементы через запяятую в строке
            alert( [] + 1 ); // "1"
            alert( [1] + 1 ); // "11"
            alert( [1,2] + 1 ); // "1,21"
        </pre>
    </div>
    <p>Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString.</p>
    
    
    
    
    <h3 class="header-style2">Функции</h3>
    <p>Присвоение аргументу функции значения по умолчанию:</p>
    <div class="code-style">
        <pre>
            function someCode(v = 'Значение по умолчанию'){
                alert(v);
            }
            someCode(); // 'Значение по умолчанию'
        </pre>
    </div>
</div>
