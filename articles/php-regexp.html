<div class="wrap">
   
    <h2 class="header-style">Регулярные выражения PHP</h2>
    
    
    <ul class="list">
        <li><a href="#1">Введение в регулярные выражения в PHP</a></li>
        <li><a href="#2">Операторы повторения символов в регулярках. <b>*, +, ?</b></a></li>
        <li><a href="#3">Группирующие скобки в регулярках PHP. <b>( )</b></a></li>
        <li><a href="#4">Экранировка спецсимволов. <b>\</b></a></li>
        <li><a href="#5">Фигурные скобки в регулярных выражения. <b>{ }</b></a></li>
        <li><a href="#6">Ограничение жадности в регулярках. <b>?</b></a></li>
        <li><a href="#7">Группы символов в регулярных выражениях. <b>\d, \s, \w</b></a></li>
        <li><a href="#8">Наборы символов в регулярных выражениях. <b>[ ]</b></a></li>
        <li><a href="#9">Оператор "кроме" для набора символов. <b>^</b></a></li>
        <li><a href="#10">Особенности русских букв в регулярках PHP</a></li>
        <li><a href="#11">Спецсимволы внутри квадратных скобок</a></li>
        <li><a href="#12">Группы символов внутри квадратных скобок</a></li>
        <li><a href="#13">Спецсимволы-исключения внутри квадратных скобок</a></li>
        <li><a href="#14">Символ шляпки(^) внутри квадратных скобок</a></li>
        <li><a href="#15">Особенности дефиса внутри квадратных скобок</a></li>
        <li><a href="#16">Начало и конец строки в регулярках PHP</a></li>
        <li><a href="#17">Команда 'или' в регулярных выражениях PHP</a></li>
        <li><a href="#18">Конец или начало слова в регулярках PHP</a></li>
        <li><a href="#19">Ограничители регулярок в PHP</a></li>
        <li><a href="#20">Проблема обратного слеша в PHP</a></li>
        <li><a href="#21">Проверка строки с помощью регулярки на PHP</a></li>
        <li><a href="#22">Автоматическое тестирование регулярок в PHP</a></li>
        <li><a href="#23">Проверка всей строки через регулярки в PHP</a></li>
        <li><a href="#24">Карманы при поиске через регулярки на PHP</a></li>
        <li><a href="#25">Поиск всех совпадений через регулярки на PHP</a></li>
        <li><a href="#26">Несохраняющие скобки в регулярках PHP</a></li>
        <li><a href="#27">Карманы при замене через регулярки на PHP</a></li>
        <li><a href="#28">Карманы в регулярном выражении в PHP</a></li>
        <li><a href="#29">Именованные карманы в регулярках PHP</a></li>
        <li><a href="#30">Именованные карманы внутри регулярки PHP</a></li>
        <li><a href="#31">Общий номер карманов в регулярках PHP</a></li>
        <li><a href="#32">Позитивный и негативный просмотр в PHP</a></li>
        <li><a href="#33">Замена с коллбэком через регулярки в PHP</a></li>
        <li><a href="#34">Модификаторы регулярок в PHP</a></li>
    </ul>
    
    <h3 class="header-style2" id="1">Введение в регулярные выражения в PHP</h3>
    <p>Регулярные выражения - это такие команды для сложного поиска и замены. Они позволяют делать очень интересные вещи, но, к сожалению, довольно тяжелы в освоении.</p>
    <p>Существует несколько функций PHP для работы с регулярными выражениями. Мы начнем знакомится с ними на примере <b>preg_replace</b>. Эта функция первым параметром принимает что менять, а вторым - на что менять, а третьим параметром - строку, в которой нужно заменять:</p>
    <div class="code-style">
        <pre>
            preg_replace(что менять, на что, строка);
            //preg_replace() если нашёл по шаблону и заменил, то возвращает новую обновлённую строку
        </pre>
    </div>
    <p>При этом первым параметром наша функция принимает не просто строку как функция str_replace(), а регулярное выражение, представляющее собой строку с набором команд, расположенных внутри символов решетки #. Эти решетки называются <i>ограничителями</i> регулярных выражений. Символы для ограничителей можно выбрать почти любые.</p>
    <p>После ограничителей можно писать <i>модификаторы</i> - команды, которые изменяют общие свойства регулярного выражения.</p>
    <p>Сами регулярные выражения состоят из двух типов символов: из тех, которые обозначают сами себя и из символов-команд, которые называются <i>специальные символы</i>.</p>
    <p>Буквы и цифры обозначают сами себя. В следующем примере мы с помощью регулярного выражения заменим букву 'a' на '!':</p>
    <div class="code-style">
        <pre>
            preg_replace('#a#', '!', 'bab'); // вернет 'b!b'
        </pre>
    </div>
    <p>А вот точка является специальным символом и обозначает <i>один любой символ</i>, именно ОДИН любой символ, не больше, чтобы обозначит много любых символов используется та же точка, но с квантификатором, который рассмотрим позже. В следующем примере мы найдем строку по такому шаблону: буква 'x', затем любой символ, затем опять буква 'x':</p>
    <div class="code-style">
        <pre>
            preg_replace('#x.x#', '!', 'xax eee'); // вернет '! eee'
        </pre>
    </div>
    
    
    
    
    
    
    
    <h3 class="header-style2" id="2">Операторы повторения символов в регулярках. <b>*, +, ?</b></h3>
    <p>Бывают ситуации, когда мы хотим указать, что символ повторяется заданное количество раз. Если мы знаем точное число повторений, то можно просто написать его несколько раз - #aaaa#. Но что делать, если мы хотим сказать такое: <i>повторить один или более раз</i>?</p>
    <p>Для этого существуют операторы (<i>квантификаторы</i>) повторения: плюс + (один и более раз), звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними. Давайте посмотрим на работу этих операторов на примерах:</p>
    <div class="code-style">
        <pre>
            //Найдем все подстроки по шаблону буква 'x', буква 'a' один или более раз, буква 'x'
            $str = 'xx xax xaax xaaax xbx';
            $res = preg_replace('#xa+x#', '!', $str); //'xx ! ! ! xbx'
            
            
            //Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или более раз, буква 'x'
            $str = 'xx xax xaax xaaax xbx';
            $res = preg_replace('#xa*x#', '!', $str); //'! ! ! ! xbx'
            
            
            //Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или один раз, буква 'x'
            $str = 'xx xax xaax xbx';
            $res = preg_replace('#xa?x#', '!', $str); //'! ! xaax xbx'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="3">Группирующие скобки в регулярках PHP. <b>( )</b></h3>
    <p>В предыдущих примерах операторы повторения действовали только на один символ, который стоял перед ними. Что делать, если мы хотим подействовать им на несколько символов?</p>
    <p>Для этого существуют группирующие скобки '(' и ')'. Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок. Давайте посмотрим на примерах.</p>
    <div class="code-style">
        <pre>
            //В следующем примере шаблон поиска выглядит так: буква 'x', далее строка 'ab' один или более раз, потом буква 'x'
            $str = 'xabx xababx xaabbx';
            $res = preg_replace('#x(ab)+x#', '!', $str); //'! ! xaabbx'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="4">Экранировка спецсимволов. <b>\</b></h3>
    <p>Предположим, что мы хотим сделать так, чтобы спецсимвол обозначал сам себя. Для этого его нужно экранировать с помощью обратного слеша. Давайте посмотрим на примерах.</p>
    <p><b>Пример 1</b>.  В следующем примере автор регулярки хотел, чтобы шаблон поиска выглядел так: буква 'a', затем плюс '+', затем буква 'x'. Однако, автор кода не заэкранировал символ '+' и поэтому шаблон поиска самом деле он выглядит так: буква 'a' один или более раз, потом буква 'x':</p>
    <div class="code-style">
        <pre>
            $str = 'a+x ax aax aaax';
            $res = preg_replace('#a+x#', '!', $str); //'a+x ! ! !'
        </pre>
    </div>
    <p><b>Пример 2</b>.  А сейчас автор заэкранировал плюс обратным слешем. Теперь шаблон поиска выглядит так, как надо: буква 'a', затем плюс '+', затем буква 'x'.</p>
    <div class="code-style">
        <pre>
            $str = 'a+x ax aax aaax';
            $res = preg_replace('#a\+x#', '!', $str); //'! ax aax aaax'
        </pre>
    </div>
    <p><b>Пример 3</b>.  В данном примере шаблон выглядит так: буква 'a', затем точка '.', затем буква 'x':</p>
    <div class="code-style">
        <pre>
            $str = 'a.x abx azx';
            $res = preg_replace('#a\.x#', '!', $str); //'! abx azx'
        </pre>
    </div>
    <p><b>Пример 4</b>.  А следующем примере автор забыл заэкранировать точку и под регулярку попали все подстроки, так как незаэкранированная точка обозначает любой символ:</p>
    <div class="code-style">
        <pre>
            $str = 'a.x abx azx';
            $res = preg_replace('#a.x#', '!', $str); //'! ! !'
        </pre>
    </div>
    <p><b>Список специальных символов и обычных</b></p>
    <p>Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. Исключение - цифры, их нельзя экранировать. Часто возникает сомнение, является ли данный символ специальным. Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика (захламляет регулярку обратными слешами).</p>
    <p>Являются спецсимволами: $ ^ . * + ? \ / {} [] () |</p>
    <p>Не являются спецсимволами: @ : , ' " ; - _ = &lt; > % # ~ ` &amp; !</p>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="5">Фигурные скобки в регулярных выражения. <b>{ }</b></h3>
    <p>Операторы +, *, ? хороши, однако, с их помощью нельзя указать конкретное число повторений. В этом случае вам на помощь придет оператор {}.</p>
    <p>Работает он следующим образом: {5} - пять повторений, {2,5} - повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' один или два раза, буква 'x':
            $str = 'xx xax xaax xaaax';
            $res = preg_replace('#xa{1,2}x#', '!', $str); //'xx ! ! xaaax'
            
            
            //В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' два раза и более, буква 'x':
            $str = 'xx xax xaax xaaax';
            $res = preg_replace('#xa{2,}x#', '!', $str); //'xx xax ! !'
            
            
            //В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' три раза, буква 'x':
            $str = 'xx xax xaax xaaax';
            $res = preg_replace('#xa{3}x#', '!', $str); //'xx xax xaax !'
            
            
            //В данном примере шаблон поиска выглядит так: буква 'a' десять раз:
            $str = 'aaa aaaaaaaaaa aaa';
            $res = preg_replace('#a{10}#', '!', $str); //'aaa ! aaa'
            
            
            
            //В данном примере автор кода хотел такой шаблон: буква 'x', буква 'a' три раза раза и меньше, буква 'x', но, к сожалению, такое - {,3} - не работает. Нужно указать явно:
            $str = 'xx xax xaax xaaax';
            $res = preg_replace('#xa{1,3}x#', '!', $str); //'xx ! ! !'
            
            
            
            //Ноль тоже допустим:
            $str = 'xx xax xaax xaaax';
            $res = preg_replace('#xa{0,3}x#', '!', $str); //'! ! ! !'
        </pre>
    </div>
    
    
    
    
    
    
    
    <h3 class="header-style2" id="6">Ограничение жадности в регулярках. <b>?</b></h3>
    <p>Регулярные выражения по умолчанию <i>жадные</i>. Это значит, что они захватывают максимальное возможное количество символов. Давайте разберем на примере. Пусть у нас есть вот такая строка:</p>
    <div class="code-style">
        <pre>
            $str = 'aeeex zzz x kkk';
        </pre>
    </div>
    <p>Пусть мы в этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a', затем любой символ один или более раз, затем буква 'x'.</p>
    <div class="code-style">
        <pre>
            $res = preg_replace('#a.+x#', '!', $str);
        </pre>
    </div>
    <p>Мы ожидаем, что в переменную в результате запишется строка '! zzz x kkk'. Однако, это не так - в переменную попадает строка '! kkk'.</p>
    <p>Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'. Из-за жадности получается, что регулярка ищет до самого последнего икса, тем самым захватывая не то, что мы ожидали.</p>
    <p>Конечно, зачастую такое поведение нам и нужно. Но конкретно в этом случае мы бы хотели отменить жадность и сказать регулярке, чтобы она искала до первого икса. Чтобы ограничить жадность, нужно после оператора повторения поставить знак вопроса:</p>
    <div class="code-style">
        <pre>
            $res = preg_replace('#a.+?x#', '!', $str);
        </pre>
    </div>
    <p>Жадность можно ограничивать всем операторам повторения, вот так: *?, +?, ?? и {}?.</p>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="7">Группы символов в регулярных выражениях. <b>\d, \s, \w</b></h3>
    <p>Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. Команда \d означает цифру от 0 до 9. Команда \w обозначает цифру, латинскую букву или знак подчеркивания. Команда \s обозначает пробел или пробельный символ: пробел, перевод строки, табуляцию. Можно инвертировать значение команды, написав большую букву: например, если \d - цифра, то \D - не цифра.</p>
    <p><b>Пример 1</b>.  Давайте найдем все цифры:</p>
    <div class="code-style">
        <pre>
            $str = '1 12 123';
            $res = preg_replace('#\d#', '!', $str); //'! !! !!!'
        </pre>
    </div>
    <p><b>Пример 2</b>.  Операторы повторения считают команды-группы одним целым, то есть группирующие скобки не нужны. В следующем примере шаблон поиска выглядит так: цифра от 0 до 9 один или более раз:</p>
    <div class="code-style">
        <pre>
            $str = '1 12 123 abc @@@';
            $res = preg_replace('#\d+#', '!', $str); //'! ! ! abc @@@'
        </pre>
    </div>
    <p><b>Пример 3</b>.  В следующем примере шаблон поиска выглядит так: все что угодно один или более раз, но не цифра от 0 до 9:</p>
    <div class="code-style">
        <pre>
            $str = '123abc3@@';
            $res = preg_replace('#\D+#', '!', $str); //'123!3!'
        </pre>
    </div>
    <p><b>Пример 4</b>.  В данном примере шаблон поиска выглядит так: пробельный символ один раз:</p>
    <div class="code-style">
        <pre>
            $str = '1 12 123 abc @@@';
            $res = preg_replace('#\s#', '!', $str); //'1!12!123!abc!@@@'
        </pre>
    </div>
    <p><b>Пример 5</b>.  В данном примере шаблон поиска выглядит так: НЕ пробельный символ один или более раз. Все подстроки, разделенные пробелами, заменятся на '!':</p>
    <div class="code-style">
        <pre>
            $str = '1 12 123 abc @@@';
            $res = preg_replace('#\S+#', '!', $str); //'! ! ! ! !'
        </pre>
    </div>
    <p><b>Пример 6</b>.  В данном примере шаблон поиска выглядит так: цифра или буква один или более раз. Все подстроки, состоящие из цифр и букв, заменятся на '!':</p>
    <div class="code-style">
        <pre>
            $str = '1 12 123a Abc @@@';
            $res = preg_replace('#\w+#', '!', $str); //'! ! ! ! @@@'
        </pre>
    </div>
    <p><b>Пример 7</b>.  В данном примере шаблон поиска выглядит так: НЕ цифра и НЕ буква один или более раз. Под данное определение в нашем случае попадает '@@@' и все пробелы (они ведь тоже не цифры и не буквы). Обратите внимание на то, что в конце один '!' - в него преобразовалась строка ' @@@' - с пробелом впереди:</p>
    <div class="code-style">
        <pre>
            $str = '1 12 123a Abc @@@';
            $res = preg_replace('#\W+#', '!', $str); //'1!12!123!Abc!'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="8">Наборы символов в регулярных выражениях. <b>[ ]</b></h3>
    <p>Группы символов \d и \w не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. Для таких задач следует использовать квадратные скобки, представляющие собой операцию ИЛИ.</p>
    <p>Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: #x[abc]x# - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.</p>
    <p>После квадратных скобок можно писать операторы повторения. К примеру, вот так: #x[abc]+x# - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.</p>
    <p>Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис. К примеру, вот так: #[a-d]# - мы получаем все символы от 'a' до 'd'. Давайте посмотрим на примерах.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z'. Для верхнего регистра также.
            $str = 'xax xbx xcx x@x';
            $res = preg_replace('#x[a-z]x#', '!', $str);//'! ! ! x@x'
            
            
            //В данном примере шаблон поиска выглядит так: между иксами любая цифра от 0 до 9:
            $str = 'xax x1x x3x x5x x@x';
            $res = preg_replace('#x[0-9]x#', '!', $str);//'xax ! ! ! x@x'
            
            
            //В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9:
            $str = 'xax x1x x3x x5x x@x';
            $res = preg_replace('#x[a-z1-9]x#', '!', $str);//'! ! ! ! x@x'
            
            
            //В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z':
            $str = 'xax xBx xcx x5x x@x';
            $res = preg_replace('#x[a-zA-Z]x#', '!', $str);//'! ! ! x5x x@x'
            
            
            //В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2:
            $str = 'xax xbx x1x x2x x3x';
            $res = preg_replace('#x[a-z12]x#', '!', $str);//'! ! ! ! x3x'
            
            
            //В данном примере шаблон поиска выглядит так: между иксами буквы от 'a' до 'z' в количестве от 1 и более:
            $str = 'xx xabesx xaadx x123x xa3x';
            $res = preg_replace('#x[a-z]+x#', '!', $str);//'xx ! ! ! x123x xa3x'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="9">Оператор "кроме" для набора символов. <b>^</b></h3>
    <p>С помощью шляпки ^ в начале квадратных скобок можно инвертировать желаемое. То есть, если, к примеру, команда [ab] ищет букву 'a' или 'b', то команда [^ab] будет искать все символы, кроме 'a' и 'b'.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ буква 'a', не 'b' и не 'c', потом буква 'z':
            $str = 'xaz xbz xcz xez';
            $res = preg_replace('#x[^abc]z#', '!', $str);//'xaz xbz xcz !'
            
            
            //В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ маленькая латинская буква, потом буква 'z':
            $str = 'xaz xbz x1z xCz';
            $res = preg_replace('#x[^a-z]z#', '!', $str);//'xaz xbz ! !'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="10">Особенности русских букв в регулярках PHP</h3>
    <p>Русские буквы не входят в группу \w. Для их получения нужно использовать группу в квадратных скобках, вот так: [а-я]. Но даже с этой группой есть проблема - сюда не войдёт буква 'ё'. Для её включения нужно сделать вот так: [а-яё].</p>
    <p>Кроме того, для правильной работы русских букв в регулярке необходимо поставить модификатор <b>u</b>:</p>
    <div class="code-style">
        <pre>
            $str = 'яяя ййй ёёё';
            $res = preg_replace('#[а-яё]#u', '!', $str); //!!! !!! !!!
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="11">Спецсимволы внутри квадратных скобок</h3>
    <p>Спецсимволы внутри [] становятся обычными символами. Это значит, что их не надо экранировать обратным слешем.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка:
            $str = 'xax xbx xcx xdx x.x x@x';
            $res = preg_replace('#x[abc.]x#', '!', $str); //'! ! ! xdx ! x@x'
            
            
            
            //В данном примере шаблон поиска выглядит так: между иксами любая маленькая латинская буква или знак +:
            $str = 'xax xbx xcx x@x x.x x+x';
            $res = preg_replace('#x[a-z+]x#', '!', $str); //'! ! ! x@x x.x !'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="12">Группы символов внутри квадратных скобок</h3>
    <p>Группы символов \d, \D, \w, \W, \s, \S внутри [] будут обозначать именно группы, то есть по-прежнему будут командами.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f':
            $str = 'xax xbx x1x x2x xhx x@x';
            $res = preg_replace('#x[\da-f]x#', '!', $str); //'! ! ! ! xhx x@x'
            
            
            //В данном примере шаблон поиска выглядит так: буква 'x', затем не цифра, не точка, и не маленькая латинская буква, затем буква 'z':
            $str = 'xaz x1z xAz x.z x@z';
            $res = preg_replace('#x[^\d.a-z]z#', '!', $str); //'xaz x1z ! x.z !'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="13">Спецсимволы-исключения внутри квадратных скобок</h3>
    <p>Вы уже знаете, что спецсимволы внутри [] становятся обычными символами. Есть, однако, исключения: если вам нужны квадратные скобки как символы, то их нужно экранировать обратным слешем.</p>
    <div class="code-style">
        <pre>
            //Для примера в следующем коде шаблон поиска выглядит так: между иксами стоит квадратная скобка:
            $str = 'x]x xax x[x x1x';
            $res = preg_replace('#x[\[\]]x#', '!', $str); //'! xax ! x1x'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="14">Символ шляпки(^) внутри квадратных скобок</h3>
    <p>Как вы знаете, шляпка внутри [] делает отрицание, будучи написанной в начале скобок. Значит, она является спецсимволом внутри этих скобок. Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места.</p>
    <div class="code-style">
        <pre>
            //В следующем примере шаблон поиска такой: первый символ - это все кроме 'd', потом две буквы 'x'.
            $str = 'axx bxx ^xx dxx';
            $res = preg_replace('#[^d]xx#', '!', $str); //'! ! ! dxx'
            
            
            
            //А теперь шаблон поиска такой: первый символ - это 'd' или '^', потом две буквы 'x':
            $str = 'axx bxx ^xx dxx';
            $res = preg_replace('#[d^]xx#', '!', $str); //'axx bxx ! !'
            
            
            
            //Можно не убирать шляпку с первого места, а просто заэкранировать ее с помощью обратного слеша, и она станет обозначать саму себя:
            $str = 'axx bxx ^xx dxx';
            $res = preg_replace('#[\^d]xx#', '!', $str); //'axx bxx ! !'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="15">Особенности дефиса внутри квадратных скобок</h3>
    <p>Дефис - тоже спецсимвол внутри [] (а вот снаружи - нет). Если вам нужен сам дефис как символ - то поставьте его там, где он не будет воспринят как разделитель группы.</p>
    <p>Почему это важно: вы можете сделать группу символов, сами не заметив этого. К примеру, вот так - [:-@] - вы думаете, что выбираете двоеточие, дефис и собаку, а на самом деле получается группа символов между : и @. В эту группу входят следующие символы: :, ;, ?, &lt;, =, >.</p>
    <p>Откуда они взялись? Из таблицы ASCII - двоеточие имеет номер меньше, чем собака - и получается группа. То есть все группы получаются по таблице ASCII (при желании этим можно пользоваться).</p>
    <p>Как с этим бороться: поставьте символ дефиса там, где он точно не будет воспринят как символ группы, например, в начале или в конце (то есть после [ или перед ]).</p>
    <p>Можно также заэкранировать дефис - тогда он будет обозначать сам себя независимо от позиции. Например, вместо [:-@] написать [:\-@] - и группы уже не будет, а будут три символа - двоеточие, дефис и собака @.</p>
    <div class="code-style">
        <pre>
            //В следующем примере шаблон поиска такой: цифра 1, затем буква от 'a' до 'z', затем цифра 2:
            $str = '1a2 1-2 1c2 1z2';
            $res = preg_replace('#1[a-z]2#', '!', $str); //'! 1-2 ! !'
            
            
            //Давайте теперь заэкранируем дефис. В результате шаблон поиска такой: цифра 1, затем буква 'a', или дефис, или буква 'z', затем цифра 2:
            $str = '1a2 1-2 1c2 1z2';
            $res = preg_replace('#1[a\-z]2#', '!', $str); //'! ! 1c2 !'
            
            
            
            //Можно просто переставить дефис, не экранируя его:
            $str = '1a2 1-2 1c2 1z2';
            $res = preg_replace('#1[az-]2#', '!', $str); //'! ! 1c2 !'
            
            
            
            //В следующем примере шаблон поиска такой: первый символ - это маленькие буквы или дефис '-', потом две буквы 'x':
            $str = 'axx Axx -xx @xx';
            $res = preg_replace('#[a-z-]xx#', '!', $str); //'! Axx ! @xx'
            
            
            
            //В следующем примере шаблон поиска такой: первый символ - это маленькие, большие буквы или дефис '-', потом две буквы 'x':
            $str = 'axx Axx -xx @xx';
            $res = preg_replace('#[a-zA-Z-]xx#', '!', $str); //'! ! ! @xx'
            
            
            
            //Можно расположить дефис между двумя группами - там он точно еще не сделает еще одну группу:
            $str = 'axx 9xx -xx @xx';
            $res = preg_replace('#[a-z-0-9]xx#', '!', $str); //'! ! ! @xx'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="16">Начало и конец строки в регулярках PHP</h3>
    <p>Существуют специальные символы, которые обозначают начало ^ или конец строки $. Давайте посмотрим их работу на примерах.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в начале строки:
            $str = 'aaa aaa aaa';
            $res = preg_replace('#^aaa#', '!', $str); //'! aaa aaa'
            
            
            
            //В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в конце строки:
            $str = 'aaa aaa aaa';
            $res = preg_replace('#aaa$#', '!', $str); //'aaa aaa !'
            
            
            
            //Когда в начале регулярки стоит ^, а в конце - $, то таким образом мы проверяем всю строку целиком на соответствие регулярке. В следующем примере шаблон поиска такой: буква 'a' повторяется один или более раз, заменить всю строку на '!' только она состоит из одних букв 'a'.
            $str = 'aaa';
            $res = preg_replace('#^a+$#', '!', $str); //'!'
        </pre>
    </div>
    
    
    

    
    
    
    
    <h3 class="header-style2" id="17">Команда 'или' в регулярных выражениях PHP</h3>
    <p>В данном уроке мы с вами разберем команду |, которая представляет собой более мощный вариант ИЛИ по сравнению с командой []. Данная команда позволяет разделить регулярку на несколько частей. При этом искомое может попасть либо под одну часть регулярки, либо под другую. Давайте посмотрим на примерах.</p>
    <div class="code-style">
        <pre>
            //В данном примере шаблон поиска такой: три буквы 'a' или три буквы 'b':
            $str = 'aaa bbb abb';
            $res = preg_replace('#a{3}|b{3}#', '!', $str); //'! ! abb'
            
            
            
            //В данном примере шаблон поиска такой: три буквы 'a' или от 1 и более букв 'b':
            $str = 'aaa bbb bbbb bbbbb axx';
            $res = preg_replace('#a{3}|b+#', '!', $str); //'! ! ! ! axx'
            
            
            
            //В данном примере шаблон поиска такой: одна или более буквы или три цифры:
            $str = 'a ab abc 1 12 123';
            $res = preg_replace('#[a-z]+|\d{3}#', '!', $str); //'! ! ! 1 12 !'
            
            
            
            //Вертикальная черта может делить регулярку не на две части, а на любое количество частей:
            $str = 'aaa bbb ccc ddd';
            $res = preg_replace('#a+|b+|c+#', '!', $str); //'! ! ! ddd'
            
            
            
            
            //Если вертикальная черта стоит внутри круглых скобок, то 'или' работает только внутри этих скобок. Для примера давайте найдем строки по следующему шаблону: в начале стоит или 'a', или 'b' один или более раз, а потом две буквы 'x':
            $str = 'axx bxx bbxx exx';
            $res = preg_replace('#(a|b+)xx#', '!', $str); //'! ! ! exx'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="18">Конец или начало слова в регулярках PHP</h3>
    <p>Команда \b обозначает начало или конец слова, а \B, соответственно, - не начало и не конец слова. Что такое слово? На первый взгляд кажется, что это нечто, ограниченное пробелами, но это не совсем так.</p>
    <p>Посмотрите на следующую строку: 'мама мыла раму'. Подстрока 'мыла' - это слово (по обоим краям пробелы), однако и 'мама', и 'раму' тоже слова, которые стоят в начале и в конце строки.</p>
    <p>Давайте посмотрим на практическое применение данной команды.</p>
    <div class="code-style">
        <pre>
            //В следующем примере шаблон поиска такой: начало слова, маленькие латинские буквы один или более раз, конец слова. Таким образом, регулярка найдет все слова и заменит их на '!':
            echo preg_replace('#\b[a-z]+\b#', '!', 'axx bxx xxx exx'); // выведет '! ! ! !'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="19">Ограничители регулярок в PHP</h3>
    <p>В качестве ограничителей могут выступать не только #, но и любые другие символы (только не буквы и не цифры).</p>
    <div class="code-style">
        <pre>
            //К примеру, возьмем в качестве ограничителей символы амперсандов:
            echo preg_replace('&amp;а+&amp;', '!', 'строка');
            
            
            //Если используются скобки, тогда левый ограничитель - это открывающая скобка, а правый - закрывающая:
            echo preg_replace('(а+)', '!', 'строка');
        </pre>
    </div>
    <p><b>Экранировка ограничителей</b></p>
    <p>Если символ не является специальным, то, когда вы используете его в качестве ограничителя, его нужно будет экранировать в самой регулярке. Посмотрим на примере.</p>
    <div class="code-style">
        <pre>
            //Пусть у нас в качестве ограничителей выступают решетки, а внутри регулярки мы ищем символ амперсанда. Так как амперсанд не является спецсимволовм, то мы его не экранируем:
            echo preg_replace('#a&amo;b#', '!', 'a&amp;b'); // выведет '!'
            
            
            
            //Пусть теперь ограничители - амперсанды и внутри регулярки нам также нужен амперсанд. В таком случае амперсанд внутри приходится экранировать, иначе это вызовет ошибку PHP:
            echo preg_replace('&amp;a\&amp;b&amp;', '!', 'a&amp;b'); // выведет '!'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="20">Проблема обратного слеша в PHP</h3>
    <div class="code-style">
        <pre>
            //Обратный слеш является спецсимволом PHP. Это значит, что в строке, если мы хотим, чтобы слеш обозначал сам себя, мы должны его удвоить:
            $str = '\\ \\\\ \\\\\\'; // на самом деле строка '\ \\ \\\'
            
            
            
            //Обратный слеш также является и спецсимволом регулярок. Это значит, что внутри регулярки, чтобы слеш обозначал сам себя, его нужно написать аж четыре раза:
            echo preg_replace('#\\\\#', '!', '\\ \\\\ \\\\\\'); // выведет '! ! !!'
            
            
            
            //Давайте теперь напишем регулярку, в которой шаблон поиска будет такой: обратный слеш один или более раз В таком случае мы напишем оператор + аж для 4 символов перед ним без группировки:
            echo preg_replace('#\\\\+#', '!', '\\ \\\\ \\\\\\'); //выведет '! ! !'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="21">Проверка строки с помощью регулярки на PHP</h3>
    <p>Поиском и заменой возможности регулярок далеко не исчерпаны. Существует также функция preg_match, которая проверяет, есть ли в строке совпадение с регуляркой. Первым параметром функция принимает регулярное выражение, а вторым - строку для поиска.</p>
    <p>При этом, если совпадений будет много, - функция найдет только первое и закончит свою работу. Поэтому функция выводит либо 1, либо 0 и используется для ответа на вопрос 'есть искомое в строке или нет'. Вернет один - значит есть (а сколько раз - неясно), вернет ноль - значит нет.</p>
    <div class="code-style">
        <pre>
            //Давайте посмотрим на примерах. Проверим, есть ли в строке подстрока, состоящая из букв 'a', повторенных один или более раз:
            echo preg_match('#a+#', 'eee aaa bbb'); // выведет 1
            
            
            
            //А теперь в нашей строке нет искомого, и функция выведет 0:
            echo preg_match('#a+#', 'eee bbb'); // выведет 0
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="22">Автоматическое тестирование регулярок в PHP</h3>
    <p>Давайте напишем код, который позволит нам удобно тестировать написанные нами регулярки сразу на нескольких строках.</p>
    <div class="code-style">
        <pre>
            //Пусть наша регулярка для тестов хранится в следующей переменной:
            $reg = '#\d{3,}#';
            
            //Давайте сделаем массив строк для проверок:
            $arr[] = 'aaa 123 bbb';
            $arr[] = 'aaa 12345 bbb';
            $arr[] = 'aaa 12x bbb';
            $arr[] = 'aaa 12 bbb';
            
            //Переберем этот массив циклом, проверяя каждый элемент нашей регуляркой:
            foreach ($arr as $str) {
                echo $str . ' ' . preg_match($reg, $str) . '<br>';
            }
            
            //Соберем весь код вместе и получим удобную заготовку для тестирования регулярок:
            $reg   = '#\d{3,}#'; // ваша регулярка

            $arr[] = 'aaa 123 bbb';   // 1
            $arr[] = 'aaa 12345 bbb'; // 1
            $arr[] = 'aaa 12x bbb';   // 0
            $arr[] = 'aaa 12 bbb';    // 0

            foreach ($arr as $str) {
                echo $str . ' ' . preg_match($reg, $str) . '<br>';
            }
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="23">Проверка всей строки через регулярки в PHP</h3>
    <p>Часто preg_match используется для проверки на соответствие регулярному выражению всей строки. В таком случае в начале регулярки следует поставить шляпку ^, а в конце - доллар $. Этим мы говорим, что под шаблон должна попасть вся строка.</p>
    <div class="code-style">
        <pre>
            //Давайте для примера узнаем, состоит ли строка целиком из букв 'a', или нет:
            echo preg_match('#^a+$#', 'aaaa'); // выведет 1
            echo preg_match('#^a+$#', 'aaab'); // выведет 0
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="24">Карманы при поиске через регулярки на PHP</h3>
    <p>Пусть у нас есть некоторая строка, содержащая домен:</p>
    <div class="code-style">
        <pre>
            $str = 'eee site.ru bbb';
        </pre>
    </div>
    <p>Давайте найдем этот домен и разделим его на части: отделим имя домена от его зоны. Для этого мы используем специальные карманы регулярных выражений.</p>
    <p>Карманы представляют собой элементы массива, в которые можно положить части найденного регуляркой. В нашем случае в первый карман мы можем положить имя домена, а во второй - его зону.</p>
    <p>Давайте сделаем это. Для начала напишем регулярку, которая находит домен в строке:</p>
    <div class="code-style">
        <pre>
            $reg = '#[a-z0-9_-]+\.[a-z]{2,}#';
        </pre>
    </div>
    <p>Давайте теперь в нашей регулярке обозначим, какие части в какой карман должны попадать. Это делается с помощью круглых скобок. Давайте выделим с их помощью часть регулярки, которая ищет имя домена, и ту часть, которая ищет доменную зону:</p>
    <div class="code-style">
        <pre>
            $reg = '#([a-z0-9_-]+)\.([a-z]{2,})#';
        </pre>
    </div>
    <p>Теперь в функции preg_match в качестве третьего параметра укажем переменную (имя любое):</p>
    <div class="code-style">
        <pre>
            preg_match($reg, $str, $res);
        </pre>
    </div>
    <p>В указанную переменную попадет массив с найденными карманами. При этом в нулевом элементе массива будет лежать найденная строка, в первом элементе - первый карман, во втором элементе - второй карман и так далее:</p>
    <div class="code-style">
        <pre>
            preg_match($reg, $str, $res);
            var_dump($res); // выведет ['site.ru', 'site', 'ru']
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="25">Поиск всех совпадений через регулярки на PHP</h3>
    <div class="code-style">
        <pre>
            //С помощью функции preg_match_all можно узнать количество всех совпадений с регулярным выражением:
            $str = 'a aa aaa bbb';
            echo preg_match_all('#a+#', $str); // выведет 3
        </pre>
    </div>
    <p><b>Карманы</b></p>
    <p>С помощью нашей функции можно разделить все найденные совпадения на карманы. Давайте посмотрим, как это делается.</p>
    <div class="code-style">
        <pre>
            //Пусть, например, у нас есть строка с доменами:
            $str = 'site.ru site123.com my-site.net';
            
            
            //Давайте напишем регулярное выражение на поиск домена, отделив имя и зону в отдельные карманы:
            $reg = '#([a-z0-9_-])+\.([a-z]{2,})#';
            
            
            
            //Результат попадет в третий параметр функции:
            preg_match_all($reg, $str, $res);
            var_dump($res);
            
            
            
            //В результате мы получим двухмерный массив. В нулевой элемент этого массива попадет содержимое нулевых карманов (то есть то, что попало под всю регулярку), во второй элемент - содержимое первых карманов и так далее:
            [
                ['site.ru', 'site123.com', 'my-site.net'],
                ['site', 'site123', 'my-site'],
                ['ru', 'com', 'net'],
            ]
        </pre>
    </div>
    <p><b>Изменение поведения preg_match_all</b></p>
    <p>С помощью четвертого параметра функции можно поменять способ группировки карманов. Подробную информацию об этом посмотрите по ссылке http://www.php.su/functions/?preg-match-all.</p>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="26">Несохраняющие скобки в регулярках PHP</h3>
    <p>Скобки () выполняют две функции - группировка символов и функцию кармана. А что делать, если нам нужно сгруппировать, но в карман не класть?</p>
    <p>Для решения такой проблемы придуманы специальные несохраняющие скобки (?: ) - они группируют, но не кладут в карман.</p>
    <p><b>Пример 1</b></p>
    <div class="code-style">
        <pre>
            //В следующем примере первые скобки нам нужны для группировки, а вторые - для кармана. Однако, и те, и другие скобки сохраняют данные в карман:
            $str = 'abab123';
            $reg = '#(ab)+([1-9]+)#';
            preg_match_all($reg, $str, $res);
            
            //В результате в наших карманах будет следующее:
            var_dump($res[0]); // выведет 'abab123'
	        var_dump($res[1]); // выведет 'ab'
            var_dump($res[2]); // выведет '123'
        </pre>
    </div>
    <p><b>Пример 2</b></p>
    <div class="code-style">
        <pre>
            //Сделаем так, чтобы первая пара скобок только группировала, но не клала в карман:
            $str = 'abab123';
            $reg = '#(?:ab)+([1-9]+)#';
            preg_match_all($reg, $str, $res);
            
            //В результате в первом кармане будет наше число:
            var_dump($res[1]); // выведет '123'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="27">Карманы при замене через регулярки на PHP</h3>
    <p>При работе с функцией preg_replace, если мы что-то положим в карман в регулярке, то в строке замены мы можем вставить содержимое этого кармана написав знак доллара $ и номер кармана. Например, $0 - нулевой карман, $1 - первый карман, $2 - второй карман и так далее.</p>
    <p>Зачем это нужно и как этим пользоваться давайте посмотрим на примерах.</p>
    <div class="code-style">
        <pre>
            //Давайте найдем все числа и вместо них вставим эти же числа, но в фигурных скобках. Для этого все найденные числа мы будем заменять на них самих же, но в фигурных скобках:
            $str = '1 23 456 xax';
            $res = preg_replace('#(\d+)#', '{$1}', $str); //'{1} {23} {456} xax'
            
            
            
            //Давайте найдем все строки, представляющие собой числа с иксами вокруг и заменим эти числа на них же, но с '!' знаками вокруг:
            $str = 'x1x x23x x456x xax';
            $res = preg_replace('#x(\d+)x#', '!$1!', $str); //'!1! !23! !456! xax'
            
            
            
            
            //Давайте решим следующую задачу: даны строки вида 'aaa@bbb' - буквы, потом собака, потом буквы. Нужно поменять местами буквы до '@' и после. Реализуем:
            $str = 'aaa@bbb ccc@ddd';
            $res = preg_replace('#([a-z]+)@([a-z]+)#', '$2@$1', $str); //'bbb@aaa ddd@ccc'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="28">Карманы в регулярном выражении в PHP</h3>
    <p>Содержимое карманов доступно не только в строке замены, но в и самой регулярке: мы можем положить что-нибудь в карман, а затем прямо в регулярке сказать, что здесь должно стоять содержимое этого кармана.</p>
    <p>Содержимое карманов доступно по их номерам, перед которыми стоит обратный слеш. Например, нулевой карман будет доступен вот так: \0, первый карман вот так - \1, второй - \2 и так далее.</p>
    <p>Уверен, что все написанное выше пока весьма туманно для вас. Это не удивительно, так какие карманы - самое малопонятное место регулярок. Давайте будем разбираться на примерах.</p>
    <div class="code-style">
        <pre>
            //Давайте найдем в строке все места, в которых стоят две любые одинаковые буквы подряд. Для решения задачи будем искать любую букву, класть ее в карман, а затем проверять, идет ли следующем символом содержимое этого кармана:
            $str = 'aa bb cd ef';
            $res = preg_replace('#([a-z])\1#', '!', $str); //'! ! cd ef'
            
            
            
            //Давайте найдем в строке все слова, в которых одинаковы первая и последняя буквы. Для решения задачи напишем следующий шаблон: буква, затем еще одна или более букв, а затем такая же буква как первая:
            $str = 'asxca buzxb csgd';
            $res = preg_replace('#([a-z])[a-z]+\1#', '!', $str); //'! ! csgd'
        </pre>
    </div>
    <p><b>Альтернативный синтаксис</b></p>
    <div class="code-style">
        <pre>
            //Вместо \1 можно писать \g1:
            $res = preg_replace('#([a-z])[a-z]+\g1#', '!', $str);
            
            
            //Можно также писать \g{1}:
            $res = preg_replace('#([a-z])[a-z]+\g{1}#', '!', $str);
            
            
            //В фигурных скобках можно указывать отрицательные числа. В этом случае карманы будут отсчитываться с конца:
            $res = preg_replace('#([a-z])([a-z])\g{-2}#', '!', $str);
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="29">Именованные карманы в регулярках PHP</h3>
    <p>Пусть с помощью preg_match, мы хотим разбить дату на день, месяц и год. Используем для этого карманы:</p>
    <div class="code-style">
        <pre>
            $str = '2025-10-29';
            $reg = '#(\d{4})-(\d{2})-(\d{2})#';

            preg_match($reg, $str, $match);
            var_dump($match); // выведет ['2025-10-29', '2025', '10', '29']
        </pre>
    </div>
    <p>Как вы видим, в результате мы получаем массив, в котором в нулевом элементе будет вся дата, в первом - год, во втором - месяц, в третьем - день.</p>
    <p>Иногда, однако, было бы удобно получить содержимое карманов в виде ассоциативного массива. То есть в нашем случае было бы неплохо получить вот такой массив:</p>
    <div class="code-style">
        <pre>
            [
                'year'  => '2025',
                'month' => '10',
                'day'   => '29'
            ]
        </pre>
    </div>
    <p>Для этого в регулярках существует специальный синтаксис. Вот он: (?&lt;name>pattern), где pattern - это регулярка, а name - это имя кармана.</p>
    <p>Давайте перепишем нашу регулярку для даты через именованные карманы:</p>
    <div class="code-style">
        <pre>
            $str = '2025-10-29';
            $reg = '#(?&lt;year>\d{4})-(?&lt;month>\d{2})-(?&lt;day>\d{2})#';

            preg_match($reg, $str, $match);
            var_dump($match);
        </pre>
    </div>
    <p>В результате у нас получится ассоциативный массив, в котором ключами будут имена карманов, а значениями - то, что в них попало:</p>
    <div class="code-style">
        <pre>
            [
                'year'  => '2025',
                'month' => '10',
                'day'   => '29',
            ]
        </pre>
    </div>
    <p>На самом деле в массиве с результатом значения карманов будут доступны как по имени, так и по порядковому номеру. То есть, к примеру, год будет доступен по ключу 'year' и по номеру 1, месяц - по ключу 'month' и по номеру 2 и так далее:</p>
    <div class="code-style">
        <pre>
            [
                'year'  => '2025',
                'month' => '10',
                'day'   => '29',

                1       => '2025',
                2       => '10',
                3       => '29'
            ]
        </pre>
    </div>
    <p><b>Альтернативный синтаксис</b></p>
    <p>Можно также использовать синтаксис (?P&lt;name>pattern):</p>
    <div class="code-style">
        <pre>
            $reg = '#(?P&lt;year>\d{4})-(?P&lt;month>\d{2})-(?P&lt;day>\d{2})#';
        </pre>
    </div>
    <p>Доступен также синтаксис (?'name'pattern). Он более короткий, однако, внешние кавычки регулярного выражение придется сделать двойными, чтобы не было конфликта:</p>
    <div class="code-style">
        <pre>
            $reg = "#(?'year'\d{4})-(?'month'\d{2})-(?'day'\d{2})#";
        </pre>
    </div>
    
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="30">Именованные карманы внутри регулярки PHP</h3>
    <p>Всмомним, как мы пользовались карманами в самом регулярном выражении:</p>
    <div class="code-style">
        <pre>
            $res = preg_replace('#([a-z])\1#', '!', $str);
        </pre>
    </div>
    <p>Иногда бывают ситуации, когда удобнее обращаться к карману не по его номеру, а по имени. Для этого нам нужно дать карману имя:</p>
    <div class="code-style">
        <pre>
            $res = preg_replace('#(?&lt;letter>[a-z])#', '!', $str);
        </pre>
    </div>
    <p>Теперь мы можем обратиться к этому карману через синтаксис \g&lt;name>, вот так:</p>
    <div class="code-style">
        <pre>
            $res = preg_replace('#(?&lt;letter>[a-z])\g&lt;letter>#', '!', $str);
        </pre>
    </div>
    <p><b>Альтернативный синтаксис</b></p>
    <p>Описанные именованные карманы имеют еще несколько альтернативных синтаксисов: (?P=name), \g{name}, \g'name', \k&lt;name>, \k'name', \k{name}.</p>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="31">Общий номер карманов в регулярках PHP</h3>
    <p>Рассмотрим следующую ситуацию. Пусть у нас есть переменная с годом, который может изменяться от 1990 до 2099. Пусть мы хотим получать последние две цифры года в карман. Напишем соответствующую регулярку:</p>
    <div class="code-style">
        <pre>
            $reg = '#19(9\d)|20(\d\d)#';
        </pre>
    </div>
    <p>Нас, однако, здесь поджидает одно неудобство. Дело в том, что для годов прошлого века две цифры будут попадать в первый карман, а для годов второго века - во второй. Посмотрим на примерах.</p>
    <p>Вот первый вариант:</p>
    <div class="code-style">
        <pre>
            $str = '1991';
            preg_match($reg, $str, $res);
            var_dump($res); // [1 => '91']
        </pre>
    </div>
    <p>А вот второй вариант:</p>
    <div class="code-style">
        <pre>
            $str = '2021';
            preg_match($reg, $str, $res);
            var_dump($res); // [2 => '21']
        </pre>
    </div>
    <p>Пусть теперь мы хотим записать найденные цифры года в переменную. Нас ждет проблема, ведь мы не знаем точно, с каким ключом забирать данные из кармана:</p>
    <div class="code-style">
        <pre>
            $year = $res[1]; // нужен ключ или 1, или 2
        </pre>
    </div>
    <p>Можно решить проблему через условие:</p>
    <div class="code-style">
        <pre>
            if (!empty($res[1])){
                $year = $res[1];
            } else{
                $year = $res[2];
            }
        </pre>
    </div>
    <p>Однако, есть решение попроще. Можно использовать специальную команду (?| ). Все карманы, которые находятся внутри нее будут иметь один номер. Давайте исправим нашу регулярку</p>
    <div class="code-style">
        <pre>
            $reg = '#(?|19(9\d)|20(\d\d))#';
        </pre>
    </div>
    <p>И теперь наш год точно будет в кармане с номером один:</p>
    <div class="code-style">
        <pre>
            $year = $res[1];
        </pre>
    </div>
    
    
    
    
    
    
    
    <h3 class="header-style2" id="32">Позитивный и негативный просмотр в PHP</h3>
    <p>Иногда нужно решить задачу такого типа: найти строку 'aaa' и заменить ее на '!', но только если после 'aaa' стоит 'x', а сам 'x' при этом не заменять. Если мы попытаемся решить задачу 'в лоб', то у нас ничего не выйдет:</p>
    <div class="code-style">
        <pre>
            preg_replace('#aaax#', '!', 'aaax'); // будет '!', а надо '!x'
        </pre>
    </div>
    <p><b>Просмотр вперед</b></p>
    <p>Для решения задачи нужен способ сказать, что 'x' не следует заменять. Делается это с помощью специальных скобок (?= ), которые просто смотрят, но не забирают с собой.</p>
    <p>Эти скобки называются позитивный просмотр вперед. Позитивный - так как 'x' (в нашем случае) должен быть - только тогда произойдет замена.</p>
    <p>Давайте применим эти скобки для решения нашей задачи:</p>
    <div class="code-style">
        <pre>
            preg_replace('#aaa(?=x)#', '!', 'aaax'); // вернет '!x'
        </pre>
    </div>
    <p>Есть и негативный просмотр вперед - (?! ) - он, наоборот, говорит, что чего-то должно не быть. В следующем примере замена произойдет, только если после 'aaa' не стоит 'x':</p>
    <div class="code-style">
        <pre>
            preg_replace('#aaa(?!x)#', '!', 'aaab'); // вернет '!b'
        </pre>
    </div>
    <p><b>Просмотр назад</b></p>
    <p>Аналогичным образом есть позитивный просмотр назад - (?&lt;= ). В следующем примере замена произойдет, только если перед 'aaa' стоит 'x':</p>
    <div class="code-style">
        <pre>
            preg_replace('#(?&lt;=x)aaa#', '!', 'xaaa'); // вернет 'x!'
        </pre>
    </div>
    <p>И есть также негативный просмотр назад - (?<! ). В следующем примере замена произойдет, только если перед 'aaa' не стоит 'x':</p>
    <div class="code-style">
        <pre>
            preg_replace('#(?&lt;!x)aaa#', '!', 'baaa'); // вернет 'b!'
        </pre>
    </div>
    
    
    
    
    
    
    
    <h3 class="header-style2" id="33">Замена с коллбэком через регулярки в PHP</h3>
    <p>Пусть у нас есть следующая строка:</p>
    <div class="code-style">
        <pre>
            $str = '2+3= 3+5= 7+8=';
        </pre>
    </div>
    <p>Пусть нам нужно найти все конструкции вида число+число= и сделать так, чтобы после равно появился результат сложения.</p>
    <p>Для решения подобной задачи удобно воспользоваться функцией preg_replace_callback, которая работает аналогично функции preg_replace - находит и заменяет по регулярному выражению, но позволяет выполнять дополнительные манипуляции с найденными кусочками.</p>
    <p>Первым параметром функция принимает регулярку, вторым - на что меняем, третьим - строку, в которой осуществляется замена.</p>
    <p>При этом во второй параметр следует передавать функцию-коллбэк, которая будет вызвана для каждого найденного совпадения.</p>
    <p>Первым параметром коллбэка нужно указать переменную, в которую будет попадать найденное. Эта переменная будет представлять собой массив карманов найденного.</p>
    <p>Давайте попробуем на практике. Напишем, код, который поймает наши подстроки, при этом положив первое число в первый карман, а второе - во второй:</p>
    <div class="code-style">
        <pre>
            $str = '2+3= 3+5= 7+8=';
	
            preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
                var_dump($match);
            }, $str);
        </pre>
    </div>
    <p>В результате наш var_dump сработает три раза, по очереди выведя следующее:</p>
    <div class="code-style">
        <pre>
            ['2+3=', '2', '3']
            ['3+5=', '3', '5']
            ['7+8=', '7', '7']
        </pre>
    </div>
    <p>Идем дальше. Каждое совпадение будет заменено на то, что возвращает коллбэк через return. Давайте для примера заменим каждую из искомых подстрок на знак '!':</p>
    <div class="code-style">
        <pre>
            $str = '2+3= 3+5= 7+8=';
	
            $res = preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
                return '!';
            }, $str);

            echo $res; // выведет '! ! !'
        </pre>
    </div>
    <p>А теперь заменим каждую подстроку на сумму пары чисел в ней:</p>
    <div class="code-style">
        <pre>
            $str = '2+3= 3+5= 7+8=';
	
            $res = preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
                return $match[1] + $match[2];
            }, $str);

            echo $res; // выведет '5 8 13'
        </pre>
    </div>
    <p>Получается, что наша задача почти решена. Осталось сделать так, чтобы перед суммой чисел оставалась искомая подстрока. Для этого будем вставлять перед суммой содержимое нулевого кармана:</p>
    <div class="code-style">
        <pre>
            $str = '2+3= 3+5= 7+8=';
	
            $res = preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
                return $match[0] . ($match[1] + $match[2]);
            }, $str);

            echo $res; // выведет '2+3=5 3+5=8 7+8=13'
        </pre>
    </div>
    
    
    
    
    
    
    
    
    <h3 class="header-style2" id="34">Модификаторы регулярок в PHP</h3>
    <p>Как вы уже знаете, модификаторы представляют собой команды, которые пишутся после правого ограничителя регулярки. Давайте посмотрим, что полезного можно сделать с их помощью.</p>
    <p><b>Игнорирование регистра</b></p>
    <p>По умолчанию в регулярках регистр символов имеет значение. В следующем примере мы найдем только буквы в нижнем регистре:</p>
    <div class="code-style">
        <pre>
            preg_replace('#[a-z]+#', '!', 'aaa bbb AAA'); // вернет '! ! AAA'
        </pre>
    </div>
    <p>Мы можем изменить такое поведение регулярки, использовав модификатор i. Исправим нашу регулярку в соответствии с этим:</p>
    <div class="code-style">
        <pre>
            preg_replace('#[a-z]+#i', '!', 'aaa bbb AAA'); // вернет '! ! !'
        </pre>
    </div>
    <p><b>Комментарии в регулярке</b></p>
    <p>Модификатор x разрешает расставлять в регулярке произвольные пробелы и переводы строк. Кроме того, символ решетки становится символом однострочного комментария (соотвественно, ограничители придется заменить на другие).</p>
    <p>Давайте посмотрим на примере. Пусть у нас есть вот такая регулярка:</p>
    <div class="code-style">
        <pre>
            preg_replace('#[a-z]+@[0-9]+#', '!', 'aaa@333');
        </pre>
    </div>
    <p>Давайте используем модификатор x и расставим в для каждой части нашей регулярки поясняющие комментарии:</p>
    <div class="code-style">
        <pre>
            preg_replace('~
                [a-z]+ # буквы 
                @      # символ собаки
                [0-9]+ # цифры
            ~x', '!', 'aaa@333');
        </pre>
    </div>
    <p><b>Работа с юникодом</b></p>
    <p>Модификатор u, с которым вы уже сталкивались ранее, заставляет регулярку корректно работать с юникодом. В частности, корректно обрабатывать кириллические строки:</p>
    <div class="code-style">
        <pre>
            preg_replace('#[а-яё]#u', '!', 'яяя ййй ёёё');
        </pre>
    </div>
    <p><b>Изменение жадности</b></p>
    <p>Модификатор U делает так, что все операторы повторений станут по умолчанию нежадными, а добавление ?, наоборот, будет добавлять им жадности:</p>
    <div class="code-style">
        <pre>
            preg_replace('#x.+x#U', '!', 'xax xaax xaaax'); // вернет '! ! !'
        </pre>
    </div>
    <p><b>Экранировка обычных символов</b></p>
    <p>Модификатор X делает так, что экранировка обычного символа приведет к ошибке. Без этого оператора обычные символы можно экранировать, они все равно будут обозначать сами себя (исключение: цифры, они станут карманами). Посмотрим на примере:</p>
    <div class="code-style">
        <pre>
            preg_replace('#x\@x#X', '!', 'x@x'); // ошибка, @ не спецсимвол
        </pre>
    </div>
    <p><b>Несколько модификаторов</b></p>
    <p>После ограничителя можно писать несколько модификаторов. Пример:</p>
    <div class="code-style">
        <pre>
            preg_replace('#[a-z]+#iU', '!', 'aaa bbb');
        </pre>
    </div>
    
</div>




















































