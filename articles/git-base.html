<div class="wrap">

    <h2 class="header-style">Git</h2>


    <ul class="list">
        <li> <a href="#1">Основы работы с Git, состояние файлов</a></li>
        <li> <a href="#2">Git. Операции отмены</a></li>
        <li> <a href="#3">Игнорирование файлов</a></li>
        <li> <a href="#4">Ветвления в Git</a></li>
        <li> <a href="#5">Удалённые репозитории Git</a></li>
    </ul>






    <h3 class="header-style2" id="1">Основы работы с Git, состояние файлов</h3>
    <p>Прежде чем начать нужно скачать сам Git по адресу <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>. Либо установить через терминал командой <span class="vue-g">$ sudo apt install git</span></p>
    <p>Как установили Git запустим его. В windows это запуск терминала Git bash в меню пуск Git->Git bash. В Ubuntu это просто заходим в терминал. Первое что нужно сделать после установки это проверить работоспособность программы. Здесь же в консоли посмотрим версию программы:</p>
    <p><span class="vue-g">$ git --version</span></p>
    <p>Следующий важный шаг - указать имя и адрес электронной почты пользователя. Код который мы будем писать и который будет находится под системой контроля версий, будет содержать данные его автора, то есть те данные которые мы укажем. Это является обязательным, так как с одним кодом могут работать разные люди и всегда важно знать, кто над чем работал. Укажем имя при помощи специальной команды:</p>
    <p><span class="vue-g">$ git config --global user.name "Aleksandr Telegin"</span></p>
    <p>Опция <b>--global</b> означает что данные настройки будут использоваться во всех проектах, то есть глобально. Имя можно проверить командой:</p>
    <p><span class="vue-g">$ git config --list</span></p>
    <p>Также нужно заполнить адрес электронной почты:</p>
    <p><span class="vue-g">$ git config --global user.email sastelegin@mail.ru</span></p>
    <p>Если допущена ошибка в адресе почты, например так  -  <b>git config --global user.email sdgsdgsd</b>, то испарвить можно такой командой:</p>
    <p><span class="vue-g">$ git config --unset-all --global user.email </span> - эта команда удалит адрес почты и дальше можно командой задать нормальный адрес. С именем тоже самое.</p>
    <p>С чего же начать знакомство с Гит, всё очень просто - создаём и переходим в пустую папку в любом удобном месте. Создам папку gitproject, переходим в неё и инициализируем в ней Git командой:</p>
    <p><span class="vue-g">$ git init</span></p>
    <p>После которой консоль нам напишет что был создан репозиторий вот в этой папке <b>gitproject/.git/</b>   Эту папку теперь быдем называть рабочим каталогом, а репозиторий это хранилище, где хранятся некоторые данные.  Если мы говорим о git, то в этой папке   .git он будет хранить всю необходимую информацию о версиях нашего проекта и некоторые служебные вещи. Сама папка <b>.git</b> скрыта, её можно в настройках открыть. Как правило мы никогда не будем работать с этой папкой напрямую, но должны знать о её существовании.</p>

    <h3>Рабочий процесс</h3>
    <p>Теперь разберёмся с рабочим процессом. Представим ситуацию, мы работаем над страницей поиска на сайте, пусть её представляет примитивный файл <b>search.php</b>. В определённый момент мы уже добились первой рабочей версии - форма для ввода, кнопка поиск и список результатов. Теперь мы хотим сохранить наши успехи, мы делаем специальную операцию - <b>commit</b>, то есть фиксируем тукущее состояние проекта, при этом git сохраняет это состояние в своём локальном хранилище, в папку <b>.git</b>. Мы продолжили работать, но случайно удалили файл <b>search.php</b>, не беда, так как мы сделали commit, то мы можем вернуться к предыдущему состоянию этого файла. Мы продолжили работать и добавили на сайт постраничную навигацию в этот же файл search.php. Теперь просматривать результаты стало удобней, самое время зафиксировать это состояние, делаем очередной <b>commit</b>. В следующий подход мы добавили функцию подсказок к поиску, теперь сайт стал ещё умнее, делаем ещё один <b>commit</b>. На текущий момент мы имеем 3 состояния файла поиска. Представим что самую последнюю версию заказчик испробовал и получил отрицательные отзывы посетителей сайта, поэтому решил вернуться ко второй версии и поставил нам такую задачу. Git нас спасает, нам не нужно искать и удалять куски кода из 3 версии для того чтобы получить состояние 2 версии, мы просто переключаемся на второй <b>commit</b>, получаем файлы и заливаем их на рабочий сервер. На этом простом примере мы видем, что git служит хорошим помошником в работе.</p>
    <p>Давайте промоделируем работу git при разработке поиска. Сейчас мы находимся в консоле в папке gitproject  и создадим первую версию файла - простой поиск:</p>
    <p>
        <code>
            <span class="vue-g">$ notepad search.php</span> - команда в windows<br>
            <span class="vue-g">$ sudo nano search.php</span> - команда в Ubuntu<br>
        </code>
    </p>
    <p>Откроется блокнот и предложит создать такой файл. В файле пишем какой нибудь код, ну например echo "First vеrsion";. Представим что это и есть вся реализация файла поиска. Неплохо бы и сохранить первую версию в репозитории. Каждый файл в рабочем каталоге может находится в одном из 2-х состояний: 1. подверсионным контролем, то есть отслеживаемый(tracked) 2. либо нет, то есть не отслеживаемый(untracked). Для того чтобы узнать в какой состоянии находятся файлы, можно выполнить команду:</p>
    <p><span class="vue-g">$ git status</span></p>
    <p>Сейчас нас интересует блок <b>Untracked files</b> , слово <b>track</b> в данном контексте означает отслеживание и следовательно untracked files  это не отслеживаемые файлы. Так как файл search.php мы только создали, он является не отслеживаемым. В таком состоянии он может просто болтаться в папке и git не будет с ним работать, но нам нужно сделать как раз наоборот. Для того чтобы пользоваться всеми прелестями git, файл должен находится под версионным контролем, git даёт подсказку как это сделать   -  строка из консоли  -  <b>(use "git add file..." to include in what will be committed)</b>   - давайте выполним такую команду:</p>
    <p><span class="vue-g">$ git add search.php</span></p>
    <p>И сновы выполним команду git status. Видим кое-что изменилось. Для того чтобы понять, что произошло, нужно хорошо разобраться в состояниях файлов.</p>

    <h3>Состояние файлов</h3>
    <ul class="list">
        <li>Отслеживаемые(tracked)
            <ul class="list">
                <li>stage</li>
                <li>modified</li>
                <li>unmodified</li>
            </ul>
        </li>
        <li>Не отслеживаемые(untacked)</li>
    </ul>
    <p>Как упоминалось выше, файл может быть не отслеживаемый(untracked) и отслеживаемый. В свою очередь отслеживаемые файлы также могут иметь разные состояния. Файл, который мы только что создали и добавили под версионый контроль при помощи <b>git add</b> находится в staged области. Это состояние означает что файл подготовленный и будет добавлен в следующий коммит, когда мы вызовем определённую команду.</p>
    <p>Теперь мы хотим сохранить текущую версию проекта, для этого нужно выполнить команду:</p>
    <p>
        <span class="vue-g">$ git commit</span> - при этой команде откроется редактор, в котором нужно написать комментарий к этому комиту.<br>
        <span class="vue-g">$ git commit -m "First version"</span> - при такой команде с помощью опции <b>-m</b> мы сразу можем добавить коментарий.
    </p>
    <p>Эта команда - <b>git commit</b> откроет текстовый редактор, в нём будет результат работы команды <b>git status</b> и ещё некоторые детали. Назначение этого шага придумать краткое описание той работы которая была выполнена. Давайте запишем сюда текст, а коментарии удалим, удалим всё до строки 9 и на месте удалённых напишем - First version. После окончания сохраним файл и закроем редактор, при этом сразу после закрытия редактора в консоле напишутся такие строки:</p>
    <p>
        <code>
            [master (root-commit) a8dbbfa] First version<br>
            1 file changed, 2 insertions(+)<br>
            create mode 100644 search.php
        </code>
    </p>
    <p>Итак что же мы только что сделали? Мы выполнили сохранение состояния проекта в репозитории, также это называется commit по анг. или фиксация по-русски. Давайте посмотрим список файлов ls. Видим что файл search.php на месте. Также можем выполнить команду git status, будет написанно что рабочее дерево пустое и комитить нечего.
    Теперь не плохо бы убедится что комит произошёл успешно, для этого можно посмотреть истроию комитов, это делается при помощи команды:</p>
    <p>
        <span class="vue-g">$ git log</span><br>
        Author: sasha sastelegin@mail.ru<br>
        Date: Mon Nov 11 10:35:58 2019 +0300<br><br>

        <span class="ind">First version</span>
    </p>
    <p>Здесь мы видим один комит, также некоторые детали о его авторе, это те настройка, которые мы заполняли во время конфигурации и также дату комита и наш коментарий, который мы писали в редакторе. Ещё один важный атрибут в этом списке это контрольная сумма комита, то есть хеш. Git подсчитывает хеш для каждого комита, а точнее для набора файлов, которые входят в этот комит. Таким образо Гит получает уникальный идентификатор для каждого комита. Механиз при котором Гит пользуется для вычисления хеш сумм называется sha-1. Мы часто будем встречать хеши, так Гит сохраняет в свою базу не по имени а по хеш сумме содержимого. </p>
    <p>Настало время разработать вторую версию поиска. Отредактируем файл:</p>
    <p>
        <span class="vue-g">notepad search.php</span> или <span class="vue-g">$ sudo nano search.php</span>
    </p>
    <p>Напишем там примерно, echo "Second version";, будем считать что работа сделана, сохраним файл и выполним <b>git status</b>. И здесь мы опять увидем кое-что новое  -  Changes not staged for commit: - изменения не добавленные в staged область, то есть не подготовленные к комиту. Это ещё одно состояние в котором может находится файл, состояние <b>modified</b> означает что файл уже находится под системой контроля версий и в нём произошли некоторые изменения со времён последнего комита.</p>
    <p>Давайте предположим что мы также решили добавить в проект файл инструкцию, простой файл с названием README.md:</p>
    <p>
        <span class="vue-g">$ sudo nano README.md</span>
    </p>
    <p>Откроется блокнот, запишем в этом файле что нибудь, сохраним и посмотрим статус снова - <b>git status</b>. Как видим новый файл попал в область не отслеживаемых файлов, изменённый файл search.php попал в область отслеживаемых файлов, но он находится в состоянии модификации - modified. Сейчас мы не можем выполнить команду git commit, для начала надо добавить оба эти файла в staged область, то есть подготовить их в комиту. Сделать это можно командой:</p>
    <p>
        <code>
            <span class="vue-g">$ git add README.md</span><br>
            <span class="vue-g">$ git add search.php</span>
        </code>
    </p>
    <p>И опять проверяем статус: <b>git status</b>. Теперь мы видим что оба файла находятся в satged состоянии и готовы к комиту.
    Выполним комит упрощённым образом:</p>
    <p>
        <span class="vue-g">git commit -m "Second search version and created new file README.md"</span>   - в кавычках нужно написать какой то текст, который будет характеризовать выполненую работу
    </p>
    <p>Видим сообщение, комит выполнен успешно. Теперь просмотрим историю комитов: <b>git log</b></p>
    <p>И уже видим 2 комита с хеш суммой:</p>
    <p>
        <span class="vue-g">$ git log</span><br>
        commit 23ssdswdk32jkercxv43sdf489dfa9s8d912389<br>
        Author: sasha sastelegin@mail.ru<br>
        Date: Mon Nov 11 13:24:08 2019 +0300<br><br>

        <span class="ind">Second search version and created new file README.md</span><br><br>

        commit 12assdfdk32jker923489dfa9s8d912389sf8s9<br>
        Author: sasha sastelegin@mail.ru<br>
        Date: Mon Nov 11 10:35:58 2019 +0300<br><br>

        <span class="ind">First version</span>
    </p>
    <p>Файлы, которые мы только что добавили в комит находятся под системой контроля версий, то есть являются отслеживаемыми. Кроме того в них не происходило изменений со времён последнего комита, а значит они имеют состояние <b>unmodified</b>. Это 3е возможное состояние отслеживаемых файлов.</p>
    <p>Проделаем 3й этап работы. Напишем в файле search.php - echo "Third version"   и специально допустим ошибку, забыв поставить точку с запятой и сохраним. Также представим что файл README решили перенести из проекта в какую то другую систему и поэтому его нужно удалить:</p>
    <p>
        <span class="vue-g">$ sudo rm README.md</span>
    </p>
    <p>Посмотрим состояние файлов: <b>git status</b>. Теперь на нужно сделать комит, но предварительно нужно добавить все файлы в staged область. Не обязательно перечислять каждый из файлов, мы можем указать вот такую команду:</p>
    <p>
        <span class="vue-g">$ sudo git add .</span> - точка означает что добавим все файлы сразу
    </p>
    <p>Всё подготовленно к комиту:</p>
    <p>
        <span class="vue-g">$ git commit -m "Third search version and delete file README.md"</span>
    </p>
    <p>Комит выполнен, посмотрим список комитов: <b>git log</b></p>
    <p>
        <span class="vue-g">$ git log</span><br>
        commit 922ssdswdk32sdr54cxv43sdf489dfa9s8d9123<br>
        Author: sasha sastelegin@mail.ru<br>
        Date: Mon Nov 11 13:36:08 2019 +0300<br><br>

        <span class="ind">Third search version and delete file README.md</span><br><br>

        commit 23ssdswdk32jkercxv43sdf489dfa9s8d912389<br>
        Author: sasha sastelegin@mail.ru<br>
        Date: Mon Nov 11 13:24:08 2019 +0300<br><br>

        <span class="ind">Second search version and created new file README.md</span><br><br>

        commit 12assdfdk32jker923489dfa9s8d912389sf8s9<br>
        Author: sasha sastelegin@mail.ru<br>
        Date: Mon Nov 11 10:35:58 2019 +0300<br><br>

        <span class="ind">First version</span>
    </p>
    <p>Команда git add может вызываться и с другими командами изменяющими её поведение.</p>









    <h3 class="header-style2" id="2">Git. Операции отмены</h3>
    <h4>Эта статья логическое продолжение предыдущей статьи</h4>
    <p>Очень часто возникают ситуации, когда нужно что отменить или изменить, в таком случае пригодятся операции отмены. Для начала рассморим ещё один полезный способ использования команды <b>git commit</b>. Предположим что мы забыли добавить какие то изменения в предыдущий комит и хотим это сделать. Конечно мы можем создать ещё один комит, но не хотим этого делать, так как изменения связаны логически с предыдущим комитом. Давайте внесём изменения в нужный файл и добавим их в staged область. Открываем наш файл search.php - <span class="vue-g">$ sudo nano search.php</span>. В файле исправляем допущенную нами ранее ошибку, где мы не добавили ";" сохраняем и добавляем файл в staged область - <span class="vue-g">$ sudo git add search.php</span>. Можем периодически проверять состояние файла командой проверки статуса. Видим что файл готов к комиту и чтобы закомитить в <b>предыдущий комит</b>, выполним такую команду:</p>
    <p>
        <code>
            <span class="vue-g">$ git commit --amend -m "Third version Modified"</span><br>
            <span class="vue-g">$ git log</span><br>
            commit 2kjhkjsd872h3j2hs87d89782714hjhsi8d78932<br>
            Author: sasha sastelegin@mail.ru<br>
            Date: Mon Nov 11 13:36:16 2019 +0300<br><br>
        
            <span class="ind">Third search version Modified</span><br><br>
        
            commit skjdfh832372h3j2hs87d89782714hjhsisdasdq<br>
            Author: sasha sastelegin@mail.ru<br>
            Date: Mon Nov 11 13:24:16 2019 +0300<br><br>
        
            <span class="ind">Second search version and created new file README.md</span><br><br>
        
            commit 23wjsd872h3j2hs87d89782714hjhsi8sdfqqqqg<br>
            Author: sasha sastelegin@mail.ru<br>
            Date: Mon Nov 11 10:35:16 2019 +0300<br><br>
        
            <span class="ind">First version</span><br><br>
        </code>
    </p>
    <p>Видим что комитов осталсь всё также 3. Когда мы выполняли предыдущий комит, мы добавили параметр <b>--amend</b>, переводится как вносить поправки. При этом последний комит был отредактирован и был изменён коментарий. Достаточно часто бывает ситуация, когда надо исправить только коментарий, например мы просто забыли его написать, но тут же вспомнили что это нужно сделать, тогда можно не вносить никакие изменения в файлы, а просто вызвать команду - <b>git commit --amend -m "Third version Modified"</b> добавив просто коментарий.</p>
    <hr>
    <p>Изучим ещё одну операцию отмены, а именно отмену <b>staged</b>(состояния) подготовки файла. Давайте кое что сделаем с нашим проектом. Сейчас он находится в чистом состоянии, то есть ничего не добавлялось, ничего не изменялось. Предположим что во время дальнейщей работы мы изменили один существующий файл и добавил ещё один новый. Открывем существующий файл что то там меняем сохраняем и создаём новый файл например new.txt. После этого добавляем файлы в staged область - <b>git add .</b></p>
    <p>Можем проверить git status. И вдруг мы вспоминаем что не хотели включать эти 2 файла в один комит, мы хотели например в один комит добавить изменённый файл, а в другой новый файл. Ситуация конечно редкая, но она показывает как отменить stage состояние подготовки к комиту. Мы можем удалить файл new.txt из stage области, сделать комит изменённого файла search.php  и потом добавить новый файл в stage область и сделать ему комит также. Удаляем файл из stage области с помощью команды:</p>
    <p>
        <span class="vue-g">$ git reset HEAD new.txt</span>
    </p>
    <p>И проверив статус увидим, что файл изменёный находится в stage области, а файл new.txt не отслеживается и горит красным. Теперь можно завершить часть работы и сделать комит изменённого файла:</p>
    <p>
        <span class="vue-g">$ git commit -m "Edit search"</span>
    </p>
    <p>Вызовем <b>git log</b>  и увидем что появился 4-й комит. Далее добавляем оставшийся не отслеживаемый новый файл new.txt в <b>stage</b> область и комитим его. Откроем историю <b>git log</b> и увидем 5-й комит.</p>
    <hr>
    <p>Ещё одна операция отмены, отмена изменений. Предположим что мы внесли изменения в один из файлов. После того как мы это сделали, мы поняли что работа выполнена не так как надо, при этом ещё и удалили нужные данные в файле, теперь нужно отменить эти изменения, команда git status нам подскажет, там будет такая строчка <b>(use "git checkout -- file..." to discard in working directory)</b> - тут написано как отменить изменения в каком то файле. Давайте выполним такую команду:</p>
    <p>
        <span class="vue-g">$ git checkout -- new.txt</span>
    </p>
    <p>Всё изменения откатитлись назад. Также важно понимать что команда <b>git checkout</b> это опасная команда, при её использовании любые изменения файла пропадают. Использовать её надо тогда когда на 100% уверены что изменения файла не нужно комитить. Также помним что всё что зафиксированно комитом можно востановить.</p>










    <h3 class="header-style2" id="3">Игнорирование файлов</h3>
    <p>Существуют ситуации когда мы не хотим добавлять файлы в репозиторий, в таком случае они будут присутствовать в секции не отслеживаемых файлов, так будет каждый раз когда мы будем использовать команду git status, это тоже может быть не желательным особенно если файлов большое количество. Когда возникают такие ситуации, например, когда в проекте есть папка, в которой мы сохраняем аватарки пользователей или видеофайлы пользователей. Файлы пользователей обычно не должны попадать в репозиторий, так как репозиторий касается всего проекта, а не файлов пользователей. Также может возникнуть потребность инорировать автоматически генерируемые системные файлы, например, файл с историей ошибок или кешированные данные. Гит предоставляет удобный способ игнорировать файлы путём создания файла <b>.gitignore</b>. В нём будут перечисляться все файлы и папки, которые должны быть проигнорированы.</p>
    <p>Давайте добавим в наш проект несколько файлов которые должны быть заигнорированы. К примеру это будут файлы, в которые наша системы пишет ошибки и другие вещи:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo nano access.log</span><br>
            <span class="vue-g">$ sudo nano error.log</span><br>
            # для windows<br>
            <span class="vue-g">notepad access.log</span><br>
            <span class="vue-g">notepad error.log</span><br>
        </code>
    </p>
    <p>Также можно создать какую нибудь папку:</p>
    <p>
        <span class="vue-g">$ mkdir uploads</span>
        <span class="vue-g">$ cd uploads</span>
    </p>
    <p>Предположим  что в этой папке будут хранится файлы пользователей:</p>
    <p>
        <span class="vue-g">uploads$ sudo nano 1.txt</span>
        <span class="vue-g">uploads$ sudo nano 2.txt</span>
        <span class="vue-g">uploads$ cd ..</span>
        <span class="vue-g">$ git status</span>
    </p>
    <p>При проверки статуса мы увидем все новые добавленные файлы и папки, они находятся в состоянии не отслеживаемые. Предположим что мы не хотим их здесь видеть, но они должны присутствовать в проекте. Чтобы заигнорировать их создадим файл <b>.gitignore</b>:</p>
    <p>
        <span class="vue-g">$ sudo nano .gitignore</span>
    </p>
    <p>И перечислим в нём файлы, которые мы хотим игнорировать, вот так в столбик:</p>
    <p>
        <code>
            access.log<br>
            error.log<br>
            uploads/
        </code>
    </p>
    <p>Сохраняем, выполним проветку статуса снова и увидем только файл <b>.gitignore</b>, он должен быть включён в репозиторий, то есть следующий комит, который мы выполним, он будет произведён над файлом <b>.gitignore</b></p>
    <p>Файл <b>.gitignore</b> имеет больший функционал чем мы показали, например в нём можно использовать регулярные выражения:
    <b>*.php</b>   - все файлы, котрые заканчиваются на .php, ну и другие хитрые штуки.</p>








    <h3 class="header-style2" id="4">Ветвления в Git</h3>
    <h4>Эта статья продолжение предыдущих статей</h4>
    <p>Что такое ветки и зачем они нужны. Приведём типичный пример, представим что есть сайт компании, над которым мы работаем. В данный момент нас попросили реализовать покупку и оплату товаров. Мы скопировали актуальное состояние проекта с удалённого сервера на свою локальную машину. Работа на нашей лок. машине уже находится примерно на 60% готовности, но менеджер срочно просит внести критически важные поправки на сайт. Ирония судьбы состоит в том что при этом должны быть затронуты файлы, с которыми мы уже работаем и успели в них кое что изменить. Конечно проще всего было бы внести правки в своё состояние проекта и загрузить его на сервер, но этого делать нельзя, так как работа над оплатой товара готова только на 60%. Теперь нам ничего не остаётся как прервать работу над оплатой и снова полностью скопировать актуальную версию проекта с удалённого сервера, внести поправки от менеджера и загрузить их на удалённый сервер. Казалось бы ничего тяжёлого в этом нет, но когда мы всё таки закончим работу над оплатой, просто загрузить эту версию на удалённый сервер не получится, так как на удалённом сервере уже есть файлы, в которых содержатся изменения, котрых не было в том момент, когда начали работу над оплатой. Теперь придётся вручную сравнивать каждый из затронутых файлов, чтобы объединить эти 2 версии и надеяться что мы ничего не потеряем. Проблема может быть ещё серьёзней, если мы не идинственные кто работает над данным сайтом, то без использования системы контроля версий мы можем и не узнать что на рабочем сервере появились изменения. И даже если мы и будем знать что они появились, то объединять результаты вручную будет намного сложнее, так как код чужой. <b>Этот пример показан, чтобы объяснить главное назначение веток. Их стоит использовать в работе, когда происходит множество одновременных процессов</b>. Ещё больше они полезны когда над проектом трудится целая команда.</p>
    <p><b>Ещё одно главное правило веток - одна ветка одна задача</b>. Это может быть ветка, которая представляет актуальную версию файлов на рабочем сервере, на сервере для тестирования, или ветки созданные под конкретную задачу. Также следует помнить, что <b>в один момент времени активна всего одна ветка</b>. Все изменения которые мы делаем затрагивают только одну ветку. Все остальные ветки остаются без изменений. Это даёт возможность работать над полностью разными задачами параллельно и по необходимости переключаться между ветками.</p>
    <p>Так и для нашего примера. Мы говорим что есть одна основная ветка - это полностью сайт на удалённом сервере, далее мы создаём ещё одну ветку для решения задачи по модулю оплаты и работаем в ней. Когда приходит задача по срочным правкам, мы создаём ещё одну ветку и делаем изменения в ней. После окончания работы сливаем ветку со срочными изменениями с основной веткой, на рабочем сервере так появляется актуальное состояние. Позже мы переключаемся на ветку оплаты, заканчиваем работы и сливаем её с основной веткой. Во время последнего слияния нам не нужно заботиться о том что какие то данные будут перезатёрты. Git как правило автоматически выполняет слияние с учётом всех изменений. Если же он не может сделать этого автоматически, то вам будет предложено вручную определить, как именно сливать результаты. Здесь конечно придёться немного подумать, однако никакие изменения не будут потеряны и нам не нужно помнить и отслеживать каджый файл вручную</p>
    <p>Большое преимущество гит состоит в том, что ветки в этой системе контроля версий очень лёгкие и быстрые. Создание новой ветки или переключение на другую ветку выполняются очень быстро. Мы должны использовать ветки постоянно, когда решаем поставленную задачу, вносим изменения, испытываем улучшения и т.д.</p>
    <p>Как же начать работать с ветками? На самом деле в предыдущем примере мы уже работали в ветке. Давайте посомтрим, какая ветка активна на данный момент. Вводим команду <b>git status</b> и ниже в выводе видим такую строку - <b>On branch master</b> и ниже остальной вывод. Команда статуса показывает нам, что мы находимся в ветке <b>master</b>. Ветка <b>master</b> была создана автоматически, когда мы создавали проект при помощи команды <b>git init</b>. Ьы должны понимать что слово <b>master</b> это просто название ветки и никакого особого статуса эта ветка не имеет. Её можно переименновать или удалить при необходимости, но исторически так сложилось, что эту ветку предпочитают оставлять в проекте.</p>
    <p>Использование веток в гит обязательно. Мы всегда работаем в какой то определённой ветке. Её также называют HEAD веткой. Нужно запомнить что HEAD является синонимом слов - текущая, активная ветка. Рассмотрим пример близкий к реальности.</p>
    <p>Например скачаем с сайта <a href="https://startbootstrap.com/templates/blog-post/">StartBootstrap</a> html шаблон - блог записей. Распакуем его в любую папку с новым проектом. Затем прейдём в эту папку и создадим в ней Git репозиторий:</p>
    <p>
        <code>
            <span class="vue-g">$ cd /var/www</span><br>
            <span class="vue-g">$ sudo mkdir gitproject</span><br>
            <span class="vue-g">$ cd gitproject</span><br>
            <span class="vue-g">$ sudo git init</span><br>
            <span class="vue-g">$ git status</span><br>
        </code>
    </p>
    <p>Посмотрев статус мы увидим все те файлы из шаблона, они будут гореть красным, что значит что они не отслеживаются. Добавляем их в stage область и комитим:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git add .</span>
            <span class="vue-g">$ sudo git commit -m "First version"</span>
        </code>
    </p>
    <p>Выполним команду статус и увидим что мы сейчас находимся в ветке <b>master</b></p>
    <p>
        <code>
            On branch master<br>
            Nothing to commit, worcking directory clean
        </code>
    </p>
    <p>Предположим, что это уже актуальная версия нашего сайта блог-записей. Нам дали задачу прикрутить оплату на эту страницу. Оплата состоит в том, чтобы направить пользователя, по нажатию на кнопку-ссылку, на другую страницу, которая будет производить оплату. Давайте реализуем эту задачу. Так как мы договорились, что для каждой задачи мы создаём ветку, то так и поступим. Создадим ветку для работы над оплатой:</p>
    <p>
        <span class="vue-g">$ sudo git branch feature-payment</span>
    </p>
    <p>Давайте теперь посмотрим список веток:</p>
    <p>
        <span class="vue-g">$ git branch</span>
        feature-payment<br>
        <span class="green">* master</span>
    </p>
    <p>Видим уже 2 ветки - feature-payment и * master. * означает какая ветка сейчас выбрана и является HEAD. Давайте выведем расширенную информацию о ветках при помощи команды:</p>
    <p>
        <code>
            <span class="vue-g">$ git branch -v</span>
            feature-payment f733f69 First version<br>
            <span class="green">* master</span> f733f69 First version
        </code>
    </p>
    <p>В выводе мы увидим идентификатор последнего комита - f733f69, это тот же хеш нашего комита, только сокрашен до 7 символов. Как мы можем видеть - обе ветки находятся в одинаковом состоянии, т.е. указывают на одинаковый комит.</p>
    <p>Теперь нам нужно <b>переключится</b> на вновь созданную ветку, делается это командой:</p>
    <p>
        <span class="vue-g">$ git checkout feature-payment</span><br>
        Switched to branch 'feature-payment'
    </p>
    <p>Переключились на новую ветку, теперь приступим к реализации нашей задачи по оплате.</p>
    <p>Откроем файл index.html. У Виктора был сайт портфолио и у него в шаблоне были уже 2 кнопки. У меня в блоге кнопок нет, придётся самому её сделать. Сделал я их просто, по уже готовым стилям bootstrap я сделал ещё один див рядом с другими дивами и сделал в нём 2 ссылки, которые будет играть роль кнопок. Только кнопки надо запилить до инициализации гит в проекте, чтобы кнопки уже были при комите в ветку master. Одна кнопка-ссылка с названием - Cleack Me, другая - Look at Me</p>
    <p>Итак вместо # в ссылке пишем "/payment.php". Создадим также в нашей ветке feature-payment файл payment.php, ни в какие папки его не перемещаем, а прям в проекте и создадим</p>
    <p>
        <code>
            <span class="vue-g">project$ sudo touch payment.php</span><br>
            <span class="vue-g">project$ ls</span><br>
            css/<br>
            vendor/<br>
            gulpfile.js<br>
            index.html<br>
            LICENSE<br>
            package.json<br>
            package-lock.json<br>
            README.md<br>
            payment.php
        </code>
    </p>
    <p>В файле payment.php надо реализовать оплату, но мы это делать не будем, у нас задача посмотреть как работают ветки. Напишем что нибудь в payment.php, например комметарий //payment started, а ниже добавим версию //v1.0. Далее нужно сделать комит:</p>
    <p>
        <span class="vue-g">$ sudo git add .</span><br>
        <span class="vue-g">$ sudo git commit -m "Payment v1.0"</span><br>
        <span class="vue-g">$ git log</span><br>
        commit 3cjusioduosijelkrwsdifhso3748379283<br>
        Author: sasha sastelegin@mail.ru<br>
        DAte: Tue Nov 12 13:17:32 2019 +0300<br><br>
    
        <span class="ind">Payment v1.0</span><br><br>
    
        commit 3cjusioduosijelkrwsdifhso3748379283<br>
        Author: sasha sastelegin@mail.ru<br>
        DAte: Tue Nov 12 13:17:32 2019 +0300<br><br>
    
        <span class="ind">First version</span>
    </p>
    <p>И теперь выполним команду:</p>
    <p>
        <code>
            <span class="vue-g">$ git branch -v</span>
            *<span class="green"> feature-payment</span> 3c45f34 Payment v1.0<br>
            master f733f69 First version
        </code>
    </p>
    <p>Следует понимать что результат комита будет сохраняться только в текущей активной ветке. Мы видим ветка <b>master</b> остатлась в прежнем состоянии, в то время ветка feature-payment пошла вперёд и вней сохранён комит, который мы только сделали. И теперь если перейти на ветку <b>master</b>, то из проекта исчезнут файлы относящиеся к ветке <b>feature-payment</b>. В нашем случае исчезнет файл payment.php и в файле index.html исчезнет код для ссылки-кнопки. </p>
    <p>Как это работает? При переключении веток гит обращается к папке <b>.git</b> и вытаскивает из репозитория актуальную версию состояния файлов и папок для активной ветки и копирует их в рабочую директорию. Если переключится обратно на ветку <b>feature-payment</b>, то гит опять вытащит из папки <b>.git</b> актуальную версию файлов и скопирует в наш проект. Опять появится файл payment.php и в index.html будет код для ссылки кнопки.</p>
    <hr>
    <p>Ранее мы не акцентировали внимание на комитах, но теперь пришло время кое-что о них сказать. По мимо того что мы должны уметь комитить, мы ещё должны знать когда это делать. Никогда не надо делать комит, если работа ещё не закончена. Конечно это не значит что если мы работаем над чем то большим, то можно закомитить через месяц работы. Просто нужно постраться разбить задачу на целостные логические части и делать комит по завершению каждой такой части.</p>
    <p>Представим, что появилась ещё одна задача по изменению оплаты на сайте. Откроем наш файл payment.php и добавим какой нибудь код, например нужно добавить в оплату дополнительные способы оплаты, в нашем файле это будет выглядеть как строчка //v2.0. Но мы ещё не закончили её делать, работа над этой задачей продолжается.</p>
    <p>А дальше приходит задача с высоким приоритетом. Мы уже знаем что для новой задачи принято создавать новую ветку, переключится на неё и работать там. Но есть проблемы. Настоятельно рекомендуется переключаться между ветками только тогда, когда наша рабочая область в текущей ветке находится в чистом состоянии. Если выполнить команду <b>git status</b>, то мы увидим что файл payment.php горит красным, он в состоянии изменения(modofied), ведь мы его недавно изменяли. В таком состоянии переключаться между ветками категорически не рекомендуется. Если не следовать этому правилу, то отредактированные файлы могут быть затёрты, а изменения потеряны. Для того чтобы почистить рабочую область можно сделать комит, но ведь мы только начали работу над payment.php, сделали только часть и логическая целостность не завершена и если следовать правилу - не комитить не законченную работу, то для нас вариант этот не подходит. Так что же делать? А в таких случаях вместо комитов рекомендуют выполнить команду <b>git stash</b>. Можем представить это как усовершенствованный буфер обмена, как Ctrl + C, Ctrl + V. Мы можем как будто выбрать все изменённые файлы и скопировать их в буфер. При этом рабочее дерево будет <b>очищенно</b> и можем выполнять другую работу. Когда придёт время мы можем вставить скопированные данные обратно и они будут точно в таокм состоянии как и были. Давайте опробуем эту команду.</p>
    <p>Сейчас в нашем дереве есть изменёный файл payment.php и его надо поместить в так называемый буфер:</p>
    <p>
        <code>
            <span class="vue-g">$ git stash</span><br>
            Saved working directory and index state WIP on feature-payment: 3c45f34 Payment v1.0<br>
            HEAD is now at 3c45f34 Payment v1.0
        </code>
    </p>
    <p>После этого мы можем проверить состояние проекта <b>git status</b>, область будет очищена. Можем просмотреть содержимое нашего буфера</p>
    <p>
        <code>
            <span class="vue-g">$ git stash list</span><br>
            stash@{0}: WIP on feature-payment: 3c45f34 Payment v1.0
        </code>
    </p>
    <p>Теперь мы видим, что наши изменения сохранены в буфере. Они будут там находится до тех пор пока они нам не понадобятся. Ещё одна классная особенность <b>stash</b> в том, что в него можно положить данные не один раз, как в обычный буфер обмена, а столько сколько нужно.</p>
    <p>Венёмся к задаче с высоким приоритетом. Под эту задачу мы также будем создавать новую ветку, но для начала нужно кое-что уточнить. Наш репозиторий сечас выглядит как 2 ветки - <b>master</b> и <b>feature-payment</b>. Ветка master содержит в себе 1 комит, а ветка feature-payment включает в себя 2 комита. Кроме того активной сейчас является ветка feature-payment, так как на неё указывает указатель HEAD.</p>
    <hr>
    <h4>Удаление ветки</h4>
    <p><span class="vue-g">$ sudo git branch -D </span>имя ветки</p>
    <hr>
    <p>При решении нашей высокоприоритетной задачи нам нужно убедиться, что изменения затронут только основную версию проекта. То есть версию из ветки master. Сейчас мы находимся в ветке feature-payment. Переключаемся на ветку master:</p>
    <p><span class="vue-g">$ sudo git checkout master</span></p>
    <p>И создаём новую ветку для высокоприоритетной задачи:</p>
    <p><span class="vue-g">$ sudo git branch hotfix</span></p>
    <p>Переключаемся на эту ветку:</p>
    <p><span class="vue-g">$ sudo git checkout hotfix</span></p>
    <p>Вот так сейчас выглядит схема веток:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/20-20.jpg">
    <p>Добавилась новая ветка - <b>hotfix</b>, она указывает на тот же комит что и master. Ещё одно важное изменение, указатель HEAD указывает теперь на ветку hotfix, так как она теперь активна.</p>
    <p>Давайте внесём изменения в файлы, будем считать что задача состоит в том, что нужно изменить текст на кнопке - Cleack Me, а вторую кнопку удалить. Открываем файл index.html в редакторе и правим html код по задаче. Первую кнопку переименуем в Buy Me, а вторую удаляем. Теперь можно сделать комит:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git add index.html</span><br>
            <span class="vue-g">$ sudo git connit -m "Hotfix"</span><br>
        </code>
    </p>
    <p>После выполненых действий схема репозитория выглядит вот так:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/21-21.jpg">
    <p>Ветка hotfix по прежнему остаётся активной, на неё указывает HEAD указатель. Следовательно комит, который мы только что сделали был добавлен в вeтку hotfix, теперь hotfix опережает ветку master. Следующий шаг это добавить изменения из ветки hotfix в ветку master. Вот мы и подошли к теме <b>слияния веток</b>.</p>
    <h3>Слияние веток</h3>
    <p>До этого момента мы просто создавали ветки под каждую задачу, работали в них, делали комиты. Но так не может продолжаться вечно. В целом весь процесс выглядит так - <b>мы выбираем ветку master как основную долгоживущую ветку, состояние которой копируется на удалённый сервер. При поступлении новых задач мы создаём новые ветки, отвлетвляясь от master и выполняем работу в них. По окончанию работы изменения должны быть добавлены в master. Сделать это можно при помощи команды <span class="vue-g">git merge branch_name</span>. Используя эту команду мы должны указать название ветки. Обязательно запомните что выбранная ветка будет добавленная в текущую активную ветку, то есть в HEAD. Таким образом для слияния необходимо выполнить всего 2 шага:</b></p>
    <ul>
        <li><b>во первых выбрать ветку куда будут добавлены изменения(target branch)</b></li>
        <li><b>и выбрать ветку в котрой эти изменения содержатся <span class="vue-g">git merge branch_name</span></b></li>
    </ul>
    <p>Давайте добавим изменения из ветки hotfix  в ветку master. Для этого надо переключится на ветку master:</p>
    <p><span class="vue-g">$ sudo git checkout master</span></p>
    <p>И теперь объединяем ветку hotfix и master:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git merge hotfix</span>
            Updating 877b01f..17aa394
            Fast-forward
            <span class="ind">index.html</span> | <span class="green">++</span><span class="vue-g">--</span>
            <span class="ind">1</span> file changed, 2 insertion(+), 2 deletions(-)
        </code>
    </p>
    <p>Теперь посмотрим историю комитов в ветке master:</p>
    <p>
        <code>
            <span class="vue-g">$ git log</span><br>
            commit 3cjusioduosijelkrwsdifhso3748379283<br>
            Author: sasha sastelegin@mail.ru<br>
            DAte: Tue Nov 13 11:15:32 2019 +0300<br><br>
    
            <span class="ind">Hotfix</span><br><br>
    
            commit 3cjusioduosijelkrwsdifhso3748379283<br>
            Author: sasha sastelegin@mail.ru<br>
            DAte: Tue Nov 12 13:17:32 2019 +0300<br><br>
    
            <span class="ind">First version</span>
        </code>
    </p>
    <p>И как видно ветка master теперь содержит 2 комита - свой и из ветки hotfix. Что же произошло на самом деле? Данный пример слияния очень прост, дело в том что в ветку master не было добавленно ни одного комита, с тех пор как была создана ветка hotfix. В таком случае применяется стратегия слияния Fast-forward(перемотка). При этом гит просто перемещает указатель HEAD ветки msater на последний комит ветки hotfix:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/22-22.jpg">
    <p>При этом обе ветки будут имет одинаковую историю. <b>Срочные исправления сделаны, теперь вернёмся доделывать оплату v2.0</b>. </p>
    <p>Переключаемся на ветку <b>feature-pyament</b></p>
    <p><span class="vue-g">$ sudo git checkout feature-payment</span></p>
    <p>Проверяем статус, ветка чиста, так как наши изменения содержатся в буфере. Чтобы извлечь наше содержимое нужно написать команду:</p>
    <p><span class="vue-g">$ sudo git stash pop</span></p>
    <p>Результатом будет точно такой вывод, когда наш изменёный файл payment.php был красного цвета и ждал комита. Если ввести команду <b>git stash list</b>, то нам покажут пустоту, буфер пуст. Обратите внимание, что при команде stash содержимое извлекается и применяется для активной ветки, т.е. для ветки feature-payment. И не важно в какой ветке мы находились когда помещали данные в буфер.</p>
    <p>Также stash имеет некоторые доп. функции. Например извлечение конкретного состояния по его ключу. Однако приведённого примера использования как правило хватает.</p>
    <p>Продолжим работу над оплатой. Откроем файл payment.php и допишем слово //finished и можем закомитить.</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git add payment.php</span><br>
            <span class="vue-g">$ sudo git commit -m "Payment v2.0 finished"</span><br>
            <span class="vue-g">$ git log</span><br>
            commit 4027sioduosdfssjelkrwsdifhso3748379<br>
            Author: sasha sastelegin@mail.ru<br>
            DAte: Tue Nov 13 12:50:32 2019 +0300<br><br>
        
            <span class="ind">Payment v2.0 finished</span><br><br>
    
            commit 3cjusioduosijelkrwsdifhso3748379283<br>
            Author: sasha sastelegin@mail.ru<br>
            DAte: Tue Nov 12 13:17:32 2019 +0300<br><br>
        
            <span class="ind">Payment v1.0</span><br><br>
        
            commit 3cjusioduosijelkrwsdifhso3748379283<br>
            Author: sasha sastelegin@mail.ru<br>
            DAte: Tue Nov 12 13:17:32 2019 +0300<br><br>
    
        <span class="ind">First version</span>
        </code>
    </p>
    <p>В данный момент ветки выглядят так:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/23-23.jpg">
    <p>Активна ветка feature-payment и в ней появился ещё одни комит. Теперь мы хотим добавить изменения из этой ветки в ветку master. Для этого переключаемся в ветку master:</p>
    <p><span class="vue-g">$ sudo git checkout master</span></p>
    <p>И делаем слияние:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git merge feature-payment</span><br>
            Auto-merging index.html<br>
            CONFLICT (content): Merge conflict in index.html<br>
            Automatic merge failed: fix conflicts and then commit the result 
        </code>
    </p>
    <p>Здесь наступает самое интересное. Гит сообщает нам о коналикте слияний. Что это значит? Конфликт слияния это ситуация когда мы пытаемся объединить 2 ветки, в каждом из которых прошли изменения в одном и том же файле и в одной и той же строке. В таких случаях гит просто не знает какой результат ожидается от него на выходе и предлагает нам самостоятельно разобраться с ситуацией. Не стоит бояться конфликтов, это самая обычная ситуация, которая происходит у разработчиков достаточно часто. Перед тем как мы разберёмся с конфликтом, изучим ещё одну полезную команду - отмену <b>merge</b>. Она может понадобится на случай если мы неправильно указали ветку для слияния.</p>
    <p><span class="vue-g">$ sudo git merge --abort</span></p>
    <p>После этой команды ветка master вернётся в состояние до слияния с веткой feature-payment. Но всё таки выполним слияние</p>
    <p><span class="vue-g">$ sudo git merge feature-payment</span><br></p>
    <p>И будем разбираться с конфликтом. Проверим статус. Тут будет написано какие именно случились проблемы при слиянии. Красным написано <b>both modified: index.html</b>. Both значит "оба", т.е. файл был отредактирован в обеих ветках. Откроем файл index.html и в редакторе прокрутим до того места где мы меняли код. Там гит нам отметить вот таким образом:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/24-24.jpg">
    <p>Гит говорит нам что не смог разобраться как объединить эти изменения, но нашёл проблемные места и добавил спец. разметку. Всё что находится выше =========== этой черты относится к ветке HEAD, в нашем случае это ветка master, всё что ниже черты взято из ветки feature-payment. Как должен выглядеть результат решать нам. Если слияние выполнялось с веткой другого разработчика, не лишним будет с ним проконсультироваться и вместе решить чья версия лучше. Возможно результат должен содержать что то от каждой из версий. Давайте решим конфликт следующим образом:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/25-25.jpg">
    <p>Изменения мы взяли из 2х разных веток. Сохраняем файл, переходим в консоль и проверяем статус. Строчка с конфликтом так красным и горит, теперь нужно сделать комит, который и исчерпает конфликт:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git add .</span><br>
            <span class="vue-g">$ sudo git commit -m "Merge with feature-payment conflict solved"</span><br>
        </code>
    </p>
    <p>Посмотрим историю, видим последний комит, конфликт решён. Посмотрим схему финальной версии проекта:</p>
    <img src="http://localhost:8080/MyProject/template/images/bash/26-26.jpg">
    <p>Далее мы можем работать с веткой master и загрузить её на удалённый сервер.</p>









    <h3 class="header-style2" id="5">Удалённые репозитории Git</h3>
    <p>Удаленные репозитории и как с ними работать:</p>
    <ul>
        <li>git remote add</li>
        <li>git fetch</li>
        <li>git push</li>
        <li>git clone</li>
        <li>git pull</li>
    </ul>
    <p>Что такое репозиторий? Мы уже знаем, что это некоторая папка с названием <b>.git</b> в проекте. Проще всего считать репозиторий базой данных, хранилищем, в котором система контроля версий хранит состояние проекта и другую служебную информацию. Можно условно разделить репозиторий на 2 вида - <b>локальный</b> и <b>удалённый</b>. <b>Локальный</b> репозиторий как мы уже разобрались, находится на лок. компьюторе в корневой папке нашего проекта. В этом случае мы единственный человек, кто имеет доступ к этому репозиторию. <b>Удалённый</b> репозиторий находится на какой то другой машине, доступной по сети. От локального он отличается тем, что предназначен в основном для обмена данными, т.е. служит центральным хранилищем, с которым могут работать другие члены команды. Они могут загружать себе работу других и выгружать свои обновления. Ещё одно отличие удалённого репозитория - это отсутствие рабочей папки, такой, в которой мы ведём разработку на лок. машине. Она не нужна, т.к. непосредственно на удалённой машине никто не ведёт разработку. В этом случае репозиторий состоит только из папки <b>.git</b>. Можно думать об удалённом репозитории как о некотором файловом сервере, который позволяет обмениваться наработками в рамках проекта. До этого момента мы выполняли работу исключительно в лок. репозитории. Практически вся разработка должна происходить в лок. хранилище. Удалённый репозиторий понадобится, когда мы будем готовы показать свою работу команде.</p>
    <p>На самом деле для работы с удалённым репозиторием нужно всего несколько команд. Вот они:</p>
    <ul>
        <li><b>git clone</b> URL. Если мы хотим присоединится к разработке или использовать проект, для которого уже создан удалённый репозиторий.</li>
        <li><b>git remote add</b> repo_name URL. Если мы уже работаем в лок. репозитории и хотим подключить его к удалённому репозиторию.</li>
        <li><b>git fetch</b> repo_name. Если мы уже подключили удалённый репозиторий к локальному и хотим получить файлы из него.</li>
        <li><b>git push</b> repo_name branch_name. Если мы хотим отправить данные из лок. ветки в удалённый репозиторий.</li>
        <li><b>git pull</b> repo_name branch_name. Если мы хотим получить данные из ветки удалённого репозитория.</li>
    </ul>
    <p>Давайте рассмотрим как использовать эти команды в типичных рабочих ситуациях. Предположим задача звучит так - нужно написать php скрипт, который принимает адрес веб страницы. Используя этот адрес скрипт открывает страницу, считывает содержимое определённых html тегов. Результатом его работы является массив, который содержит текст из этих тегов. Можем представить, что этот скрипт нужен для сбора сокращённых версий новостей. Также мы бы хотели поручить выполнение части задачи другому человеку в команде. Для того чтобы быть уверенным в работе скрипта, мы накладываем некоторые ограничения, а именно: - логика скрипта должна содержаться в методе класса. Класс должен реализовывать указанный нами интерфейс. Мы помним что интерфейс будет содержать описание того, как должен работать класс. Таким образом работа делится на 2 части. Во первых мы загрузим интерфейс в удалённый репозиторий. Во вторых мы передадим второму разработчику доступ к этому репозиторию и текстовое описание задачи. Через некоторое время мы будем ожидать наличие готовой работы в этом же удалённом репозитории</p>
    <h3>Создание интерфейса</h3>
    <h4>Публикация локального репозитория</h4>
    <p>Мы будем использовать сервис <a href="https://bitbucket.org/">BitBucket</a>. Он позволяет создавать удалённый репозиторий и пользоваться им. Чтобы с ним работать потребуется создать учётную запись. После того как создали аккаунт, подготовим нашу локальную разработку. Создадим папку на компьюторе, назовём её например tag-parser, зайдём в неё и проинициализируем гит - <b>git init</b>. Создадим тут же в папке файл ParserIntarfase.php и в нём такой код:</p>
    <p>
        <code>
            //<?php<br>
                <span class="ind">/**</span><br>
                <span class="ind">*</span> @author sasha<br>
                <span class="ind">*/</span><br><br>

                <span class="ind">interface ParseInterface</span><br>
                <span class="ind">{</span><br>
                <span class="ind2">/**</span><br>
                <span class="ind2">*</span> @param string $url<br>
                <span class="ind2">*</span> @param string $tag<br>
                <span class="ind2">*</span> return array<br>
                <span class="ind2">public</span> function process(string $url, string $tag) : array;<br>
                <span class="ind2">*/</span><br>
                <span class="ind">}</span>
        </code>
    </p>
    <p>Код нашего интерфейса готов, можем загружать его в удалённый репозиторий. Второй разработчик может использовать этот интерфейс для того чтобы написать свой класс.</p>
    <p>Перед тем как пойти дальше нужно сделать некоторые настройки в нашем репозитории. Нужно указать имя и почту для нашего репозитория. У меня имя и почта были ранее заданны глобально, т.е. действует на все проекты. Посмотреть заданы или нет можно командой <b>git config --list</b>. Обратим внимание на то, что почта должна быть такой же как и на удалённом репозитории. Теперь можем сделать комит наших изменеений в лок. репозитории.</p>
    <p>Закомитили и следующий шаг это создать удалённый репозиторий на BitBucket. Находим кнопку created repository, откроется страница с формой. Дадим имя репозиторию - tag parser. Выбираем тип репозитория - git. Галочку приватного репозитория оставляем. Ниже в advanced settings в графе - язык можем выбрать язык php. Всё жмём создать. Откроется наша страничка репозитория, вверху в описании будет строка с адресом нашего репозитория, у меня она выглядит так - https://SashaT512@bitbucket.org/SashaT512/tag-parser.git</p>
    <p>Теперь нужно привязать этот репозиторий к нашему локальному репозиторию. Сделать это можно в консоли при помощи спец. команды - <b>git remote add</b>, она говорит нам что мы можем добавить удалённый репозиторий, далее мы вводим его имя, например remote-repo и далее адресс удалённого репозитория:</p>
    <p>
        <span class="vue-g">$ git remote add remote-repo https://SashaT512@bitbucket.org/SashaT512/tag-parser.git</span>
    </p>
    <p>Добавляем и теперь можем проверить наличие соединения:</p>
    <p>
        <span class="vue-g">$ git remote -v</span><br>
        <code>
            remote-repo    https://SashaT512@bitbucket.org/SashaT512/tag-parser.git (fetch)<br>
            remote-repo    https://SashaT512@bitbucket.org/SashaT512/tag-parser.git (push)
        </code>
    </p>
    <p>Первый адресс используется для получения данных(fetch), второй используется для записи(push). Чаще всего эти адреса совпадают, но иногда могут отличаться в целях безопасности. Стоит также отметить, что в нашем репозитории мы можем создавать подключение не только к одному удалённому репозиторию, но и к большему количеству.</p>
    <p>Ещё одна полезная команда это <b>git remote remove</b></p>
    <p>
        <span class="vue-g">$ git remote remove remote-repo</span> - она удаляет указанный репозиторий, пригодится в случае если додбавили не тот репозиторий и нужно удалить это подключение.
    </p>
    <p>Идём дальше, сейчас после подключения нам нужно поместить данные в удалённый репозиторий. Давайте для начала просмотрим список всех веток в лок. репозитории.</p>
    <p>
        <span class="vue-g">$git branch -va</span> -   -v означает verbose(подробно), -a означает all - отображать все ветки подробно, локальные и удалённые<br>
        <code>
            * <span class="green">master</span> 6a13ed4 Parser interfase
        </code>
    </p>
    <p>Теперь можно выполнить выгрузку данных в удалённый репозиторий при помощи команды <b>git push</b>, которая принимает 2 параметра - во первых это название удалённого репозитория, на который нужно отправить данные, во вторых название ветки, которую нужно отправить:</p>
    <p><span class="vue-g">$ git push remote-repo master</span></p>
    <p>После нескольких секунд прийдёт отчёт о выполнении команды:</p>
    <p>
        <code>
            Counting objects: 4, done.<br>
            Delta compression using up to 4 threads<br>
            Compressing objects: 100% (3/3), done.<br>
            Writing objects: 100% (4/4), 445 bytes | 0 bytes/s, done.<br>
            Total 4 (delta 0), reused 0 (delta 0)<br>
            To https://bitbucket.org/SashaT512/tag-parser.git<br>
            * [new branch]       master -> master
        </code>
    </p>
    <p>Если загрузка выполняется в первый раз, то может потребуется аутентификация. Появится окошко, в которое нужно будет ввести логин и пароль от BitBucket, после этого push произойдёт успешно. Проверим выгрузку. Заходим в удалённый репозиторий, заходим в наш созданный репозиторий tag-parser.</p>
    <hr>
    <h4>Моё замечание</h4>
    <p>У меня не получилось выгрузить на удалённый репозиторий как показано выше. Выдывал ошибку. Сделал по своему. В моём аккаунте мне написали что нужно сделать команду <b>git clone https://SashaT512@bitbucket.org/SashaT512/tag-parser.git</b>. Эта команда сама создаёт папку проекта tag-parser, мне нужно только зайти по пути /var/www и сюда выполнить эту команду. В созданной папке уже установлен локальный репозиторий, т.е. стоит папки <b>.git</b>, мне осталось только создать файл ParserIntarface.php, записать в него сам код и закомитить всё это дело. Потом уже подключаем удалённый репозиторий <b>git remote add r-repo https://SashaT512@bitbucket.org/SashaT512/tag-parser.git</b>, проверяем подключение и пытаемся выгрузить данные с ветки:</p>
    <p><span class="vue-g">git push r-repo master</span></p>
    <p>И теперь вроде всё получилось. При заходе на удал. репоз. видим что появился там наш файл ParserInterface.php</p>
    <hr>
    <p>Если ещё раз посмотрть список веток <b>git branch -va</b>, то теперь увидим что появились ветки и из удалённого репозитория, у меня этот список такой:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git branch -va</span><br>
            * <span class="green">master</span> c1e09aa [ahead1] Parser interface<br>
            <span class="vue-g">remores/origin/HEAD</span> -> origin/master<br>
            <span class="vue-g">remotes/origin/master</span> 4080e6a Initial commit<br>
            <span class="vue-g">remotes/r-repo/master</span> c1e09aa Parser interface
        </code>
    </p>
    <p>Ветки отмеченные крассным это скопированные ветки с удалённого репозитория в нашу лок .область. Теперь перейдём ко второй части задачи.</p>
    <h3>Клонирование существующего удалённого репозитория</h3>
    <p>Представим что мы 2й разработчик, который должен написать класс для парсинга. Попытаемся выполнить его задачу. Так как мы подсоединяемся к уже существующему проекту, то нам предоставят url удалённого репозитория. После чего мы должны выбрать папку на лок. компьюторе, пусть это будет папка class-parser и выполнить клонирование репозитория в эту папку. Есть одно замечание, если написать команду <b>git clone https://SashaT512@bitbucket.org/SashaT512/tag-parser.git</b>, то в нашу папку class parser скопируется папка tag-parser, в которой уже будет всё остальное, но мы этого не хотим, поэтому в конце команды поставим точку, которая говорит что нужно копировать сразу в нашу папку:</p>
    <p><span class="vue-g">$ sudo git clone https://SashaT512@bitbucket.org/SashaT512/tag-parser.git .</span></p>
    <p>После этой команды у нас в папке class-parser появятся файлы из удалённого репозитория, а именно README.md  и ParserInterface.php. Если посмотреть список веток, то увидим такие ветки:</p>
    <p>
        <code>
            <span class="vue-g">$ git branch -va</span><br>
            * <span class="green">master</span> 8eae156 ParserInterface.php edited online with BitBucket<br>
            <span class="vue-g">remores/origin/HEAD</span> -> origin/master<br>
            <span class="vue-g">remotes/origin/master</span> 8eae156 ParserInterface.php edited online with BitBucket<br>
        </code>
    </p>
    <p>Комментарий немного изменился у комита, это потому, что я на удалённом репозитории немного подправил файл и там же закомитил.</p>
    <p>Итак среди веток мы увидим локальную копию удалённой ветки master - remotes/origin/master, а также локальную ветку master. Также можно выполнить команду <b>git remote -v</b> и посмотреть подключения к удалённому репозиторию. Увидим такой список:</p>
    <p>
        <code>
            origin https://SashaT512@bitbucket.org/SashaT512/tag-parser.git (fetch)<br>
            origin https://SashaT512@bitbucket.org/SashaT512/tag-parser.git (push)
        </code>
    </p>
    <p>Эти подключения выполнились автоматически при клонировании и были даны названия удалённому репозиторию по умолчанию - origin.</p>
    <p>Теперь можем выполнить поставленную задачу, а именно написать класс по загруженному интерфейсу ParserInterface.php. Вспоминаем золотое правило гит, что под каждую задачу создаём свою ветку. Посмотрим какие ветки у нас есть <b>git branch</b> - * master. Видим что одна ветка master у нас. Создадим ещё одну ветку <b>git branch feature-parser</b>, переключимся на неё <b>git checkout feature-parser</b> и можем вести разработку класса.</p>
    <p>Создадим новый файл Parser.php и откроем его и напишем код нашего класса, пока он будет как макет:</p>
    <p>
        <code>
            //<?php
            <span class="ind">require_once \'ParserInterface.php\';</span><br>
            <span class="ind"><span class="blue">/**</span></span><br>
            <span class="ind"><span class="blue">* @autor sasha sanya.telegin.84@bk.ru</span></span><br>
            <span class="ind"><span class="blue">*/</span></span><br>
            <span class="ind">class Parser implements ParserInterface</span><br>
            <span class="ind">{</span><br>
                <span class="ind2">public</span> function process(string $url, string $tag)<br>
                <span class="ind2">{</span><br>
                    <span class="ind3">return</span> ['one', 'two', 'three'];<br>
                <span class="ind2">}</span><br>
            <span class="ind">}</span><br>
        </code>
    </p>
    <p>Пока пусть будет такой код класса, потом напишем нормальный. А сейчас давайте закомитим наши измененния. После того как закомитим нужно объединить нашу ветку с веткой master. Переключаемся на ветку master и выполним <b>git merge</b> ветки feature-parser в ветку master.</p>
    <p><span class="vue-g">$ sudo git merge feature-parser</span></p>
    <p>При слиянии будет использована перемотка <b>fast forward</b>, при просмотре веток видим что master имеет тот же коммит что и ветка feature-parser. Также при просмотре веток подробно - <b>git branch -v</b> мы видим такую запись - <b>[ahead 1]</b>, которая говорит что эта локальная ветка master находится впереди удалённой ветки master, также видим что id комитов у них разное. Теперь всё готово к отправке данных в удалённый репозиторий. Давайте посмотрим удалённые репозитории - <b>git remote -v</b>, как видим они называются origin, значит будет загружать на этот удалённый репозиторий:</p>
    <p><span class="vue-g">$ sudo git push origin master</span></p>
    <p>Если опять посмотреть ветки подробно и вместе с удалёнными, то увидим что теперь комитты у веток master одинаковые, значит мы загрузили нашу ветку. Идём на сайт репозитория и проверяем там наличие нашего файла Parser.php</p>
    <h3>Получение актуальных данных из удалённого репозитория</h3>
    <ul>
        <li>git fetch</li>
        <li>git push</li>
    </ul>
    <p>Теперь представим что мы тот первый разработчик, тот который создал удалённый репозиторий и загрузил туда файл интерфейса. Мы теперь хотим получить результаты работы второго разработчика. Сделать это можно двумя способами. Чтобы показать эти способы давайте скопируем папку проекта первого разработчика - tag-parser и назовём её - tag-parser2. Перейдём, например в папку tag-parser. Посмотрим статус проекта <b>git status</b>, посмотрим ветки <b>git branch -va</b>, как видим проект находится в первичном состоянии, в нём находится тот первый комит, который сделал первый разработчик при создании интерфейса:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git branch -va</span><br>
            * <span class="green">master</span> c1e09aa [ahead1] Parser interface<br>
            <span class="vue-g">remores/origin/HEAD</span> -> origin/master<br>
            <span class="vue-g">remotes/origin/master</span> 4080e6a Initial commit<br>
            <span class="vue-g">remotes/r-repo/master</span> c1e09aa Parser interface
        </code>
    </p>
    <p>Смотрим на ветку r-repo, которой и давай название первый разработчик. Итак к этому проекту подключён удалённый репозиторий, в этом мы убедимся проверив командой <b>git remote -v</b>. Далее нам нужно получить данные из удалённого репозитория. Делается это командой <b>git fetch</b>:</p>
    <p><span class="vue-g">$ sudo git fetch r-repo</span></p>
    <p>Ещё раз посмотрим на ветки <b>git branch -va</b> и уже увидим что наша локальная копия(remotes/r-repo/master) удалённой ветки изменеились:</p>
    <p>
        <code>
            <span class="vue-g">$ sudo git branch -va</span><br>
            * <span class="green">master</span> c1e09aa [ahead1] Parser interface<br>
            <span class="vue-g">remores/origin/HEAD</span> -> origin/master<br>
            <span class="vue-g">remotes/origin/master</span> 4080e6a Initial commit<br>
            <span class="vue-g">remotes/r-repo/master</span> c1e09aa Parser class
        </code>
    </p>
    <p>Была сделана обновлённая копия удалённой ветки и эта ветка уже содержит комит, который сделал второй разработчик. Мы можем переключится на ветку remotes/r-repo/master и посмотреть какие данные в ней содержатся. Если нас удовлетворили те данные, то мы можем слить эту ветку в нашу локальную ветку master. Вернёмся обратно в нашу ветку master и сливаем в неё ветку remotes/r-repo/master:</p>
    <p><span class="vue-g">$ sudo git merge remotes/r-repo/master</span></p>
    <p>Посмотрев ещё раз ветки мы увидим что наша ветка master имеет последний комит из удалённого репозитория и значит мы увидим у себя на лок. репозитории файл Parser.php</p>
    <p>Обратить нужно внимание на то что наш лок. репозиторий хоть и подключён к удалённому репозиторию, но это не онлайн связь, а всего лишь ссылки. А локальные копии веток удалённого репозитория обновляются только по запросу <b>git fetch</b>, после использования этой команды мы получаем актуальное состояние удалённого репозитория у себя в проекте.</p>
    <p>Рссмотрим второй способ получения данных из удалённого репозитория. Для этого перейдём в проект tag-parser2. Командой для второго способа является команда <b>git pull</b>, у неё 2 параметра: 1й это название удалённого репозитория, 2й это ветка удалённого репозитория</p>
    <p><span class="vue-g">$ sudo git pull r-repo master</span></p>
    <p>Объясним отличие git pull от git fetch. В то время как git fetch просто скачивает данные из удалённого репозитория и складывает их в лок. копии веток, то git pull пытается получит данные из удалённого репозитория из указанной ветки, после того как он получил данные он пытается сам слить удалённую ветку с нашей локальной веткой. Фактически те операции при git fetch, которые мы делали вручную, git pull сам всё делает. Также следует понимать что git pull нужно выполнять только в состоянии чистого рабочего дерева, иначе могут возникнуть проблемы. Также стоит знать что команда git fetch получает из удалённого репозитория все ветки, при этом мы можем переключатся между ними, смотреть какие в них произошли изменения и принимать решения, стоит их сливать в наш проект или нет. Команда git pull вытаскивает одну ветку и пытается её слить в текущую активную ветку в лок. репозитории.</p>
</div>