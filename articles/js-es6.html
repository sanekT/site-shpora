<div class="wrap">
	<h2 class="header-style">ES6. Смысл, фишки и подвохи.</h2>

	<ul class="list">
	<li><a href="#1">var, let, const - отличия</a></li>
	<li><a href="#2">Параметры по умолчанию</a></li>
	<li><a href="#3">Остаточные параметры и оператор расширения</a></li>
	<li><a href="#4">Цикл for...of</a></li>
	<li><a href="#5">Новые кавычки ``</a></li>
	<li><a href="#6">Стрелочная функция</a></li>
	</ul>


	<h3 class="header-style2" id="1">var, let, const - отличия</h3>
	<p><b>var</b> - её область видимости такая. Где бы мы не объявили переменную с помощью var, кроме функции, движок поднимет объявление этой переменной в самый верх скрипта, это означат что такие переменные всегда глобальны и видимы из любой точки скрипта.</p>
	<p><b>let</b> и <b>const</b> - по другому объявляют переменные. Любые блоки( блок это {} ) делают локальными переменные объявленные с помощью этих слов. Даже в цикле на каждой итерации переменная будет иметь своё значение при let. Также движок при let не поднимает переменную в верх скрипта, это значит что переменную можно использовать только после её объявления. Ну const это объявление константы, тут всё как у let, просто константа.</p>





	<h3 class="header-style2" id="2">Параметры по умолчанию</h3>
	<p>Также в новом стандарте ввели возможность задавать параметры по умолчанию внутри функций. Раньше, чтобы указать значение по умолчанию использовали логический оператор ||. Теперь же достаточно в функции в скобках парамертам присвоить значения по умолчанию.</p>
	<div class="code-style">
		<pre>
		    function abc(a = 12, b = {}, c = function(){}){
			...
		    }
		</pre>
	</div>





	<h3 class="header-style2" id="3">Остаточные параметры и оператор расширения</h3>
	<p><b>Остаточные параметры</b> применяются в самой функции. Когда мы передаём в функцию много аргументов, то все аргументы или их часть мы можем собрать в массив. Переменную для остаточных параметров всегда надо ставить в последнюю очередь в параметрах функции.</p>
	<p>У функций есть встроенная возможность как псевдомассив arguments, но он всегда содержит все переданные аргументы и он не является массивом, а значит не содержит методов массива.</p>
	<div class="code-style">
		<pre>
		    function abc(a = 12, b = 2, ...params){
			console.log(params); // => [3, 4, 5]
			console.log(arguments); // => {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, length: 5}
			console.log(Array.isArray(params)); // => true
				    console.log(Array.isArray(arguments)); // => false
		    }
		    abc(1, 2, 3, 4, 5);
		</pre>
	</div>
	<p><b>Оператор расширения</b> также представляет из себя троеточие ... . Используется он он уже при вызовах функции. Например, есть объект Math.max(), в него мы передаём числа для выбора из них максимального. А если мы хотим передать массив чисел? Делается это через ... :</p>
	<div class="code-style">
		<pre>
		    console.log(Math.max(...[1,2,3])); // => 3
		</pre>
	</div>
	<p>С помощью этого оператора можно соединять массивы:</p>
	<div class="code-style">
		<pre>
		    let arr1 = [1,2,3],
			arr2 = [7,8,9];
		    let arr3 = [0, ...arr1, 4, 5, ...arr2];
		    console.log(arr3); // => [0, 1, 2, 3, 4, 5, 7, 8, 9]
		</pre>
	</div>
	<p>Также можно расширить строку в массив:</p>
	<div class="code-style">
		<pre>
		    let str = 'Строка';
		    let arr = [...str];
		    console.log(arr); // => ['С', 'т', 'р', 'о', 'к', 'а']
		</pre>
	</div>
	<p>Разобрать строку может и метод Array.from(str), что переводится как сделать массив из строки. Только этот метод может работать и с псевдомассивами, а оператор расширения только с перебираемыми объектами.</p>







	<h3 class="header-style2" id="4">Цикл for...of</h3>
	<p>Это новый цикл, предназначен в основном для перебора массивов и строк. Чем он отличается от остальных циклов, например от for...in, можно посмотреть в разделе "Заметки JS"</p>





	<h3 class="header-style2" id="5">Новые кавычки ``</h3>
	<p>Эти кавычки позволяют писать переменные праям в тих кавычках не разрывая и не конкатенируя их:</p>
	<div class="code-style">
		<pre>
		    let str = 'строка';
		    console.log(`Это не разрывная ${str}`); // => 'Это не разрывная строка'
		</pre>
	</div>
	<p>Также эти кавычки позволяют переносить строку на новую линию:</p>
	<div class="code-style">
		<pre>
		    let html = `
			<div>
				<span>Цена</span>
			</div>
		    `;
		</pre>
	</div>
	
	
	
	
	
	
	<h3 class="header-style2" id="6">Стрелочная функция</h3>
	<p>Такая функция создана для каких то мелких вычислений, когда кода не много, где-то на 1 строку. Также часто используют эту функцию в тех местах где нужно сохранить контекст того объекта, который находится где-то там на верху иерархии. Попробую объяснить что это значит. Например у нас есть метод obj.abc(), объявленный в объекте obj, в этом методе внутри объявляется ещё одна функция и вызывается и в этой функции мы используем this, предполагая, что этот this будет равен объекту obj, но тут уже теряется контекст, потому что this всегда равен объекту, который вызывает функцию или метод, а функцию у нас вызывает глобальный объект и значение this и значение this будет равно undefined. Чтобы сохранить контекст делали раньше так:</p>
	<div class="code-style">
		<pre>
		    let obj = {
		    	abc(){
				let self = this;
				function innerFunc(){
					console.log(self); // => obj
				}
				innerFunc();
			}
		    };
		    obj.abc();
		</pre>
	</div>
	<p>Теперь же можно использовать стрелочную функцию, чтобы сохранился контекст:</p>
	<div class="code-style">
		<pre>
		    let obj = {
		    	abc(){
				let innerFunc = () => console.log(this); // => obj
				innerFunc();
			}
		    };
		    obj.abc();
		</pre>
	</div>
	<p>Есть такое утверждение, что <b>стрелочные ф-ии</b> не имеют <b>this</b>. Что это значит? Это значит то, что обычные ф-ии и методы при своём создании создают лексическое окружение и в него также записывается this = объект перед точкой вызвавший эту ф-ю или метод, а вот при вызове стрелочной ф-ии в его лекс. окр-е this не записывается, this внутри стрелочной ф-ии воспринимается просто как внешняя переменная, которую нужно пойти и взять из первого внешнего лекс. окр-я. То же самое и с переменной <b>arguments</b>, стрелочная ф-я его также не имеет и берёт из внешнего лес. окр-я. Ну и стрелочная ф-я не подходит для создания из неё функции-конструктора, она не работает с <b>new</b>.</p>
	<p>Также заметил что стрелочную функцию можно объявить только в выражении(Function Expration). Чтобы её объявляли как Function Declaration не видел. Можно ещё правда объявить её как анонимную функуию и передавать как функцию отложенного вызова, но в итоге она как и все анонимные функции попадёт в какую то переменную и через эту переменную будут вызывать её:</p>
	<div class="code-style">
		<pre>
		    setTimeout((a, b) => a + b, 1000);
		</pre>
	</div>
	    
</div>
