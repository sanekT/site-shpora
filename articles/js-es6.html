<div class="wrap">
    <h2 class="header-style">ES6. Смысл, фишки и подвохи.</h2>

    <ul class="list">
        <li><a href="#1">var, let, const - отличия</a></li>
        <li><a href="#2">Параметры по умолчанию</a></li>
        <li><a href="#3">Остаточные параметры и оператор расширения</a></li>
    </ul>
    
    
    <h3 class="header-style2" id="1">var, let, const - отличия</h3>
    <p><b>var</b> - её область видимости такая. Где бы мы не объявили переменную с помощью var, кроме функции, движок поднимет объявление этой переменной в самый верх скрипта, это означат что такие переменные всегда глобальны и видимы из любой точки скрипта.</p>
    <p><b>let</b> и <b>const</b> - по другому объявляют переменные. Любые блоки( блок это {} ) делают локальными переменные объявленные с помощью этих слов. Даже в цикле на каждой итерации переменная будет иметь своё значение при let. Также движок при let не поднимает переменную в верх скрипта, это значит что переменную можно использовать только после её объявления. Ну const это объявление константы, тут всё как у let, просто константа.</p>

    
    
    
    
    <h3 class="header-style2" id="2">Параметры по умолчанию</h3>
    <p>Также в новом стандарте ввели возможность задавать параметры по умолчанию внутри функций. Раньше, чтобы указать значение по умолчанию использовали логический оператор ||. Теперь же достаточно в функции в скобках парамертам присвоить значения по умолчанию.</p>
    <div class="code-style">
        <pre>
            function abc(a = 12, b = {}, c = function(){}){
                ...
            }
        </pre>
    </div>
    
    
    
    
    
    <h3 class="header-style2" id="2">Остаточные параметры и оператор расширения</h3>
    <p><b>Остаточные параметры</b> применяются в самой функции. Когда мы передаём в функцию много аргументов, то все аргументы или их часть мы можем собрать в массив. Переменную для остаточных параметров всегда надо ставить в последнюю очередь в параметрах функции.</p>
    <p>У функций есть встроенная возможность как псевдомассив arguments, но он всегда содержит все переданные аргументы и он не является массивом, а значит не содержит методов массива.</p>
    <div class="code-style">
        <pre>
            function abc(a = 12, b = 2, ...params){
                console.log(params); // => [3, 4, 5]
                console.log(arguments); // => {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, length: 5}
                console.log(Array.isArray(params)); // => true
			    console.log(Array.isArray(arguments)); // => false
            }
            abc(1, 2, 3, 4, 5);
        </pre>
    </div>
    <p><b>Оператор расширения</b> также представляет из себя троеточие ... . Используется он он уже при вызовах функции. Например, есть объект Math.max(), в него мы передаём числа для выбора из них максимального. А если мы хотим передать массив чисел? Делается это через ... :</p>
    <div class="code-style">
        <pre>
            console.log(Math.max(...[1,2,3])); // => 3
        </pre>
    </div>
    <p>С помощью этого оператора можно соединять массивы:</p>
    <div class="code-style">
        <pre>
            let arr1 = [1,2,3],
                arr2 = [7,8,9];
            let arr3 = [0, ...arr1, 4, 5, ...arr2];
            console.log(arr3); // => [0, 1, 2, 3, 4, 5, 7, 8, 9]
        </pre>
    </div>
    <p>Также можно расширить строку в массив:</p>
    <div class="code-style">
        <pre>
            let str = 'Строка';
            let arr = [...str];
            console.log(arr); // => ['С', 'т', 'р', 'о', 'к', 'а']
        </pre>
    </div>
    <p>Разобрать строку может и метод Array.from(str), что переводится как сделать массив из строки. Только этот метод может работать и с псевдомассивами, а оператор расширения только с перебираемыми объектами.</p>
    
</div>
