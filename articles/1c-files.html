<div class="wrap">
   
    <h2 class="header-style">Работа с файлами, почтой. Диалоги выбора файла, цвета, шрифта и стандартных периодов</h2>

    <p>Цикл видео про работу с файлами - https://www.youtube.com/watch?v=K-4xNKBcFl8&list=PLnhTnXRFDQ7dJa-1DtA2bcKvK4pxV8GRP</p>

    <h3 class="header-style2">Оглавление</h3>
    <ul class="list">
        <li><a href="#1">Что следует изучать в области обмена данными между 1с и другими системами</a></li>
        <li><a href="#dialog-select-files">Диалог выбора файла</a></li>
        <li><a href="#dialog-enter-str">Диалог ввода строки, числа, значения, даты</a></li>
        <li><a href="#dialog-select-color">Диалог выбора цвета</a></li>
        <li><a href="#dialog-select-font">Диалог выбора шрифта</a></li>
        <li><a href="#dialog-edit-period">Диалог выбора стандартного периода</a></li>
        <li><a href="#work-files">Подготовка к работе с файлами</a></li>
        <li><a href="#txt-base">Частоиспользуемые методы класса "ТекстовыйДокумент</a></li>
        <li><a href="#txt">Читаем текстовый файл TXT, пример 1(использование синх методов ТекстовыйДокумент/ЧтениеТекста)</a></li>
        <li><a href="#txt2">Читаем текстовый файл TXT, пример 2(использование синх методов ТекстовыйДокумент)</a></li>
        <li><a href="#txt3">Пишем в текстовый файл TXT пример 1(использование синх методов ТекстовыйДокумент)</a></li>
        <li><a href="#txt4">Пишем в текстовый файл TXT пример 2(использование синх методов ТекстовыйДокумент)</a></li>
        <li><a href="#txt4-1">Пишем в текстовый файл TXT пример 3(использование синх методов ЗаписьТекста)</a></li>
        <li><a href="#txt5">Читаем текстовый файл TXT, пример 3(использование асинх методов)</a></li>
        <li><a href="#txt6">Пишем в текстовый файл TXT, пример 3(использование асинх методов)</a></li>
        <li><a href="#csv">Читаем текстовый файл CSV</a></li>
        <li><a href="#xlsx">Читаем файл Excel</a></li>
        <li><a href="#xlsx2">Пишем в файл Excel</a></li>
        <li><a href="#dbf">Читаем файл DBF</a></li>
        <li><a href="#xml">Читаем файл XML(классы ЧтениеXML и XDTO)</a></li>
        <li><a href="#xml-2">Выгрузка данных из 1С в XML(класс ЗаписьXML)</a></li>
        <li><a href="#xml-3">Выгрузка и загрузка сложных типов данных из 1С в XML(класс ЗаписьXML и глоб. метод ЗаписатьXML/ПрочитатьXML)</a></li>
        <li><a href="#xdto">XDTO</a></li>
        <li><a href="#html">Читаем файл HTML</a></li>
        <li><a href="#http">Работа с HTTP</a></li>
        <li><a href="#ftp">Читаем с помощью FTP данные с сайта</a></li>
        <li><a href="#zip">Архивируем файл в zip формате</a></li>
        <li><a href="#json">Читаем файл JSON</a></li>
        <li><a href="#json2">Пишем в файл JSON</a></li>
        <li><a href="#mail">Работа с внешней почтой и встроенной почтой</a></li>
        <li><a href="#com">Работа 1С с COM объектами</a></li>
        <li><a href="#web-service">Работа с веб-сервисами. Объект "WSСсылка"</a></li>
        <li><a href="#web-service2">Работа с веб-сервисами. Объект "Web-сервисы"</a></li>
        <li><a href="#http-service">Работа 1С с http-сервисами</a></li>
        <li><a href="#plan-obmena">Работа с планами обмена</a></li>
        <li><a href="#read-file-on-server">Чтение файла на стороне сервера. Класс ДвоичныеДанные.</a></li>
        <li><a href="#abc">Чтение файла со списком контрагентов и запись их в справочник Контрагенты</a></li>
        <li><a href="#abc2">Заполнение контрагента по ИНН. Добавляем расширение в типовую конфу. Используются HTTP объекты. Используется чтение JSON</a></li>
        <li><a href="#"><span class="светло_красный">Нужно подробно описать XML, XML Schema, XDTO пакеты. Пока что-то внятных курсов не нашёл, нужно искать</a></li>
        <li><a href="#"></a></li>
        <li><a href="#"></a></li>
    </ul>







    
    <h2 class="header-style" id="1">Что следует изучать в области обмена данными 1с и других систем</h2>
    <p>Для специализации в области интеграции 1С с другими системами рекомендуется изучить следующие темы:</p>
    <ul class="list">
        <li>Технологии OLE и COM.</li>
        <li>Работа с XML-документами.</li>
        <li>Создание веб-сервисов средствами 1С:Предприятия.</li>
        <li>Настройка обмена данными и перенос объектов.</li>
        <li>Использование REST API для интеграции 1С и других систем.</li>
        <li>Создание собственных правил конвертации и редактирование правил обмена в типовых конфигурациях.</li>
        <li>Загрузка данных из табличного документа.</li>
        <li>Настройка конвертации объектов при онлайн-обмене.</li>
    </ul>






    <h2 class="header-style" id="dialog-select-files">Диалог выбора файла</h2>
    <p>Диалог выбора файла это окно выбора файла при нажатии команды на открытие этого окна. Диалоги бывают разные: выбор, сохраниение и выбор папки(каталога). Не буду всё описывать, я создам обработку "РаботаСДиалогами" в базе "Учебная база(Курс Камков - Основные объекты)". Там будут все примеры работы с диалогами не только файлов.</p>
    <p>Когда пользователь видит окно выбора файла и выбирает его, то диалог не загружает файл, а копирует путь до этого файла. Так как диалог это взаимодействие с пользователем, то код команды будет только на стороне клиента. Объект, с помощью которого и осуществляется выбор файла, называется ДиалогВыбораФайла. В справке его можно найти Общие объекты -> Работа с файлами -> ДиалогВыбораФайла.</p>
    <p>Нужно создать объект от класса ДиалогВыбораФайла и задать режим работы диалога(это системное перечисление(РежимДиалогаВыбораФайла) дающее на выбор 3 режима: открытие, выбор каталога и сохранение. У созданного объекта есть ряд настроек(свойств), например, Заголовок - это то что будет в заголовке окна выбора файла, Каталог - заранее можем спозиционировать окно в выбранном каталоге, Фильтр( <a href="#filter">подробнее</a> ) - это настройка по форматам файлов(только текстовые файлы, только картинки и т.д.) ну и т.д. Там в справке можно почитать про разные свойства.</p>
    <p>После того как мы создали объект от ДиалогВыбораФайла, нам нужно показать его пользователю. Для этого есть 3 метода: Выбрать(), ВыбратьАсинх() и Показать. Это вообще все методы, что есть у этого объекта. Использовать будем метод Показать(), почему не Выбрать(), потому что Выбрать() это синхронный метод, остальные 2 асинхронные, но будем использовать Показать(). Параметр у этого метода только 1 это ОписаниеОповещения(процедура отложенного вызова).</p>
    <div class="code-style">
        <pre>
            --Выбор файла
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ВыбратьФайл<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла.Открытие<span class="светло_красный">)</span>;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span>"ПослеВыбораФайла", ЭтотОбъект<span class="светло_красный">)</span>;
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры 

            &НаКлиенте
            Процедура</span> ПослеВыбораФайла<span class="светло_красный">(</span>ВыбранныеФайлы, Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//переменная ВыбранныеФайлы это массив с путями до файлов/а, либо Неопределено
                //по умолчанию всегда будет возвращаться 1 файл в массиве, потому что
                //у объекта Проводник есть свойство МножественныйВыбор и у него стоит Ложь</span>
                <span class="светло_красный">Если</span> ВыбранныеФайлы <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда
                    Возврат;
                КонецЕсли;</span>

                ПутьКФайлу <span class="светло_красный">=</span> ВыбранныеФайлы<span class="светло_красный">[</span>0<span class="светло_красный">]</span>;
                Сообщить<span class="светло_красный">(</span>ПутьКФайлу<span class="светло_красный">)</span>;
                <span class="зелёный">//ну и далее что то делаем с этим файлом: читаем программно, записываем в него или ещё что то</span>
            <span class="светло_красный">КонецПроцедуры</span></span>


            --Выбор каталога(папки)
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ВыбратьКаталог<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                <span class="зелёный">//применить фильтр к выбору папки мы не можем, папка она и в Африке папка</span>
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>ВыборКаталога<span class="светло_красный">)</span>;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span>"ПослеВыбораКаталога", ЭтотОбъект<span class="светло_красный">)</span>;
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры 

            &НаКлиенте
            Процедура</span> ПослеВыбораКаталога<span class="светло_красный">(</span>ВыбранныеПапки, Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//переменная ВыбранныеПапки это массив с путями до папок, либо Неопределено</span>
                <span class="светло_красный">Если</span> ВыбранныеПапки <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли;</span>

                ПутьКПапке <span class="светло_красный">=</span> ВыбранныеПапки<span class="светло_красный">[</span>0<span class="светло_красный">]</span>;
                Сообщить<span class="светло_красный">(</span>ПутьКПапке<span class="светло_красный">)</span>;
                <span class="зелёный">//ну и далее что то делаем с этим путём до папки</span>
            <span class="светло_красный">КонецПроцедуры</span></span>

            --Это второй способ для диалога через функцию ВыбратьАсинх(). Она делает то же  
            --что и Показать() с оповещением
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Асинх Процедура</span> ВыбратьКаталог<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                Проводник = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);

                ВыбранныеФайлы = <span class="светло_красный">Ждать</span> Проводник.ВыбратьАсинх();
            
                Если ВыбранныеФайлы &lt;> Неопределено Тогда
                    Каталог = ВыбранныеФайлы[0]; 
                    ...   
                КонецЕсли;
            <span class="светло_красный">КонецПроцедуры</span></span>




            --Сохранение файла
            --Что тут понимается под сохранением файла. При отработке этого кода, откроется окно
            --как и при выборе файла, только с кнопкой "Сохранить". В поле вводим имя файла и жмём Сохранить
            --и в переменную ПутьКФайлу попадает путь этого файла, куда мы сохранили. Пока не понимаю
            --для чего это нам нужно. Мы в файл что то можем записать и затем сохранять? Или мы так создаём новый
            --файл? Короче как станет более понятно допишу.
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> СохранитьФайл<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Сохранение<span class="светло_красный">)</span>;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span>"ПослеСохранения", ЭтотОбъект<span class="светло_красный">)</span>;
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры 

            &НаКлиенте
            Процедура</span> ПослеСохранения<span class="светло_красный">(</span>ВыбранныеФайлы, Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//переменная ВыбранныеФайлы это массив с путями сохранённых файлов, либо Неопределено</span>
                <span class="светло_красный">Если</span> ВыбранныеФайлы <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли;</span>

                ПутьКФайлу <span class="светло_красный">=</span> ВыбранныеФайлы<span class="светло_красный">[</span>0<span class="светло_красный">]</span>;
                Сообщить<span class="светло_красный">(</span>ПутьКФайлу<span class="светло_красный">)</span>;
            <span class="светло_красный">КонецПроцедуры</span></span>
        </pre>
    </div>

    <p id="filter">Теперь более подробно поговорим про настройки объекта Проводник(выше в коде переменная) в режиме РежимДиалогаВыбораФайла.Открытие. Есть такое свойство как Фильтр, которое позволяет указать формат выбираемого файла. Когда открывается окно выбора файла, нам ОС показывает все файлы в текущей папке, но вверху справа есть поле поиска(Винда 10). Если в этом поле вписать маску "*.txt", то останутся файлы в папке только с таким расширением. Нам нужно программно в свойстве Фильтр задать такие маски. В Фильтр нужно передать строку из 2х частей: "имя фильтра|маска". Пример - "Текстовый документ (*.txt)|*.txt". Если же нам нужно несколько фильтров, то передаётся такая строка - "Текстовый документ (*.txt)|*.txt|Табличный документ (*.mxl)|*.mxl". Фильтры в строке между собой тоже отделяются прямой чертой. И теперь в окне выбора файла внизу справа над кнопками появится меню выбора фильтров. Там теперь можно выбирать какой фильтр применить к файлам, если фильтров больше 2х.</p>
    <p>Также есть возможность указать в одном фильтре несколько форматов. Для этого маски разделяются ";". Бывает нужно выбрать картинки, а картинки в разных форматах и хочется все картинки отобразить, в этом случае поможет такой способ задания масок: "Картинки|*.jpg;*.png;*.jpeg;*.gif".</p>
    <div class="code-style">
        <pre>
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ВыбратьФайл<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Открытие<span class="светло_красный">)</span>;
                ФильтрТекстовыхФайлов <span class="светло_красный">=</span> <span class="серый">"Текстовый документ (*.txt)|*.txt|CSV-файл|*.csv"</span><span class="светло_красный">;</span>
                ФильтрКартинок <span class="светло_красный">=</span> <span class="серый">"Картинки|*.jpg;*.png;*.jpeg;*.gif"</span><span class="светло_красный">;</span>
                Проводник.Фильтр <span class="светло_красный">=</span> ФильтрТекстовыхФайлов;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="серый">"ПослеВыбораФайла"</span>, ЭтотОбъект<span class="светло_красный">)</span>;
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры </span></span>

            --Далее там процедура оповещения
        </pre>
    </div>










    <h2 class="header-style" id="dialog-enter-str">Диалог ввода строки</h2>
    <p>Эта глобальная функция(ВвестиСтроку или ВвестиСтрокуАсинх) позволяет вывести пользователю окно для ввода строки от него. Пример получения от пользователя ИНН:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            <span class="светло_красный">Асинх Процедура</span> IS_ЗаполнитьПоИНН(Команда)
                ИНН = <span class="светло_красный">Ждать</span> ВвестиСтрокуАсинх(, "Введите ИНН", 12); 
                
                Если ИНН = Неопределено Тогда
                    Возврат;
                КонецЕсли;

                Если СтрДлина(ИНН) &lt; 10 Тогда
                
                КонецЕсли;
            <span class="светло_красный">КонецПроцедуры</span>
        </pre>
    </div>
    <p>Также есть и диалоги для ввода числа, значения, даты.</p>










    
    <h2 class="header-style" id="dialog-select-color">Диалог выбора цвета</h2>
    <p>Когда мы для какого то объекта конфы создаём реквизит и задаём ему тип, то выбор типов один, но когда мы для этого же объекта создадим форму и в форме на закладке "Реквизиты" создадим реквизит и выберем ему тип, то тут типы более расширены. В этом расшеренном списке есть такой тип как "Цвет". Создам в обработке "РаботаСДиалогами" в форме реквизит ВыбратьЦвет и задам ему тип "Цвет". Это простой способ выбора цвета. Также мы можем программно открывать такое окно выбора по нажатию на кнопку "ВыбратьЦвет". Для этих целей есть класс "ДиалогВыбораЦвета".</p>
    <div class="code-style">
        <pre>
            --Выбор цвета программно
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ВыбратьЦветПрограммно<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                ВыборЦвета <span class="светло_красный">= Новый</span> ДиалогВыбораЦвета;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеВыбораЦвета"</span>, ЭтотОбъект<span class="светло_красный">)</span>;
                ВыборЦвета<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеВыбораЦвета<span class="светло_красный">(</span>ВыбранныйЦвет, Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//в переменную ВыбранныйЦвет попадает либо объект Цвет, либо Неопределено
                //объект Цвет имеет 4 свойства: Вид, Зеленый, Красный, Синий</span>	
                <span class="светло_красный">Если</span> ВыбранныйЦвет <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли;</span>	
                
                <span class="зелёный">//если в окне мышкой выбрать цвет, то увидим в сообщении -1, -1, -1. Такой вид цвета называется "Элемент стиля"
                //если же руками вбить все 3 цвета, то покажет эти цифры какие мы вбили. Такой вид цвета называется "Абсолютным"
                //для чего так сделано пока не знаю. В видео тоже не рассказали </span> 
                Сообщить<span class="светло_красный">(</span><span class="светло_синийl">"Выбран цвет: "</span> <span class="светло_красный">+</span> ВыбранныйЦвет<span class="светло_красный">.</span>Красный <span class="светло_красный">+</span> <span class="светло_синийl">", "</span> <span class="светло_красный">+</span> ВыбранныйЦвет<span class="светло_красный">.</span>Зеленый <span class="светло_красный">+</span> <span class="светло_синийl">", "</span> <span class="светло_красный">+</span> ВыбранныйЦвет<span class="светло_красный">.</span>Синий<span class="светло_красный">)</span>;
            <span class="светло_красный">КонецПроцедуры</span></span>
        </pre>
    </div>
















    <h2 class="header-style" id="dialog-select-font">Диалог вобора шрифта</h2>
    <p>Диалог цвета, диалог шрифта нужны в те моменты, когда пользователю нужно оформить содержимое какого то поля или каких то строк.</p>
    <div class="code-style">
        <pre>
            --Диалог шрифта
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ВыбратьШрифт<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                ВыборШрифта <span class="светло_красный">= Новый</span> ДиалогВыбораШрифта;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеВыбораШрифта"</span>, ЭтотОбъект<span class="светло_красный">)</span>;
                ВыборШрифта<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;
            <span class="светло_красный">КонецПроцедуры  

            &НаКлиенте
            Процедура</span> ПослеВыбораШрифта<span class="светло_красный">(</span>ВыбранныйШрифт<span class="светло_красный">,</span> Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//в переменную ВыбранныйШрифт ложится также Объект Шрифт и он уже имеет побольше свойств
                //если что смотреть в справке</span>	
                <span class="светло_красный">Если</span> ВыбранныйШрифт <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли</span>;	
                
                Сообщить<span class="светло_красный">(</span><span class="светло_синийl">"Выбран шрифт: "</span> <span class="светло_красный">+</span> ВыбранныйШрифт<span class="светло_красный">.</span>Имя <span class="светло_красный">+</span> <span class="светло_синийl">", размер: "</span> <span class="светло_красный">+</span> ВыбранныйШрифт<span class="светло_красный">.</span>Размер<span class="светло_красный">)</span>;	
            КонецПроцедуры</span></span>
        </pre>
    </div>













    
    <h2 class="header-style" id="dialog-edit-period">Диалог выбора стандартного периода</h2>
    <p>Тут как и с цветом можно создать в форме реквизит и задать ему тип "Стандартный переод", а можно программно по кнопке вызывать этот диалог. Этот диалог позволяет пользователю выбирать начало и конец периода. Программно задать период позволяет класс ДиалогРедактированияСтандартногоПериода.</p>
    <div class="code-style">
        <pre>
            --Диалог стандартного периода
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ВыбратьПериодПрограммно<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                ВыборПериода <span class="светло_красный">= Новый</span> ДиалогРедактированияСтандартногоПериода<span class="светло_красный">()</span>;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеВыбораПериода"</span>, ЭтотОбъект<span class="светло_красный">)</span>;
                ВыборПериода<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;
            <span class="светло_красный">КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеВыбораПериода<span class="светло_красный">(</span>ВыбранныйПериод, Параметры<span class="светло_красный">) Экспорт</span>
                <span class="светло_красный">Если</span> ВыбранныйПериод <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли</span>;	
                
                Сообщить<span class="светло_красный">(</span><span class="светло_синийl">"Выбран период: "</span> <span class="светло_красный">+</span> ВыбранныйПериод<span class="светло_красный">.</span>ДатаНачала <span class="светло_красный">+</span> <span class="светло_синийl">" - "</span> <span class="светло_красный">+</span> ВыбранныйПериод<span class="светло_красный">.</span>ДатаОкончания<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры</span></span>
        </pre>
    </div>













    work-files
    <h2 class="header-style" id="work-files">Подготовка к работе с файлами</h2>
    <p>Видео, с которого описываю эту тему 3 в списке проигрывания.</p>
    <p>На практике часто нужно работать с данными, которые храняться в фалах. Эти работы можно поделить на 2 типа. Первый это загрузка данных из файлов и второй это выгрузка данных в файлы. Начнём с первого.</p>
    <p>При загрузке данных из файлов нужно знать, что загружать данные можно несколькими способами. Пользователь может через диалог выбрать путь до файла и нажать загрузить и произойдёт загрузка в БД. А можно и без участия пользователя загружать, например, алгоритм сам в определённое время по заранее известному пути загрузит данные из файла и запишет в БД. Мы будем рассматривать способ с пользователем. Программный способ сильно не отличается, там просто не нужно работать с формой.</p>
    <p>Загрузка данных из файла происходит в 2 этапа: 1) прочитать файл, показать данные пользователю, 2) Записать данные в БД(только если пользователь согласился их записывать, вдруг файл не тот выбрал). НЕ ПРАВЛЬНО делать так, когда пользователь выбрал файл и нажал на кнопку и произошла запись в БД, потому что у пользователя нет способа отказаться от загрузки данных. Вот так правильно:</p>
    <img src="../img/1С-1/2023-02-01_21-46-13.png" class="screen" alt="">
    <p>Создадим обработку "ЧтениеРазныхФайлов" и в ней будем читать разные форматы файлов. Обработка также в базе Камкова "Основные объекты". Хочу отметить, что когда создавали табличную часть "ДанныеФайла", то убрали командную панль(панель где кнопка "Добавить, поиск и ещё что то"). Убрали так. Выделяем табличную часть слева в элементах формы и в свойствах убираем <span class="светло_синий">галочку "Автозаполнение"</span>. Также у табличной части убрали поле "Номер строки", просто выделил поле в нижнем окне, где форма показана и через контекстное меню удалил. Ну и убрали командную панель у самой формы, это та панель где в пользовательской части вверху слева есть кнопка "Ещё", убрали точно также, сняв <span class="светло_синий">галочку "Автозаполнение"</span>.</p>
    <p>Далее хочу ещё отметь как сделали так, чтобы у поля "ПутьКФайлу" появилась справа кнопка выбора. Для этого выделим это поле и в его свойствах найдём <span class="светло_синий">параметр "КнопкаВыбора"</span> и поставим ей значение Да. Спрва от поля появится кнопочка с 3мя точками.</p>
    <p>Также у нас есть поле "ФорматФайла". Можно создать заранее Перечисление "ФорматыФайлов" и него указать 6 форматов, затем назначим тип для поля "ФорматФайла" ПеречислениеСсылка.ФорматыФайлов. Затем в свойствах поля в параметре "СписокВыбора" заполняем по кнопке "Заполнить" и из перечисления заполнятся все наши форматы. Ну и также выберем отображение в виде тумблера. Если же не делали объект Перечисление с форматами, то также в <span class="светло_синий">параметре "СписокВыбора"</span> ручками заполняем форматы. Нажимает на полюсик, ввели имя формата, опять полюсик - имя и т.д.</p>
    <p>Ещё одно замечание. Нужно пользователю запретить добавлять новую строку в табличную часть, хотя как он может её добавить, если кнопка "Добавить" уже убрана? Ну всё равно упомяну эту возможность. Есть такой <span class="светло_синий">параметр "ИзменитьСоставСтрок"</span> в свойствах табличной части, вот там тоже галочку снимаем.</p>
    <p>Продолжаем. У поля "Путь к файлу" есть событие "НачалоВыбора", оно и сработает при клике по кнопке "...", поэтому вешаем обработчик на это событие на клиенте.</p>
    <div class="code-style">
        <pre>
            --По клику на кнопку "..." поля "ПутьКФайлу" срабатывает событие НачалоВыбора 
            --и по этому событию отработает этот обработчик
            --Обработчик открывает диалог выбора файла и применяет фильтр. 
            --После выбора файла поле "ПутьКФайлу" сохраняет путь до файла в себе,
            --а поле "ФорматФайла" сохраняет в себе строку с форматом
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ПутьКФайлуНачалоВыбора<span class="светло_красный">(</span>Элемент, ДанныеВыбора, СтандартнаяОбработка<span class="светло_красный">)</span>
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Открытие<span class="светло_красный">)</span>;
                Проводник<span class="светло_красный">.</span>Заголовок <span class="светло_красный">=</span> <span class="светло_синийl">"Выберите файл с контрагентами"</span>; 
                
                <span class="светло_красный">Если</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"TXT"</span> <span class="светло_красный">Тогда</span>
                    ЗначениеФильтра <span class="светло_красный">=</span> <span class="светло_синийl">"Текстовый документ (*.txt)|*.txt"</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"CSV"</span> <span class="светло_красный">Тогда</span>
                    ЗначениеФильтра <span class="светло_красный">=</span> <span class="светло_синийl">"Текстовый документ (*.csv)|*.csv"</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"XLS"</span> <span class="светло_красный">Тогда</span>
                    ЗначениеФильтра <span class="светло_красный">=</span> <span class="светло_синийl">"Файл Excel (*.xls)|*.xls"</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"DBF"</span> <span class="светло_красный">Тогда</span>
                    ЗначениеФильтра <span class="светло_красный">=</span> <span class="светло_синийl">"Таблица DBF (*.dbf)|*.dbf"</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"XML"</span> <span class="светло_красный">Тогда</span>
                    ЗначениеФильтра <span class="светло_красный">=</span> <span class="светло_синийl">"Файл XML (*.xml)|*.xml"</span>;
                <span class="светло_красный">Иначе</span>
                    Возврат;
                <span class="светло_красный">КонецЕсли</span>;

                Проводник<span class="светло_красный">.</span>Фильтр <span class="светло_красный">=</span> ЗначениеФильтра;

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеВыбораФайла"</span>, ЭтотОбъект<span class="светло_красный">)</span>;
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">)</span>;	
            <span class="светло_красный">КонецПроцедуры 

            &НаКлиенте
            Процедура</span> ПослеВыбораФайла<span class="светло_красный">(</span>ВыбранныеФайлы, Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//переменная ВыбранныеФайлы это массив с путями до файлов/а, либо Неопределено
                //по умолчанию всегда будет возвращаться 1 файл в массиве, потому что
                //у объекта Проводник есть свойство МножественныйВыбор и у него стоит Ложь</span>
                <span class="светло_красный">Если</span> ВыбранныеФайлы <span class="светло_красный">=</span> Неопределено <span class="светло_красный">Тогда</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли</span>;

                <span class="зелёный">//мы записали путь до файла в поле ПутьКФайлу, дальше будем читать разные файлы
                //беря путь из этого поля</span>
                Объект<span class="светло_красный">.</span>ПутьКФайлу <span class="светло_красный">=</span> ВыбранныеФайлы<span class="светло_красный">[</span>0<span class="светло_красный">]</span>;
            <span class="светло_красный">КонецПроцедуры</span></span>

            --у нас есть формат, у нас есть путь, теперь нужно прочитать файл по этому пути
            --Вызываем соответсвующие процедуры, они описаны ниже
            <span class="светло_синий"><span class="r">&НаКлиенте
            Процедура</span> ПрочитатьФайл<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                <span class="светло_красный">Если</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"TXT"</span> <span class="светло_красный">Тогда</span>
                    ПрочитатьФайлTXT<span class="светло_красный">()</span>;	
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"CSV"</span> <span class="светло_красный">Тогда</span>
                    ПрочитатьФайлCSV<span class="светло_красный">()</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"XLSX"</span> <span class="светло_красный">Тогда</span>
                    ПрочитатьФайлXLSX<span class="светло_красный">()</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"DBF"</span> <span class="светло_красный">Тогда</span>
                    ПрочитатьФайлDBF<span class="светло_красный">()</span>;
                <span class="светло_красный">ИначеЕсли</span> Объект<span class="светло_красный">.</span>ФорматФайла <span class="светло_красный">=</span> <span class="светло_синийl">"XML"</span> <span class="светло_красный">Тогда</span>
                    ПрочитатьФайлXML<span class="светло_красный">()</span>;
                <span class="светло_красный">Иначе</span>
                    <span class="светло_красный">Возврат</span>;
                <span class="светло_красный">КонецЕсли</span>;	
            <span class="светло_красный">КонецПроцедуры</span> </span>
        </pre>
    </div>










    <h2 class="header-style" id="txt-base">Частоиспользуемые методы класса "ТекстовыйДокумент"</h2>
    <p>Вот по этой ссылке показаны разные способы использования этого класса - <a href="https://helpme1s.ru/rabota-s-tekstovym-dokumentom-v-yazyke-1s-8-3-8-2-v-primerax">тут</a></p>











    <h2 class="header-style" id="txt">Читаем текстовый файл TXT, пример 1(использование синхронных методов)</h2>
    <p>Чтобы прочитать текстовый файл, во встроенном языке нам нужны 2 объекта.</p>
    <ul class="list">
        <li><b>ТекстовыйДокумент</b> - файл считывается целицом и далее с помощью цикла построчно можно обработать его. Подходит для работы с небольшими файлами. Про объект можно почитать в справочнике по пути Общие объекты -> Текстовый документ.</li>
        <li><b>ЧтениеТекста</b> - предназначен для последовательного чтения текстовых файлов большой длины.</li>
    </ul>
    <div class="code-style">
        <pre>
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ПрочитатьФайлTXT<span class="светло_красный">()</span>
                <span class="зелёный">//примером текстового файла будет Список контрагентов. В каждой строке файла задано
                //краткое наименование контрагентов, полное наименование и УМП контрагентов
                //все 3 части разделены ";" </span>

                Объект<span class="светло_красный">.</span>ДанныеФайла<span class="светло_красный">.</span>Очистить<span class="светло_красный">();</span>

                <span class="зелёный">//эта переменная будет выступать переключателем. Как читать файл челиком или по строчно</span>
                ПоследовательноеЧтение <span class="светло_красный">=</span> Истина<span class="светло_красный">;</span>
                
                <span class="зелёный">//тут 2 способа читать текстовый файл</span>
                <span class="светло_красный">Если НЕ</span> ПоследовательноеЧтение <span class="светло_красный">Тогда</span>
                    <span class="зелёный">//1й способ
                    //класс ТекстовыйДокумент позволяет считать файл целиком и далее в цикле разбирать по строкам</span>
                    Текст <span class="светло_красный">= Новый</span> ТекстовыйДокумент<span class="светло_красный">;</span>
                    
                    <span class="зелёный">//метод синхронный, не будет работать, если выключено использование синхронных методов в конфе
                    //1й параметр это путь до файла
                    //2й параметр это тип файла, указываем кодировку текста, в котором будет выполняться чтение. По умолчанию UTF8
                    //3й параметр это раздилитель строк</span>
                    Текст<span class="светло_красный">.</span>Прочитать<span class="светло_красный">(</span>Объект<span class="светло_красный">.</span>ПутьКФайлу<span class="светло_красный">);</span>

                    <span class="зелёный">//обход строк текста в цикле</span>
                    <span class="светло_красный">Для</span> НомерСтроки <span class="светло_красный">=</span> 1 <span class="светло_красный">По</span> Текст<span class="светло_красный">.</span>КоличествоСтрок<span class="светло_красный">() Цикл</span>
                        ТекущаяСтрока <span class="светло_красный">=</span> Текст<span class="светло_красный">.</span>ПолучитьСтроку<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">);</span>
                        
                        <span class="зелёный">//нам нужно строку разделить по ";". Если в строке меньше 3х частей, то будем считать
                        //такую строку ошибочной и будем её пропускать</span>
                        МассивЧастей  <span class="светло_красный">=</span> СтрРазделить<span class="светло_красный">(</span>ТекущаяСтрока<span class="светло_красный">,</span> ";"<span class="светло_красный">);</span>
                        <span class="светло_красный">Если</span> МассивЧастей<span class="светло_красный">.</span>Количество<span class="светло_красный">() &lt;</span> 3 <span class="светло_красный">Тогда
                            Продолжить;	
                        КонецЕсли;</span> 
                        
                        <span class="зелёный">//в табличную часть добавляем новую строку
                        //и колонкам этой строки задаём части массива</span>
                        НоваяСтрока <span class="светло_красный">=</span> Объект<span class="светло_красный">.</span>ДанныеФайла<span class="светло_красный">.</span>Добавить<span class="светло_красный">();</span>
                        НоваяСтрока<span class="светло_красный">.</span>КраткоеНаименование <span class="светло_красный">=</span> МассивЧастей<span class="светло_красный">[</span>0<span class="светло_красный">];</span>
                        НоваяСтрока<span class="светло_красный">.</span>ПолноеНаименование <span class="светло_красный">=</span> МассивЧастей<span class="светло_красный">[</span>1<span class="светло_красный">];</span>
                        НоваяСтрока<span class="светло_красный">.</span>УНП <span class="светло_красный">=</span> МассивЧастей<span class="светло_красный">[</span>2<span class="светло_красный">];
                    КонецЦикла;
                Иначе</span>  
                    <span class="зелёный">//2й способ
                    //класс ЧтениеТекста предназначен для поледовательного чтения текстовых файлов большой длины
                    //также есть возмжность читать по несколько букв. Для этого есть метод Прочитать(14), прочитает 14 букв в строке</span>
                    Текст <span class="светло_красный">= Новый</span> ЧтениеТекста<span class="светло_красный">;</span>
                    Текст<span class="светло_красный">.</span>Открыть<span class="светло_красный">(</span>Объект<span class="светло_красный">.</span>ПутьКФайлу<span class="светло_красный">);</span>
                    
                    <span class="зелёный">//разделитель не указываем, по умолчанию разделяются строки по переносу строки(\r\n или \n)</span>
                    ТекущаяСтрока <span class="светло_красный">=</span> Текст<span class="светло_красный">.</span>ПрочитатьСтроку<span class="светло_красный">();</span>
                    <span class="зелёный">//используем цикл Пока, потому что не известно число строк в файле</span>
                    <span class="светло_красный">Пока</span> ТекущаяСтрока <span class="светло_красный">&lt;> Неопределено Цикл</span>
                        МассивЧастей  <span class="светло_красный">=</span> СтрРазделить<span class="светло_красный">(</span>ТекущаяСтрока<span class="светло_красный">,</span> ";"<span class="светло_красный">);</span>
                        <span class="светло_красный">Если</span> МассивЧастей<span class="светло_красный">.</span>Количество<span class="светло_красный">() &lt;</span> 3 <span class="светло_красный">Тогда
                            Продолжить;	
                        КонецЕсли;</span> 
                        
                        НоваяСтрока <span class="светло_красный">=</span> Объект<span class="светло_красный">.</span>ДанныеФайла<span class="светло_красный">.</span>Добавить<span class="светло_красный">();</span>
                        НоваяСтрока<span class="светло_красный">.</span>КраткоеНаименование <span class="светло_красный">=</span> МассивЧастей<span class="светло_красный">[</span>0<span class="светло_красный">];</span>
                        НоваяСтрока<span class="светло_красный">.</span>ПолноеНаименование <span class="светло_красный">=</span> МассивЧастей<span class="светло_красный">[</span>1<span class="светло_красный">];</span>
                        НоваяСтрока<span class="светло_красный">.</span>УНП <span class="светло_красный">=</span> МассивЧастей<span class="светло_красный">[</span>2<span class="светло_красный">];</span>

                        <span class="зелёный">//считываем следующую строку</span>
                        ТекущаяСтрока <span class="светло_красный">=</span> Текст<span class="светло_красный">.</span>ПрочитатьСтроку<span class="светло_красный">();	
                    КонецЦикла;
                КонецЕсли;	
            КонецПроцедуры</span></span>
        </pre>
    </div>











    <h2 class="header-style" id="txt2">Читаем текстовый файл TXT, пример 2(использование синхронных методов)</h2>
    <p>Продолжим тот же пример с обработкой "Консоль запросов", что я описал выше, где мы писали в файл текст запроса из текстового документа этой обработки. Теперь нужно ранее записанный в файл текст запроса вставить в поле текстовго документа в обработке.</p>
    <img src="../img/1С-1/2023-11-22_18-47-58.png" class="screen" alt="">
    <div class="code-style">
        <pre>
            --модуль формы обработки "Консоль запросов"

            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ЗагрузитьТекстЗапроса<span class="светло_красный">(</span>Команда)
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Открытие<span class="светло_красный">);</span>

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеОткрытия"</span><span class="светло_красный">,</span> ЭтотОбъект<span class="светло_красный">);</span>
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">);
            КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеОткрытия<span class="светло_красный">(</span>ВыбранныеФайлы<span class="светло_красный">,</span> Параметры<span class="светло_красный">) Экспорт</span>
                ТекстовыйФайл <span class="светло_красный">= Новый</span> ТекстовыйДокумент<span class="светло_красный">;</span>
                
                <span class="зелёный">//Читаем с файла, в переменной ВыбранныеФайлы массив с 
                //путями выбранных файлов, в данном примере там только один элемент с путём</span>
                ТекстовыйФайл<span class="светло_красный">.</span>Прочитать<span class="светло_красный">(</span>ВыбранныеФайлы<span class="светло_красный">[</span>0<span class="светло_красный">]);</span>

                <span class="зелёный">//Очистим от предыдущих записей тестовый документ</span>
                ТекстЗапроса<span class="светло_красный">.</span>Очистить<span class="светло_красный">();</span>

                <span class="светло_красный">Для</span> НомерСтроки <span class="светло_красный">=</span> 1 <span class="светло_красный">По</span> ТекстовыйФайл<span class="светло_красный">.</span>КоличествоСтрок<span class="светло_красный">() Цикл</span>
                    ТекущаяСтрока <span class="светло_красный">=</span> ТекстовыйФайл<span class="светло_красный">.</span>ПолучитьСтроку<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">);</span>
                    
                    ТекстЗапроса<span class="светло_красный">.</span>ДобавитьСтроку<span class="светло_красный">(</span>ТекущаяСтрока<span class="светло_красный">);	
                КонецЦикла;	
            КонецПроцедуры</span></span>
        </pre>
    </div>












    <h2 class="header-style" id="txt3">Пишем в текстовый файл TXT пример 1(использование синхронных методов)</h2>
    <p>Разберём такой пример, есть внешняя обработка "Консоль запросов" и в ней есть кнопка сохранения текста запроса в текстовый файл на компьюторе. Код будет работать так, мы жмём на кнопку сохранить и на компьютор в указанную папку в коде мы сохраняем текст запроса в также в указанный файл в коде. Т.е. у нас нет возможности выбрать папку и имя файла, мы пишем на рабочий стол в заранее определенную папку и в файл. Пока я не знаю как сделать так, чтобы вывести форму с полем ввода для ввода имени файла и записать в файл с введённым именем. Как узнаю изменю немного код.</p>
    <p><span class="светло_красный">Узнал как сделать доп. форму с вводом имени файла и запись в этот файл текста запроса, описал этот пример в статье "Пишем в текстовый файл TXT способ 3"</span></p>
    <div class="code-style">
        <pre>
            --модуль формы обработки "Консоль запросов"

            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> СохранитьТекстЗапроса<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                <span class="зелёный">//я хочу сохранять в файл на рабочем столе, но на разных компах своё имя пользователя
                //Есть такой метод как  КаталогВРеменныхФайлов(), он возвращает путь до временной папки
                //пользователя, мы отрезает в конце путь до этой папки и подставляем рабочий стол
                //и получим, что где бы не запустилась обработка, мы сможем сохранить на рабочий стол. </span>
                Путь <span class="светло_красный">=</span> КаталогВРеменныхФайлов<span class="светло_красный">();</span> <span class="зелёный">//это синхронный метод</span>
                Путь <span class="светло_красный">=</span> СтрЗаменить<span class="светло_красный">(</span>Путь<span class="светло_красный">,</span> <span class="светло_синийl">"AppData\Local\Temp\"</span><span class="светло_красный">,</span> <span class="светло_синийl">"Desktop\"</span><span class="светло_красный">);</span>
                Путь <span class="светло_красный">=</span> Путь <span class="светло_красный">+</span> <span class="светло_синийl">"Тексты запросов"</span><span class="светло_красный">;</span>

                <span class="зелёный">//этот метод создаёт папку по указанному пути, создаваемая папка также 
                //должны быть указана в пути, здесть это "Тексты запросов" папка</span>
                СоздатьКаталог<span class="светло_красный">(</span>Путь<span class="светло_красный">);</span><span class="зелёный">//это синхронный метод</span>

                ТекстовыйФайл <span class="светло_красный">= Новый</span> ТекстовыйДокумент<span class="светло_красный">;</span>
            
                <span class="зелёный">// Устанавливаем содержимое файла.</span>
                ТекстовыйФайл<span class="светло_красный">.</span>УстановитьТекст<span class="светло_красный">(</span>ТекстЗапроса<span class="светло_красный">.</span>ПолучитьТекст<span class="светло_красный">());</span>

                <span class="зелёный">// Записываем файл на диск.
                // Если такой файл уже существует - он будет перезаписан.</span>
                ТекстовыйФайл<span class="светло_красный">.</span>Записать<span class="светло_красный">(</span>Путь <span class="светло_красный">+</span> <span class="светло_синийl">"\ТекстЗапроса1.txt"</span><span class="светло_красный">);<span class="зелёный">//это синхронный метод</span>
            КонецПроцедуры</span></span>
        </pre>
    </div>















    <h2 class="header-style" id="txt4">Пишем в текстовый файл TXT пример 2(использование синхронных методов)</h2>
    <p>Тут тот же пример записи текста запроса в файл, но уже с использованием диалога выбора файлов.</p>
    <div class="code-style">
        <pre>
            --модуль формы обработки "Консоль запросов"

            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> СохранитьТекстЗапроса<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>  
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Сохранение<span class="светло_красный">);</span>

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеСохранения"</span><span class="светло_красный">,</span> ЭтотОбъект<span class="светло_красный">);</span>
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">);	
            КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеСохранения<span class="светло_красный">(</span>ВыбранныеФайлы<span class="светло_красный">,</span> Параметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//переменная ВыбранныеФайлы это массив с путями сохранённых файлов, либо Неопределено</span>
                <span class="светло_красный">Если</span> ВыбранныеФайлы <span class="светло_красный">= Неопределено Тогда
                    Возврат;
                КонецЕсли;</span>

                ТекстовыйФайл <span class="светло_красный">= Новый</span> ТекстовыйДокумент<span class="светло_красный">;</span>

                <span class="зелёный">// Устанавливаем содержимое файла.</span>
                ТекстовыйФайл<span class="светло_красный">.</span>УстановитьТекст<span class="светло_красный">(</span>ТекстЗапроса<span class="светло_красный">.</span>ПолучитьТекст<span class="светло_красный">());</span>

                <span class="зелёный">// Записываем файл на диск.
                // Если такой файл уже существует - он будет перезаписан.</span>
                ТекстовыйФайл<span class="светло_красный">.</span>Записать<span class="светло_красный">(</span>ВыбранныеФайлы<span class="светло_красный">[</span>0<span class="светло_красный">]);
            КонецПроцедуры</span></span>
        </pre>
    </div>










    <li><a href="#txt4-1">Пишем в текстовый файл TXT пример 3(использование синх методов)</a></li>
    <p>Тут будем использовать класс - "ЗаписьТекста". Будем выгружать номенклатуру в текстовый файл. В отличии от примера выше, если текста много, о не будем загружать его сразу в объект ТекстовыйФайл, это может много занять памяти, поэтому мы построчно запишем много данных.</p>
    <div class="code-style">
        <pre>
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> СохранитьТекстЗапроса<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>  
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Сохранение<span class="светло_красный">);</span>

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеСохранения"</span><span class="светло_красный">,</span> ЭтотОбъект<span class="светло_красный">);</span>
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">);	
            КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеСохранения(ВыбранныеФайлы, Параметры) Экспорт
                <span class="зелёный">//переменная ВыбранныеФайлы это массив с путями сохранённых файлов, либо Неопределено</span>
                <span class="светло_красный">Если</span> ВыбранныеФайлы <span class="светло_красный">= Неопределено Тогда
                    Возврат;
                КонецЕсли;</span>

                ЗТ = <span class="светло_красный">Новый</span> ЗаписьТекста;
                ЗТ.Открыть(ВыбранныеФайлы[0]);

                Выборка = Справочники.Номенклатура.Выбрать();

                Пока Выборка.Следующий() Цикл
                    ЗТ.ЗаписатьСтроку(СтрШаблон("%1 - %2", Выборка.Код, Выборка.Наименование));    
                КонецЦикла;

                ЗТ.Закрыть();
            КонецПроцедуры</span>
        </pre>
    </div>











    <h2 class="header-style" id="txt5">Читаем текстовый файл TXT, пример 1(использование асинхронных методов)</h2>
    <p>Этот пример опять же из моей внешней обработки "Моя консоль запросов". Нужно прочитать текст запроса из текстового файла:</p>
    <div class="code-style">
        <pre>
            //получение текста запроса из файла и вставка его в поле текстового документа
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ЗагрузитьТекстЗапроса<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                Проводник <span class="светло_красный">= Новый</span> ДиалогВыбораФайла<span class="светло_красный">(</span>РежимДиалогаВыбораФайла<span class="светло_красный">.</span>Открытие<span class="светло_красный">);</span>

                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения<span class="светло_красный">(</span><span class="светло_синийl">"ПослеВыбораФайла"</span><span class="светло_красный">,</span> ЭтотОбъект<span class="светло_красный">);</span>
                Проводник<span class="светло_красный">.</span>Показать<span class="светло_красный">(</span>Оповещение<span class="светло_красный">);
            КонецПроцедуры

            &НаКлиенте
            Процедура</span> ПослеВыбораФайла<span class="светло_красный">(</span>ВыбранныеФайлы<span class="светло_красный">,</span> ДопПараметры<span class="светло_красный">) Экспорт</span> 
                <span class="светло_красный">Если</span> ВыбранныеФайлы <span class="светло_красный">= Неопределено Тогда
                    Возврат;
                КонецЕсли;</span>

                ТекстовыйФайл <span class="светло_красный">= Новый</span> ТекстовыйДокумент<span class="светло_красный">;</span> 

                ПараметрыЧтения <span class="светло_красный">= Новый</span> Структура<span class="светло_красный">(</span><span class="светло_синийl">"ТекстовыйФайл"</span><span class="светло_красный">,</span> ТекстовыйФайл<span class="светло_красный">);</span>
                Оповещение <span class="светло_красный">= Новый</span> ОписаниеОповещения(<span class="светло_синийl">"ПослеЧтенияФайла"</span><span class="светло_красный">,</span> ЭтаФорма<span class="светло_красный">,</span> ПараметрыЧтения<span class="светло_красный">);</span>
                
                <span class="зелёный">//Читаем с файла. Этот метод асинхронный. Первый параметр(оповещение) можно 
                //не передавать, но тогда мы не получим прочитанный текст из файла,
                //потому что если продолжить писать код вниз после этого метода, 
                //то там не увидим в объекте "ТекстовыйФайл" прочитанного запроса из файла.
                //Я так понимаю это из-за того, что он тупо ещё не успел прочитать его.
                //Метод начал своё выполнение, но и платформа не ждёт его завершения и идёт дальше по коду.
                //А вот когда метод полностью прочитает из файла, он вызовет процедуру из переданного
                //в него оповещения. Так что тут обязательно нужно передвать оповещение.
                //Также в оповещение нужно передать сам объект текстового документа, чтобы
                //внутри процедуры получить из него прочитанный текст и чтото с ним сделать.</span>
                ТекстовыйФайл<span class="светло_красный">.</span>НачатьЧтение<span class="светло_красный">(</span>Оповещение<span class="светло_красный">,</span> ВыбранныеФайлы<span class="светло_красный">[</span>0<span class="светло_красный">]);	
            КонецПроцедуры  

            <span class="зелёный">//Вот эта та самая процедура, которая вызовется при окончании чтения из файла
            //У неё один единственный параметр это "ДопПараметры", через который мы и передаём из оповещения
            //объект текстового документа. И уже из этого объект построчно читаем запрос полученный из файла.</span>
            &НаКлиенте
            Процедура</span> ПослеЧтенияФайла<span class="светло_красный">(</span>ДопПараметры<span class="светло_красный">) Экспорт</span>
                <span class="зелёный">//очистим от предыдущих записей тестовый документ</span>
                ТекстЗапроса<span class="светло_красный">.</span>Очистить<span class="светло_красный">();</span>

                <span class="светло_красный">Для</span> НомерСтроки <span class="светло_красный">=</span> 1 <span class="светло_красный">По</span> ДопПараметры<span class="светло_красный">.</span>ТекстовыйФайл<span class="светло_красный">.</span>КоличествоСтрок<span class="светло_красный">() Цикл</span>
                    ТекущаяСтрока <span class="светло_красный">=</span> ДопПараметры<span class="светло_красный">.</span>ТекстовыйФайл<span class="светло_красный">.</span>ПолучитьСтроку<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">);</span>
                    
                    ТекстЗапроса<span class="светло_красный">.</span>ДобавитьСтроку<span class="светло_красный">(</span>ТекущаяСтрока<span class="светло_красный">);	
                КонецЦикла;	
            КонецПроцедуры</span></span>
        </pre>
    </div>











    <h2 class="header-style" id="txt6">Пишем в текстовый файл TXT, пример 1(использование асинхронных методов)</h2>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СохранитьТекстЗапроса(Команда)  
                Оповещение = Новый ОписаниеОповещения("ПослеЗакрытияФормы", ЭтотОбъект);
                ОткрытьФорму("ВнешняяОбработка.МояУчебнаяКонсольЗапросов.Форма.ФормаВведенияИмениФайла",,ЭтаФорма,,,,Оповещение, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);	
            КонецПроцедуры

            &НаКлиенте
            Процедура ПослеЗакрытияФормы(РезультатЗакрытия, Параметры) Экспорт
                <span class="зелёный">//переменная РезультатЗакрытия будет содержать то, что передастся
                //при вызове метода Закрыть() у подчинённой формы. В нашем случае
                //это имя файла, в который и надо записать текст запроса</span>
                Если РезультатЗакрытия = Неопределено Тогда
                    Возврат;
                КонецЕсли;
                
                <span class="зелёный">//хочу сохранить текст запроса в файл на рабочем столе пользователя.
                //пока нашёл такой способ, есть глоб. метод, который вернёт путь до
                //папки с верменными файлами в виндовс, с него и возьмём кусочек пути,
                //а дальше добавим путь до рабочего стола</span>
                Оповещение = Новый ОписаниеОповещения("ПоОкончаниюПолученияКаталога", ЭтотОбъект, РезультатЗакрытия);
                НачатьПолучениеКаталогаВременныхФайлов(Оповещение);
            КонецПроцедуры  


            &НаКлиенте
            Процедура ПоОкончаниюПолученияКаталога(ИмяКаталогаВременныхФайлов, ДопПараметры) Экспорт 
                <span class="зелёный">//создаём путь до папки </span>
                Путь = СтрЗаменить(ИмяКаталогаВременныхФайлов, "AppData\Local\Temp\", "Desktop\");
                Путь = Путь + "Тексты запросов\";

                <span class="зелёный">//этот метод создаёт папку по указанному пути, имя создаваемой папки также 
                //должно быть указано в пути, здесь это "Тексты запросов"</span>
                Оповещение = Новый ОписаниеОповещения("ПоОкончаниюСозданияКаталога", ЭтотОбъект, ДопПараметры);
                НачатьСозданиеКаталога(Оповещение, Путь);
            КонецПроцедуры


            &НаКлиенте
            Процедура ПоОкончаниюСозданияКаталога(ИмяКаталога, ДопПараметры)  Экспорт
                ТекстовыйФайл = Новый ТекстовыйДокумент;  

                <span class="зелёный">// Устанавливаем содержимое файла.</span>
                ТекстовыйФайл.УстановитьТекст(ТекстЗапроса.ПолучитьТекст());

                <span class="зелёный">//Записываем файл на диск.
                //Если такой файл уже существует - он будет перезаписан.
                //имя файла берём из "ДопПараметры", который мы перепрокинули сюда
                //из параметра "РезультатЗакрытия". В неё 
                //имя файла попадает из подчинённой формы, которая передаёт его 
                //при своём закрытии через метод Закрыть()</span> 
                Путь = ИмяКаталога + "\" + ДопПараметры.ИмяФайла + ".txt";

                <span class="зелёный">//Тут можно опустить первым параметров оповещение, я так полагаю из-за
                //того, что после этого метода никакой код больше не выполняется.</span>
                ТекстовыйФайл.НачатьЗапись(, Путь);	
            КонецПроцедуры
        </pre>
    </div>













    <h2 class="header-style" id="csv">Читаем текстовый файл CSV</h2>
    <p>Чтение этого формата ничем не отличается от чтения txt. Чтобы не было проблем с кодировкой, то создаю файл, даю ему расширение .csv и открываю его в excel и только потом копирую из текстового файла .txt контрагентов в эксель и сохраняю.</p>
    <p>Вот пример внутренней обработки, которая из файла CSV получает номенклатуру и добавляет их в справочник, если номенклатура повторяется пропускаем её, если нет группы, добавляем её. Эта обработка находится в базе Камков - Основные объекты. Называется "ЗагрузкаНоменклатурыИзCSV":</p>
    <div class="code-style">
        <pre>
            --модуль формы обработки 

            &НаКлиенте
            Процедура ПрочитатьФайлCSV(Команда)
                Проводник = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);

                Оповещение = Новый ОписаниеОповещения("ПослеОткрытия", ЭтотОбъект);
                Проводник.Показать(Оповещение);
            КонецПроцедуры

            &НаКлиенте
            Процедура ПослеОткрытия(ВыбранныеФайлы, Параметры) Экспорт 
                //после выбора файла в диалоговом окне в параметр
                //"ВыбранныеФайлы" попадает массив с путями до файлов
                //в виде строк, например - "C:\Users\Professional\Desktop\Примеры файлов для 1С\Номенклатура.csv"
                //Если элемент в массиве один, то первым элементов будет эта строка с путём    

                Если ВыбранныеФайлы = Неопределено Тогда
                    Возврат;
                КонецЕсли;
                
                ТекстовыйФайл = Новый ТекстовыйДокумент;
                
                //Читаем с файла, в переменной ВыбранныеФайлы массив с 
                //путями выбранных файлов, в данном примере там только один элемент с путём
                ТекстовыйФайл.Прочитать(ВыбранныеФайлы[0]);   

                Если ТекстовыйФайл.КоличествоСтрок() = 0 Тогда
                    Возврат;
                КонецЕсли;
                
                ПолучитьНоменклатуруНаСервере(ТекстовыйФайл);
                
            КонецПроцедуры     


            &НаСервереБезКонтекста
            Процедура ПолучитьНоменклатуруНаСервере(ТекстовыйФайл)
                //создадим 2 массива для хранения новой добавленной номенклатуры
                //и группы, чтобы обновлённые данные каждый раз не получать из БД
                МассивДобавленнойНоменклатуры = Новый Массив;
                МассивДобавленныхГрупп = Новый Массив;

                //запросом получаем имеющуюся номенклатуру
                Запрос = Новый Запрос;
                Запрос.Текст = "ВЫБРАТЬ
                            |	Номенклатура.Наименование КАК Наименование,
                            |	Номенклатура.ВидНоменклатуры КАК ВидНоменклатуры,
                            |	ПРЕДСТАВЛЕНИЕ(Номенклатура.Родитель) КАК ПРодитель,
                            |	Номенклатура.Родитель КАК Родитель
                            |ИЗ
                            |	Справочник.Номенклатура КАК Номенклатура
                            |ГДЕ
                            |	Номенклатура.ЭтоГруппа = ""Ложь"""; 
                
                Выборка = Запрос.Выполнить().Выбрать();
                
                
                Для НомерСтроки = 1 По ТекстовыйФайл.КоличествоСтрок() Цикл  
                    НоваяГруппа = Ложь;
                

                    //в первой строке находится заголовок, поэтому он нам не интересен
                    Если НомерСтроки = 1 Тогда
                        Продолжить;
                    КонецЕсли;
                    
                    //получаем из текстового файла очередную строку
                    ТекущаяСтрока = ТекстовыйФайл.ПолучитьСтроку(НомерСтроки);
                    
                    //провереям строку на пустоту
                    Если ПустаяСтрока(ТекущаяСтрока) Тогда
                        Продолжить;
                    КонецЕсли;   

                    //разбиваем строку по начертанию "|" как указано в файле CSV
                    МассивДанных = СтрРазделить(ТекущаяСтрока, "|");

                    НазваниеНоменклатуры = СокрЛП(МассивДанных[0]);
                    ВидНоменклатуры = СокрЛП(МассивДанных[1]);
                    ГруппаНоменклатуры = СокрЛП(МассивДанных[2]);
                    
                    ИндексВидаНоменклатуры = 0;
                    Если ВидНоменклатуры = "Услуга" Тогда
                        ИндексВидаНоменклатуры = 1;
                    ИначеЕсли ВидНоменклатуры = "Материал" Тогда	
                        ИндексВидаНоменклатуры = 2;
                    КонецЕсли;
                    
                    //в цикле ищем добавдяемую номенклатуру в выборке  
                    ЕстьТакаяНоменклатура = Ложь; 
                    Выборка.Сбросить();
                    Пока Выборка.Следующий() Цикл
                        Если НазваниеНоменклатуры = Выборка.Наименование Тогда
                            ЕстьТакаяНоменклатура = Истина;
                            Прервать;
                        КонецЕсли;
                    КонецЦикла; 

                    //в цикле ищем добавляемую номенклатуру в массиве добавленных номенклатур
                    Если ЕстьТакаяНоменклатура = Ложь Тогда
                        Для каждого Номенклатура Из МассивДобавленнойНоменклатуры Цикл
                            Если НазваниеНоменклатуры = Номенклатура Тогда
                                ЕстьТакаяНоменклатура = Истина;
                                Прервать;
                            КонецЕсли;	
                        КонецЦикла;
                    КонецЕсли;
                    
                    
                    //номенклатура есть такая в базе, дальше не продолжаем
                    Если ЕстьТакаяНоменклатура Тогда
                        Продолжить;	
                    КонецЕсли;
                    
                    //в цикле ищем добавляемую группу  в выборке
                    НетТакойГруппы = Ложь;     
                    Выборка.Сбросить();
                    Пока Выборка.Следующий() Цикл
                        Если Выборка.ПРодитель = ГруппаНоменклатуры Тогда
                            НетТакойГруппы = Ложь;
                            Прервать;
                        Иначе
                            НетТакойГруппы = Истина;
                        КонецЕсли;
                    КонецЦикла; 

                    //в цикле ищем добавляему группу в массиве групп
                    Если НетТакойГруппы = Истина Тогда
                        Для каждого Группа Из МассивДобавленныхГрупп Цикл
                            Если Группа = ГруппаНоменклатуры Тогда
                                НетТакойГруппы = Ложь;
                                Прервать;
                            Иначе
                                НетТакойГруппы = Истина;
                            КонецЕсли;
                        КонецЦикла;
                    КонецЕсли;
                    
                    
                    
                    Если НетТакойГруппы Тогда
                        ОбъектГруппыНоменклатуры = Справочники.Номенклатура.СоздатьГруппу();
                        ОбъектГруппыНоменклатуры.Наименование = ГруппаНоменклатуры;
                        Если ВидНоменклатуры = "Товар" Тогда
                            СсылкаНаГруппуТовары = Справочники.Номенклатура.НайтиПоНаименованию("Товары");
                        КонецЕсли;
                        ОбъектГруппыНоменклатуры.Родитель = СсылкаНаГруппуТовары;
                        ОбъектГруппыНоменклатуры.Записать();
                        НоваяГруппа = Истина;
                        МассивДобавленныхГрупп.Добавить(ГруппаНоменклатуры);
                    КонецЕсли;
                    

                    ОбъектНоменклатуры = Справочники.Номенклатура.СоздатьЭлемент(); 
                    ОбъектНоменклатуры.Наименование = НазваниеНоменклатуры;
                    ОбъектНоменклатуры.ВидНоменклатуры = Перечисления.ВидыНоменклатуры.Получить(ИндексВидаНоменклатуры);

                    Если НоваяГруппа Тогда
                        ОбъектНоменклатуры.Родитель = ОбъектГруппыНоменклатуры.Ссылка;
                    Иначе
                        ОбъектНоменклатуры.Родитель = Справочники.Номенклатура.НайтиПоНаименованию(ГруппаНоменклатуры);	
                    КонецЕсли;
                    
                    ОбъектНоменклатуры.Записать();
                    МассивДобавленнойНоменклатуры.Добавить(НазваниеНоменклатуры);    
                КонецЦикла;
            КонецПроцедуры 
        </pre>
    </div>














    <h2 class="header-style" id="xlsx">Читаем файл Excel</h2>
    <p><b>Пример 1</b></p>
    <p>Существует также несколько способов читать excel файл. Мы рассмотрим только один способ, который использует для чтения файла класс встроенного языка - ТабличныйДокумент. У класса есть метод <span class="светло_синий">Прочитать()</span>, который позволяет прочитать данные в том числе и из формата excel. <span class="светло_красный">Особенность этого метода в том, что он доступен только на сервере</span>.</p>
    <p>Также у класса есть метод - <span class="светло_синий">ПолучитьОбласть()</span>, который получает данные табличного документа по указанному адресу, например, "R1C2" - 1я строка, 2я колонка.</p>
    <p>Есть свойство <span class="светло_синий">ВысотаТаблицы</span>, которое позволяет получить количество строк в считанном файле.</p>
    <div class="code-style">
        <pre>
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ПрочитатьФайлXLSX<span class="светло_красный">()</span>
                <span class="зелёный">//примером файла Excel будет Список контрагентов.xlsx.</span>
                ПрочитатьФайлXLSXНаСервере<span class="светло_красный">();	
            КонецПроцедуры

            &НаСервере
            Процедура</span> ПрочитатьФайлXLSXНаСервере<span class="светло_красный">()</span>
                ТабДок <span class="светло_красный">= Новый</span> ТабличныйДокумент<span class="светло_красный">;</span>

                <span class="зелёный">//чтобы при чтении файла исключить вылет ошибок обернём чтение в Попытка..Исключение</span>
                <span class="светло_красный">Попытка</span>
                    <span class="зелёный">//из табличного файла данные можно считывать 2мя способами.Либо по типам значений - число считывается как число, строка как строка,
                    //либо всё считывать как текст, т.е. всё будет считываться как строки.
                    //Мы выбрали значение "Значение", т.е. считывать будем значения такие как они есть:
                    //число как число, строка как строка. Также, насколько я понимаю,
                    //метод Прочитать() получает строку с путём до файла на компьюторе клиента,
                    //значит этот метод идёт с сервера на клиент, по переданному пути получает содержимое файла
                    //и возвращается на сервер с этим файлом.</span>
                    ТабДок<span class="светло_красный">.</span>Прочитать<span class="светло_красный">(</span>Объект<span class="светло_красный">.</span>ПутьКФайлу<span class="светло_красный">,</span> СпособЧтенияЗначенийТабличногоДокумента<span class="светло_красный">.</span>Значение<span class="светло_красный">);</span>
                <span class="светло_красный">Исключение</span>
                    <span class="зелёный">//ОписаниеОшибки() это метод Глобального контекста, который вернёт текст ошибки</span>
                    Сообщение <span class="светло_красный">= Новый</span> СообщениеПользователю<span class="светло_красный">;</span>
                    Сообщение<span class="светло_красный">.</span>Текст <span class="светло_красный">=</span> <span class="светло_синийl">"Не удалось прочитать указанный файл по причине "</span> <span class="светло_красный">+</span> ОписаниеОшибки<span class="светло_красный">();</span>
                    Сообщение<span class="светло_красный">.</span>Сообщить<span class="светло_красный">();</span>
                    Возврат<span class="светло_красный">;
                КонецПопытки;</span>

                <span class="зелёный">//если ошибок нет, то можем двигаться дальше и нам нужно получить количество строк в табличном файле</span>
                КоличествоСтрок <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ВысотаТаблицы<span class="светло_красный">;</span>

                <span class="зелёный">//и далее в цикле будем считывать построчно табличный файл, начинать будем
                //со 2й строки, потому что в 1й строке шапка</span>
                <span class="светло_красный">Для</span> НомерСтроки <span class="светло_красный">=</span> 2 <span class="светло_красный">По</span> КоличествоСтрок <span class="светло_красный">Цикл</span>
                    <span class="зелёный">//в табличную часть добавляем новую строку
                    //и колонкам этой строки задаём части массива</span>
                    НоваяСтрока <span class="светло_красный">=</span> Объект<span class="светло_красный">.</span>ДанныеФайла<span class="светло_красный">.</span>Добавить<span class="светло_красный">();</span> 

                    <span class="зелёный">//метод ПолучитьОбласть() вернёт объект типа ТабличныйДокумент, нам же нужно получить содержимое ячейки
                    //у вернувшегося объекта есть подобъект ТекущаяОбласть, а унего есть свойство Текст, которое нам и даст
                    //содержимое ячейки </span>
                    НоваяСтрока<span class="светло_красный">.</span>КраткоеНаименование <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ПолучитьОбласть<span class="светло_красный">(</span><span class="светло_синийl">"R"</span> <span class="светло_красный">+</span> Формат<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">,</span> <span class="светло_синийl">"ЧГ=0"</span><span class="светло_красный">) +</span> <span class="светло_синийl">"C1"</span><span class="светло_красный">).</span>ТекущаяОбласть<span class="светло_красный">.</span>Текст<span class="светло_красный">;</span>
                    НоваяСтрока<span class="светло_красный">.</span>ПолноеНаименование <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ПолучитьОбласть<span class="светло_красный">(</span><span class="светло_синийl">"R"</span> <span class="светло_красный">+</span> Формат<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">,</span> <span class="светло_синийl">"ЧГ=0"</span><span class="светло_красный">) +</span> <span class="светло_синийl">"C2"</span><span class="светло_красный">).</span>ТекущаяОбласть<span class="светло_красный">.</span>Текст<span class="светло_красный">;</span>
                    НоваяСтрока<span class="светло_красный">.</span>УНП <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ПолучитьОбласть<span class="светло_красный">(</span><span class="светло_синийl">"R"</span> <span class="светло_красный">+</span> Формат<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">,</span> <span class="светло_синийl">"ЧГ=0"</span><span class="светло_красный">) +</span> <span class="светло_синийl">"C3"</span><span class="светло_красный">).</span>ТекущаяОбласть<span class="светло_красный">.</span>Текст<span class="светло_красный">;
                КонецЦикла;	
            КонецПроцедуры</span></span>
        </pre>
    </div>
    <p>Этот код чтения файла сработает только в структуре, когда БД находится на одном компьюторе вместе с клиентом. Если же сервер будет на другом компьюторе удалённо, то такого пути до файла там просто не будет, а потому будет ошибка.</p>

    <p><b>Пример 2</b></p>
    <p>Допустим мы хотим из файла эксель выбрать данные и записать их в регистр сведений. Вот так выглядит файл Контрагенты.xlsx:</p>
    <img src="../img/1С-1/2023-10-28_08-24-29.png" class="screen-2" alt="">
    <p>И вот так должен выглядеть регистр с уже записанными данными:</p>
    <img src="../img/1С-1/2023-10-28_08-26-13.png" class="screen" alt="">
    <p>В регистре ресурс это только "Значение", остальное измерение. Создадим обработку, с полемм вода для ввода пути к файлу и кнопкой для записи данных в регистр. Вот обработчик этой кнопки:</p>
    <div class="code-style">
        <pre>
            --модуль формы обработки
            <span class="светло_синий"><span class="светло_красный">&НаСервере
            Процедура</span> ЗагрузитьДанныеИзФайлаНаСервере<span class="светло_красный">()</span>
                ТабДок <span class="светло_красный">= Новый</span> ТабличныйДокумент<span class="светло_красный">;</span>

                <span class="зелёный">//чтобы при чтении файла исключить вылет ошибок обернём чтение в Попытка..Исключение</span>
                <span class="светло_красный">Попытка</span>
                    <span class="зелёный">//из табличного файла данные можно считывать 2мя способами.Либо по типам значений - число считывается как число, строка как строка,
                    //либо всё считывать как текст, т.е. всё будет считываться как строки.</span>
                    ТабДок<span class="светло_красный">.</span>Прочитать<span class="светло_красный">(</span>ПутьКФайлу<span class="светло_красный">,</span> СпособЧтенияЗначенийТабличногоДокумента<span class="светло_красный">.</span>Значение<span class="светло_красный">);</span>
                <span class="светло_красный">Исключение</span>
                    <span class="зелёный">//ОписаниеОшибки() это метод Глобального контекста, который вернёт текст ошибки</span>
                    Сообщение <span class="светло_красный">= Новый</span> СообщениеПользователю<span class="светло_красный">;</span>
                    Сообщение<span class="светло_красный">.</span>Текст <span class="светло_красный">=</span> <span class="светло_синийl">"Не удалось прочитать указанный файл по причине "</span> <span class="светло_красный">+</span> ОписаниеОшибки<span class="светло_красный">();</span>
                    Сообщение<span class="светло_красный">.</span>Сообщить<span class="светло_красный">();</span>
                    Возврат<span class="светло_красный">;
                КонецПопытки;</span>

                <span class="зелёный">//если ошибок нет, то можем двигаться дальше и нам нужно 
                //получить количество строк и колонок в табличном файле</span>
                КоличествоСтрок <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ВысотаТаблицы<span class="светло_красный">;</span>  
                КоличествоКолонок <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ШиринаТаблицы<span class="светло_красный">;</span>

                <span class="зелёный">//создаём пустой набор записей и делаем запись пустого набора для очистки ранее записанного</span>
                НаборЗаписей <span class="светло_красный">=</span> РегистрыСведений<span class="светло_красный">.</span>ДанныеФайла<span class="светло_красный">.</span>СоздатьНаборЗаписей<span class="светло_красный">();</span>
                НаборЗаписей<span class="светло_красный">.</span>Записать<span class="светло_красный">();</span>

                <span class="зелёный">//в цикле считываем построчно табличный файл</span>
                <span class="светло_красный">Для</span> НомерСтроки = 1 <span class="светло_красный">По</span> КоличествоСтрок <span class="светло_красный">Цикл </span>
                    <span class="зелёный">//в цикле считываем поколоночно табличный файл</span>              
                    <span class="светло_красный">Для</span> НомерКолонки = 1 <span class="светло_красный">По</span> КоличествоКолонок <span class="светло_красный">Цикл </span>
                        Запись <span class="светло_красный">=</span> НаборЗаписей<span class="светло_красный">.</span>Добавить<span class="светло_красный">();</span> 
                        Запись<span class="светло_красный">.</span>ИмяФайла <span class="светло_красный">=</span> Сред<span class="светло_красный">(</span>ПутьКФайлу<span class="светло_красный">,</span> СтрНайти<span class="светло_красный">(</span>ПутьКФайлу<span class="светло_красный">,</span> <span class="светло_синийl">"\"</span><span class="светло_красный">,</span> НаправлениеПоиска<span class="светло_красный">.</span>СКонца<span class="светло_красный">) +</span> 1<span class="светло_красный">);</span>
                        Запись<span class="светло_красный">.</span>НомерСтрокиФайла <span class="светло_красный">=</span> НомерСтроки<span class="светло_красный">;</span>
                        Запись<span class="светло_красный">.</span>НомерКолонкиФайла <span class="светло_красный">=</span> НомерКолонки<span class="светло_красный">;</span>
                        Значение <span class="светло_красный">=</span> ТабДок<span class="светло_красный">.</span>ПолучитьОбласть<span class="светло_красный">(</span><span class="светло_синийl">"R"</span> <span class="светло_красный">+</span> Формат<span class="светло_красный">(</span>НомерСтроки<span class="светло_красный">,</span> <span class="светло_синийl">"ЧГ=0"</span><span class="светло_красный">) +</span> <span class="светло_синийl">"C"</span> <span class="светло_красный">+</span> Формат<span class="светло_красный">(</span>НомерКолонки<span class="светло_красный">,</span> <span class="светло_синийl">"ЧГ=0"</span><span class="светло_красный">)).</span>ТекущаяОбласть<span class="светло_красный">.</span>Текст<span class="светло_красный">;</span> 

                        <span class="зелёный">//преобразовываем данные файла в нужные типы</span>
                        <span class="светло_красный">Попытка</span>
                            А <span class="светло_красный">=</span> 0 <span class="светло_красный">+</span> Значение<span class="светло_красный">;</span>
                            <span class="зелёный">//если исключение не сработало, значит преобразовалось в число</span>
                            Запись<span class="светло_красный">.</span>Значение <span class="светло_красный">=</span>  А<span class="светло_красный">;</span>
                        <span class="светло_красный">Исключение</span>
                            Позиция <span class="светло_красный">=</span> СтрНайти<span class="светло_красный">(</span>Значение<span class="светло_красный">,</span> <span class="светло_синийl">"2023"</span><span class="светло_красный">);</span>
                            <span class="светло_красный">Если</span> Позиция <span class="светло_красный">Тогда</span>
                                <span class="зелёный">//если заши сюда, значит значение дата</span>
                                МассивСтрок <span class="светло_красный">=</span> СтрРазделить<span class="светло_красный">(</span>Значение<span class="светло_красный">,</span> "."<span class="светло_красный">);</span>
                                                                            
                                ПеревёрнутыйМассив <span class="светло_красный">= Новый</span> Массив<span class="светло_красный">;</span>
                                Шаг <span class="светло_красный">=</span> МассивСтрок<span class="светло_красный">.</span>ВГраница<span class="светло_красный">();</span>
                                <span class="светло_красный">Пока</span> Шаг <span class="светло_красный">>=</span> 0 <span class="светло_красный">Цикл</span>
                                    ПеревёрнутыйМассив<span class="светло_красный">.</span>Добавить<span class="светло_красный">(</span>МассивСтрок<span class="светло_красный">[</span>Шаг<span class="светло_красный">]);</span>
                                    Шаг <span class="светло_красный">=</span> Шаг <span class="светло_красный">-</span> 1<span class="светло_красный">;
                                КонецЦикла;</span>
            
                                СтрокаДаты <span class="светло_красный">=</span> СтрСоединить<span class="светло_красный">(</span>ПеревёрнутыйМассив<span class="светло_красный">);</span>
                                Запись<span class="светло_красный">.</span>Значение <span class="светло_красный">=</span>  Дата<span class="светло_красный">(</span>СтрокаДаты<span class="светло_красный">);</span>
                            <span class="светло_красный">Иначе</span>
                                <span class="зелёный">//ну и если мы тут, значит значение строка</span>
                                Запись<span class="светло_красный">.</span>Значение <span class="светло_красный">=</span>  Значение<span class="светло_красный">;
                            КонецЕсли;
                        КонецПопытки;
                    КонецЦикла;
                КонецЦикла;</span> 

                НаборЗаписей<span class="светло_красный">.</span>Записать<span class="светло_красный">();
            КонецПроцедуры

            &НаКлиенте
            Процедура</span> ЗагрузитьДанныеИзФайла<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                ЗагрузитьДанныеИзФайлаНаСервере<span class="светло_красный">();
            КонецПроцедуры</span></span>
        </pre>
    </div>

    <p><b>Пример 3</b></p>
    <p>Вот на этом сайте показаны ещё способы как читать из эксель - <a href="https://ironskills.by/tpost/dgg1j0v4k1-kak-prochitat-excel-v-1s-4-sposoba">тут</a>.</p>
    <p>Также Сергей Семёнов на ютубе показывает как прочитать товары в группировке из файла эксель в справочник Номенклатура. <a href="https://www.youtube.com/watch?v=A15Of-ibTf8&t=829s">Тут</a>.</p>












    <h2 class="header-style" id="xlsx2">Пишем в файл Excel</h2>
    <p>Создадим обработку, которая будет сохранять файл эксель с товарами из справочника Номенклатура. Учебная версия не позволяет сохранять табличные документы, поэтому тут просто выводим табдок в отдельное окно. Я без макетов, сразу напряму писал в ТД. Вот код обработки:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ВыгрузитьНоменклатуру(Команда)
                ТабДок = Новый ТабличныйДокумент;
                ВыгрузитьНоменклатуруНаСервере(ТабДок);

                ТабДок.Показать();
            КонецПроцедуры

            &НаСервереБезКонтекста
            Процедура ВыгрузитьНоменклатуруНаСервере(ТабДок)
                ТабДок.Область("R1C1").Текст = "Номенклатура из справочника";

                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	Номенклатура.Наименование КАК Наименование,
                    |	Номенклатура.ЦенаПокупки КАК ЦенаПокупки,
                    |	Номенклатура.ЦенаПродажи КАК ЦенаПродажи,
                    |	Номенклатура.ВидНоменклатуры КАК ВидНоменклатуры
                    |ИЗ
                    |	Справочник.Номенклатура КАК Номенклатура
                    |ГДЕ
                    |	Номенклатура.ЭтоГруппа = &Ложь
                    |	И Номенклатура.ВидНоменклатуры = ЗНАЧЕНИЕ(Перечисление.ВидыНоменклатуры.Товар)";
                
                Запрос.УстановитьПараметр("Ложь", Ложь);
                РезультатЗапроса = Запрос.Выполнить();
                Выборка = РезультатЗапроса.Выбрать();
                
                СчетчикСтрок = 2;
                Пока Выборка.Следующий() Цикл
                    ТабДок.Область("R" + СчетчикСтрок + "C1").Текст = Выборка.Наименование;
                    ТабДок.Область("R" + СчетчикСтрок + "C2").Текст = Выборка.ЦенаПокупки;
                    ТабДок.Область("R" + СчетчикСтрок + "C3").Текст = Выборка.ЦенаПродажи;
                    ТабДок.Область("R" + СчетчикСтрок + "C4").Текст = Выборка.ВидНоменклатуры;

                    СчетчикСтрок = СчетчикСтрок + 1;
                КонецЦикла;


                //так мы сохраняем табдок в файл
                //МестоположениеФайла  = "C:\Users\Professional\Desktop\Товары";
                //ТабДок.Записать(МестоположениеФайла , ТипФайлаТабличногоДокумента.XLSX);	
            КонецПроцедуры    
        </pre>
    </div>


















    <h2 class="header-style" id="dbf">Читаем файл DBF</h2>
    <p>На сегодня работать с таким форматом файлов приходится не часто. Поэтому не буду описывать его. Если вдруг понадобится, то вот это видео - https://www.youtube.com/watch?v=bCA4KrLzHg8&list=PLnhTnXRFDQ7dJa-1DtA2bcKvK4pxV8GRP&index=7 , где описано как с ним работать.</p>


















    <h2 class="header-style" id="xml">Читаем файл XML</h2>
    <p>Существуют разные способы читать такие файлы. Рассмотрим 2 таких способа. Первый способ чтения это последовательный способ, который предпологает, что данные из xml документа считываются последовательно по одному узлу за раз. То есть считываем самый первый тег, за ним второй, за ним содержимое тега, за ним закрывающий второй тег, за ним 1й закрывающий тег.</p>
    <p>Вот такой xml будем разбирать:</p>
    <img src="../img/1С-1/2023-07-28_08-09-55.png" class="screen" alt="">
    <p><b>Для последовательного</b> чтения узлов xml используется <span class="светло_синий">класс ЧтениеXML</span>:</p>
    <div class="code-style">
        <pre>
            --Способ 1й
            <span class="светло_синий">&НаКлиенте
            Процедура ПрочитатьФайлXML()
                ОбъектXML = Новый ЧтениеXML;

                <span class="зелёный">//Если получили строку XML через HTTP
                //ОбъектXML.УстановитьСтроку("Строка xml полученная через http");</span>

                <span class="зелёный">//Если xml в файле</span>
                ОбъектXML.ОткрытьФайл(Объект.ПутьКФайлу);

                <span class="зелёный">//для того чтобы прочитать очередной узел xml документа есть метод Прочитать(), который возвращает булево значение</span>
                Пока ОбъектXML.Прочитать() Цикл
                    <span class="зелёный">//при прочтении первого узла в ОбъектXML в свойство Имя попадает имя узла, в нашем случае "ContragentList"
                    //в свойство ТипУзла попадает значение НачалоЭлемента - это системное перечисление
                    //в свойство Значение попадает содержимое узла - "", этот тег в себе содержит другие теги, а потому считается содержимое пустым
                    //на следущем узле Имя - "Contragent", ТипУзла - НачалоЭлемента, Значение - ""
                    //на следущем узле Имя - "NAME", ТипУзла - НачалоЭлемента, Значение - ""
                    //на следущем узле Имя - "#text", ТипУзла - Текст, Значение - "Краткое наименование Контрагент1"
                    //на следущем узле Имя - "NAME", ТипУзла - КонецЭлемента, Значение - ""
                    // и так далее</span>	
                    Если ОбъектXML.Имя = "Contragent" И ОбъектXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                        <span class="зелёный">//для меня было удивлением, что переменная Новая строка созданная на 2м круге цикла и её содержимое
                        //будет существовать и на остальных кругах цикла. Переменная не удаляется на следующем круге
                        //даже если мы не зайдём в это условие и не создадим её заново. Т.е. тут действует принцип как в js
                        //при объявлении переменных через var, когда переменные всплывают и становятся доступными отовсюду в процедуре
                        //при объявлении переменных через let в js такое уже не прокатывает. Могу сделать вывод, что в 1с
                        //переменные всплывают, поэтому переменная НоваяСтрока на следующем круге видна</span>
                        НоваяСтрока = Объект.ДанныеФайла.Добавить();
                        Продолжить;
                    ИначеЕсли ОбъектXML.Имя = <span class="серый">"NAME"</span> И ОбъектXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                        ОбъектXML.Прочитать();
                        НоваяСтрока.КраткоеНаименование = ОбъектXML.Значение;
                        Продолжить;	
                    ИначеЕсли ОбъектXML.Имя = <span class="серый">"FULL_NAME"</span> И ОбъектXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                        ОбъектXML.Прочитать();
                        НоваяСтрока.ПолноеНаименование = ОбъектXML.Значение;
                        Продолжить;
                    ИначеЕсли ОбъектXML.Имя = <span class="серый">"UNP"</span> И ОбъектXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                        ОбъектXML.Прочитать();
                        НоваяСтрока.УНП = ОбъектXML.Значение;
                    КонецЕсли;	
                КонецЦикла;

                ОбъектXML.Закрыть();	
            КонецПроцедуры</span>
        </pre>
    </div>
    <p><b>Второй способ</b> это <span class="светло_синий">механизм XDTO(XML Data Transfer Objects)</span>. Этот механизм разработан фирмой 1С, который позволяет на уровне языка 1с оперировать не узлами XML, а прикладными понятиями "Контрагент", "Счёт" и привычными встроенными типами("ТаблицаЗначение", "СправочникСсылка" и т.д.)</p>
    <p>Объект.ДанныеФайла - это реквизит формы с типом (Таблица значений), настоящий тип - "ДанныеФормыКоллекция", но имеет примерно такие же методы как и тип "Таблица значений".</p>
    <div class="code-style">
        <pre>
            <span class="светло_синий">&НаКлиенте
            Процедура ПрочитатьФайлXML()
                <span class="зелёный">//способ с фабрикой XDTO</span>
                ОбъектXML = Новый ЧтениеXML;
                ОбъектXML.ОткрытьФайл(Объект.ПутьКФайлу);

                КонтрагентыXDTO = ФабрикаXDTO.ПрочитатьXML(ОбъектXML);
                Для каждого Элемент Из КонтрагентыXDTO.Contragent Цикл
                    НоваяСтрока = Объект.ДанныеФайла.Добавить();
                    НоваяСтрока.КраткоеНаименование = Элемент.NAME;
                    НоваяСтрока.ПолноеНаименование = Элемент.FULL_NAME;
                    НоваяСтрока.УНП = Элемент.UNP;		
                КонецЦикла;		
            КонецПроцедуры</span>
        </pre>
    </div>
    <p>Конечно это далеко не полные данные по этим способам чтения. В дальнейшем буду добавлять.</p>










    <h2 class="header-style" id="xml-2">Выгрузка данных из 1С в XML</h2>
    <p>Для выгрузки данных в файл XML есть класс <span class="светло_синий">ЗаписьXML</span>. У объекта этого класса есть такие методы:</p>
    <ul class="list">
        <li><b>ОткрытьФайл()</b> - открывает файл для последующей записи в него.</li>
        <li><b>ЗаписатьОбъявлениеXML()</b> - добавляет первую строку(объявление) в XML-документ. Имеется в виду первая строка с тегом xml, где описывается версия, кодировка и т.д.</li>
        <li><b>ЗаписатьНачалоЭлемента(&lt;ИмяЭлемента>)</b> - записывает начало элемента в XML-документ(открывающий тег).</li>
        <li><b>ЗаписатьТекст(&lt;Текст>)</b> - записывает содержимое элемента.</li>
        <li><b>ЗаписатьКонецЭлемента()</b> - записывает конец элемента в XML-жокумент(закрывающий тег).</li>
    </ul>
    <div class="code-style">
        <pre>
            --предполагается что у нас в обработке есть табличная часть и мы из этой табличной части
            --выгружаем в файл
            --В табличную же часть можно по кнопке загрузить данные из базы
            <span class="светло_синий">&НаКлиенте
            Процедура ВыгрузитьДанныевФайлXML()
                ЗаписьXML = Новый ЗаписьXML;
                ЗаписьXML.ОткрытьФайл(&lt;ПутьКФайлу>);
                ЗаписьXML.ЗаписатьОбъявлениеXML();

                <span class="зелёный">//создаём корневой узел контрагента</span>
                ЗаписьXML.ЗаписатьНачалоЭлемента(<span class="серый">"ContragentList"</span>);

                Для каждого СтрокаТабЧасти Из Объект.ДанныеФайла Цикл
                    ЗаписьXML.ЗаписатьНачалоЭлемента(<span class="серый">"Contragent"</span>);
                        <span class="зелёный">//Краткое наименование</span>
                        ЗаписьXML.ЗаписатьНачалоЭлемента(<span class="серый">"NAME"</span>);
                        ЗаписьXML.ЗаписатьТекст(СтрокаТабЧасти.КраткоеНаименование);
                        ЗаписатьКонецЭлемента();

                        <span class="зелёный">//Полное наименование</span>
                        ЗаписьXML.ЗаписатьНачалоЭлемента(<span class="серый">"LAST_NAME"</span>);
                        ЗаписьXML.ЗаписатьТекст(СтрокаТабЧасти.ПолноеНаименование);
                        ЗаписатьКонецЭлемента();

                        <span class="зелёный">//УНП</span>
                        ЗаписьXML.ЗаписатьНачалоЭлемента(<span class="серый">"UNP"</span>);
                        ЗаписьXML.ЗаписатьТекст(СтрокаТабЧасти.УНП);
                        ЗаписатьКонецЭлемента();
                    ЗаписатьКонецЭлемента(<span class="серый">"Contragent"</span>);
                КонецЦикла;

                ЗаписатьКонецЭлемента();

                <span class="зелёный">//закрываем файл</span>
                ЗаписьXML.Закрыть();
            КонецПроцедуры</span>
        </pre>
    </div>






    <h2 class="header-style" id="xml-3">Выгрузка и загрузка сложных типов данных из 1С в XML(класс ЗаписьXML и глоб. метод ЗаписатьXML/ПрочитатьXML</h2>
    <p><b>Выгрузка</b></p>
    <p>Есть возможность не описывать выгрузку как в прошлом примере, а можно выгрузить данные документа в пару строк:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ВыгрузитьНаСервере()
                ЗаписьXML = Новый ЗаписьXML;

                <span class="зелёный">//указываем в какой файл будем выгружать</span>
                ЗаписьXML.ОткрытьФайл("C:\Users\Professional\Desktop\1С картинки шпоры\Документ.xml");

                <span class="зелёный">//- ЗаписьXML - объект, через который осуществляется запись XML.
                //- 2й параметр - записываемое в поток XML значение. В нашем случае это "ДокументОбъект.ПродажаТоваров"
                //Ну и сама процедура ЗаписатьXML() выполняет сериализацию значения в формат XML.</span>
                ЗаписатьXML(ЗаписьXML, Объект.ДокументПродажи.ПолучитьОбъект());

                ЗаписьXML.Закрыть();
            КонецПроцедуры



            &НаКлиенте
            Процедура Выгрузить(Команда)
                ВыгрузитьНаСервере();
            КонецПроцедуры
        </pre>
    </div>
    <p>Если посмотреть в файл, куда выгрузились данные документа, то в некоторых тегах можно увидеть вместо товара, контрагента и прочее просто цифры, это так выглядят ссылки без представления</p>
    <img src="../img/1С-1/2024-12-06_10-34-07.png" class="screen" alt="">
    <p><b>Загрузка</b></p>
    <p>Теперь загрузим данные из такого xml файла, как мы выше создали.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Загрузить(Команда)
                ЗагрузитьНаСервере();
            КонецПроцедуры



            &НаСервере
            Процедура ЗагрузитьНаСервере()
                ЧтениеXML = Новый ЧтениеXML;
                ЧтениеXML.ОткрытьФайл("C:\Users\Professional\Desktop\1С картинки шпоры\Документ.xml");

                ДокументОбъект = ПрочитатьXML(ЧтениеXML);
                ДокументОбъект.Записать();

                ЧтениеXML.Закрыть();
            КонецПроцедуры
        </pre>
    </div>










    <h2 class="header-style" id="xml_base">Основы XML</h2>
    <p>Смотрю по этому <a href="https://rutube.ru/video/5ea3cd090b122d7ac74ff73675cc8076/?&utm_source=embed&utm_medium=referral&utm_campaign=logo&utm_content=5ea3cd090b122d7ac74ff73675cc8076&utm_term=yastatic.net%2F&referrer=appmetrica_tracking_id%3D1037600761300671389%26ym_tracking_id%3D7980878808820014124">видео</a> или <a href="https://www.youtube.com/watch?v=IfbtbGMHpQ0">тут</a>. Очень подробное видео, советую пересматривать.</p>
    <p><b>Начинается суть где=то с 29 минуты</b></p>
    <p>XML(Extended Markup Language) - это язык разметки, это способ представления каких-либо структурированных данных.</p> 
    <p>Есть много языков разметки и как правило они все не универсальны. Поэтому придумали XML. Его одно из преимуществ это расширяемость и универсальность, что позволяет на ходу придумать свой язык разметки на базе XML, что и делает его невероятно гибким, он мгновенно подстраивается под ту задачу, которая стоит.</p>
    <p>Ещё одним плюсом явялется его независимость от платформы, ОС и программ обработки.</p>
    <p>Позволяет также представлять не только данные, но и метаданные.</p>
    <p><b>Представление данных</b></p>
    <p>Документ может содержать(это не только xml, но и ворд, эксель и т.д.):</p>
    <ul class="list">
        <li>Данные(это само содержание документа, что мы передаём)</li>
        <li>Структуру(это данные распределённые в виде дерева)</li>
        <li>Уровень представления(это то что мы увидим на экране или на принтере, не зависит от устройства)</li>
    </ul>
    <img src="../img/1С-обмен данными/2025-03-26_09-22-06.png" class="screen" alt="">
    <p>У XML нет "уровня представления", есть только данные и отношение данных к тому или другому "узлу". Вот как браузер покажет данные xml документа? Никак, браузер просто выведет сам документ и всё. Вот так я попытался открыть в браузере xml документ:</p>
    <img src="../img/1С-обмен данными/2025-03-26_09-30-14.png" class="screen" alt="">
    <p>С одной стороны кажется что xml менее развит чем html и ограничен, но это не так, xml находится этажом выше html и является более абстрактной сущностью. Т.е. на его основе можно сделать свой документ, который будет решать нужные мне задачи.</p>
    <p>Как и html, xml использует для разметки теги для хранения данных и теги могут быть вложенными. Элемент это сами теги(начальные и конечные) и вложенные  в них данные.</p>
    <p>XML регистрозависимый язык, каким регистром написаны теги, таким и пользуемся.</p>
    <p>У языком разметки есть 3 главных уровня:</p>
    <img src="../img/1С-обмен данными/2025-03-26_09-43-03.png" class="screen-2" alt="">
    <p>Синтаксис это когда нужно писать "корова", а не "карова". В xml это когда нужно писать правильно угловые скобки там где это нужно, атрибуты там где нужно и так далее. Ну или как в языке 1с, после каждой конструкции нужно ставить ";".</p>
    <p>Грамматика, например в html это когда в тег нужно ложить те теги, которые указанны в стандарте.</p>
    <p>Если посмотреть картинку примера xml документа выше, то мы видим, что у xml есть синтаксис, под вопросом грамматика и очень под большим вопросом семантика. Потому что смысла у названия тегов нет, мы придумаваем названия сами и вкладываем куда хотим.</p>
    <p>Получается, когда мы составляет под какую то свою задачу xml документ, то только тогда и появляется и грамматика(мы вкладываем теги друг в друга) и семантика(мы задаём смысл нашим тегам)</p>
    <img src="../img/1С-обмен данными/2025-03-26_10-13-31.png" class="screen-2" alt="">
    <p>Кстати схемы xml это и есть способы описания грамматики. Мы когда создаём xml документ для описания "списка цен", мы в этот миг изобрели свой язык разметки. И можем описать грамматику нашего языка разметки "список цен". И если мы хотим, чтобы нашим языком разметки пользовались другие, мы можем описать грамматиские правила с помощью схем. Это нужно для валидации.</p>
    <p>Дальше буду просто по временным меткам</p>
    <p>00:54:00 - <b>синтаксис</b> xml документа</p>
    <p>01:20:00 - рассказ про CDATA. Если коротко, то это тег описывающий внутри себя просто текст, который не нужно анализировать. В этом тексте могут быть запрещённые знаки и их не нужно анализировать.</p>
    <img src="../img/1С-обмен данными/2025-03-26_11-08-48.png" class="screen-2" alt="">
    <p>01:22:30 - краткий итог структуры xml документа</p>
    <p>01:24:30 - про пролог и когда в нём нужно указывать кодировку. И про кодировки рассказывает и про BOM метку.</p>
    <p>01:40:00 - первый уровень проверки любой программы-парсера, которая читает xml документ это правило - "хорошо сформированный документ", т.е. идёт перечисление, какие синтаксические правила проверяются у читаемого документа.</p>
    <img src="../img/1С-обмен данными/2025-03-26_12-53-28.png" class="screen" alt="">
    <p>02:06:40 - есть и второй уровень проверки, но о ней позже. Лабаораторная работа по созданию xml документа. Описывают распизание занятий в xml документе. Что они там создали в видео не показали, ну как я понял обычный xml документ.</p>
    <p>02:40:50 - про конфликты xml документов. <b>Пространства имён</b>.</p>
    <p>02:54:50 - мы придумали строку для описания простанства имён нашего файла, например, http://www.specialist.ru/course/xml/lab1, теперь нужно как то привязать это простанство к нашему файлу, для этого есть 2 способа. Первый это через атрибут xmlns(xml name space). Если хотим всему документу привязать пространство, то указываем для тега-корня документа этот атрибут и в его значении вот та строка с пространством имени.</p>
    <img src="../img/1С-обмен данными/2025-03-26_18-24-25.png" class="screen-2" alt="">
    <p>Но можно привязывать и отдельно каджый элемент к своему пространству имён.</p>
    <p>03:04:50 - второй способ указания пространства имён.</p>
    <img src="../img/1С-обмен данными/2025-03-26_18-52-07.png" class="screen" alt="">
    <p>03:25:00 - показывает как документ ворда распаковать в xml файл.</p>
    <p>03:29:00 - <b>грамматика</b> языка. Это как раз DTD(описание структуры документа) и схемы. Когда, например, мы получаем xml документ извне и хотим добавить в нашу БД данные из этого документа, то для начала нужно проверить(провалидировать) этот документ. Это как раз и есть второй уровень проверки.</p>
    <p>03:39:00 - подробно рассказывает как описать структуру документа через DTD.</p>
    <p>Следующее <a href="https://www.youtube.com/watch?v=3nDvSiPQy24">видео</a></p>
    <p>00:00:00 - описание структуры документа через xml схемы. Если для нашего документа описана схема, то указать где валидатору смотреть её можно так:</p>
    <img src="../img/1С-обмен данными/2025-03-28_08-57-11.png" class="screen" alt="">
    <p>Следующее <a href="https://rutube.ru/video/d44622422d1815b8708686ecb9735d7b/">видео</a></p>
    <p>00:00:00 - </p>
    <p>00:00:00 - </p>











    <h2 class="header-style" id="xdto">XDTO, XDTO-пакеты</h2>
    <p>Описываю это из видео Камкова "Средства интеграции и обмена данными 7.1" с 3ч 13м.</p>
    <p>Про механизм XDTO очень хорошо описано в книге "От 8.0 к 8.1", она есть у меня  в книгах 1с.</p>
    <p>XDTO(XML Data Transfer Objects - объекты переноса данных с помощью XML) - механизм позволяющий нам описать структуру обмена данными с помощью XML.</p>
    <p>Ещё определение механизма. Если существует некоторая внешняя схема xml, по которой нужно подготовить данные, можно по этой схеме построить модель XDTO, получить набор типов объектов и потом, создавая эти объекты и заполняя значения их свойств и вводя их в xml-документы, получать xml-документы, соотвествующие их схеме.</p>
    <p>Способность оперировать с данными, представленными в виде XML, и обеспечение возможности работы с этими данными в привычной объектной манере являются ключевыми свойствами механизма XDTO.</p>
    <p>Часто требуется выяснить соответствует ли xml файл заявленному формату. <span class="светло_красный">Пока не понимаю о каком формате идёт речь</span>. Вот что такое формат данных:</p>
    <img src="../img/1С-обмен данными/2025-03-30_09-31-46.png" class="screen-2" alt=""> 
    <p>Схемы xml служат для описания форматов и структуры данных, т.е. каких типов данные и кто в кого вложен, т.е. описание грамматики xml-документа.</p>
    <P>Один из способов это сделать это через XDTO-пакеты. На самом деле у XDTO-пакета немного другое применение, но сначала посмотрим как его создать и использовать, а потом перейдём к случаям, где он действительно необходим.</p>
    <p>Добавим XDTO-пакет и первое, что нам предлагают, это задать пространство имён. Пространство имён нужно для того, чтобы наши элементы в xml документе не ссорились с другими элементами другого xml документа. Напишем - "specialist.ru", соглашаемся и в вылетевшем окошке укажем пространство имён нашего созданного пакета, чтобы система заменила в нём пространство на наше:</p>
    <img src="../img/1С-обмен данными/2025-03-28_10-30-50.png" class="screen" alt="">
    <p>Часто пространство имён это строка и часто она совпадает с доменным именем сайта</p>
    <p>Что можно делать в созданном нами XDTO-пакете? Можно добавлять описание структуры xml файла. Например, можно добавлять элементы xml файла, тут они будут называться объектами. Также можно описывать типы значений. <span class="светло_красный">Это получается, что XDTO примерно делает то, что делает DTD или XML Schema?</span></p>
    <img src="../img/1С-обмен данными/2025-03-28_10-41-24.png" class="screen-2" alt="">
    <p>Мы начнём с описания типов. Но чтобы описать типы, мы сначала должны знать что за xml файл мы будем выгружать, что в нём за типы будут. Давайте опишем пакет, который позволит нам выгружать и загружать в xml файле данные документа "ПоступлениеТоваров". Давайте будем передавать вот эти реквизиты:</p>
    <img src="../img/1С-обмен данными/2025-03-28_10-47-27.png" class="screen-2" alt="">
    <p>Теперь мы можем описать типы этих реквизитов. Добавим первый тип значения и назовём его также как и реквизит - "Номер". Следующее свойство это "Базовый тип". Есть пространство имён "http://www.w3.org/2001/XMLSchema", где описаны базовые типы. Откроем список пространств имён и выберем там вот этот, чтоя написал и в нём выберем тип - "string".</p>
    <img src="../img/1С-обмен данными/2025-03-28_11-21-14.png" class="screen" alt="">
    <p>Также зададим длину номера, если посмотреть в редакторе документа, то там длина номера 9 знаков, значит укажем в свойстве "Длина" число 9, а лучше указать в свойстве "максимальная длина":</p>
    <img src="../img/1С-обмен данными/2025-03-28_11-27-46.png" class="screen" alt="">
    <p>Получается мы ввели свой тип значения "Номер", использовали для этого базовый тип "string", но сделали его более строгим, указав количесвто знаков в строке(не больше 9).</p>
    <p>Далее нужно описать тип "Дата", как сказал Камков, этот тип это копия типа Номер, просто базовый тип другой, поэтому уберём этот тип вообще.</p>
    <p>Затем опишем типа для реквизита "Контрагент". У него тип это справочник ссылка, но таких базовых типов в xml стандартах нет. Поэтому будет делать так как система сама делает, мы будем выгружать ссылку так как она есть в виде идентификатора. Можно было бы взять базовый тип "string" и задать количество знаков, но мы сделаем по другому. 1С уже описало для таких идентификаторов тип, находится он в пространстве имён "http://v8.1c.ru/8.1/data/core" и называется "UUID":</p>
    <img src="../img/1С-обмен данными/2025-03-28_16-56-54.png" class="screen-2" alt="">
    <p>Получается мы опять добавили свой тип "Идентификатор", но он без ограничений и просто ссылается на другой тип "UUID". Просто чтобы в коде потом не писать простанство имён типа "UUID", мы просто напишем "Идентификатор" и он сам сошлётся на "UUID".</p>
    <p>Далее у нас идёт табличная часть, для самой части мы не описываем тип, а вот для реквизитов нужно и то только то, что мы ещё не описали. Например, описывать тип для ссылки номенклатуры уже не нужно, мы только что описали идентификатор, он для всех ссылок. Нам нужно описать для реквизита "Наименование".</p>
    <p>Тут всё как у номера, базовый тип "string", а максимальная длина мы подсмотрим для этого реквизита в свойствах, там 25 знаков, значит ставим 25:</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-07-20.png" class="screen-2" alt="">
    <p>И последний тип опишем для реквизита "Количество" табличной части, у меня его нет в картинке, просто рано срисовал. Тут базовый тип "decimal", потому что число с плавающей запятой и общее 15, точность 2:</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-11-17.png" class="screen-2" alt="">
    <p>Описали, но это ещё не всё. Нам также надо описать реквизит "Номенклатура", но не как ссылка, а как объект, у которого есть 2 свойства: Ссылка и Наименование. Для этого у пакеты вызываем подтекстное меню и выбираем пункт - "Тип объекта".</p>
    <p>Создаём объект "Номенклатура" и всё, а затем в подтекстном меню уже созданного объекта выбираем - добавить свойство:</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-24-07.png" class="screen-2" alt="">
    <p>Называем свойство - "Ссылка" и в пункте "Тип" выбираем наш созданный тип из нашего пространства имён:</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-26-01.png" class="screen-2"  alt="">
    <p>С наименованием то же самое. Если попробовать сохранить конфигурацию, то получим ошибку:</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-30-58.png" class="screen" alt="">
    <p>Камков говорит, что дальше разберёмся с этой ошибкой.</p>
    <p>Оказывается табличную часть также нужно описать, мы её опишем как строка табличной части. Она будет описана через тип - объект. В неё также добавим 2 свойства - "Номенклатура" и "Количество":</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-37-25.png" class="screen-2" alt="">
    <p>И ещё нужно описать тип объекта для документа в целом. Назовём его "ПоступлениеТоваров" и добавим 3 свойства также как и для других объектов:</p>
    <img src="../img/1С-обмен данными/2025-03-28_17-42-30.png" class="screen-2" alt="">
    <p>Минимальное количество строк в табличной части укажем как 0, а максимальное -1, что означает бесконечное.</p>
    <p>И также нам надо описать тип корневого элемента, потому что документ не катит за корень, их моэет быть несколько. Назовём корневой - "ОбменДокументами" и единственное свойство у него будет документ "ПоступлениеТоваров" также с мин 0  и макс -1:</p>
    <img src="../img/1С-обмен данными/2025-03-28_19-10-59.png" class="screen" alt="">
    <p>Как можно заметить описание типов идёт от самых простых и вложенных до корня. Если бы мы начали с корня, то вкладывать нечего было бы.</p>
    <p>Теперь разберёмся с той ошибкой, которая вылетает при сохранении. Мы для идентификатора выбрали тип из не стандартного пространства имён, поэтому нужно явно в пакете сослаться на это пространство. Для этого в ошибке скопируем пространство имён, далее для пакета в подтекстном меню выберем пункт - Добавить - Директива импорта и вставляем скопированную строку с пространством в пространтсво имён.</p>
    <p>Переименуем наш XDTO-пакет в "ОбменДокументами". Пока наш пакет ничего не делает, он лишь содержит описание типов передаваемых данных.</p>
    <p>Теперь стоит задача с помощью этого пакета выгрузить данные тех документов поступления, которые есть в базе. Нам придётся написать код и не мало, чтобы в соответствии с пакетом произвести выгрузку.</p>
    <p>Создадим обработку "ПакетыXDTO", которую можно найти в базе Камкова - "Основные объекты". В форме будет только 2 кнопки: "Выгрузить" и "Загрузить". Опишем действие кнопки "Выгрузить":</p>
    <div class="code-style">
        <pre>
            &НаСервереБезКонтекста
            Процедура ВыгрузитьНаСервере()
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    <span class="серый">"ВЫБРАТЬ
                    |	ПоступлениеТоваровТовары.Ссылка КАК Ссылка,
                    |	ПоступлениеТоваровТовары.Ссылка.Номер КАК Номер,
                    |	ПоступлениеТоваровТовары.Ссылка.Контрагент КАК Контрагент,
                    |	ПоступлениеТоваровТовары.Товар КАК Товар,
                    |	ПоступлениеТоваровТовары.Товар.Наименование КАК ТоварНаименование,
                    |	ПоступлениеТоваровТовары.Количество КАК Количество
                    |ИЗ
                    |	Документ.ПоступлениеТоваров.Товары КАК ПоступлениеТоваровТовары
                    |
                    |УПОРЯДОЧИТЬ ПО
                    |	Номер
                    |ИТОГИ ПО
                    |	Ссылка"</span>;
                
                РезультатЗапроса = Запрос.Выполнить();

                ПространствоИмен = <span class="серый">"specialist.ru"</span>;

                <span class="зелёный">//ФабрикаXDTO содержит наборы пакетов XDTO, там все пакеты, которые есть в системе
                //и плюс наш пакет. Все те пространства имён, которые уже есть и в которых описаны
                //уже разные типы это и есть пакеты XDTO. Тут мы из коллекции пакетов выбираем наш пакет
                //и из нашего пакета выбираем тип "Номер", который мы описали ранее и так далее
                //получаем все типы</span>
                НомерТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"Номер"</span>);
                ИдентификаторТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"Идентификатор"</span>);
                НаименованиеТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"Наименование"</span>);
                КоличествоТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"Количество"</span>);
                НоменклатураТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"Номенклатура"</span>);
                ТоварыСтрокаТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"ТоварыСтрока"</span>); 
                ПоступлениеТоваровТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"ПоступлениеТоваров"</span>);
                ОбменДокументамиТип = ФабрикаXDTO.Тип(ПространствоИмен, <span class="серый">"ОбменДокументами"</span>);

                <span class="зелёный">//метод Создать() с одним параметром вернёт ОбъектXDTO из переданного типа</span>
                ОбменДокументамиXDTO = ФабрикаXDTO.Создать(ОбменДокументамиТип);

                <span class="зелёный">//выбираем группировки</span>
                ВыборкаСсылка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
                Пока ВыборкаСсылка.Следующий() Цикл
                    <span class="зелёный">//метод Создать() вернёт ОбъектXDTO из переданного типа</span>
                    ПоступлениеТовароXDTO = ФабрикаXDTO.Создать(ПоступлениеТоваровТип);
                    
                    <span class="зелёный">//для объекта поступления мы создавали 3 свойства, заполним их</span>
                    ПоступлениеТовароXDTO.Номер = ФабрикаXDTO.Создать(НомерТип, ВыборкаСсылка.Номер);
                    ПоступлениеТовароXDTO.Контрагент = ФабрикаXDTO.Создать(ИдентификаторТип, ВыборкаСсылка.Контрагент.УникальныйИдентификатор());

                    <span class="зелёный">//выбираем детальные из текущей группировки</span>
                    ВыборкаДетальных = ВыборкаСсылка.Выбрать();
                    Пока ВыборкаДетальных.Следующий() Цикл
                        <span class="зелёный">//создадим строку табличной части и заполним её свойства</span>
                        ТоварыСтрокаXDTO = ФабрикаXDTO.Создать(ТоварыСтрокаТип);

                        <span class="зелёный">//прежде чем заполнять номенклатуру в строке табличной части её нужно создать как объект
                        //и заполнить её свойства</span>
                        НоменклатураXDTO = ФабрикаXDTO.Создать(НоменклатураТип);
                        НоменклатураXDTO.Ссылка = ФабрикаXDTO.Создать(ИдентификаторТип, ВыборкаДетальных.Товар.УникальныйИдентификатор());
                        НоменклатураXDTO.Наименование = ФабрикаXDTO.Создать(НаименованиеТип, ВыборкаДетальных.ТоварНаименование);

                        <span class="зелёный">//затем мы уже заполняем свойства строки</span>
                        ТоварыСтрокаXDTO.Номенклатура = НоменклатураXDTO;
                        ТоварыСтрокаXDTO.Количество = ФабрикаXDTO.Создать(КоличествоТип, ВыборкаДетальных.Количество);
                    
                        <span class="зелёный">//ну и заполняем свойство Товары у объекта поступления. Оказывается свойство Товары
                        //является списком XDTO и у него появляется метод Добавить()
                        //Списком свойство становится когда мы указываем максимальное количество при 
                        //создании данного типа в пакете XDTO</span>
                        ПоступлениеТовароXDTO.Товары.Добавить(ТоварыСтрокаXDTO);		
                    КонецЦикла;	

                    <span class="зелёный">//в корень xml документа в его свойство "ПоступлениеТоваров" добавим XDTO объект
                    //документа. Так как мы в этом свойстве трогали максимальное количество, то это
                    //список</span>
                    ОбменДокументамиXDTO.ПоступлениеТоваров.Добавить(ПоступлениеТовароXDTO);	
                КонецЦикла;
                
                <span class="зелёный">//в корневом элементе "ОбменДокументамиXDTO" мы собрали все данные документа и его нужно 
                //записать в xml файл</span>
                ЗаписьXML = Новый ЗаписьXML;
                ЗаписьXML.ОткрытьФайл(<span class="серый">"C:\Users\Professional\Desktop\1С\Примеры файлов для 1С\ДанныеПоступления.xml"</span>);

                <span class="зелёный">//далее обычно вызывается глобальный метод ЗаписатьXML(), куда передаётся ЗаписьXML и объект с 
                //данными для записи, но у фабирики тоже есть такой метод</span>
                ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбменДокументамиXDTO);

                ЗаписьXML.Закрыть();
            КонецПроцедуры

            &НаКлиенте
            Процедура Выгрузить(Команда)
                ВыгрузитьНаСервере();
            КонецПроцедуры
        </pre>
    </div>
    <p>Теперь опишем действия кнопки "Загрузить":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Загрузить(Команда)
                ЧтениеXML = Новый ЧтениеXML;
                ЧтениеXML.ОткрытьФайл(<span class="серый">"C:\Users\Professional\Desktop\1С\Примеры файлов для 1С\ДанныеПоступления.xml"</span>);

                <span class="зелёный">//прочтение фабрикой xml документа вернёт ровно тот объект XDTO "ОбменДокументамиXDTO"
                //который мы выше записывали в файл</span>
                ОбменДокументамиXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);

                ЧтениеXML.Закрыть();

                <span class="зелёный">//далее нужно просто разобрать данные из </span>ОбменДокументамиXDTO в документ объекты и записать в базу
            КонецПроцедуры
        </pre>
    </div>
    <p>Как я понял, чтобы обмен файлами работал между системами, нужно, чтобы в другой системе тоже были описаны такие же XDTO пакеты, которые мы описали.</p>
    <p>ПакетыXDTO можно передавать с помощью выгрузки в XML схемы и загрузки из них. Кстати, если внешние системы не понимают XDTO-пакеты, то при выгрузке пакета в xml схему он становится понятен всем, потому что xml схемы это универсальный формат описания данных и понятен всем. Если выгрузить наш пакет, то получим такую схему:</p>
    <img src="../img/1С-обмен данными/2025-03-30_10-11-22.png" class="screen" alt="">
    <p></p>
    <p></p>
    <p></p>
    











    <h2 class="header-style" id="html">Читаем файл HTML</h2>
    <p>В форме обработки мы можем создать реквизит("ПолеHTML") формы с типом "Строка", перенести его в элементы формы и в палитре свойств в свойстве "Вид" задать "Поле HTML документа". Также создадим ещё один реквизит("Адрес") с типом "Строка", в нём будем хранить адрес на страницу html в интернете или ещё где то. Также создадим команду, по котрой мы введём адрес во второй реквизит и его присвоим первому реквизиту:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьHTML(Команда)
                ПолеHTML = Адрес;
            КонецПроцедуры
        </pre>
    </div>
    <p>У реквизита с видом "Поле HTML документа" есть событие "ДокументСформирован". Так как html страница загружается постепенно, то это событие наступит, когда весь документ будет загружен. У обработчика этого события будет параметр "Элемент", который будет содержать кучу свойст и методов, в том числе и COM объект данной страницы, который даст доступ ко всем свойствам, методам и событиям html страницы.</p>










    <h2 class="header-style" id="http">Работа с HTTP</h2>
    <p>Работа с HTTP описана в отдельном разделе шпоры - "HTTP в 1С"</p>











    <h2 class="header-style" id="ftp">Читаем с помощью FTP данные с сайта</h2>
    <p>FTP (File Transfer Protocol) — это протокол для передачи данных через интернет. Переводится как «протокол передачи файлов». С его помощью можно скачать или отправить что угодно: видео, музыку, программы, изображения. В процедуре передачи файлов участвуют два элемента — клиент и сервер. Первый отправляет запрос в виде команды, а второй обрабатывает её и возвращает ответ в виде файла или сообщения об ошибке.</p>
    <p>FTP был разработан в 1971 году, чтобы быстро и удобно передавать файлы с одного компьютера на другой и управлять удалёнными серверами.</p>
    <p>Протокол FTP может работать как в безопасном, так и в небезопасном режиме. В безопасном режиме данные передаются через зашифрованный канал, используя SSL/TLS протоколы(FTPS или SFTP).</p>
    <p>Чтобы получить доступ к файлам какого-нибудь ресурса, можно в сети спросить доступ по ftp к сайту. Вот, например, к яндексу есть доступ к файлам по такому хосту - "ftp.yandex.ru". Откроется список папок и файлов корня сайта, поищем какой-нибудь текстовый файл, такой найдём в папке "ufficiozero". Вот так будет выглядеть путь - "https://ftp.yandex.ru/ufficiozero/readme.txt". Файл readme.txt мы и попробуем скачать.</p>
    <p>Создадим также обработку с командой "Загрузить":</p>
    <p>Я не предусмотрел одну неточность. Доступ к файлам яндекса сделали наглядно и к хосту прибавили "ftp", но передача файлов всё ранво же происходит по http протоколу. Поэтому этот пример не заработает в коде ниже:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Загрузить(Команда)
                //1м параметром указываем хост
                FTPСоединение = Новый FTPСоединение("ftp.yandex.ru");

                //1й параметр это остальной адрес ресурса. 2й это куда сохраняем
                FTPСоединение.Получить("/ufficiozero/readme.txt", "C:\Users\Professional\Desktop\1С картинки шпоры\r.txt");
            КонецПроцедуры
        </pre>
    </div>
    <p>Потому что платформа к хосту "ftp.yandex.ru" добавит протокол ftp и будет выглядеть так - "ftp://ftp.yandex.ru", а такого адреса нет и будет ошибка. Я пока не смог понять как получить доступ хоть к какому-нибудь сайту через протокол ftp.</p>












    <h2 class="header-style" id="zip">Архивируем файл в zip формате</h2>
    <p>Допустим скачали фал из сети и нужно его заархивировать:</p>
    <div class="code-style">
        <pre>
            <span class="светло_синий">&НаКлиенте
            Процедура Загрузить(Команда)
                <span class="зелёный">//1м параметром указываем хост</span>
                FTPСоединение = Новый FTPСоединение(<span class="серый">"ftp.yandex.ru"</span>);

                <span class="зелёный">//1й параметр это остальной адрес ресурса. 2й это куда сохраняем</span>
                FTPСоединение.Получить(<span class="серый">"/ufficiozero/readme.txt"</span>, <span class="серый">"C:\Users\Professional\Desktop\1С картинки шпоры\r.txt"</span>);

                ЗаписьZIPФайла = Новый ЗаписьZipФайла;

                <span class="зелёный">//указываем куда сохранить сжатый файл</span>
                ЗаписьZIPФайла.Открыть(<span class="серый">"C:\Users\Professional\Desktop\1С картинки шпоры\r.zip"</span>);

                <span class="зелёный">//ну и указываем адрес файла, который нужно сжать</span>
                ЗаписьZIPФайла.Добавить(<span class="серый">"C:\Users\Professional\Desktop\1С картинки шпоры\r.txt"</span>);

                <span class="зелёный">//и записываем</span>
                ЗаписьZIPФайла.Записать();

                <span class="зелёный">//Чтение зип файлов происходит с помощью объекта класса ЧтениеZIPФайла</span>
            КонецПроцедуры</span>
        </pre>
    </div>

















    <h2 class="header-style" id="json">Читаем файл JSON</h2>
    <p>Код будет в обработке "Чтение разных файлов" в базе "Учебная база(курс Камков - Основные объекты)". Для чтения json-объекта там отдельно я создал таблицу значений и поместил её на вторую вкладку. Так что выбираем в диалоге файл json и на второй вкладке жмём "Получить json файл".</p>
    <p>Видео по которому делаю - https://www.youtube.com/watch?v=OMhNFmqb8vI</p>
    <p>JSON(Javascript Objects Notation) - текстовый формат обмена данными, основанный на Javascript. Используется в REST API.</p>
    <img src="../img/1С-1/2023-07-30_07-34-03.png" class="screen" alt="">
    <p>JSON может быть в виде javascript объекта или в виде массива:</p>
    <div class="code-style">
        <pre>
            <span class="зелёный">//json-объект</span>
            {
                "name": "Ложкин ЕвгенийСтепанович",
                "age": 32
            }

            <span class="зелёный">//json-массив</span>
            ["Иванов", "Петров", "Сидоров"]
        </pre>
    </div>
    <p>JSON-объекты могут иметь глубокую вложенность. Например такую:</p>
    <img src="../img/1С-1/2023-07-30_07-48-35.png" class="screen" alt="">
    <p>Для примера мы будем читать файл Сотрудники.json, который лежит у меня на рабочем столе в папке "Примеры файлов для 1С". Чтобы проыитать json можно использовать следующие способы:</p>
    <p><span class="vue-d-b">Используем объект от класса ЧтениеJSON</span></p>
    <ul class="list">
        <li>Этот объект предназначен для последовательного(потокового) чтения JSON, т.е. читается каждый узел объекта json, начиная от открывающихся скобок и т.д. И в зависимости от того какой именно в данный миг находится в потоке узел, мы и принимаем решение что делать.</li>
    </ul>
    <p><span class="vue-d-b">ПрочитатьJSON()</span></p>
    <ul class="list">
        <li>Метод глобального контекста</li>
        <li>Позволяет преобразовать json в фиксированный набор типов платформы(например, json-объект может быть преобразован в Структура или в Соответствие, а json-массив в массив 1С).</li>
        <li>Работает в связке с объектом ЧтениеJSON.</li>
    </ul>
    <p><b>Опишем первый способ чтения</b>. Вот такой файл будем читать и добавлять в табличную часть формы обработки:</p>
    <img src="../img/1С-1/2023-07-30_08-56-31.png" class="screen" alt="">
    <p>Когда мы в потоке дойдём до скобки "{", значит мы начинаем читать нового сотрудника, поэтому надо добавить строку в таблицу значений и начать заполнять колонки.</p>
    <div class="code-style">
        <pre>
            --модуль формы обработки
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ПрочитатьJsonФайл<span class="светло_красный">(</span>Команда<span class="светло_красный">)</span>
                ПрочитатьФайлJSONПоследовательно<span class="светло_красный">();
            КонецПроцедуры 

            &НаКлиенте
            Процедура</span> ПрочитатьФайлJSONПоследовательно<span class="светло_красный">()</span>
                <span class="зелёный">//тут мы опишем как читать файл json последовательно через объект 
                //класса ЧтениеJSON</span>  
                ТаблицаДляJSON<span class="светло_красный">.</span>Очистить<span class="светло_красный">();</span>

                ЧтениеJSON <span class="светло_красный">= Новый</span> ЧтениеJSON<span class="светло_красный">;</span>
                ЧтениеJSON<span class="светло_красный">.</span>ОткрытьФайл<span class="светло_красный">(</span>Объект<span class="светло_красный">.</span>ПутьКФайлу<span class="светло_красный">);</span>

                <span class="зелёный">//или в случае если мы получили строку json из http запроса
                //ЧтениеJSON.УстановитьСтроку(СтрокаJSON);</span>

                <span class="зелёный">//В Соответствии указываем те ключи свойства json-объекта,
                //значение которых хотим добавлять в таблицу значений
                //также ключам должны соответствовать поля таблицы значений  
                //т.е. значение свойства с ключом "name" мы запишем в поле "Содтрудник"
                //и т.д.</span>
                СоответствиеПолей <span class="светло_красный">= Новый</span> Соответствие<span class="светло_красный">;</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"name"</span><span class="светло_красный">,</span> <span class="светло_синийl">"Сотрудник"</span><span class="светло_красный">);</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"inn"</span><span class="светло_красный">,</span> <span class="светло_синийl">"ИНН"</span><span class="светло_красный">);</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"partner_type"</span><span class="светло_красный">,</span> <span class="светло_синийl">"ВидПартнёрства"</span><span class="светло_красный">);</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"is_supplier"</span><span class="светло_красный">,</span> <span class="светло_синийl">"Поставщик"</span><span class="светло_красный">);</span>

                <span class="зелёный">//Итак в объект ЧтениеJSON мы записали строку json из файла
                //теперь нужно начать читать файл, для этого есть 
                //метод Прочитать(). Он позволяет прочитать очередной
                //узел и возвращает Истина, если прочитали и Ложь, если нет
                //1й цикл как бы переключает json-объекты сотрудников</span> 
                <span class="светло_красный">Пока</span> ЧтениеJSON<span class="светло_красный">.</span>Прочитать<span class="светло_красный">() Цикл</span>
                    <span class="зелёный">//внутри цикла, для понимания на каком узле мы сейчас находимся,
                    //у ЧтениеJSON есть свойство "ТипТекущегоЗначения". Для обозначения разных
                    //узлов json-объекта это свойство изпользует системное
                    //перечисление "ТипЗначенияJSON". В этом перечислении есть следующие значения
                    //"НачалоМассива" - это значит что мы в самом начале json-массива
                    //"НачалоОбъекта"  - это значит мы в начале json-объекта	
                    //"ИмяСвойства"  - это значит что мы читаем ключ свойства	
                    //"Строка", "Число", "Null" или "Булево" - это значит мы читаем значение свойства 	
                    //Также у ЧтениеJSON есть свойство "ТекущееЗначение", из него мы можем 	
                    //получить значение ключа свойства, когда поток стоит на узле "ИмяСвойства", 	
                    //либо получить значение свойства когда поток стоит на узлах "Строка", "Число", "Null" или "Булево"</span> 	
                    ТипУзлаJSON <span class="светло_красный">=</span> ЧтениеJSON<span class="светло_красный">.</span>ТипТекущегоЗначения<span class="светло_красный">;</span>
                    
                    <span class="светло_красный">Если</span> ТипУзлаJSON <span class="светло_красный">=</span> ТипЗначенияJSON<span class="светло_красный">.</span>НачалоОбъекта <span class="светло_красный">Тогда</span> 
                        <span class="зелёный">//Тип узла "НачалоОбъекта", значит нужно добавить
                        //новую строку в таблицу значений и дальше заполнять её</span>
                        СтрокаТЗ <span class="светло_красный">=</span> ТаблицаДляJSON<span class="светло_красный">.</span>Добавить<span class="светло_красный">();</span>
                        
                        <span class="зелёный">//2й цикл, который бегает по внутреннему json-объекту и 
                        //достаёт из него данные</span>
                        <span class="светло_красный">Пока</span> ЧтениеJSON<span class="светло_красный">.</span>Прочитать<span class="светло_красный">() Цикл</span> 
                            <span class="светло_красный">Попытка</span>
                                ТекущееЗначениеУзла <span class="светло_красный">=</span> ЧтениеJSON<span class="светло_красный">.</span>ТекущееЗначение<span class="светло_красный">;</span>
                            <span class="светло_красный">Исключение</span> 
                                <span class="светло_красный">Если</span> ЧтениеJSON<span class="светло_красный">.</span>ТипТекущегоЗначения <span class="светло_красный">=</span> ТипЗначенияJSON<span class="светло_красный">.</span>КонецОбъекта <span class="светло_красный">Тогда 
                                    Прервать;
                                КонецЕсли; 
                            КонецПопытки;</span> 
                        
                            ПолеТЗ <span class="светло_красный">=</span> СоответствиеПолей<span class="светло_красный">.</span>Получить<span class="светло_красный">(</span>ТекущееЗначениеУзла<span class="светло_красный">);</span>	
                            <span class="светло_красный">Если</span> ПолеТЗ <span class="светло_красный">&lt;></span> Неопределено <span class="светло_красный">Тогда</span>
                                ЧтениеJSON<span class="светло_красный">.</span>Прочитать<span class="светло_красный">();</span>
                                СтрокаТЗ<span class="светло_красный">[</span>ПолеТЗ<span class="светло_красный">] =</span> ЧтениеJSON<span class="светло_красный">.</span>ТекущееЗначение<span class="светло_красный">;
                                Продолжить;				
                            КонецЕсли;</span>

                            ЧтениеJSON<span class="светло_красный">.</span>Прочитать<span class="светло_красный">();
                        КонецЦикла;
                    КонецЕсли;	
                КонецЦикла;</span> 

                ЧтениеJSON<span class="светло_красный">.</span>Закрыть<span class="светло_красный">();
            КонецПроцедуры</span></span>
        </pre>
    </div>
    <p><b>Опишем второй способ чтения</b>. Читать будем тот же файл, но через глобальный метод ПрочитатьJSON(). Нам также понадобится объект класса ЧтениеJSON. У метода ПрочитатьJSON() достаточно много параметров, но ключевые из них это первые 2. Первый параметр это как раз нужный нам объект класса ЧтениеJSON, а второй это булев параметр, который при Истине говорит, что json-объект будет прочитан в Соответствие, иначе в Структуру. В итоге метод ПрочитатьJSON() вернёт массив соответствий или структур. Читать в соответствие более универсально, потому что ключи могут содержать пробелы в названии, а структура не допускает такие ключи:</p>
    <div class="code-style">
        <pre>
            -модуль формы обработки
            <span class="светло_синий"><span class="светло_красный">&НаКлиенте
            Процедура</span> ПрочитатьФайлJSONГлобМетодом<span class="светло_красный">()</span>
                <span class="зелёный">//тут мы опишем как читать файл json с помощью глобального 
                //метода ПрочитатьJSON()</span>  
                ТаблицаДляJSON<span class="светло_красный">.</span>Очистить<span class="светло_красный">();</span>

                ЧтениеJSON <span class="светло_красный">= Новый</span> ЧтениеJSON<span class="светло_красный">;</span>
                ЧтениеJSON<span class="светло_красный">.</span>ОткрытьФайл<span class="светло_красный">(</span>Объект<span class="светло_красный">.</span>ПутьКФайлу<span class="светло_красный">);</span>	

                <span class="зелёный">//или в случае если мы получили строку json из http запроса
                //ЧтениеJSON.УстановитьСтроку(СтрокаJSON);</span>

                МассивСотрудников <span class="светло_красный">=</span> ПрочитатьJSON<span class="светло_красный">(</span>ЧтениеJSON<span class="светло_красный">);</span>
                
                <span class="зелёный">//тут также укажем соответствие для определения тех ключей
                //значения которых мы хотим достать из json-объекта</span>
                СоответствиеПолей <span class="светло_красный">= Новый</span> Соответствие<span class="светло_красный">;</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"name"</span><span class="светло_красный">,</span> <span class="светло_синийl">"Сотрудник"</span><span class="светло_красный">);</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"inn"</span><span class="светло_красный">,</span> <span class="светло_синийl">"ИНН"</span><span class="светло_красный">);</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"partner_type"</span><span class="светло_красный">,</span> <span class="светло_синийl">"ВидПартнёрства"</span><span class="светло_красный">);</span>
                СоответствиеПолей<span class="светло_красный">.</span>Вставить<span class="светло_красный">(</span><span class="светло_синийl">"is_supplier"</span><span class="светло_красный">,</span> <span class="светло_синийl">"Поставщик"</span><span class="светло_красный">);</span>

                <span class="светло_красный">Для каждого</span> Сотрудник <span class="светло_красный">Из</span> МассивСотрудников <span class="светло_красный">Цикл</span>
                    СтрокаТЗ <span class="светло_красный">=</span> ТаблицаДляJSON<span class="светло_красный">.</span>Добавить<span class="светло_красный">();</span>
                    
                    <span class="светло_красный">Для каждого</span> Свойство <span class="светло_красный">Из</span> Сотрудник <span class="светло_красный">Цикл</span>
                        ПолеТЗ <span class="светло_красный">=</span> СоответствиеПолей<span class="светло_красный">.</span>Получить<span class="светло_красный">(</span>Свойство.Ключ<span class="светло_красный">);</span>
                        <span class="светло_красный">Если</span> ПолеТЗ <span class="светло_красный">&lt;></span> Неопределено <span class="светло_красный">Тогда</span>
                            СтрокаТЗ<span class="светло_красный">[</span>ПолеТЗ<span class="светло_красный">] =</span> Свойство<span class="светло_красный">.</span>Значение<span class="светло_красный">;
                        КонецЕсли;
                    КонецЦикла;
                КонецЦикла;</span>	

                ЧтениеJSON<span class="светло_красный">.</span>Закрыть<span class="светло_красный">();                
            КонецПроцедуры</span></span>
        </pre>
    </div>
    <p>Пример ещё с чтением json есть тут же в разделе в статье "Заполнение контрагента по ИНН. Добавляем расширение в типовую конфу. Используются HTTP объекты. Используется чтение JSON".</p>












    <h2 class="header-style" id="json2">Пишем в файл JSON</h2>
    <div class="code-style">
        <pre>
            <span class="зелёный">//запись в файл clients.json JSON объекта
            //Каталог это путь к папке, которую получили через ДиалогФайла</span>
            ЗаписьJSON = Новый ЗаписьJSON;
            ЗаписьJSON.ОткрытьФайл(Каталог + "\clients.json");

            <span class="зелёный">//ТаблицаКонтрагентов это таблица значений на форме, заполненная списком контрагентов</span>
            МассивДанных = Новый Массив;
            Для каждого Строка Из ТаблицаКонтрагентов Цикл
                СтруктураДанных = Структура("Наименование, ИНН, КПП"); 
                ЗаполнитьЗначенияСвойств(СтруктураДанных, Строка);
                
                МассивДанных.Добавить(СтруктураДанных);
            КонецЦикла; 

            <span class="зелёный">//далее используем метод глобального объекта ЗаписатьJSON</span>
            ЗаписатьJSON(ЗаписьJSON, МассивДанных);

            ЗаписьJSON.Закрыть();
        </pre>
    </div>













    <h2 class="header-style" id="mail">Работа с внешней почтой и встроенной почтой</h2>
    <p>Внешняя почта это почтовые клиенты установленные на комп, телефон или доступные через браузер. Примеры почтовых клиентов:  Microsoft Outlook, Mozilla Thunderbird, Apple Mail, Google Gmail. 1С может через объект работать с этими почтовыми клиентами. Для работы с почтовым клиентом(внешняя почта) есть класс "Почта", "ПочтовоеСообщение".</p>
    <p>Встроенная почта это когда 1С сам выступает в роли почтового клиента и внутри себя может работать с почтой: рассылать, сортировать, удалять и т.д.</p>
    <p>Чаще всего используется встроенная почта, чтобы не было необходимости устанавливать доп. программное обеспечение. Рассмотрим этот способ на примере.</p>
    <p>Создадим обработку, чтобы посмотреть как это работает. В обработке создадим 2 команды: "Отправить" и "Получить". Опишем обработчик для первой команды.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Отправить(Команда)
                <span class="зелёный">//Пользователь и Пароль это реквизиты формы</span>

                ИнтернетПочта = Новый ИнтернетПочта;

                <span class="зелёный">//Создадим профиль для доступа в почте</span>
                Профиль = Новый ИнтернетПочтовыйПрофиль;
                Профиль.АдресСервераSMTP = "smtp.mail.ru";
                Профиль.ПользовательSMTP = "sanya.telegin.84@bk.ru";
                <span class="зелёный">//Вообще говорят, что нужен пароль того акка почты, с которого
                //отправляется сообщение, но у меня ничего не получалось
                //Вылетала всё время ошибка, что требуется пароль приложения
                //Оказалось, что на почте mail нужно получить спец пароль
                //для доступа из внешенго приложения, а 1С это внешнее приложение.
                //В общем в акке отправителя нужно получить спец пароль. Как его получить
                //можно узнать в поисковике, просто введя - "как получить пароль mail для внешнего
                //приложения" или ниже оставлю картинку</span>
                Профиль.ПарольSMTP = "CB9Wpwrw7r8YGt0HxeYB";
                Профиль.ПортSMTP = 465;
                <span class="зелёный">//Протокол шифрования</span>
                Профиль.ИспользоватьSSLSMTP = Истина;
                Профиль.ТолькоЗащищеннаяАутентификацияSMTP = Ложь;

                <span class="зелёный">//создадим сообщение</span>
                ПочтовоеСообщение = Новый ИнтернетПочтовоеСообщение;
                ПочтовоеСообщение.Отправитель = "sanya.telegin.84@bk.ru";
                ПочтовоеСообщение.Получатели.Добавить("sastelegin@mail.ru"); 
                ПочтовоеСообщение.Тема = "Интернет почта 1С";
                ПочтовоеСообщение.Тексты.Добавить("Отправлено из 1С");

                ИнтернетПочта.Подключиться(Профиль);
                ИнтернетПочта.Послать(ПочтовоеСообщение);
                ИнтернетПочта.Отключиться();
            КонецПроцедуры
        </pre>
    </div>
    <p>Картинка, как получить пароль доступа для внешних приложений:</p>
    <img src="../img/1С-1/2024-11-30_21-33-15.png" class="screen" alt="">
    <p>Теперь опишем обработчик для команды "Получить", этим способом получаются письма из указанного почтового ящика. Не забываем что нужно для каждого ящика получать спец. пароль для доступа с внешнего ПО. В первом примере это пароль для адреса "sanya.telegin.84@bk.ru", а во втором примере пароль для "sastelegin@mail.ru":</p>
    <div class="code-style">
        <pre> 
            &НаКлиенте
            Процедура Принять(Команда)
                ИнтернетПочта = Новый ИнтернетПочта;

                <span class="зелёный">//Создадим профиль для доступа в почте</span>
                Профиль = Новый ИнтернетПочтовыйПрофиль;
                Профиль.АдресСервераPOP3 = "pop.mail.ru";
                Профиль.ПортPOP3 = 110;
                Профиль.Пользователь = "sastelegin@mail.ru";
                Профиль.Пароль = "3N2FibpDjp7nmrwAjduR"; <span class="зелёный">//спец пароль для внешнего ПО данного почт. ящика</span>

                ИнтернетПочта.Подключиться(Профиль);
                <span class="зелёный">//метод Выбрать считывает письма с указанного почтового ящика
                //если не указать первым параметром Ложь, то после считывания удалит
                //все письма.</span>
                МассивСообщений = ИнтернетПочта.Выбрать(Ложь);
                
                <span class="зелёный">//также есть метод ПолучитьЗаголовки(). Это метод более быстрый
                //мы получаем заголовки писем, можем выбрать для нас нужные письма
                //по заголовкам в сторонний массив и передать этот массив вторым 
                //параметром в метод Выбрать()
                //Заголовки = ИнтернетПочта.ПолучитьЗаголовки();</span>
            КонецПроцедуры       
        </pre>
    </div>
    <p>Как видим для получения писем с ящика нужно адрес сервера POP3.</p>














    <h2 class="header-style" id="com">Работа 1С с COM объектами</h2>
    <p>Про COMобъект также описанно в разделе про печатные формы в статье "Вывод в active document".</p>
    <p>Ещё про com объекты много видео у девушки на канале, полистать модно найти - <a href="https://www.youtube.com/@PelageyaPrime">тут</a></p>
    <p>COM (Component Object Model). Бывают случаи, когда некоторое приложение выполняет какой то функционал и этот функционал может потребоваться в другом приложении. Такие потребности давно появились, соответственно давно есть решение таких потребностей. Одно из решений это использование COM модели, когда разные приложения предоставляют свои функции друг другу.</p>
    <p>Мы посмотрим как написанные функции и процедуры внутри 1С можно вызывать извне из других приложений.</p>
    <p>Если открыть контекстное меню у корея конфигурации, то там можно увидеть "Модуль внешнего соединения". Описанный в нём код можно вызывать извне. Создадим в этом модуле функцию, возвращающую количество элементов в справочнике "Номенклатура":</p>
    <div class="code-style">
        <pre>
            Функция GetCount() Экспорт
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	КОЛИЧЕСТВО(*) КАК КоличествоЭлементов
                    |ИЗ
                    |	Справочник.Номенклатура КАК Номенклатура";
                
                РезультатЗапроса = Запрос.Выполнить();
                Выборка = РезультатЗапроса.Выбрать();
                
                Выборка.Следующий();

                Возврат Выборка.КоличествоЭлементов;	
            КонецФункции
        </pre>
    </div>
    <p>Также сохраним написанный код в конфигурацию БД нажав на бочонок.</p>
    <p>Далее создадим где-нибудь на компе файл "script.vbs" и отроем его в notepad++. Для справки - Скрипты на Windows с расширением .vbs пишутся на языке Visual Basic Scripting Edition (VBScript).</p>
    <p>Короче вот такой скрипт описали:</p>
    <div class="code-style">
        <pre>
            <span class="зелёный">'создадим объект для соединения. Объект v83.ComConnector это платформа его создаёт, когда устанавливается в винду</span>
            set connector = CreateObject("v83.ComConnector")

            <span class="зелёный">'создадим соединение с нашей инфобазой взяв адрес в окне инфобаз</span>
            set connection = connector.connect("File='C:\Users\Professional\Documents\УБКамковОО';")

            <span class="зелёный">'теперь можно вызвать функцию, которую описали в 1С, и покажем в окне сообщения</span>
            MsgBox connection.GetCount() 
        </pre>
    </div>
    <p>Сохраняем и просто через контекстное меню пытаемся открыть файл, винда сама запустит на выполнение этот скрипт. Будет ошибка, которую Камков не сказал как решить. Тем более он на перерыве разбирал эту ошибку. В общем вот такой примерно один из способов вызвать функцию через COM соединение из 1С.</p>
    <p><b>Далее рассмотрим пример как внутри 1С связываться с другими приложениями через COM модель.</b></p>
    <p>Попробуем загрузить данные из Excel. Есть конечно способ прочитать файл Excel с помощью объекта класса табличного документа, но тут мы свяжемся именно через COM модель.</p>
    <p>Кстати, вот из сети страница, где показаны многие возможности работы с Excel -  <a href="https://infostart.ru/1c/articles/913440/">тут</a>.</p>
    <p>Вот один из способов взаимодействия с внешним приложением</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Загрузить(Команда)
                <span class="зелёный">//параметром в конструктор нужно передать название приложения, 
                //под которым оно записалось в винду при установке</span>
                Excel = Новый COMОбъект(<span class="серый">"Excel.Application"</span>);

                <span class="зелёный">//объект Excel теперь содержит свойства и методы приложения Excel
                //Их при необходимости можно посмотреть в сети
                //Вот этими 2мя командами мы открываем файл в программе Excel</span>
                Excel.WorkBooks.Open(<span class="серый">"C:\Users\Professional\Desktop\Примеры файлов для 1С\Контрагенты.xlsx"</span>);
                Excel.Visible = Истина;

                <span class="зелёный">//Запишем в ячейку строку "Привет"</span>
                Excel.WorkBooks(1).WorkSheets(1).Cells(1,4).Value = <span class="серый">"Привет"</span>;
            КонецПроцедуры
        </pre>
    </div>
    <p>Рассмотрим второй способ.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Загрузить(Команда)
                COMОбъект = ПолучитьCOMОбъект(<span class="серый">"C:\Users\Professional\Desktop\Примеры файлов для 1С\Контрагенты.xlsx"</span>);

                <span class="зелёный">//получим содержимое ячейки и выведем его в окно сообщений</span>
                Значение = COMОбъект.WorkSheets(1).Cells(1,1).Value;
                Сообщить(Значение);

                <span class="зелёный">//Чтобы com объект не висел в памяти завершие его работу</span>
                COMОбъект.Application.Quit;
            КонецПроцедуры    
        </pre>
    </div>












    <h2 class="header-style" id="web-service">Работа 1С с веб-сервисами. Объект WS-ссылка</h2>
    <p>Описываю пример из видео Камкова "Средства обмена данными 7.2" с самого начала.</p>
    <p>Ещё один из способов взаимодействия 1С со сторонними приложениями это взаимодействие с веб-сервисами.</p>
    <p>Веб-сервис - это место где-то в сети, которое содержит ряд функций. Мы можем вызывать эти функции и они нам вернут результат своей работы.</p>
    <p>Для примера возьмём сайт центрального банка России. В самом низу сайта есть ссылка "Технические ресурсы", перейдя по ней мы увидим разные услуги, предоставляемые этим сайтом. Перейдём по ссылке "Веб-сервис для получения ежедневных данных". Самой первой строчкой будет урл адрес веб-сервиса, который предоставляет такие услуги. Скопируем его.</p>
    <p>В конфигурации в разделе "Общие" есть объект "WS-ссылки" - этот объект хранит ссылки на веб-сервисы. Допустим мы часто пользуемся каким-то веб-сервисом и нам часто нужна ссылка на него, вот и будем тут хранить. Добавим объект и сохраним там ссылку на веб-сервис, которую получили на сайте. Но когда сохраняем ссылку в конце её нужно добавить в конце "?wsdl". Это нужно для того чтобы мы получили xml файл с описанием этого сервиса. Без неё 1С не даст сохранить ссылку.</p>
    <p>Немного о файле ****.wsdl описано в разделе PHP -> PHP и XML, Web-services, SOAP.</p>
    <p>Обзовём только что добавленную ссылку, например, "Ежедневные данные". Нажмём на кнопку "Открыть" и увидим дерево от нашей ссылки. При открытии 1С уже сделал запрос по ней и загрузил все функции, которые предоставляет этот сервис:</p>
    <img src="../img/1С-1/2024-12-04_20-48-12.png" class="screen-2" alt="">
    <p>Далее создадим обработку, которая с помощью этого веб-сервиса поможет нам получить справочник с валютами. Будет всего одна команда "Загрузить". Опишем для неё обработчик.</p>
    <div class="code-style">
        <pre>  
            <span class="светло_синий">&НаСервере
            Процедура ЗагрузитьНаСервере()
                <span class="зелёный">//в первую очередь нужно подключистя к веб-сервису. Мы уже сохранили одну ссылку на веб-сервис
                //в объект WS-ссылки. Получим её оттуда</span>
                Прокси = WSСсылки.ЕжедневныеДанные.СоздатьWSПрокси(
                            "http://web.cbr.ru/",
                            "DailyInfo",
                            "DailyInfoSoap");

                <span class="зелёный">//В функцию "EnumValutes" требуется передать Истина или Ложь. Далее будет волшебство с фабрикой XDTO</span>
                ТипПараметра = Прокси.ФабрикаXDTO.Тип(
                            "http://web.cbr.ru/",
                            "EnumValutes");
                Параметр = Прокси.ФабрикаXDTO.Создать(ТипПараметра);

                Параметр.Seld = Ложь;

                <span class="зелёный">//в переменную Прокси мы получили объект посредник, у которого есть все
                //функции, которые предоставляет этот веб-сервис. Нужный нам метод называется
                //"EnumValutes". Как мы узнали какой метод нам нужен? На сайте банка ниже
                //ссылки на веб-сервис описана эта функция, так и узнали, что она делает.</span>
                Данные = Прокси.EnumValutes(Параметр);

                <span class="зелёный">//В переменную Данные функция веб-сервиза вернёт результат своей работы
                //Результат мы получим в виде обекта XDTO. Если поискать, что есть в этом 
                //объекте, то найдём свойство EnumValutes с типом "СписокXDTO", откроем его
                //и там будет список всех валют. Нам для заполнения нашего справочника
                //нужен код, наименование и наименование полное. Под эти реквизиты мы в этом списке
                //можем найти значения. Для кода подойдёт значения свойства VnumCode,
                //для наименования короткого подойдут значения свойства VcharCode, а для
                //полного наименования - Vname </span>
                Для каждого Значение Из Данные.EnumValutesResult.diffgram.ValuteData.EnumValutes Цикл
                    <span class="зелёный">//бывают валюты, которые не содержат ни кода, ни буквенного обозначения
                    //каждый элемент коллекции это объект XDTO и если валюта не имеет буквенного обозначения
                    //то и свойств VcharCode у объекта не будет. Вот чтобы у нас не вылетали
                    //ошибки, что такого свойства нет мы и проверяем на их наличие</span>
                    Если Значение.Свойства().Получить("VcharCode") = Неопределено Тогда
                        Продолжить;
                    КонецЕсли;

                    СправочникОбъект = Справочники.Валюты.СоздатьЭлемент();	
                    СправочникОбъект.Код = Значение.VnumCode;	
                    СправочникОбъект.Наименование = Значение.VcharCode;	
                    СправочникОбъект.НаименованиеПолное = Значение.Vname;	
                    
                    СправочникОбъект.Записать();
                КонецЦикла;
            КонецПроцедуры

            &НаКлиенте
            Процедура Загрузить(Команда)
                ЗагрузитьНаСервере();
            КонецПроцедуры</span>
        </pre>
    </div>
    <p>Курсы валют также можно загрузить через функцию этого веб-сервиса.</p>













    <h2 class="header-style" id="web-service2">Работа 1С с веб-сервисами. Объект Web-сервис</h2>
    <p>У Камкова мало что рассказано об объекте "веб-сервис". Этот объект нужен для создания функций у нас в конфигурации для вызова их извне.</p>
    <p>Например, мы уже описали XDTO-пакет и он находится в пространстве имён "specialist.ru". Создадим новый Web-сервис - "ОбменДокументами", на закладке "Прочее" мы укажем пространство имён такое же как и XDTO-пакет и выберем наш созданный пакет:</p>
    <img src="../img/1С-обмен данными/2025-03-30_18-30-35.png" class="screen-2" alt="">
    <p>Затем на закладке "Операции" мы создадим метод назвав его ПолучитьДокументы(), а в свойстве "Тип возвращаемого значения" укажем корневой объект из нашего пакета:</p>
    <img src="../img/1С-обмен данными/2025-03-30_18-34-53.png" class="screen" alt="">
    <p>Мы можем добавить параметры нашему методу, вызовем подтекстное меню у метода и добавить параметр. Зададим 2 параметры: "ДатаНачала" и "ДатаОкончания". Типы значения для них возьмём из простраства xml схемы:</p>
    <img src="../img/1С-обмен данными/2025-03-30_18-39-34.png" class="screen-2" alt="">
    <p>Также надо описать код для этого метода:</p>
    <img src="../img/1С-обмен данными/2025-03-30_18-41-48.png" class="screen-2" alt="">
    <p>После нажатия на лупу откроется модуль с заготовкой:</p>
    <img src="../img/1С-обмен данными/2025-03-30_18-46-28.png" class="screen-2" alt="">
    <p>И остаётся опубликовать наш метод: "Администрирование" - "Публикация на веб сервере". ПРи выборе этого пункта у меня вышло сообщение "Веб сервер не обнаружен". Ну там далее по обстоятелствам, нужно в инете смотреть как выложить на сервер наш метод.</p>












    <h2 class="header-style" id="http-service">Работа 1С с http-сервисами</h2>
    <p>HTTP-сервис это тоже объект конфигураии и выполняет примерно то же самое что и веб-сервис, но немного по другому. Вот <a href="https://infostart.ru/1c/articles/1523650/">сайт</a>, на котором описано отличие между ними.</p>












    <h2 class="header-style" id="plan-obmena">Работа с планами обмена</h2>
    <p>В разделе Общие дерева конфигурации есть такой объект как "Планы обмена". Допустим мы обменялись с сайтом данными справочника Номенклатура. Этот справочник имеет не маленькие данные. Позже мы в работе 1С что-то изменили в товаре этого справочника, например, поменяли значение какого-то одного реквизита и нам нужно изменение передать на сайт. И что, придётся опять передавать все товары из-за одного изменённого реквизита трятя ресурсы и время? Нет, вот для таких целей есть объект плана обмена, он отслеживает изменения.</p>
    <p>В редакторе окна этого объекта на вкладке "Основные" есть кнопка "Состав", где мы и выбираем объекты, за которыми нужно следить. Как вообще происходит отслеживание изменений. Платформа создаёт дополнительную таблицу связанную с тем объектом, который мы отслеживаем. Называется эта таблица "Изменения". Её можно увидеть в консоли запросов обратившись к ней вот так:</p>
    <div class="code-style">
        <pre>
            ВЫБРАТЬ
                *
            ИЗ
                Справочник.Номенклатура.Изменения
        </pre>
    </div> 
    <p>Пока эта таблица пустая, даже если внести изменения в любой товар, то ничего в таблице не появится. Нужно для начала зайти в план обмена, который мы создали и создать 2 плана: "Узел"(Код "У") и "Центр"(Код "Ц") - это примеры. Один элемент плана обмена уже был сразу, мы его назвали "Центр", это та БД с которой мы работаем. "Центр" это источник, а нужен ещё один узел приёмник. Это я так понял. Теперь у нас есть сторонний узел, на который мы типо передаём. Теперь если внести изменения в товар, то в запросе в таблице "Изменения" мы уже увидим узел, на который нужно передать и в поле "Ссылка" увидим ссылку на товар, в котором произошло изменения и его нужно передать.</p>
    <img src="../img/1С-1/2024-12-05_11-22-11.png" class="screen" alt="">
    <p>Это и есть назначение объекта конфигурации "План обмена", отслеживать измнениея у указанных объектов. Теперь на примере обработки посмотрим выгрузку и загрузку xml файлов. Переводить данные в xml мы будем через метод ЗаписатьXML, который умеет записывать объекты справочников, документов в xml файлы целиком. Опишем обработчик команды "Выгрузить":</p>
    <div class="code-style">
        <pre>           
            &НаСервере
            Процедура ВыгрузитьНаСервере()
                <span class="светло_красный">В чём разница между ЗаписьXML и ЗаписатьXML()? 
                ЗаписьXML это объект, который предназанчен для последовательной записи данных в узы xml файла,
                но можно не мучаться с детальной записью и записать всё быстрее. Для этого нужен метод ЗаписатьXML().
                Ему первым параметром подаём объект ЗаписьXML и вторым параметром объект документа, элемента спаравочника 
                или как у нас в примере объект плана обмена(ПланОбменаОбъект.ИмяПлана). Система сама запишет данные
                из объекта обмена в объект ЗаписьXML</span>
                <span class="зелёный">//нам нужно записать в xml файл всё то, что накопилось для передачи
                //в таблице "Изменения"</span>
                ЗаписьXML = Новый ЗаписьXML;

                <span class="зелёный">//указываем в какой файл будем выгружать</span>
                ЗаписьXML.ОткрытьФайл("C:\Users\Professional\Desktop\1С картинки шпоры\Обмен с сайтом.xml");

                <span class="зелёный">//объект ЗаписьСообщения нам нужен для того, чтобы в xml файл записать
                //служебные данные</span>
                ЗаписьСообщения = ПланыОбмена.СоздатьЗаписьСообщения();
                <span class="зелёный">//параметр Узел это реквизит формы с типом ПланОбменаСсылка.ОбменССайтом
                //т.е. мы на форме выбираем узел, в адрес которого будет послано сообщение обмена данными.
                //Узел нужен чтобы мы в заголовок xml файла записали откуда и куда мы выгружаем данные
                //это надо, чтобы данные не передались в посторонние узлы </span>
                ЗаписьСообщения.НачатьЗапись(ЗаписьXML, Узел);

                <span class="зелёный">//Получит запросом выборку данных, которые изменились
                //У меня вопрос, почему мы выбираем данные из таблицы Изменения у всего плана обмена
                //а не у нашего конкретного плана "ОбменССайтом"?
                </span>
                Выборка = ПланыОбмена.ВыбратьИзменения(Узел, ЗаписьСообщения.НомерСообщения);

                Пока Выборка.Следующий() Цикл
                    Данные = Выборка.Получить();
                    ЗаписатьXML(ЗаписьXML, Данные);
                КонецЦикла;

                ЗаписьСообщения.ЗакончитьЗапись();
                ЗаписьXML.Закрыть();
            КонецПроцедуры

            &НаКлиенте
            Процедура Выгрузить(Команда)
                ВыгрузитьНаСервере();
            КонецПроцедуры
        </pre>
    </div>
    <p>Вот так будет выглядеть xml файл:</p>
    <img src="../img/1С-1/2024-12-06_10-44-53.png" class="screen" alt="">
    <p>Теперь выгруженный xml файл попробуем прочитать обратно:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ЗагрузитьНаСервере()
                ЧтениеXML = Новый ЧтениеXML;
                ЧтениеXML.ОткрытьФайл("C:\Users\Professional\Desktop\1С картинки шпоры\Обмен с сайтом.xml");

                ЧтениеСообщения = ПланыОбмена.СоздатьЧтениеСообщения();
                ЧтениеСообщения.НачатьЧтение(ЧтениеXML, ДопустимыйНомерСообщения.Очередной);

                Пока ВозможностьЧтенияXML(ЧтениеXML) Цикл
                    Данные = ПрочитатьXML(ЧтениеXML);
                    Данные.Записать();		
                КонецЦикла;

                ЧтениеСообщения.ЗакончитьЧтение();
                ЧтениеXML.Закрыть();
            КонецПроцедуры

            &НаКлиенте
            Процедура Загрузить(Команда)
                ЗагрузитьНаСервере();
            КонецПроцедуры
        </pre>
    </div>
    <p>Чтобы предыдущий xml файл прочитался, нам нужно его открыть и вручную поменять источник и приёмник, т.е. из "У" в "Ц" в заголовке</p>











    <h2 class="header-style" id="konvertaciya">Работа с конвертацией данных</h2>
    <p>Конвертация данных — это преобразование данных из одного формата в другой. Обычно с сохранением основного логическо-структурного содержания информации.</p>
    <p>Делаю по видео Камкова "Средства интеграции и обмена данными 7.2". Описывать всё не буду, там много объяснений. Смотреть с 02:11:30.</p>
















    
    <h2 class="header-style" id="read-file-on-server">Чтение файла на стороне сервера. Класс ДвоичныеДанные.</h2>
    <p>Если вспомнить процедуру чтения файла excel, то мы выполняли её на сервере, потому что метод Прочитать() не доступен на клиенте. В этот метод 1м параметром передаётся путь до файла. В нашем случае информационная база и клиент находятся на одном копьюторе, поэтому и путь до файла на стороне сервера нашёлся. Но что если сервер будет другой компьютер, путь уже не сработает, потому что на другом компьютере структура файлов другая и там нет того файла, который есть на нашем компе. И как вывод, если у нас будет клиент-серверная структура, то код который мы написали для чтения файла excel выше уже не стработает. Напишем другой код, который использует <b>временное хранилище</b>. Временное хранилище это место куда веб сервер временно ложит файлы прилетевшие с клиента. Как я понимаю на веб сервер установлен язык 1с, по типу php. Теперь 1с нужно забрать данные файла из временного хранилища веб сервера, но как узнать где лежат данные? А это нам скажет клиент, который когда ложил данные в хранилище обратно получил адрес этих данных. Клиент пересылает адрес на сервер в скрипт 1с и 1с по этому адресу забирает из хранилища данные и записывает их в фаёловою систему сервера. Ну а потом берёт из этой файловой системы сервера данные файла и что то с ними делает.</p>
    <p>Чтобы клиент смог поместить данные файла в хранилище, нам для начала нужно считать двоичные данные этого файла на клиенте. Потом поместить во временное хранилище.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПрочитатьФайлXLSX()
                <span class="зелёный">//примером файла Excel будет Список контрагентов.xlsx


                //1с на веб сервере по переданному пути не найдёт файл, поэтому нужно передать файл на сервер
                //во временное хранилище. Передать файл нужно в виде двоичных данных, а для этого на клиенте
                //нужно файл получить в виде этих двоичных данных. Для этого есть класс ДвоичныеДанные
                //класс вернёт объект с двоичными данными</span>
                ДанныеФайла = Новый ДвоичныеДанные(Объект.ПутьКФайлу);

                <span class="зелёный">//Далее двоичные данные файла нужно поместить во временное хранилище используя глобальным метод
                //этот метод вернёт адрес места в хранилище, куда он положил данные файла </span>
                АдресДанных = ПоместитьВоВременноеХранилище(ДанныеФайла);
            
                <span class="зелёный">//далее адрес передадим на серверную сторону 1с</span>
                ПрочитатьФайлXLSXНаСервере(АдресДанных);	
            КонецПроцедуры

            &НаСервере
            Процедура ПрочитатьФайлXLSXНаСервере(АдресДанных)
                <span class="зелёный">//из-за того что метод Прочитать() доступен только на сервере мы и вынуждены выполнять код на сервере</span>
                ТабДок = Новый ТабличныйДокумент;

                <span class="зелёный">//теперь нам надо получить объект с двоичными данными файла из временного хранилища веб сервера
                //для этого используем метод глобального контекста</span>
                Данные = ПолучитьИзВременногоХранилища(АдресДанных);

                <span class="зелёный">//двоичные данные нужно теперь записать в файловой системе веб сервера
                //у объекта Данные есть метод Записать(), в качестве параметра надо передать имя файла, куда будем записывать данные
                //чтобы избежать совпадений имён мы вызовем глобальный метод для создания уникального временного имени для файла
                //в параметрах можно указать расширение файла</span> 
                ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xlsx");
                <span class="зелёный">//метод Записать сам создаст файл в файловой системе веб сервера, даст ему имя из параметра и запишет в него двоичные данные</span>
                Данные.Записать(ИмяВременногоФайла);

                <span class="зелёный">//чтобы при чтении файла исключить вылет ошибок обернём чтение в Попытка..Исключение</span>
                Попытка
                    <span class="зелёный">//из табличного файла данные можно считывать 2мя способами.Либо по типам значений - число считывается как число, строка как строка,
                    //либо всё считывать как текст, т.е. всё будет считываться как строки.
                    //1м параметром передаём имя временного файла на сервере, в котором и лежит наш файл с клиента</span> 
                    ТабДок.Прочитать(ИмяВременногоФайла, СпособЧтенияЗначенийТабличногоДокумента.Значение);
                Исключение
                    <span class="зелёный">//ОписаниеОшибки() это метод Глобального контекста, который вернёт текст ошибки</span>
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Не удалось прочитать указанный файл по причине " + ОписаниеОшибки();
                    Сообщение.Сообщить();
                    Возврат;
                КонецПопытки;

                <span class="зелёный">//если ошибок нет, то можем двигаться дальше и нам нужно получить количество строк в табличном файле</span>
                КоличествоСтрок = ТабДок.ВысотаТаблицы;

                <span class="зелёный">//и далее в цикле будем считывать построчно табличный файл, начинать будем
                //со 2й строки, потому что в 1й строке шапка</span>
                Для НомерСтроки = 2 По КоличествоСтрок Цикл
                    <span class="зелёный">//в табличную часть добавляем новую строку
                    //и колонкам этой строки задаём части массива</span>
                    НоваяСтрока = Объект.ДанныеФайла.Добавить(); 

                    <span class="зелёный">//метод ПолучитьОбласть() вернёт объект типа ТабличныйДокумент, нам же нужно получить содержимое ячейки
                    //у вернувшегося объекта есть подобъект ТекущаяОбласть, а унего есть свойство Текст, которое нам и даст
                    //содержимое ячейки</span> 
                    НоваяСтрока.КраткоеНаименование = ТабДок.ПолучитьОбласть("R" + Формат(НомерСтроки, "ЧГ=0") + "C1").ТекущаяОбласть.Текст;
                    НоваяСтрока.ПолноеНаименование = ТабДок.ПолучитьОбласть("R" + Формат(НомерСтроки, "ЧГ=0") + "C2").ТекущаяОбласть.Текст;
                    НоваяСтрока.УНП = ТабДок.ПолучитьОбласть("R" + Формат(НомерСтроки, "ЧГ=0") + "C3").ТекущаяОбласть.Текст;
                КонецЦикла;	
            КонецПроцедуры
        </pre>
    </div>















    <h2 class="header-style" id="abc">Чтение файла со списком контрагентов и запись их в справочник Контрагенты</h2>
    <p>Использовать будем эту же обработку "ЧтениеРазныхФайлов". Напомню она находится в конфе "Курс Камкова Основные объекты". Рядом с кнопкой "Прочитать файл" добавим кнопку "Записать файл", которая будет создавать новые элементы справочника и записывать их в БД.</p>
    <p>Покажем 2 способа как это сделать, первый будет с ошибками, а второй с исправлением ошибок. Итак на кнопку "Записать в файл" повесим обработчик с клиентом и процедурой на сервере. Так как мы будем создавать новые элементы справочника, то такие работы идут только на сервере, потому что нужно работать с БД. Ниже в коде процедуры создания и записи новых элементов справочника, остальной код по чтению файлов описан выше:</p>
    <div class="code-style">
        <pre>
            --запись контрагентов в справочник
            --предполагается что файл уже прочитан и табличная часть ДанныеФайла заполнена
            &НаКлиенте
            Процедура ЗаписатьФайл(Команда)
                ЗаписатьФайлНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ЗаписатьФайлНаСервере()
                <span class="зелёный">//нам нужно выполнить обход коллекции табличной части ДанныеФайла и для каждой строки создать новый 
                //элемент справочника Контрагенты</span>
                Для каждого СтрокаТабЧасти Из Объект.ДанныеФайла Цикл
                    <span class="зелёный">//далее нам надо проверить по полю УНП нет ли совпадений контрагентов из файла с контрагентами в справочнике
                    //если УНП совпало то не надо создавать новый элемент. Для этого будем использовать объектную модель запроса
                    //к БД. У менеджера справочников есть метод НайтиПоРеквизиту(). В цикле будем подставлять в этот метод
                    //имя реквизита и его значение и искать есть ли такой уже в базе.
                    //метод возвращает ссылку на найденный элемент, если не нашёл, то пустая ссылка вернётся.</span>
                    СсылкаЭлемента = Справочники.Контрагенты.НайтиПоРеквизиту("УНП", СтрокаТабЧасти.УНП);

                    <span class="зелёный">//сравним что нам вернулось, если пустая ссылка, то её нужно сравнить с пустой ссылкой
                    //если там не пустая ссылка, а вполне конкретная, то пропускаем данный круг цикла, потому что такой элемент 
                    //значит есть уже в справочнике</span>
                    Если СсылкаЭлемента &lt;> Справочники.Контрагенты.ПустаяСсылка() Тогда
                        Продолжить;	
                    КонецЕсли;

                    <span class="зелёный">//ну а если ссылка пустая, то создадим новый элемент справочника и зполним его</span>
                    НовыйЭлемент = Справочники.Контрагенты.СоздатьЭлемент();

                    <span class="зелёный">//в моём случае можно указать папку в которую запишем элементы</span>
                    НовыйЭлемент.Родитель = Справочники.Контрагенты.НайтиПоНаименованию("Поставщики");

                    НовыйЭлемент.Наименование = СтрокаТабЧасти.КраткоеНаименование;
                    НовыйЭлемент.НаименованиеПолное = СтрокаТабЧасти.ПолноеНаименование;
                    НовыйЭлемент.УНП = СтрокаТабЧасти.УНП;

                    <span class="зелёный">//далее нужно записать новый элемент справочника в базу</span>
                    НовыйЭлемент.Записать();
                КонецЦикла;

                Сообщить("Создание контрагентов завершено");
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="светло_красный">Напомню это мы описали сопособ с ошибками создания и записи элементов справочника</span>.</p>
    <p>Первая ошибка кроется в том, что разные типы у реквизита "УНП" в справочнике и в табличной части ДанныеФайла. В справочнике стоит Число, а в таб. части строка. И из-за этого при поиске реквизита "УНП" мы передаём УНП с типом строка, а сравнение внутри метода НайтиПоРеквизиту() идёт с реквизитом справочника "УНП" с типом число, поэтому сравнение не правильно сработает и у нас появятся повторные контрагенты. Решение простое, просто приводим 2й параметр этого метода к числу.</p>
    <p>Вторая ошибка в том, что у нас в цикле выполняется метод НайтиПоРеквизиту() и у меня ещё и метод НайтиПоНаименованию(). Эти методы делают запросы в базу. А вдруг у нас контрагентов 10 000, то будет сделано 20 000 запросов в базу. И это у меня файловый способ организации базы, а если это с настоящим веб сервером, который от себя ещё посылает переделанные запросы в СУБД. Это очень нагрузит все системы и СУБД и сервер, короче ОЧЕНЬ ПЛОХО делать запросы в цикле. Мы можем сделать один запрос, получить все значения реквизита "УНП" в оперативную память, поместить их в массив, а затем в цикле берём значение "УНП" из табличной части и ищем их в этом массиве, если не нашли значит создаём новый элемент. Вот обновлённый код:</p>
    <div class="code-style">
        <pre>
            --запись контрагентов в справочник
            --предполагается что файл уже прочитан и табличная часть ДанныеФайла заполнена
            &НаКлиенте
            Процедура ЗаписатьФайл(Команда)
                ЗаписатьФайлНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ЗаписатьФайлНаСервере()  
                <span class="зелёный">//выберем все значения поля УНП и перепишем их в массив</span>
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	Контрагенты.УНП КАК УНП
                    |ИЗ
                    |	Справочник.Контрагенты КАК Контрагенты";
                
                РезультатЗапроса = Запрос.Выполнить();	
                ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
                
                МассивУНП = Новый Массив;
                Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
                    МассивУНП.Добавить(ВыборкаДетальныеЗаписи.УНП);
                КонецЦикла;

                <span class="зелёный">//также вынесем получение ссылки на элемент-папку Поставщики, чтобы указвать её
                //в качестве родителя для созданных элементов. Можно получить ссылку и на Покупатели если надо</span>
                СсылкаНаПоставщика = Справочники.Контрагенты.НайтиПоНаименованию("Поставщики");

                <span class="зелёный">//нам нужно выполнить обход коллекции табличной части ДанныеФайла и создать новые 
                //элементы справочника Контрагенты</span>
                Для каждого СтрокаТабЧасти Из Объект.ДанныеФайла Цикл
                    Если МассивУНП.Найти(Число(СтрокаТабЧасти.УНП)) &lt;> Неопределено Тогда
                        Продолжить;	
                    КонецЕсли;

                    <span class="зелёный">//если в массиве не найдено, то создадим новый элемент справочника и зполним его</span>
                    НовыйЭлемент = Справочники.Контрагенты.СоздатьЭлемент();

                    <span class="зелёный">//в моём случае можно указать папку в которую запишем элементы
                    //чтобы указать родителя не пойдёт просто записать строку "Поставщики", потому что Поставщики как и Покупатели
                    //это такие же эелементы справочника, а потому надо указать ссылку на элемент, чтобы её указать надо получить такую
                    //ссылку, найдём её по наименованию в базе</span>
                    НовыйЭлемент.Родитель = СсылкаНаПоставщика;

                    НовыйЭлемент.Наименование = СтрокаТабЧасти.КраткоеНаименование;
                    НовыйЭлемент.НаименованиеПолное = СтрокаТабЧасти.ПолноеНаименование;
                    НовыйЭлемент.УНП = СтрокаТабЧасти.УНП;

                    <span class="зелёный">//далее нужно записать новый элемент справочника в базу</span>
                    НовыйЭлемент.Записать();
                КонецЦикла;

                Сообщить("Создание контрагентов завершено");
            КонецПроцедуры
        </pre>
    </div>












    <h2 class="header-style" id="abc2">Заполнение контрагента по ИНН</h2>
    <p>Делаю по видео "Заполнение реквизитов контрагента по ИНН в 1С" от IRONSKILS, видео есть и на компе.</p>
    <p>Почти в каждой типовой конфигурации есть справочник контрагентов. Было бы здорово при создании нового контрагента иметь кнопку, которая при вводе ИНН заполнила бы нам данные в карточке контрагента. Создадим такую кнопку.</p>
    <p>Но сначала разберёмся где взять данные контрагента по ИНН. Есть <a href="https://egrul.nalog.ru/index.html">сайт</a>, на котором предоставляются все данные по ИНН, ОГРН или по наименованию ЮЛ, ИП. Но данные предоставляются либо вот так в строке: </p>
    <img src="../img/1С-1/2024-11-14_09-42-36.png" class="screen" alt="">
    <p>Либо в формате .pdf при нажатии на кнопку "Получить выписку". Нам не подходит не тот, ни другой способ. Потому что мы предполагаем обращение из кода к данным, а тут нужно вручную вставлять ИНН. Проще говоря нам нужен API от этого сайта, но такого програмного взаимодействия этот сайт не предоставляет, но есть другой сайт, который предоставляет API для взаимодействия с ЕГРЮЛ. Вот этот <a href="https://egrul.itsoft.ru/">сайт</a>.</p>
    <p>На этом сайте через API можно получить данные по ИНН в формате xml, json, csv. Как это работает? Мы с помощью программного интерфейса отправим к этому сайту ИНН контрагента, а в ответ этот сайт нам пришлёт данные этого контрагента. Нам нужны краткие данные, поэтому пролистываем вниз до секции:</p>
    <img src="../img/1С-1/2024-11-14_09-55-00.png" class="screen" alt="">
    <p>В этой секции приведён api, в который мы вставляем нужный ИНН и в ответ придут данные в виде json. Удобнее работать в программе Postman, где мы в строку GET вводит этот http и нам придёт ответ не в виде строки, как это будет выглядеть в браузере, а уже в виде объекта, который глазу человека понятней:</p>
    <img src="../img/1С-1/2024-11-14_10-04-20.png" class="screen" alt="">
    <p>И нам оставнется в 1С прочитать этот json, взять нужные данные и подставить в поля контрагента. Давайте добавим такую функциональность к типовой конфигурации. У меня на данный миг установленная учебная УТ 11.4 и УНФ 3.0.  В УНФ в форме элемента контрагента уже есть такая кнопка, она по ИНН или наименованию заполняет контрагента. Мы отключим эту кнопку и добавим свою. Но конфигурация находится на поддержке и мы не будем снимать её, чтобы разблокировать возможность изменять форму. Мы добавим расширение.</p>
    <p>Итак, в конфигураторе жмём "Конфигурация" -> "Расширения конфигурации" и добавляем расширение. Укажем имя расширения: "IRONSKILLS_ЗаполнениеПоИНН" и префикс: "IS_" и нажмём ОК. Расширение создано, сразу снимем флаги "Безопасный режим" и "Защита от опасных действий" о откроем расширение двойным кликом по нему. Это расширение откроется по умолчанию слева под основной конфигурацией.</p>
    <p>Для формы элемента справочника "Контрагенты" через контекстное меню добавляем расширение:</p>
    <img src="../img/1С-1/2024-11-14_10-23-33.png" class="screen2" alt="">
    <p>Откроется редактор формы элемента, но уже в расширении. Нам нужно сделать свою кнопку, для этого нам нужно создать команду формы и элемент формы, который будет ссылаться на эту команду, но сделаем это программно в событии формы "ПриСозданииНаСервере" с типом вызова "Вызвать после". Далее описание действий будет в коде в виде комментариев:</p>
    <div class="code-style">
        <pre>
            --форма элемента расширения "IRONSKILLS_ЗаполнениеПоИНН"

            
            <span class="светло_синий"><span class="светло_красный">&НаСервере
            Процедура</span> IS_ПриСозданииНаСервереПосле(Отказ, СтандартнаяОбработка)
                <span class="зелёный">//отключим видимость старой кнопки "Заполнение по ИНН и наименованию"</span>
                Элементы.ФормаЗаполнитьРеквизитыПоДаннымЕГР.Видимость = Ложь; 

                <span class="зелёный">//далее создадим программно команду формы</span>  
                ИмяКоманды = <span class="тёмно_серый">"IS_ЗаполнитьПоИНН"</span>;
                Команда = ЭтаФорма.Команды.Добавить(ИмяКоманды);
                <span class="зелёный">//зададим имя процедуры, которая выполнится по нажатию на эту команду</span>
                Команда.Действие = ИмяКоманды;
                <span class="зелёный">//команды изменяет данные карточки контрагента, поэтому установим 
                //свойство "ИзменяетСохраняемыеДанные" в Истина, чтобы появилась
                //"звёздочка" рядом с именем контрагента, что сигнализирует об изменении
                //данных и что их нужно сохранить</span>
                Команда.ИзменяетСохраняемыеДанные = Истина;
                <span class="зелёный">//заполним заголовок команды, это так будет подписана кнопка для пользователя.</span>
                Команда.Заголовок = <span class="тёмно_серый">"Заполнить по ИНН"</span>; 


                <span class="зелёный">//далее нужно создать кнопку в элементах формы связанную с этой командой</span>
                НовыйЭлемент = Элементы.Добавить(ИмяКоманды, Тип(<span class="тёмно_серый">"КнопкаФормы"</span>), Элементы.КомандыВажно);
                НовыйЭлемент.ИмяКоманды = ИмяКоманды;
            <span class="светло_красный">КонецПроцедуры</span>  


            <span class="зелёный">//процедура вызываемая по команде "IS_ЗаполнитьПоИНН" созданной нами</span>
            <span class="светло_красный">&НаКлиенте
            Асинх Процедура</span> IS_ЗаполнитьПоИНН(Команда)
                ИНН = <span class="светло_красный">Ждать</span> ВвестиСтрокуАсинх(, <span class="тёмно_серый">"Введите ИНН"</span>, 12); 
                
                <span class="светло_красный">Если</span> ИНН = Неопределено <span class="светло_красный">Тогда
                    Возврат;
                КонецЕсли;</span>

                <span class="светло_красный">Если</span> СтрДлина(ИНН) &lt; 10 <span class="светло_красный">Тогда</span>
                    ПредупреждениеАсинх(<span class="тёмно_серый">"Неправильный ИНН, повторите ввод данных"</span>);
                    <span class="светло_красный">Возврат;
                КонецЕсли;</span>

                <span class="зелёный">//все проверки прошли, теперь по ИНН нужно получить данные с сайта
                //для этого используем объекты HTTP, вынесем получение данных в отдельную функцию</span>
                ДанныеКонтрагента = IS_ПолучитьДанныеКонтрагнетаПоИНН(ИНН);

                <span class="зелёный">//структуру ДанныеКонтрагента получили, теперь на сервере заполним реквизиты 
                //справочника из этой структуры. Почему на сервере, потому что мы ещё хотим особым образом 
                //заполнить табличную часть "КонтактнаяИнформация". Эта табличная часть не видна
                //в карточке контрагента, но она есть и мы её заполняем</span>
                IS_ЗаполнитьРеквизитыКонтрагентаПоИНН(ДанныеКонтрагента);
                
            <span class="светло_красный">КонецПроцедуры </span>


            <span class="светло_красный">&НаСервереБезКонтекста
            Функция</span> IS_ПолучитьДанныеКонтрагнетаПоИНН(ИНН)
                <span class="зелёный">//Создадим структуру, в которую поместим данные контрагента</span>
                ДанныеКонтрагента = <span class="светло_красный">Новый</span> Структура;

                <span class="зелёный">//сразу можем вставить в структуру ИНН</span>
                ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"ИНН"</span>, ИНН); 
                
                <span class="зелёный">//https://egrul.itsoft.ru/short_data/?7730588444
                //сайт не требует пароля, поэтому параметры "Пользователь" и "Пароль" пропускаем</span>
                АдресСервера = <span class="тёмно_серый">"egrul.itsoft.ru"</span>; 
                АдресРесурса = <span class="тёмно_серый">"/short_data/?"</span> + ИНН; 
                Соединение = <span class="светло_красный">Новый</span> HTTPСоединение(АдресСервера,,,,,30, Новый ЗащищенноеСоединениеOpenSSL);
                Запрос = <span class="светло_красный">Новый</span> HTTPЗапрос(АдресРесурса);

                <span class="зелёный">//Если вдруг не будет интернета в компьюторе или другая ошибка,
                //то заключим нашу инструкцию по выполнению запроса в 
                //Попытка...Исключение</span>
                <span class="светло_красный">Попытка</span>
                    Ответ = Соединение.Получить(Запрос); 	
                <span class="светло_красный">Исключение</span>
                    <span class="зелёный">//в этом блоке есть глобальная функция ОписаниеОшибки()
                    //её есть смысл использовать только в блоке Исколючение...КонецПопытки
                    //она возвращает описание ошибки, такое же, какое было бы выдано в окне сообщений пользователю</span>
                    Сообщение = <span class="светло_красный">Новый</span> СообщениеПользователю;
                    Сообщение.Текст = <span class="тёмно_серый">"Не удалось получить данные по ИНН по причине: "</span> + ОписаниеОшибки();
                    Сообщение.Сообщить();
                    <span class="светло_красный">Возврат</span> ДанныеКонтрагента;
                <span class="светло_красный">КонецПопытки; </span>   

                СтрокаJSON = Ответ.ПолучитьТелоКакСтроку();
                ДанныеЕГРЮЛ = Неопределено;
                <span class="светло_красный">Если</span> Ответ.КодСостояния = 200 <span class="светло_красный">Тогда</span>
                    ЧтениеJSON = <span class="светло_красный">Новый</span> ЧтениеJSON;
                    ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
                
                    <span class="зелёный">//2й параметр это прочитать ли в соответствие данные, мы говорим Да</span> 
                    ДанныеЕГРЮЛ = ПрочитатьJSON(ЧтениеJSON, Истина);
                <span class="светло_красный">Иначе</span>
                    Текст = СтрШаблон(<span class="тёмно_серый">"Не удалось получить данные по ИНН"
                                        "|Код состояния: %1"
                                        "|Ответ сервера: %2"</span>,
                                        Ответ.КодСостояния,
                                        СтрокаJSON);

                    Сообщение = <span class="светло_красный">Новый</span> СообщениеПользователю;
                    Сообщение.Текст = Текст;
                    Сообщение.Сообщить();
                    <span class="светло_красный">Возврат</span> ДанныеКонтрагента;
                <span class="светло_красный">КонецЕсли;</span>

                
                <span class="зелёный">//если в соответствии ДанныеЕГРЮЛ есть ключ "short_form", значит это ИП
                //всё дело в том, что данные для ИП и для ЮЛ немного отличаются</span>
                <span class="светло_красный">Если</span> ДанныеЕГРЮЛ[<span class="тёмно_серый">"short_form"</span>] &lt;> Неопределено И ДанныеЕГРЮЛ[<span class="тёмно_серый">"short_form"</span>] = <span class="тёмно_серый">"ИП"</span> <span class="светло_красный">Тогда</span>
                    ВидКонтрагента = Перечисления.ВидыКонтрагентов.ИндивидуальныйПредприниматель;	
                    ДанныеКонтрагента.Вставить("ЮридическийАдрес", Неопределено);
                <span class="светло_красный">Иначе</span>	
                    ВидКонтрагента = Перечисления.ВидыКонтрагентов.ЮридическоеЛицо;
                    <span class="зелёный">//адрес будет только для ЮЛ, для ИП адрес это адрес его прописки, а это личные данные, как я понял</span>
		            ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"ЮридическийАдрес"</span>, ДанныеЕГРЮЛ[<span class="тёмно_серый">"address"</span>]);
                <span class="светло_красный">КонецЕсли;</span>

                <span class="зелёный">//ключи называем так как называются реквизиты в справочнике</span>
                ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"ВидКонтрагента"</span>,       ВидКонтрагента);	
                ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"КПП"</span>,                  ДанныеЕГРЮЛ[<span class="тёмно_серый">"kpp"</span>]);	
                ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"РегистрационныйНомер"</span>, ДанныеЕГРЮЛ[<span class="тёмно_серый">"ogrn"</span>]);	
                ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"Наименование"</span>,         ДанныеЕГРЮЛ[<span class="тёмно_серый">"short_name"</span>]);	
                ДанныеКонтрагента.Вставить(<span class="тёмно_серый">"НаименованиеПолное"</span>,   ДанныеЕГРЮЛ[<span class="тёмно_серый">"full_name"</span>]);	
                
                <span class="светло_красный">Возврат</span> ДанныеКонтрагента;
            <span class="светло_красный">КонецФункции</span>


            <span class="светло_красный">&НаСервере
            Процедура</span> IS_ЗаполнитьРеквизитыКонтрагентаПоИНН(ДанныеКонтрагента)
                <span class="зелёный">//для заполнения реквизитов возпользуемся глобальной процедурой</span>
                ЗаполнитьЗначенияСвойств(Объект, ДанныеКонтрагента);
                

                <span class="зелёный">//этот участок кода скопирован из типовой. Мы из общего модуля с помощью
                //функции НоваяКонтактнаяИнформация() получаем таблицу значений с установденными колонками
                //и теперь заполняем эту таблицу значений данными адреса из структуры ДанныеКонтрагента
                //Напомню, что адрес будет только если мы получили данные ЮЛ, ИП не имеет адреса
                //А дальше вызываются много функций и процедур из общих модулей, которые в итоге
                //добавят данные адреса в табличну часть "КонтактнаяИнформация" и в реквизиты на форме</span>
                НоваяКонтактнаяИнформация = УправлениеКонтактнойИнформацией.НоваяКонтактнаяИнформация();
                
                <span class="светло_красный">Если</span> ДанныеКонтрагента.ЮридическийАдрес &lt;> Неопределено <span class="светло_красный">Тогда</span>
                    ДанныеКИ = НоваяКонтактнаяИнформация.Добавить();
                    ДанныеКИ.Представление = ДанныеКонтрагента.ЮридическийАдрес;
                    ДанныеКИ.Значение = <span class="тёмно_серый">""</span>;
                    ДанныеКИ.Вид = Справочники.ВидыКонтактнойИнформации.ЮрАдресКонтрагента;
                    
                    ДанныеКИ = НоваяКонтактнаяИнформация.Добавить();
                    ДанныеКИ.Представление = ДанныеКонтрагента.ЮридическийАдрес;
                    ДанныеКИ.Значение = <span class="тёмно_серый">""</span>;
                    ДанныеКИ.Вид = Справочники.ВидыКонтактнойИнформации.ФактАдресКонтрагента;
                <span class="светло_красный">КонецЕсли;</span>
                
                УправлениеКонтактнойИнформацией.УстановитьКонтактнуюИнформациюОбъекта(Объект, НоваяКонтактнаяИнформация); 
                ИмяЭлементаДляРазмещения = Элементы.КонтактнаяИнформация.Имя;
                УправлениеКонтактнойИнформацией.ПриЧтенииНаСервере(ЭтотОбъект, Объект, ИмяЭлементаДляРазмещения);

                <span class="зелёный">//эта строчка тоже взята из типовой из события "ПриИзменении" поля ИНН
                //она устанавливает представление на гиперссылку "ИНН/КПП", после этого кода 
                //будет "ИНН: 7730588444/КПП: 77308544" </span>
                УстановитьЗаголовокЮридическихДанных(ЭтотОбъект);
            <span class="светло_красный">КонецПроцедуры</span>
        </pre>
    </div>



</div>
