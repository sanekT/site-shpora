<div class="wrap">
    <h2 class="header-style">Сервер баз данных MySQL</h2>
    
    
    <h3 class="header-style2"></h3>
    <p>Уровень 2 день 2, 02:01:50</p>
    <p>У MySQL несколько движков. 2 из них основных - InnoDB, а 2й MyISAM.</p>
    <p>Основные параметры по умолчанию:</p>
    <ul class="list">
        <li>Порт: 3306</li>
        <li>Логин: root</li>
        <li>Пароль: ''</li>
        <li>Настроечный файл: my.ini</li>
        <li>Утилиты командной строки: mysql.exe, mysqldump.exe</li>
    </ul>
    <p>Тут стоит обратить внимание на то, что MySQL это именно сервер баз данных, а не просто БД. Как он работает на сервере. Браузер отсылает запрос на веб-сервер(Apache), у этого веб-сервера есть свой ip и порт, также в интернете есть почтовый сервер со своим ip и портом, есть mysql-сервер тоже со своим ip и портом. Все эти сервера это программы, которые оказывают присущие им услуги. На веб-сервере лежат папочки-сайты, на почтовом сервере  лежат папочки-почтовые ящики, на серверe mysql тоже лежат папочки, каждая папочка БД. А связующим звеном между этими серверами является серверная технология, в нашем случае это PHP. Так вот браузер отослал запрос веб-серверу, а он прежде чем отдать страницу обратно, смотрит есть ли там код-php, если есть то он вызывает модуль PHP и отдаёт ему страницу на исполнение и уже скрипт исполняясь отправляет почту на почтовый сервер или лезет в БД на сервер mysql. Почтовый и mysql серверы отвечают чем то php-скрипту, а скрипт исполнившись уже отдаёт готовую html страницу веб-серверу, а тот отдаёт браузеру.</p>
    
    
    
    
    <h3 class="header-style2">Использование утилит командной строки</h3>
    <ul class="list">
        <li>Соединение с монотором MySQL
            <ul class="list">
                <li>mysql <b>-u</b>логин <b>-p</b>пароль. В моём случае чтобы зайти в командную строку mysql надо в cmd перейти в папку где лежит mysql, это D:\OpenServer\OSPanel\modules\database\MySQL-5.7-x64\bin  и ввести команду - mysql -uroot без ; на конце.</li>
            </ul>
        </li>
        <li>Внимание! Внутри монитора MySQL надо явно указывать конец запроса(;). Когда жмём enter, то это не считывается как конец запроса, а вот ; и enter считывается.
            <ul class="list">
                <li>USE имя_БД;</li>
                <li>quit;</li>
            </ul>
        </li>
        <li>После соединения с БД мы посылаем запросы, например выборку всех данных, они вернутся ту же в командной строке в виде таблички, а можно на конце запроса дописать \G и вернутся в другом виде данные.
        </li>
        <li>Экспорт базы данных
            <ul class="list">
                <li>msqldump <b>-u</b>логин <b>-p</b>пароль имя_БД > dump.sql</li>
            </ul>
        </li>
        <li>Импорт базы данных
            <ul class="list">
                <li>msqldump <b>-u</b>логин <b>-p</b>пароль имя_БД &lt; dump.sql</li>
            </ul>
        </li>
    </ul>
    
    
    
    
    
    
    <h3 class="header-style2">Работа с БД через PHP</h3>
    <p>Что такое монитор MySQL? Это просто как бы экран между пользователем и сервером баз данных. Мы пишем в командной строке команды и тут же в командной строке сервер нам отвечает и выводит инфу. PHP также может служить таким монитором между нами и сервером БД. Чтобы PHP мог работать с MySQL должно быть подключено расширение php_mysqli.dll</p>
    <p><b>Пошаговые действия для работы с MySQL:</b></p>
    <ul class="list">
        <li>Установка соединения с сервером</li>
        <li>Выбор базы данных для работы</li>
        <li>Исполнение запроса</li>
        <li>Обработка данных</li>
        <li>Закрытие соединения</li>
    </ul>
    <p><b>Соединение и работа с сервером БД:</b></p>
    <div class="code-style">
        <pre>
            //соединение с сервером БД и выбор БД. Вернёт в переменную тип object при успешном подключении и false при не успешном
            <span class="vue-g"><span class="vue-b">$link</span> = <span class="vue-b">mysqli_connect</span>(<span class="vue-r">'localhost'</span>, <span class="vue-r">'root'</span>, <span class="vue-r">''</span>, <span class="vue-r">'name_db'</span>,);</span>
            
            //отслеживание ошибки при соединении
            <span class="vue-g">if(!<span class="vue-b">$link</span>){
                echo <span class="vue-r">'Ошибка: '</span> . <span class="vue-b">mysqli_connect_errno</span>(<span class="vue-b">$link</span>) . <span class="vue-r">':'</span> . <span class="vue-b">mysqli_connect_error</span>(<span class="vue-b">$link</span>);
            }</span>
            
            //посылаем простой запрос. Результат: true или false. Важно знать, что если сервер не смог установить кодировку, то php не выдаст никакой ошибки, для этого и нужно результат проверять на наличие ошибок
            <span class="vue-g"><span class="vue-b">$result</span> = <span class="vue-b">mysqli_query</span>(<span class="vue-b">$link</span>, <span class="vue-r">"SET NAMES 'utf8'"</span>);</span>
            или
            <span class="vue-g"><span class="vue-b">mysqli_set_charset</span>(<span class="vue-b">$link</span>, <span class="vue-r">'utf8'</span>);</span>
            
            //отслеживаем ошибки при исполнении запроса
            <span class="vue-g">if(!<span class="vue-b">$result</span>){
                echo <span class="vue-r">'Ошибка: '</span> . <span class="vue-b">mysqli_errno</span>(<span class="vue-b">$link</span>) . <span class="vue-r">':'</span> . <span class="vue-b">mysqli_error</span>(<span class="vue-b">$link</span>);
            }</span>
            
            //посылаем запрос на выборку. Результат object или false. Тут также нужно проверять на наличие ошибок, если пришёл false. 
            <span class="vue-g"><span class="vue-b">$result</span> = <span class="vue-b">mysqli_query</span>(<span class="vue-b">$link</span>, <span class="vue-r">"SELECT * FROM teachers"</span>);</span>
            
            //можно выбрать другую БД
            <span class="vue-g"><span class="vue-b">mysqli_select_db</span>(<span class="vue-b">$link</span>, <span class="vue-r">'name_db'</span>);</span>
            
            //закрываем соединнение
            <span class="vue-g"><span class="vue-b">mysqli_close</span>(<span class="vue-b">$link</span>);</span>
            
            //обрабатываем результат
            <span class="vue-g"><span class="vue-b">$row</span> = <span class="vue-b">mysqli_fetch_array</span>(<span class="vue-b">$result</span>);</span>
        </pre>
    </div>
    <p>Запросы к серверу БД бывают 2х типов: безответные и с ответом. Безответный запрос выше показан на примере установления кодировки или запрос на изменение каких то данных в таблице или удаление данных, в ответ приходит только успех или не успех и всё. А вот запрос с ответом содержит при успехе объект с данными.</p>
    <p>Небольшой совет как искать ошибки в SQL синтаксисе. Например мы посылаем запрос: <b>$result = mysqli_query($link, "SELECT * FROM students WHERE id=$x");</b>. Даже если мы проверим результат на ошибки, то серсер БД вернёт нам ошибку, что в SQL запросе есть ошибка, а какая фиг его знает. Тут ошибка в том что для значения id мы подставляем переменную $x, которой нет, поэтому один из способов выявить такую ошибку  это перед запросом через echo вывести строку запроса: <b>echo "SELECT * FROM students WHERE id=$x";</b> и на экране мы увидим такое: <b>SELECT * FROM students WHERE id=</b> . Как видим в id ничего не передаётся. Саму строку запроса тоже не надо передавать в функцию запроса, а делаем вот так:</p>
    <div class="code-style">
        <pre>
            $sql = "SELECT * FROM students WHERE id=$x";
            echo $sql;
            $result = mysqli_query($link, $sql);
        </pre>
    </div>
    <p>Если нужно проверили через вывод переменную $sql и всё. Не надо целый запрос копировать для вывода.</p>
    <p><b>Обработка пришедшего результата</b>. Вернувшийся объект $result функция mysqli_fetch_array() обработает и запишет в переменную $row запись под id=1 в виде массива</p>
    <div class="code-style">
        <pre>
            $sql = "SELECT * FROM students WHERE id=1";
            $result = mysqli_query($link, $sql);
            $row = mysqli_fetch_array($result);
        </pre>
    </div>
    <div class="code-style">
        <pre>
            //в $row будет лежать массив такого вида
            Array
            (
                [0] => 1
                [id] => 1
                [1] => Masha
                [name] => Masha
                [2] => text
                [content] => text
            )
        </pre>
    </div>
    <p>Тут повторяются поля в нумерованных свойствах и в именованных свойствах. Это сделано для удобства, когда нужны его нумерованные свойства, а когда именованные. Такой массив делается по умолчанию из за константы MYSQLI_BOTH.</p>
    <div class="code-style">
        <pre>
            //по умолчанию
            $row = mysqli_fetch_array($result)
            или
            $row = mysqli_fetch_array($result, MYSQLI_BOTH);
            
            
            //чтобы возвращать нумерованный массив
            $row = mysqli_fetch_row($result)
            или
            $row = mysqli_fetch_array($result, MYSQLI_NUM);
            
            
            //чтобы возвращать именнованый массив
            $row = mysqli_fetch_assoc($result)
            или
            $row = mysqli_fetch_array($result, MYSQLI_ASSOC);
        </pre>
    </div>
    <p>Если нам надо получить не 1 запись, а несколько, для этого надо обработку объекта запустить в цикле:</p>
    <div class="code-style">
        <pre>
            //получить поле name где id=1, id=2, id=3
            $result = <span class="vue-b">mysqli_query</span>($link, "SELECT name FROM students WHERE id IN (1,2,3)");
            
            while($row = <span class="vue-b">mysqli_fetch_assoc</span>($result)){
                echo "&lt;pre>";
                print_r($row);
                echo "&lt;/pre>";
            }
            
            //результат
            Array
            (
                [name] => Masha
            )
            Array
            (
                [name] => Petja
            )
            Array
            (
                [name] => Ivan
            )
        </pre>
    </div>
    <p>Если же нужно сразу вернуть все записи в виде массива не используя цикл, то есть такая функция:</p>
    <div class="code-style">
        <pre>
            //получить поле name где id=1, id=2, id=3
            $result = <span class="vue-b">mysqli_query</span>($link, "SELECT name FROM students WHERE id IN (1,2,3)");
            
            $arr = <span class="vue-b">mysqli_fetch_all</span>($result, MYSQLI_ASSOC);
            echo "&lt;pre>";
            print_r($arr);
            echo "&lt;/pre>";
            
            //результат
            Array
            (
                [0] => Array
                    (
                        [name] => Masha
                    )

                [1] => Array
                    (
                        [name] => Petja
                    )

                [2] => Array
                    (
                        [name] => Ivan
                    )   
            )
        </pre>
    </div>
    
    
    
    
    
    <h3 class="header-style2">Полезные функции для работы с сервером БД</h3>
    <div class="code-style">
        <pre>
            <span class="vue-g"><span class="vue-b">$link</span> = <span class="vue-b">mysqli_connect</span>(<span class="vue-r">'localhost'</span>, <span class="vue-r">'root'</span>, <span class="vue-r">''</span>, <span class="vue-r">'name_db'</span>,);</span>
            
            //экранируем строки! Эта функция подставляет обратный слэш для внутреннего '.
            <span class="vue-g"><span class="vue-b">$name</span> = <span class="vue-b">mysqli_real_escape_string</span>(<span class="vue-b">$link</span>, <span class="vue-r">"Jhon O'Brian"</span>);</span>
            <span class="vue-g"><span class="vue-b">$sql</span> = <span class="vue-r">"INSERT INTO teachers(name, email) VALUES('<span class="vue-b">$name</span>', 'jhon@gmail.com')"</span></span>
            //полезная функция, которой надо пользоваться пропуская все строки приходящие из формы
            function clearString($data, $link){
                $data = trim(strip_tags($data));
                return mysqli_real_escape_string($link, $data);
            }
            
            <span class="vue-g"><span class="vue-b">mysqli_query</span>(<span class="vue-b">$link</span>, <span class="vue-b">$sql</span>);</span>
            //получаем первичный ключ(id) новой записи. Если сразу после запроса вызвать эту функцию, то она вернёт id новой записи, например, чтобы послать куку нвовму пользователю. Также ключ вернётся, если id в БД являются автоинрементарными и если запрос в БД был INSERT
            <span class="vue-g"><span class="vue-b">$id</span> = <span class="vue-b">mysqli_insert_id</span>(<span class="vue-b">$link</span>);</span>
                  
            <span class="vue-g"><span class="vue-b">$sql</span> = <span class="vue-r">"DELETE FROM lessons WHERE room = 'БК-1'"</span>;</span>
            <span class="vue-g"><span class="vue-b">mysqli_query</span>(<span class="vue-b">$link</span>, <span class="vue-b">$sql</span>);</span>
            //сколько записей изменено?
            <span class="vue-g"><span class="vue-b">$count</span> = <span class="vue-b">mysqli_affected_rows</span>(<span class="vue-b">$link</span>);</span>
            
            <span class="vue-g"><span class="vue-b">$sql</span> = <span class="vue-r">"SELECT * FROM courses"</span>;</span>
            <span class="vue-g"><span class="vue-b">$result</span> = <span class="vue-b">mysqli_query</span>(<span class="vue-b">$link</span>, <span class="vue-b">$sql</span>);</span>
            //сколько записей вернулось?
            <span class="vue-g"><span class="vue-b">$row_count</span> = <span class="vue-b">mysqli_num_rows</span>(<span class="vue-b">$result</span>);</span>
            //сколько полей в вернувшихся записях?
            <span class="vue-g"><span class="vue-b">$fields_count</span> = <span class="vue-b">mysqli_num_fields</span>(<span class="vue-b">$result</span>);</span>
        </pre>
    </div>
    
    
    
    
    
    
    <h3 class="header-style2">Опасность SQL-инъекций</h3>
    <p>В запрос мы подставляем только строки и числа</p>
    <p><b>Первое правило</b>, если мы подставляем в запрос числовую переменную для вставки id, то нужно приводить эту переменную к положительному числу: <b>$id = abs((int)$id);</b></p>
    <p><b>Второе правило</b> для строк использовать <b>подготовленные запросы</b>. Смысл подготовленных запросов в том, что с помощью функции <b>msqli_prepare($link, $sql)</b> мы говорим серверу, чтобы он разобрал запрос, сервер разбирает запрос и  ждёт только параметров для этого запроса. При разобранных запросах уже очень трудно сделать вставку вредоносных строк от злоумышленника.</p>
    <p>Подготовленные запросы немного медленее чем обычные, тут нужно самим уже выбирать, что для нас больше подходит, безопасность или можно ей пренебречь.</p>
    
    
    
    
    
    <h3 class="header-style2">Обязательная минимальная защита приходящих данных на сервер и запись их в БД</h3>
    <div class="code-style">
        <pre>
            function clearString($data, $link){
                $data = trim(strip_tags($data));
                return mysqli_real_escape_string($link, $data);
            }
            
            $name = clearString($_POST['name']);
            $id = abs((int)$_POST['id']);
            
            
            //<b>если будем вставлять эти данные в запрос к БД</b>
            $sql = "INSERT INTO users(id, name) VALUES(?, ?)";
            $stmt = mysqli_prepare($link, $sql);//<b>сервер разбери запрос</b>
            mysqli_stmt_bind_param($stmt, "is", $id, $name);//<b>сервер, вот параметры для запроса. "is" обозначает, 1й параметр это число(i - integer), 2й - строка(s - string)</b>
            //<b>а теперь исполни подготовленный запрос с переданными параметрами</b>
            mysqli_stmt_execute($stmt);
            mysqli_stmt_close($stmt);
        </pre>
    </div>
    
    
    
</div>
    
