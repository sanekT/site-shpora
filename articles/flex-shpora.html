<div class="wrap">
    <h3 class="header-style2">Шпаргалка по flexbox</h3>
    <p>Вот адрес шпоры - <a href="https://tpverstak.ru/flex-cheatsheet/">тут</a>.</p>

    <ol class="list">
        <li><a href="#note1">Мои личные заметки по флексам</a></li>
    </ol>



    <h2 class="header-style">Шпаргалка по flexbox с сайта metanit.com</h2> 


    <h3 class="header-style2">Flex контейнер</h3> 
    <p>При задании <b>display: flex;</b> флекс-контейнеру, этот контейнер определяется как блочный элемент:</p>
    <img src="../img/Flexbox/1.png" alt="" class="screen">
    <p>При задании <b>display: inline-flex;</b> флекс-контейнеру, этот контейнер определяется как строчный элемент, т.е. флекс контейнер встанет в ряд с другими строчными элементами и расширяется только на ширину флекс-элементов внутри него, но внутри флекс контейнера блоки будут как и в примере выше:</p>
    <img src="../img/Flexbox/2.png" alt="" class="screen">




    <h3 class="header-style2">Направление flex-direction</h3>
    <p>Flex-элементы во flex-контейнере могут иметь определенное направление, а именно они могут располагаться в виде строк или в виде столбцов. Для управления направлением элементов CSS3 предоставляет свойство <b>flex-direction</b>. По умолчанию стоит flex-direction: row;. Вот какие значения принимает это войство:</p> 
    <img src="../img/Flexbox/3.png" alt="" class="screen">
    <img src="../img/Flexbox/4.png" alt="" class="screen">
    <img src="../img/Flexbox/5.png" alt="" class="screen">
    <img src="../img/Flexbox/6.png" alt="" class="screen">




    <h3 class="header-style2">flex-wrap</h3>
    <p>Свойство <b>flex-wrap</b> определяет, будет ли flex-контейнер несколько рядов элементов (строк или столбцов) в случае если его размеры недостаточны, чтобы вместить в один ряд все элементы. Это свойство может принимать следующие значения:</p>
    <ul class="list">
        <li><b>nowrap</b> - значение по умолчанию, которое определяет flex-контейнер, где все элементы раполагаются в одну строку (при расположении в виде строк) или один столбец (при расположении в столбик). Элементы внутри сжимаются до ширины своего содержимого и начинают вылазить за пределы контейнера.
        <img src="../img/Flexbox/7.png" alt="" class="screen">
        И вот так при flex-direction: row-reverse;
        <img src="../img/Flexbox/8.png" alt="" class="screen">
        </li>
        <li><b>wrap</b> - если элементы не помещаются во flex-контейнер, то создает дополнительные ряды в контейнере для размещения элементов. При расположении в виде строки содаются дополнительные строки, а при расположении в виде столбца добавляются дополнительные столбцы.
        <img src="../img/Flexbox/9.png" alt="" class="screen">
        И вот так при flex-direction: row-reverse;
        <img src="../img/Flexbox/10.png" alt="" class="screen">
        А так при flex-direction: column;
        <img src="../img/Flexbox/11.png" alt="" class="screen">
        И flex-direction: column-reverse;
        <img src="../img/Flexbox/12.png" alt="" class="screen">
        </li>
        <li><b>wrap-reverse</b> - то же самое, что и значение wrap, только элементы располагаются в обратном порядке</li>
    </ul>




    <h3 class="header-style2">flex-flow. Порядок элементов</h3>
    <p><b>flex-flow</b></p>
    <p>Свойство flex-flow позволяет установить значения сразу для обоих свойств flex-direction и flex-wrap. Оно имеет следующий формальный синтаксис: <b>flex-flow: [flex-direction] [flex-wrap]</b>. Причем второе свойство - flex-wrap можно в принципе опустить, тогда для него будет использоваться значение по умолчанию - nowrap.</p>
    <p><b>order</b></p>
    <p>Свойство order позволяет установить группу для flex-элемента, позволяя тем самым переопределить его позицию внутри flex-контейнера. В качестве значения свойство принимает числовой порядок группы. К одной группе может принадлежать несколько элементов. Например, элементы в группе 0 располагаются перед элементами с группой 1, а элементы с группой 1 располагаются перед элементами с группой 2 и так далее.</p>
    <img src="../img/Flexbox/13.png" alt="" class="screen">
    <p>Флекс-элементу 6 и 9 задан класс .group1{order: -1;}. Элементам 1, 5, 7, 8 не задан никакой класс, а занчит у них стоит по умолчанию order: 0;. Ну и элементам 2, 3, 4 задан класс .group2{order: 1;}.</p>





    <h3 class="header-style2">Выравнивание элементов. justify-content</h3>
    <p><b>justify-content</b> выравнивает элементы вдоль основной оси - main axis (при расположении в виде строки по горизонтали, при расположении в виде столбца - по вертикали) и принимает следующие значения:</p>
    <ul class="list">
        <li><b>flex-start или start</b> - значение по умолчанию, при котором первый элемент выравнивается по левому краю контейнера(при расположении в виде строки) или по верху (при расположении в виде столбца), за ним располагается второй элемент и так далее.</li>
        <li><b>flex-end или end</b> - последний элемент выравнивается по правому краю (при расположении в виде строки) или по низу (при расположении в виде столбца) контейнера, за ним выравнивается предпоследний элемент и так далее.</li>
        <li><b>center</b> - элементы выравниваются по центру.</li>
        <li><b>space-between</b> - если в стоке только один элемент или элементы выходят за границы flex-контейнера, то данное значение аналогично flex-start. В остальных случаях первый элемент выравнивается по левому краю (при расположении в виде строки) или по верху (при расположении в виде столбца), а последний элемент - по правому краю контейнера (при расположении в виде строки) или по низу (при расположении в виде столбца). Все оставшееся пространство между ними равным образом распределяется между остальными элементами.</li>
        <li><b>space-around</b> - если в строке только один элемент или элементы выходят за пределы контейнера, то его действие аналогично значению center. В ином случае элементы равным образом распределяют пространство между левым и правым краем контейнера, а расстояние между первым и последним элементом и границами контейнера составляет половину расстояния между элементами.</li>
        <li><b>space-evenly</b> - oчень похож на space-arround, но только выравнивание идёт поровну со всех сторон.</li>
    </ul>




    <h3 class="header-style2">Выравнивание элементов. align-items и align-self</h3>
    <p><b>Свойство align-items</b></p>
    <p>Свойство align-items также выравнивает элементы, но уже по поперечной оси (cross axis) (при расположении в виде строки по вертикали, при расположении в виде столбца - по горизонтали). Это свойство может принимать следующие значения:</p>
    <ul class="list">
        <li><b>stretch</b> - значение по умолчанию, при котором flex-элементы растягиваются по всей высоте (при расположении в строку) или по всей ширине (при расположении в столбик) flex-контейнера. Если же у элементов задана жёстко высота или ширина, то они не будут растягиваться на всю высоту или ширину контейнера.</li>
        <li><b>flex-start</b> - элементы выравниваются по верхнему краю (при расположении в строку) или по левому краю (при расположении в столбик) flex-контейнера</li>
        <li><b>flex-end</b> - элементы выравниваются по нижнему краю (при расположении в строку) или по правому краю (при расположении в столбик) flex-контейнера</li>
        <li><b>center</b> - элементы выравниваются по центру flex-контейнера</li>
        <li><b>baseline</b> - элементы выравниваются в соответствии со своей базовой линией</li>
    </ul>
    <p><b>Свойство align-self</b></p>
    <p>Свойство align-self позволяет переопределить значение свойства align-items для одного элемента. Оно может принимать все те же значения плюс значение "auto". auto - значение по умолчанию, при котором элемент получает значение от свойства align-items, которое определено в flex-контейнере. Если в контейнере такой стиль не определен, то применяется значение stretch.</p>
    <img src="../img/Flexbox/14.png" alt="" class="screen">





    <h3 class="header-style2">Выравнивание строк и столбцов. align-content</h3>
    <p>Свойство align-content управляет выравниванием рядов (строк и столбцов) во flex-контейнере и поэтому применяется, если свойство flex-wrap имеет значение wrap или wrap-reverse. Свойство align-content может иметь следующие значения:</p>
    <ul class="list">
        <li><b>stretch</b> - значение по умолчанию, при котором строки (столбцы) растягиваются, занимая все свободное место</li>
        <li><b>flex-start</b> - строки (столбцы) выравниваются по началу контейнера (для строк - это верхний край, для столбцов - это левый край контейнера)</li>
        <li><b>flex-end</b> - строки (столбцы) выравниваются по концу контейнера (строки - по нижнему краю, столбцы - по правому краю)</li>
        <li><b>center</b> - строки (столбцы) позиционируются по центру контейнера</li>
        <li><b>space-between</b> - строки (столбцы) равномерно распределяются по контейнеру, а между ними образуются одинаковые отступы. Если же имеющегося в контейнере места недостаточно, то действует аналогично значению flex-start</li>
        <li><b>space-around</b> - строки (столбцы) равным образом распределяют пространство контейнера, а растояние между первой и последней строкой (столбцом) и границами контейнера составляет половину расстояния между соседними строками (столбцами).</li>
    </ul>





    <h3 class="header-style2">Управление элементами. flex-basis, flex-shrink и flex-grow</h3>
    <p>Кроме свойств, устанавливающих выравнивание элементов относительно границ flex-контейнера, есть еще три свойства, которые позволяют управлять элементами:</p>
    <ul class="list">
        <li><b>flex-basis</b> - определяет начальный размер flex-элемента</li>
        <li><b>flex-shrink</b> - определяет, как flex-элемент будет уменьшаться относительно других flex-элементов во flex-контейнере</li>
        <li><b>flex-grow</b> - определяет, как flex-элемент будет увеличиваться относительно других flex-элементов во flex-контейнере</li>
    </ul>
    <p><b>flex-basis</b></p>
    <p>flex-basis это можно сказать сопоставим min-width, но разница в том, что когда карточки уже станут по 1й в ряду, как на мобилке, то при min-width будем сжимать экран, а карточки не сожмутся меньше заданного, они начнут выходить за экран, а при flex-basis, будут сжиматься, потому что переносится уже некуда, но в отличии от min-width позволяют дальше сжимать карточку.</p>
    <p>Flex-контейнер может увеличиваться или уменьшаться вдоль своей центральной оси, например, при изменении размеров браузера, если контейнер имеет нефиксированные размеры. И вместе с контейнером также могут увеличиваться и уменьшаться его flex-элементы. Свойство flex-basis определяет начальный размер flex-элемента до того, как он начнет изменять размер, подстраиваясь под размеры flex-контейнера. Это свойство может принимать следующие значения:</p>
    <ul class="list">
        <li><b>auto</b> - начальный размер flex-элемента устанавливается автоматически(т.е. по содержимому)</li>
        <li><b>content</b> - размер flex-элемента определяется по его содержимому.</li>
        <li><b>числовое значение</b> - мы можем установить конкретное числовое значение для размеров элемента</li>
    </ul>
    <img src="../img/Flexbox/15.png" alt="" class="screen">
    <p>У первого элемента у свойства flex-basis установлено значение auto. Поэтому первый элемент в качестве реального значения для ширины будет использовать значение свойства width.</p>
    <p>У второго элемента у свойства flex-basis установлено значение auto, однако и свойство width имеет значение auto. Поэтому реальная ширина элемента будет устанавливаться по его содержимому.</p>
    <p>У третьего элемента свойство flex-basis имеет конкретное значение, которое и используется. А свойство width в этом случае уже не играет никакой роли.</p>
    <p>Простыми словами что такое flex-basis. Например у нас есть элементы во флекс контейнере и элементам не задано никакой ширины, они автоматически расширены по своему содержимому и мы задаём всем элементам flex-grow: 1;, они сразу же расширятся на одинаковую ширину по всему контейнеру, но когда мы начнём сжимать экран адаптируя под телефон и перенос элементов будет разрешён, то все элементы будут сжиматься до упора и не перенесутся на другую строку до тех пор, пока они не сожмутся до своего содержимого, это бывает не нужно и не красиво. Для этого и задают flex-basis элементам, при сжатии когда ширина элемента подойдёт к той, что задана через flex-basis, то тут уже элемент перестанет сжиматься и перенесётся на другую строку, если же запрещен перенос то элементы будут и дальше сжиматься не смотря и на заданный flex-basis. Т.е если перенос разрешён, то элемент при заданном flex-basis как бы говорит, что он не будет сжиматься ниже этой заданной ширины, он будет бороться за эту заданную ширину и перенесёт элемент на новую строку. Вместо flex-basis можно попробовать и min-width задать для элементов.</p>
    <p>Также если не задаём никакие flex-grow и зададим элементам flex-basis, то они примут эту ширину и она будет приоритетней, чем если задать элементу одновременно ширину через width.</p>
    <p><b>flex-shrink</b></p>
    <p>Если flex-контейнер имеет недостаточно места для размещения элемента, то дальнейшее поведение этого элемента мы можем определить с помощью свойства flex-shrink. Оно указывает, как элемент будет усекаться относительно других элементов. В качестве значения свойство принимает число. По умолчанию его значение 1, это значит, что элементы будут сжиматься одинакого при уменьшении флекс контейнера. Пример:</p>
    <img src="../img/Flexbox/16.png" alt="" class="screen">
    <p>А вот другой пример с разным числом в flex-shrink. В данном случае начальная ширина каждого элемента равна 200px, то есть совокупная ширина составляет 600px. Однако ширина flex-контейнера составляет всего 400px. То есть размер контейнера недостаточен для вмещения в него элементов, поэтому в действие вступает свойство flex-shrink, которое определено у элементов.</p>
    <p>Для усечения элементов браузер вычисляет коэффициент усечения (shrinkage factor). Он вычисляется путем перемножения значения свойства flex-basis на flex-shrink. Таким образом, для трех элементов мы получим следующие вычисления:</p>
    <img src="../img/Flexbox/17.png" alt="" class="screen">
    <img src="../img/Flexbox/18.png" alt="" class="screen">
    <p>первый лемент усёкся на 34px, второй на 68px, третий на 102px.</p>
    <p>Вот <b>объяснение с усечением</b>. У нас есть флекс контейнер 400px, в нём 3 элемента, каждому задан flex-basis: 200px, также первому задано усекаться flex-shrink: 1;, второму flex-shrink: 2;, третьему flex-shrink: 3;, как будет высчитываться их усечение? Точно также рассчитывается как и при увелеличении. Считаем общее кол-во частей - 1 + 2 + 3 = 6 частей, теперь определяем сколько места не хватает, если каждому задана база по 200px, то в сумме все занимают 600px, а у нас контейнер 400px, значит 600 - 400 = 200px не хватает, значит надо в зависимости от частей урезать каждый на какую то величину, вычисляем - 200 / 6 = 33.33(34). Выходит на 1 часть 34px, значит первый урезаем на 1 часть (34px), второй на 2 части(68px), третий урезаем на 3 части(102px). В итоге получаем 1й = 200 - 34 = 166px, 2й = 200 - 68 = 132px, 3й = 200 - 102 = 98px. Если сложить получившиеся ширины элементов то в сумме будет 400px.</p>
    <p><b>flex-grow</b></p>
    <p>Свойство flex-grow управляет расширением элементов, если во flex-контейнере есть дополнительное место. Данное свойство во многом похоже на свойство flex-shrink за тем исключением, что работает в сторону увеличения элементов. В качестве значения свойство flex-grow принимает положительное число, которое указывает, во сколько раз элемент будет увеличиваться относительно других элементов при увеличении размеров flex-контейнера. По умолчанию свойство flex-grow равно 0.</p>
    <p>Итак, для каждого элемента есть базовые начальные размеры. Здесь явным образом размеры для элементов не указаны, поэтому размер каждого элемента в данном случае будет складываться из размеров внутреннего содержимого, к которым добавляются внутренние отступы.</p>
    <img src="../img/Flexbox/19.png" alt="" class="screen">
    <p>По мере растягивания контейнера будут увеличиваться элементы в соответствии со свойством flex-grow, которое указано для каждого элемента. Пространство, на которое растягивается контейнер, считается дополнительным пространством.</p>
    <img src="../img/Flexbox/20.png" alt="" class="screen">
    <p>Так как у первого элемента свойство flex-grow равно 0, то первый элемент будет иметь константные постоянные размеры. У второго элемента flex-grow равно 1, а третьего - 2. Таким образом, в сумме они дадут 0 + 1 + 2 = 3. Поэтому второй элемент будет увеличиваться на 1/3 дополнительного пространства, на которое растягивается контейнер, а третий элемент будет получать 2/3 дополнительного пространства.</p>
    <p>Вот <b>объяснение с увеличением</b>. Как работает flex-grow. брал сообщение откуда то из интернета под видео. Например у нас есть 5 флекс элементов, зададим им flex-basis: 100px;, элементы приняли свои размеры и справа осталось свободное пространство в 300px. Зададим 3му элементу flex-grow: 1, тогда он растянется на все свободные 300px и станет 400px, тогда как остальным запрещено растягиваться, потому как по умолчанию у них flex-grow: 0; и они так и остануться по 100px. Теперь ещё 5му элементу зададим flex-grow: 2;, получается у нас уже есть 2 элемента, которые претендуют на разные куски свободного пространства(300px), как же их распределить? Берём и слаживаем эти части: 3й элемент хочет 1 часть, 5й хочет 2 части, складываем и получаем 3 части, теперь свобожное пространство делим на эти части: 300 / 3 = 100, получается на одну часть приходится 100px, значит 3му элементу добавляем 1 часть, т.е. 100px, а 5му добавляем 2части, т.е. 200px. В итоге 1,2, и 4 элементы остаются как и были по 100px, 3й равен 200px, а 5й равен 300px. Вот так деляться расстояния между элементами.</p>
    <p><b>Свойство flex</b></p>
    <p>Свойство flex является объединением свойств flex-basis, flex-shrink и flex-grow и имеет следующий формальный синтаксис:</p>
    <p><b>flex: [flex-grow] [flex-shrink] [flex-basis]</b></p>
    <p>По умолчанию свойство flex имеет значение 0 1 auto. Означает, что элементам запрещено растягиваться (1е 0), когда контейнер больше суммы ширин элементов(т.е. остаётся свободное простанство), разрешенно сужаться(2е 1), когда контейнер сжимаем, то и элементы внутри одинакого сжимаются, потому что задано 1(т.е. для каждого элемента задано flex-shrink: 1;), ну и размер по содержимому (auto), если конечно не заданы ширины отдельно. </p>
    <p>Кроме конкретных значений для каждого из подсвойств мы можем задать для свойства flex одно из трех общих значений:</p>
    <ul class="list">
        <li><b>flex: none;</b> - эквивалентно значению 0 0 auto, при котором flex-элемент не растягивается и не усекается при увеличении и уменьшении контейнера</li>
        <li><b>flex: auto;</b> - эквивалентно значению 1 1 auto</li>
        <li><b>flex: initial;</b> - эквивалентно значению 0 1 auto</li>
    </ul>
    <p>Пример:</p>
    <img src="../img/Flexbox/21.png" alt="" class="screen">
    <img src="../img/Flexbox/22.png" alt="" class="screen">
    <p>Здесь каждый элемент имеет начальную ширину в 150 пикселей, так как у всех элементов свойство flex-basis имеет значение 0, что в целом для всех элементов будет составлять 600 пикселей. При сжатии контейнера будут уменьшаться 3-й и 4-й элементы, так как у них свойство flex-shrink больше нуля. И так как у обоих элементов это свойство равно 1, то оба элемента будут уменьшаться в равных долях. При растяжении контейнера будут увеличиваться 2-й и 4-й элементы, так как у этих элементов свойство flex-grow больше нуля. И также, так как это свойство равно 1, то эти элементы будут увеличиваться в равных долях.</p>






    <h3 class="header-style2" id="note1">Мои личные заметки по флексам</h3>
    <p><b>1.</b>  Первое моё замечание . Если во флекс контейнере есть 2 флекс элемента и они разположены в ряд, то они занимают по умолчанию ширину по своему содержимому. Я хотел задать правому элементу ширину большую, чем у него было и пытался разными способами через просто width: 300px;, также через flex-basis: 300px;, но он не раздвигался, через flex-grow задавал 1, давая разрешение на увеличение, но не помогало. Тогда я задал левому элементу ширину по меньше(без разницы через width или flex-basis) и вот когда левый элемент принял новую ширину, то за ним правый элемент также принял заданную ширину. Тогда я попробовал правому ничего не задавать, а задать только левому новую ширину и он сразу отреагировал. Пока могу сделать вывод, что задать самому последнему правому элементу какую то ширину не получится, пока всем предыдущим элементам левее не задать свои размеры по меньше, чтобы последнему было куда раздвигаться. Т.е. получается правый элемент не может раздвинуться пока на него давят предыдущие элементы, предыдущие нужно немного уменьшить, чтобы раздвинуть последний. Но это как я понимаю только тогда, когда эти 2 внутренних элемента занимают всю ширину контейнера, если же есть свободное место в контейнере, то тогда правый элемент сможет расширится самостоятельно, без затрагивания левого.
    <b>2.</b> </p> 
</div>
