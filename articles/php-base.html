<div class="wrap">
    <h2 class="header-style">Основы PHP</h2>
    
    
    <h3 class="header-style2">Типы данных и функции с ними связанные</h3>
    <ul class="list">
        <li><b>integer</b> - целочисленный тип данных, функция, которая может показать тип данных - var_dump()</li>
        <li><b>float, double</b> - числа с плавающей запятой</li>
        <li><b>string</b> - переменные содержащие текст</li>
        <li><b>boolean</b> - true или false</li>
        <li><b>null</b> - пустота в переменной, $a = null;</li>
        <li><b>array</b> - массив.</li>
        <li><b>object</b> - объект. Пример: $obj = new Class(); $a-> = 'word'</li>
        <li><b>resource</b> - ссылка на некие внешние данные. В примере при подключении к базе данных, возвращается некий дескриптор этого подключения, это и есть ресурс.</li>
    </ul>
    <p>Проверка <b>isset()</b>, устанавливает лежит ли в переменной хоть что то кроме null. Эта функция вернёт false только тогда когда переменной нет и когда в ней null.</p>
    <p>Проверка на пустоту - <b>empty()</b>.
    <img class="screen" src="../img/php/4.png" alt="" width="700px">
    
    
    
    
    <h3 class="header-style2">Приведение типов</h3>
    <p><b>Насильно приводим к другому типу:</b></p>
    <ul class="list">
        <li><b>(int)val</b></li>
        <li><b>(bool)val</b></li>
        <li><b>(string)val</b></li>
    </ul>
    <p>При явном преобразрвании строки в число вот так - $str = (int)'word', получим 0, если в начале строки не будет цифр.</p>
    <p>PHP в отличии от JS может самостоятельно привести сроку '3word' к числу 3 при мат. операции, а в JS нужно сначала parseInt('3word') сделать:</p>
    <div class="code-style">
        <pre>
            echo 3 + '5word'; // 8
            echo 3 + '2.3'; // 3.3
        </pre>
    </div>
    <p>При сравнении(==) разных типов php приводит оба операнда к числу. Оператор тождественного равенства === не выполняет приведения типов и сравнивает сначала то, что типы идентичны, например, целые числа, а затем сравнивает их значения.</p>
    
    
    
    <h3 class="header-style2">Заметка</h3>
    <p class="note">Также заметил что в php при вычислении 3 &amp;&amp; 4 вернётся логическое значение true, а в js вернётся 4</p>
    
    
    
    
    <h3 class="header-style2">Разница ' ' и " "  в PHP</h3>
    <p>В отличии от js в php есть разница между этими кавычками. Двойные кавычки видят внутри себя переменную, а одинарные нет. В двойных кавычках если подставляем переменную, то лучше тогда её подставлять в {}:</p>
    <div class="code-style">
        <pre>
            $lang = 'php';
            $str = 'Я изучаю $lang'; // 'Я изучаю $lang'
            $str = "Я изучаю $lang"; // 'Я изучаю php'
            $str = "Я изучаю {$lang}"; // 'Я изучаю php'(правельней всего)
        </pre>
    </div>
    <p>Есть такая дериктива как HEREDOC, в неё можно записывать строки с разными кавычками, переносами, табуляциями и он всё поймёт, но у этого способа есть строгое правило написания синтаксиса:</p>
    <div class="code-style">
        <pre>
            $lang['language'] = 'php';
            $str = &lt;&lt;&lt;HEREDOC
            "Я изучаю {$lang['language']}"
            HEREDOC;
        </pre>
    </div>
    <p>Также php не прочитает в "" константу, а только переменную.</p>
    
    
    
    
    
    <h3 class="header-style2">Важное место в разработке занимает поиск слабых мест в коде и обработка их. Обработка и логирование ошибок</h3>
    <p>Например есть функция, которая при отработке выводит кусок html кода и этот код отдаётся браузеру и браузер уже выводит на экран результат. Но в функции есть слабое место, которое может вызвать ошибку и эта ошибка отдатся браузеру и он её выведет на экран, если включены ошибки,и по проанализировав эту ошибку можно наненсти вред сайту. 
    Чтобы такого не случилось, нужно сразу во время разработки стараться выявлять такие слабые места и обрабатывать их, чтобы ошибка не выводилась, а выводилась то сообщение, которое мы укажем. Ну например такая функция:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            function drawMenu($menu, $vertical = true){
                if(!is_array($menu)) return false;
                ...
                ...
                return true;
            }
            
            if(!drawMenu($menu)) echo "Извините, произошла ошибка";
        </pre>
    </div>
    <p>Как видно из кода выше, слабым местом было то, что в функцию может прийти не массив и тогда php выкинет ошибку, но мы перехватываем инициативу и ещё до возможной ошибки проверяем на массив переменную и если там не массив прекращаем работу функции и выдаём своё сообщение об ошибке. Вот примерно так нужно отлавливать сразу слабые места и обрабатывать их. Но есть одно НО, выдать сообщение мы то выдали, а нам как разработчику не понятно что была за ошибка. Это когда мы обрабатывали тот кусок кода, то помнили что там за проблема, а если это сообщение выскочит через время, то уже и не помним что там случилось. Для таких случаев нужно создать свою пользовательскую функцию перехватчик ошибок, например myError. Эту функцию php должен как то видеть и знать, что ей нужно передать всё о произошедшей ошибке. Для этого существует такая встроенная функция как <b>set_error_handler()</b> и ей в качестве аргумента нужно передать нашу функцию обработчик ошибок. Вот примерно как должно это выглядеть:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            function myError($errno, $errmsg, $file, $line){
                echo $errmsg;
            }
            
            set_error_handler('myError');
            
            function drawMenu($menu, $vertical = true){
                foreach($menu as $val){
                    echo $val;
                }
                return true;
            }
            
            drawMenu('Не массив');
        </pre>
    </div>
    <p>Теперь на экране мы увидим только сообщение об ошибке, без указания строки, пути к файлу и т.д. вот такое:</p>
    <img class="screen-2" src="../img/php/1.png" alt="">
    <p>Вместо:</p>
    <img class="screen" src="../img/php/2.png" alt="">
    <p>Ещё раз, что произошло. Я убрал обработку ошибки и передал в функцию не массив, чтобы цикл foreach выдал ошибку, но эта ошибка перехватывается нашей функцией myError и php передаёт в мою функцию аргументы в строгом порядке - номер ошибки, сообщение в чём проблема, путь до файла и номер строки где произошла ошибка. А вот уже внутри моей функции можнорешать что и где и когда вывести или залогировать в журнал.</p>
    <p>Там ещё есть про ошибки, есть ещё функция trigger_error(), error_log правда уже немного не понял о чём он рассказывал. Если что это Уроввень 1 День3 начиная где то с 02:00:00. Там уже больше он рассказывал как логировать ошибки.</p>
    
    
    
    
    <h3 class="header-style2">Служебные функции и языковые конструкции</h3>
    <ul class="list">
        <li><b>phpinfo();</b> - выводит целую страницу разной информации о версии php, о сервере, о подключенных расширениях php, о заголовках http, о директивах включенных и нет php.ini и т.д.</li>
        <li><b>echo</b> - выводит информацию на экран, может выводить через запятую: echo 'один', 'два';. Но есл и echo выводит параметр в скобках, то уже только один параметр он может вывести. Приводит к строке выводимую инфу.</li>
        <li><b>print</b> - выводит только один параметр. Отличие его от конструкции echo это то что он возвращает 1, а echo не возвращает ничего.</li>
        <li><b>include, include_once</b> - конструкция для подключения файла. Вернёт true при удачном подключении файла. Если файла нет, то выскочит просто Warning с предупреждением о том , что файла нет и скрипт продолжит работу</li>
        <li><b>required, required_once</b> - конструкция для подключения файла. В отличии от include если подключаемого файла нет, то вылетит фатальная ошибка и скрипт остановится.</li>
        <li><b>ini_get('post_max_size')</b> - функция для получения информации, которая лежит в указанной директиве.</li>
        <li><b>ini_set('post_max_size', '8M')</b> - функция для записи информации в заданную директиву.</li>
        <li><b>get_defined_functions()</b> - функция возвращает все определённые в даный момент функции в виде массива</li>
        <li><b>get_defined_constants(true)</b> - выведет все определённые констаны. Там константы для ошибок, версия php, версия ОС и много другого.</li>
    </ul>
    
    
    
    
    <h3 class="header-style2">Функции для работы с переменными</h3>
    <p><a href="https://www.php.net/manual/ru/ref.var.php">Функции для работы с переменными</a></p>
    <ul class="list">
        <li><b>unset($x)</b> - удаляет переменную x</li>
        <li><b>gettype($x)</b> - вернёт тип переменной в строковом виде.</li>
        <li><b>is_string($str)</b> - вернёт лог. тип, если в переменной строка</li>
        <li><b>is_integer($int)</b> - вернёт лог. тип, если в переменной число</li>
        <li><b>is_boolean($bool)</b> - вернёт лог. тип, если в переменной булев тип</li>
        <li><b>is_null($x)</b> - вернёт лог. тип, если в переменной null</li>
        <li><b>is_array($arr)</b> - вернёт true если массив</li>
        <li><b>is_file($f)</b> - вернёт true если файл</li>
        <li><b>is_dir($d)</b> - вернёт true если папка</li>
    </ul>
    
    
    
    <h3 class="header-style2">Константы и псевдоконстанты</h3>
    <p><b>Псевдоконстанты.</b> Почему псевдо, потому что изменяются. Подходят для отладки кода.</p>
    <ul class="list">
        <li><b>__LINE__</b> - возвращает номер строки, на которой она прописана.</li>
        <li><b>__FLIE__</b> - возвращает полный физический путь к файлу.</li>
        <li><b>__FUNCTION__</b> - возвращает имя функции, внутри которой она прописана.</li>
        <li><b>__DIR__</b> - возвращает полный физический путь к текущей папке.</li>
    </ul>
    <p><b>Константы.</b> Это встроенные константы в сам php.</p>
    <ul class="list">
        <li><b>E_ALL</b> - обозначает, что выбраны все ошибки.</li>
        <li><b>PHP_VERSION</b> - возвращает версию php.</li>
        <li><b>PHP_OS</b> - возвращает версию операционной системы.</li>
        <li><b>get_defined_constans(true)</b> - вернёт список всех определённых констант</li>
    </ul>
    <ul class="list">
        <li><b>define('PROLOG', true)</b> - создали константу PROLOG со значением true</li>
        <li><b>defined(PROLOG)</b> - возвращает лог. значение существоует ли эта константа или нет</li>
    </ul>
    
    
    
    
    <h3 class="header-style2">Функции для работы со строками</h3>
    <p><a href="https://www.php.net/manual/ru/ref.strings.php">Функции для работы со строками</a></p>
    <p>В отличии от js в php работа в строках идёт не с символами, а с байтами.</p>
    <p>Получение символа строки, длина строки:</p>
    <div class="code-style">
        <pre>
            $str = 'word';
            $str2 = 'слово';
            echo $str{2}; // r
            echo $str[2]; // r, через [] тоже можно получить
            echo $str2{0}; // ??, не понимает
            echo strlen($str); // 4
            echo strlen($str2); // 10, потому что русские символы 
            echo mb_strlen($str2); // 5, теперь нормально
            echo $str{strlen($str) - 1}; // d
        </pre>
    </div>
    <p>Склеивать строки можно 2мя спсобами:</p>
    <div class="code-style">
        <pre>
            $str = 'word';
            $str2 = 'of';
            $str3 = 'tanks';
            echo $str . ' ' . $str2 . ' ' . $str3; //word of tanks
            echo "{$str $str2 $str3}";// word of tanks
        </pre>
    </div>
    <ul class="list">
        <li><b>strtoupper($str)</b> - возвращает строку в верхнем регистре. <b>mb_strtoupper()</b>.</li>
        <li><b>strtolower($str)</b> - возвращает строку в нижнем регистре. <b>mb_strtolower()</b>.</li>
        <li><b>trim(), ltrim(), rtrim()</b> - удаляет пробелы у строки</li>
        <li><b>strip_tags()</b> - удаляет HTML и PHP теги из строки</li>
        <li><b>strpos($str, $substr)</b> - Возвращает позицию первого вхождения подстроки $substr в строке $str. 3й параметр указывает с какой позиции начать искать.</li>
        <li><b>strrpos($str, $substr)</b> - Возвращает позицию последнего вхождения подстроки $substr в строке $str</li>
        <li><b>substr($str, $pos_start, $length)</b> - взятие подстроки из строки $str начиная с позиции $pos_start и длиной $length</li>
    </ul>
    
    
    
    
    <h3 class="header-style2">Функции для работы с массивами</h3>
    <p><a href="https://www.php.net/manual/ru/ref.array.php">Функции для работы с массивами</a></p>
    <p>Масивы можно объявить 2мя спсобами. $arr = [] и $arr = array(). Массивы есть с упорядоченной коллекцией - $arr = [ 'word', 12, true ] и есть ассоциативные массивы - $arr = ['name' => 'Jhon', 'age' => 23]. Обращение идёт через [] и через {} как и в строках(чтобы не было путаницы к массиву обращаются через [], а к строкам через {}), например $arr[0] - 'word' или $arr['name'] - 'Jhon'. Присвоить новый элемент в конец массива можно так: $arr[] = 23. В php нумерацию элементов можно назначить самому: $arr = [ 2 => 'word', 23, true]. Всё теперь порядок начнётся с 2, а не с 0 как по умолчанию, и пойдёт дальше увеличиваясь на 1. Также в отличии от js можно присвоить 4 элемент вот так - $arr[99] = 45 и php  не сделает кучу пустых значчений между 4 индексом и 99, просто сразу за 4 индексом пойдёт 99.</p>
    <p><b>Пустой массив при приведении к булеву типу есть false</b></p>
    <ul class="list">
        <li><b>count($arr)</b> - вернёт количество элементов массива.</li>
        <li><b>print_r() и var_dump()</b> - функции для просмотра массивов.</li>
        <li><b>unset($arr)</b> - удаляем массив</li>
        <li><b>unset($arr[2])</b> - удаляем элемент массива с интексом 2</li>
        <li><b>list()</b> - деструктуризация массива по переменным: list($one, $two) = [4, 5]; - теперь в $one лежит 4, а в $two - 5. Это работает только с индексированным массивом. Также доступно такое обращение, например есть фукнция, которая возвращает массив abc() и теперь можно получить отдельный элемент массива так: $one = abc()[3];</li>
        <li><b>implode</b> - Объединяет элементы массива в строку с разделителем:
        <div class="code-style">
            <pre>
                $array = array('имя', 'почта', 'телефон');
                $comma_separated = implode(",", $array);

                echo $comma_separated; // имя,почта,телефон
            </pre>
        </div>
        </li>
        <li><b>explode</b> - разбивает строку на массив по разделилтелю:
        <div class="code-style">
            <pre>
                $pizza  = "кусок1 кусок2 кусок3";
                $pieces = explode(" ", $pizza);
                print_r($pieces); // ["кусок1", "кусок2", "кусок3"]
            </pre>
        </div>
        </li>
        <li><b>serialize(), unserialize()</b>:
        <div class="code-style">
            <pre>
                $user = [
                    'name' => 'Jhon',
                    'login' => 'root',
                    'password' => '1234'
                ]
                echo serialize($user); // a:3:{s:4:"name";s:4:"Jhon";s:5:"login";s:4:"root";s:8:"password";s:4:"1234";}
            </pre>
        </div>
        </li>
        <li><b>base64_encode и base64_decode</b> - запакует и распакует сериализованную строку для того, чтобы сериализованная строка не развалилась, потому что она состоит из : и "", а значит может развалиться, а base64_encode выдаёт только лат. буквы и цифры так:
        <div class="code-style">
            <pre>
                $user = [
                    'name' => 'Jhon',
                    'login' => 'root',
                    'password' => '1234'
                ]
                echo serialize($user); // a:3:{s:4:"name";s:4:"Jhon";s:5:"login";s:4:"root";s:8:"password";s:4:"1234";}
                echo base64_encode(serialize($user));//YTozOntzOjQ6Im5hbWUiO3M6NDoiSmhvbiI7czo1OiJsb2dpbiI7czo0OiJyb290IjtzOjg6InBhc3N3b3JkIjtzOjQ6IjEyMzQiO30=
            </pre>
        </div>
        </li>
    </ul>
    
    
    
    
    
    <h3 class="header-style2">Функции связанные с датой</h3>
    <p><a href="https://www.php.net/manual/ru/ref.datetime.php">Функции работы с датой</a></p>
    <ul class="list">
        <li><b>strftime()</b> - возвращает строку с датой по переданным ей аргументам: 
        <div class="code-style">
            <pre>
                echo strftime('Сегодня %d-%m-%Y');//Сегодня 23-03-2021
                echo strftime('Сегодня %d-%B-%Y');//Сегодня 23-March-2021
                //Чтобы месяц был по русски, пишем так:
                setlocale(LC_ALL, "russian");
                $day = strftime('%d');
                $mon = strftime('%B');
                $mon = iconv('windows-1251', 'utf-8', $mon);
                $year = strftime('%Y');
                echo $mon; // Март
            </pre>
        </div>
         </li>
         <li><b>getdate()</b> - возвращает массив текущей даты и времени:
         <div class="code-style">
             <pre>
                 Array
                    (
                        [seconds] => 39
                        [minutes] => 16
                        [hours] => 17
                        [mday] => 25
                        [wday] => 4
                        [mon] => 3
                        [year] => 2021
                        [yday] => 83
                        [weekday] => Thursday
                        [month] => March
                        [0] => 1616681799//метка времени
                    )
             </pre>
         </div>
         </li>
         <li><b>echo time()</b> - выведет в браузере текущую метку времени(timestamp)</li>
         <li><b>mktime(0, 0, 0, 2, 15, 1978)</b> - возвращает метку времени заданной даты. С её помощью можно получить метку времени в будущем. mktime() без аргументов равен time()</li>
         <li><b>date()</b> - выводит время и дату в определённом формате, это можно сказать аналог strftime(), но короче в записи и используется чаще него:
         <div class="code-style">
             <pre>
                 echo date("d-m-Y H:i:s");// 25-03-2021 17:30:38
                 echo date("d-m-Y H:i:s", timestamp);//выдаст текущую дату и время
             </pre>
         </div>
         </li>
    </ul>
    
    
    
    
    <h3 class="header-style2">Математические функции и константы</h3>
    <ul class="list">
        <li><b>pi()</b> - Возвращает число пи. Константа M_PI делает то же самое.</li>
    </ul>
    
    
    
    
    
    
    
    
    <h3 class="header-style2">Функции которые выводят параметры по типу arguments из JavaScript</h3>
    <div class="code-style">
        <pre>
            function foo(){
                echo <span class="vue-g">func_num_args()</span>;//выведет кол-во принятых аргументов: 5 
                print_r(<span class="vue-g">func_get_args()</span>);//выведет массив из полученных аргументов: [1, 2, 3, 4, 5]
                echo <span class="vue-g">func_get_arg(2)</span>;//выведет аргумент по индексу 2: 3
            }
            
            foo(1, 2, 3, 4, 5);
        </pre>
    </div>
    
    
    
    
    <h3 class="header-style2">TypeHinting(уточнение типа)</h3>
    <p>Как сказал Борисов из специалиста, то пока работает только на массив, говорил это в 2016 году:</p>
    <div class="code-style">
        <pre>
            function foo(<span class="vue-g">array</span> $param){
                
            }
            
            foo(1);//ошибка, нужен аргумент массив
            foo([1, 2]);//всё правильно
        </pre>
    </div>
    <div class="code-style">
        <pre>
            function foo(<span class="vue-g">callable</span> $param){
                $param();
            }
            
            //в функцию нужно передать то, что можно вызвать, например функцию, метод, класс
            function bar(){}
            
            foo(bar);
        </pre>
    </div>
    
    
    
    <h3 class="header-style2">Заметка</h3>
    <p class="note">Цикл <b>foreach ( $arr as $val ) {}</b>, $arr - массив, $val значение св-ва массива.<br> Второй вариант <b>foreach ( $arr as $key => $val ){}</b>.<br>Ссылка в цикле <b>foreach (  $arr  as  &amp;$val  ){}</b> - теперь все операции с $val будут менять значения св-в в массиве, без этой ссылки значения останутся прежними.</p> 
    
    
    
    
    
    
    
    <h3 class="header-style2">Заметка</h3>
    <p class="note">Через файл .htaccess можно настраивать PHP. Например можно отключить директиву коротких кавычек, пишем такую строку php_flag short_open_tag off. Перезапустим сайт и посмотрим на инфу через функцию phpinfo(). На сайте увидим в столбце Local Value, что короткие кавычки теперь отключены. Если же изменить напрямую в файле php.ini эту настройку, то уже глобально отключится эта директива. Об этом говорится в видео специалиста Уровень 1, Урок 1 из 3, на 01:03:30. Эти видео у меня на компе в разделе php от специалиста.</p>
    
    
    
    
    
    
    <h3 class="header-style2">Суперглобальные массивы $GLOBALS и др. </h3>
    <p>Массив $GLOBALS почти то же самое что и в js window, хранит все переменные, константы, функции в себе:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            $name = 'Mike';
            $GLOBALS['name'] = 'Mike';
            //эти две строки делают одно и тоже
        </pre>
    </div>
    <p>Также в этом массиве лежат такие суперглобальные  массивы как:</p>
    <ul class="list">
        <li><b>$_ENV</b> - содержит инфу о ОС</li>
        <li><b>$_SERVER</b> - содержит разные значения переменных, которые пришли на сервер. Это такие как данные  протокола HTTP. Можно вызвать через var_dump этот массив и посмотреть, что внутри. Также можно посмотреть вызвав функцию phpinfo() и пролистав почти в самый низ до раздела php variables</li>
        <li><b>$_COOKIE</b> - для работы с куками</li>
        <li><b>$_SESSION</b> - для работы с сеансами</li>
        <li><b>$_FILES</b> - для работы с файлами, которые закачиваются на сервер</li>
        <li><b>$_GET</b> - </li>
        <li><b>$_POST</b></li>
        <li><b>$_REQUEST</b></li>
    </ul>
    
    
    
    
    
    <h3 class="header-style2">Обработка ошибок</h3>
    <p>Нужно описать из видео специалиста уровень 1, урок 3 из 3, время 02:03:39</p>
    
    
    
    
    
    <h3 class="header-style2">Заметка</h3>
    <p class="note">При echo true; выведится '1'. При echo false; выведится пустая строка ''. false при приведении к числу даст 0. true к числу даст 1</p>
    
    
    
    
    
    <h3 class="header-style2">Ошибки в PHP</h3>
    <ul class="list">
        <li>Уровни ошибок - <b>1. E_PARSE, 2. E_ERROR, 3. E_WARNING, 4. E_NOTICE, 5. E_DEPRECATED</b>. Каждой константе присвоенно также число. E_ALL - выводит все ошибки. E_ALL AND ~E_NOTICE - выводит все ошибки кроме нотайсов.</li>
        <li>В файде php.ini за вывод ошибок отвечают след. директивы: <b>display_errors = on  и error_reporting = E_ALL AND ~E_NOTICE</b></li>
        <li>Есть функция в php, которой можно сказать, чтобы она включила все ошибки: <b>error_reporting(E_ALL)</b></li>
        <li>А так мы говорим чтобы выключила все ошибки: <b>error_reporting(0)</b></li>
    </ul>
    
    
    
    
    
    <h3 class="header-style2">Глобальная и локальная область видимости</h3>
    <p>Если в функции мы хотим обратиться к глобальной переменной, то есть 3 способа:</p>
    <ul class="list">
        <li>1. <b>global $name</b> - в функции пишем такую инструкцию и теперь переменная $name берётся из глобальной области. Надостаток этого способа в том, что в начале функции мы можем обратиться к глобальной переменной, а внизу этой функуии при обращении к этой переменной уже не понятно, мы к глобальной обращаемся или к локальной. Можно тогда внизу функции, где мы решили обратиться к этой переменной, то там же и обращаться через global, тогда мы видим, что обращаемся к глобальной области видимости, но тогда в начале функции не видно, что внизу $name станет уже глобальной, а пока она локальная:
        <div class="code-style">
            <pre>
                &lt;?php
                function abc($name){
                    //код
                    ..
                    ..
                    ..
                    //
                    global $name;
                    $name = '...';
                }
            </pre>
        </div>
        <p>Ещё один момент связан с со словом global это то, что global $name это ссылка на ту переменную, которая находится в глобальной области и поэтому если внутри функции удалить unset($name), то удалится ссылка, а переменная $name останется в глобальной области.</p>
        </li>
        <li>2. <b>$GLOBALS['name']</b> - также в функции обращаемся к глобальной переменной через глобальный массив, в котором хранятся все объявленные глобальные переменные.</li>
        <li>3. <b>function abc(&amp;$name){}</b> - ну и 3й способ это сделать локальную переменную $name ссылающейся на глобальную переменную $name с помощью &amp;</li>
    </ul>
    

    
    
    
    
    <h3 class="header-style2">Про ссылку &amp;</h3>
    <p class="note">Только переменные можно передать по ссылке:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            function abc(&amp;$name){
                ...
            }
            abc('Mike');// Ошибка, нельзя передать просто строку
            $name = 'Mike';
            abc($name);//всё передастся
        </pre>
    </div>
    <p class="note">Как изменить элементы массива:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            $arr = [1, 2, 3];
            foreach($arr as $v){
                $v *= 10;
            }
            print_r($arr);//так и останется массив [1, 2, 3]
            
            
            
            //как надо ---------------
            $arr = [1, 2, 3];
            foreach($arr as &amp;$v){
                $v *= 10;
            }
            print_r($arr);//[10, 20, 30]
        </pre>
    </div>
    <p class="note">Ещё способы применения ссылки:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            function abc($a, &amp;$b){
                if($a){
                    return true;
                }else{
                    $b = 'Сообщение об ошибке';
                    return false;
                }
            }
            
            abc(10, $err);
            //передав такие аргументы, вернётся true
            abc(0, $err);
            //передав 0 вернётся false, а в переменнную $err запишется сообщение об ошибке
        </pre>
    </div>
    
    
    
    
    
    <h3 class="header-style2">Счётчик</h3>
    <p>Вот так можно сделать счётчик в php:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            function abc(){
                static $x = 0;
                echo $x++;
            }
            
            abc();
            abc();
            abc();
            //выведет 012
        </pre>
    </div>
    
    
    
    
    
    <h3 class="header-style2">HTTP</h3>
    <p>Протокол транспортировки гипертекста. уровень 1, урок 3 из 3, время 02:36:15</p>
    <img class="screen" src="../img/php/3.png" alt=""> 
    <p>Так примерно выглядит форма для отправки данных на сервер:</p>
    <div class="code-style">
        <pre>
            &lt;form action="handler.php" method="get">
                Логин:
                &lt;input type="text" name="login">
                Пароль:
                &lt;input type="password" name="pass">
                &lt;input type="submit">
            &lt;/form>
        </pre>
    </div>
    <p>После нажатия на кнопку с типом submit браузер соберёт такую строку для отправки:</p>
    <p><b>GET /handler.php?login=Mike&amp;pass=1234 HTTP/1.1</b> </p>
    <p>Всё что написано после ?  и до HTTP называется строка запроса(QUERY_STRING) и лежит она в $_SERVER['QUERY_STRING'].</p>
    <p>Но посылать метом GET, если есть пароли, не безопасно. Поэтому посылают методом POST, для этого в форме надо в атрибуте method указать 'post'. Тепрь браузер соберёт немного по другому запрос:</p>
    <p><b>POST  /handler.php  HTTP/1.1</b></p>
    <p><b>...</b></p>
    <p><b>Referer:  http://example.com/page-with-form.html</b></p>
    <p><b>Content-Type:  application/x-www-form-urlencoded</b></p>
    <p><b>Content-Length:  20</b></p>
    <p></p>
    <p><b>login=Mike&amp;pass=1234</b></p>
    <p>При методе post заголовок Referer всегда посылается, так как он содержит адрес, кто именно послал форму. Также передаётся Content-Type и Content-Length.</p>
    <p>После того как отправлен запрос по HTTP сервер вызывает указанный обработчик на исполнение и в этом обработчике надо как то принять данные посланные браузером и формой. Php уже подготовил для нас эти данные и распихал их по суперглобальным массивам $_GET, $_POST или $_REQUEST. Если данные были посланы методом GET, то и получаем их в массиве $_GET или $_REQUEST. Если посланы методом POST, то получаем в $_POST или $_REQUEST. Допустим что форма послала методом POST, то и получить наши инпуты можно так:</p>
    <div class="code-style">
        <pre>
            &lt;?php
            $login = $_POST['login'];
            $password = $_POST['pass'];
        </pre>
    </div>
    <p>Но так никогда не надо принимать данные пришедшие извне. Всегда надо их хотя бы минимально обрабатывать, потму что могут прислать что угодно и всё сломается. Вот минимальная обработка данных:</p>
    <div class="code-style">
        <pre>
            $login = trim(strip_tags($_POST['login']));
            $password = trim(strip_tags($_POST['pass']));
            $age = abs((int)$_POST['age']);//либо 0 либо положительное число получим
        </pre>
    </div>
    
    
    
    
    
    
</div>
