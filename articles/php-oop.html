<div class="wrap">
  
  <h2 class="header-style">ООП</h2>
   
   <ul class="list">
       <li><a href="#1">Абстрактный класс</a></li>
       <li><a href="#2">Интерфейс</a></li>
       <li><a href="#3">Финальный класс и метод</a></li>
       <li><a href="#4">Трейты</a></li>
       <li><a href="#5">Шпаргалка по ООП</a></li>
       <li><a href="#6">Константы и статические члены класса</a></li>
       <li><a href="#7">Магические функции автозагрузки классов</a></li>
       <li><a href="#8">Обработка исключений try catch</a></li>
       <li><a href="#9">Контроль типов(type hinting)</a></li>
   </ul>
   
   
   
   
   
   <h3 class="header-style2">Абстрактный класс</h3>
    <p>Абстрактный класс - это не сам чертёж, а набросок чертежа. Это зарисовка, а не сам рисунок. Чтобы обозначить абстрактый класс, перед словом class пишут слово abstract.</p>
    <ul class="list">
        <li>От абстрактоного класса нельзя создать объект.</li>
        <li>От абстрактного класса обязаны наследоваться другие классы.</li>
        <li>Абстрактный класс может иметь абстрактые методы и если они есть, то наследник обязан переопределить эти методы(перегрузить) иначе ошибка. Этот пункт один из главных для чего используют абстрактный класс. Также если есть аргумент в абстрактном классе, то и наследник обязан при переопределении указать этот аргумент.</li>
    </ul>
    <div class="code-style">
        <pre>
            //<b><span class="vue-or">создание абстрактного класса</span>
            <span class="vue-g">abstract class <span class="vue-b">HouseAbstract</span>{
                public <span class="vue-b">$model</span> = <span class="vue-r">""</span>;
                public <span class="vue-b">$square</span>;
                public <span class="vue-b">$floors</span>;
                
                function <span class="vue-b">__construct</span>(<span class="vue-b">$model</span>, <span class="vue-b">$square</span> = <span class="vue-b">0</span>, <span class="vue-b">$floors = 1</span>){
                    if(!<span class="vue-b">$model</span>)
                        throw new <span class="vue-b">Exception</span>(<span class="vue-r">'Ошибка! Укажите модель!'</span>);
                    <span class="vue-b">$this</span>-><span class="vue-b">model</span> = <span class="vue-b">$model</span>;
                    <span class="vue-b">$this</span>-><span class="vue-b">square</span> = <span class="vue-b">$square</span>;
                    <span class="vue-b">$this</span>-><span class="vue-b">floors</span> = <span class="vue-b">$floors</span>;
                }
                
                function <span class="vue-b">startProject</span>(){
                    echo <span class="vue-r">"Start. Model:</span> {$this->model}<span class="vue-r">\n\n</span>";
                }
                
                function <span class="vue-b">stopProject</span>(){
                    echo <span class="vue-r">"Stop. Model:</span> {$this->model}<span class="vue-r">\n\n</span>";
                }
                
                //<span class="vue-or">абстрактный метод</span>
                abstract function <span class="vue-b">build</span>();
            }</span></b>
            
            
            
            <b><span class="vue-g">class <span class="vue-b">SimpleHouse</span> extends <span class="vue-b">HouseAbstract</span>{
                //<span class="vue-or">обязательная реализация абстрактного метода</span>
                function <span class="vue-b">build</span>(){
                    echo <span class="vue-r">"Build. House:</span> <span class="vue-b">{$this</span>-><span class="vue-b">square}</span><span class="vue-r">x</span>{$this-><span class="vue-b">floors}</span><span class="vue-r">\n</span>";
                }
                <span class="vue-r">или</span>
                //<span class="vue-or">Ну или как минимум указать у этого метода {}.</span>
                function <span class="vue-b">build</span>(){}
            }</span></b>
        </pre>
    </div>
    <p>Смысл абстрактных классов это заставить наслеников реализовать абстрактные методы. Т.е. смысл программы заклыдывается в абстрактных классах, а детали реализуются в обычных классах. Это можно представить как руководитель отдела(абстрактный класс) раздаёт задачи(абстрактные методы), которые сотрудники должны выполнить и без разницы, одни сотрудники уволились или другие нанялись, сотрудникам не нужно заного вспоминать или бегать спрашивать, а "что делать?", есть руководитель, котрый скажет что делать. Сотрудники просто должны уже детально испольнить указы.</p>
   
   
   
   
   
   <h3 class="header-style2">Интерфейс</h3>
   <p>Интерфейс это абстрактый класс, который содержит только абстрактые методы.</p>
   <table border="1">
       <tr><th>Абстрактный класс</th><th>Интерфейс</th></tr>
       <tr><td>1. Свойства</td><td>1. ---</td></tr>
       <tr><td>2. Обычные методы</td><td>2. ---</td></tr>
       <tr><td>3. Абстрактные методы</td><td>3. Абстрактные методы(слово abstract перед function писать не надо)</td></tr>
       <tr><td>4. Создание объекта невозможно</td><td>4. Создание объекта невозможно</td></tr>
       <tr><td>5. Наследуется(extends)</td><td>5. Реализуется(implements)</td></tr>
       <tr><td>6. Наследник имеет только одного родителя</td><td>6. Наследник может реализовать методы нескольких интерфейсов</td></tr>
       <tr><td>7. ---</td><td>7. Все методы должны быть public</td></tr>
   </table>
   <div class="code-style">
        <pre>
            //<b><span class="vue-or">создание интерфейса</span>
            <span class="vue-g">interface <span class="vue-b">Paintable</span>{
                //<span class="vue-or">абстрактный метод</span>
                function <span class="vue-b">paint</span>();
            }</span></b>
            
            //<b><span class="vue-or">создание интерфейса</span>
            <span class="vue-g">interface <span class="vue-b">Brik</span>{}</span></b>
            
            <b><span class="vue-g">class <span class="vue-b">SimpleHouse</span> extends <span class="vue-b">HouseAbstract</span> implements <span class="vue-b">Paintable</span>, <span class="vue-b">Brik</span>{
                //<span class="vue-or">обязательная реализация абстрактного метода</span>
                function <span class="vue-b">paint</span>(){
                    echo <span class="vue-r">"Красим дом"</span>;
                }
            }</span></b>
        </pre>
    </div>
    <p>Бывают интерфейсы пустые, но с разными названиями, если класс реализует какой то интерфейс, то название этого интерфейса выступает в качестве флага, что класс использовал такой то интефейс, а значит класс развивается в таком то направлении. Например, есть класс Human и он реализует интерфейс MedicalPropertyHuman, потом мы можем посмотреть а какой интерфейс мы реализовали и сделать вывод, что класс развивался в сторону медициских показателей человека.</p>
    <p>Или другой пример, описаный кодом выше, есть интерфейс Paintable, а в нём метод paint(), и уже потом когда есть какой то абстракный класс HouseAbstract дома и мы наследуем от него, то нам не понятно этот дом можно красить или нет. Мы берём наследуем от абстрактного класа и реализуем интерфейс Paintable и уже понятно что дом нужно красить и реализовать метод paint() нужно тоже. Интерфейсы Paintable и Brik выступают в качестве флагов, что делать с домом. И когда приходят маляры, то они не в курсе, что там в интерфейсах находится, создаётся объект от SimpleHouse и этот объект проверяется, а ты от таких то родителей: <b>if($obj instanceOf Paintable)</b> и если да, то маляры красят дом.</p>
    
    
    
    
    
    
    
    <h3 class="header-style2">Финальный класс и метод</h3>
    <p>Финальный класс это противоположность абстрактному классу. От финального класса нельзя наследовать и можно создавать объекты. Смысл этого класа в том, чтобы показать, что класс ещё на стадии разработки и наследовать от него не нужно, потому что может всё в  нём поменяться.</p>
    <p>Если в обычном классе есть финальный метод, то его нельзя переопределять в наследниках. Тут та же самая причина, ещё не готов метод. Например все методы встроенного класса Exception они финальные, их нельзя переопределить, конструктор можно, а остальные нельзя.</p>
    
    
    
    
    
    
    <h3 class="header-style2">Трейты</h3>
    <p>Уровень 3 день 1 -- 04:00:00</p>
   
   
   
   
   
   
    <h3 class="header-style2">Шпаргалка по ООП</h3>
    <div class="code-style">
        <pre>
            <b>class Animal{
               //public <span class="vue-g">это модификатор, который показывает что свойство доступно на запись и на чтение отовсюду</span>
                <span class="vue-b">public</span> $name;
                <span class="vue-b">public</span> $age = 0;
                <span class="vue-b">public</span> $type;
                
                //protected <span class="vue-g">это модификатор, который запрещает получить и записать значение в это св-во извне, но это св-во может наследоваться в потомок-класс</span>
                <span class="vue-b">protected</span> $protected = 2;
                
                //private <span class="vue-g">это модификатор, который запрещает получить и записать значение в это св-во извне и в отличии от protected даже не наследуется. В основном этот модификатор нужен для собственных нужд класса, а не для использования вне класса.</span>
                <span class="vue-b">private</span> $private = 3;
                
                //<span class="vue-g">это магический метод, который запускается автоматически как только сработал оператор new при создании объекта</span>
                function <span class="vue-b">__construct</span>($t){
                    $this->type = $t;
                }
                
                //<span class="vue-g">метод класса. <span class="vue-r">$this</span> это ссылка на тот объект, который будет создан из этого класса. Обратим внимание, что свойство $name здесь вызывается без знака $</span>
                //<span class="vue-g">вызовы внутри класса свойств и методов происходят через <span class="vue-r">$this</span></span>
                function say($w){
                    echo "{$this->name} сказал $w";
                    $this->drawLine();
                }
                
                function run(){
                    echo "$this->name бежит";
                }
                
                function drawLine(){
                    echo "&lt;hr>";
                }
                
                function functionName(){
                    echo "Вызвана функция " . <span class="vue-b">__FUNCTION__</span>;
                }
                
                function className(){
                    echo "Используем класс " . <span class="vue-b">__CLASS__</span>;
                }
                
                function methodName(){
                    echo "Вызван метод " . <span class="vue-b">__METHOD__</span>;
                }
                
                
                //<span class="vue-g">это магический метод, который запускается автоматически перед тем как удаляется объект</span>
                function <span class="vue-b">__destruct</span>($t){
                    echo "Тут можно закрыть БД или удалить объект или ещё что то";
                }
            }
            
            
            class Cattish <span class="vue-b">extends</span> Animal{
                //<span class="vue-g">класс "Кошачий" наследует от класса "Животные" все свойства и методы с модификаторами <span class="vue-r">public</span> и <span class="vue-r">protected</span></span>
                
                //<span class="vue-g">переопределить и дополнить можно и этот метод</span>
                function __construct($t){
                    parent::__construct($t);
                    //<span class="vue-g">что то своё</span>
                }
                
                //<span class="vue-g">перегрузка метода. Наследник переопределил метод родителя</span>
                function drawLine(){
                    echo "&lt;hr>&lt;hr>";
                }
                
                //<span class="vue-g">тоже переопределяем родительский метод, но не весь, а только часть. То что уже есть в род. методе нас устраивает, мы только добавили своё немного, для этого вызываем то что есть в род. методе и добавляем свой код.</span>
                function run(){
                    parent::run();
                    echo "&lt;br>И при этом мявкает";
                }
            }
            
            //<span class="vue-g">аргумент в скобках передаётся в метод конструктор</span>
            $cat = new Animal("Кошка");
            $dog = new Animal("Собака");
            $obj = new Animal("Просто объект");
            
            //как видно, свойство $name вызывается без $
            $cat->name = 'Мурзик';
            echo $cat->age;//<span class="vue-g">0</span>
            $cat->say('мяу');//<span class="vue-g">Мурзик сказал мяу</span>
            
            $obj->functionName();//<span class="vue-g">Вызвана функция functionName</span>
            $obj->className();//<span class="vue-g">Используем класс className</span>
            $obj->methodName();//<span class="vue-g">Вызван метод Animal::methodName</span>
            
            echo $cat->type;//<span class="vue-g">Кошка</span>
            echo $obj->type;//<span class="vue-g">Просто объект</span>
            
            
            $bars = new Cattish("Барс");
            $bars->run();//<span class="vue-g">Барс бежит&lt;br>И при этом мявкает</span></b>
        </pre>
    </div>
    <p>При создании свойств в классе лучше всего их всех делать приватными, и уже по необходимости открывать к ним доступ напрямую по необходимости. И также создать под каждое свойство свои геттеры и сеттеры для получения и записи значений. Но так неудобно создавать под каждое свойство по 2 метода. Есть более удобный способ работать с закрытыми свойствами, который позоляет убить 2х зайцев сразу: не дать создавать новые свойства и убрать ошибки при обращении напрямую в закрытым св-вам. Этот способ заключается в магических методах <b>__set()</b> и <b>__get()</b>. Например мы создали объект класса и пытаемся обратится к свойству, которого нет или оно закрыто, тогда php просто возьмёт и запишет это новое свойство или выдаст ошибку, но перед тем как это сделать, php проверит наличие этих магических методов и если они есть, то выполнит что в них описано. Чтобы такого не было описываем __set() метод, который принимает 1м параметром имя св-ва и 2м его значение:</p>
    <div class="code-style">
        <pre>
            class User{
                private $_name;
                private $_age;
                
                function __set($name, $val){
                    switch($name){
                        case "name": $this->_name = $val; break;
                        case "age": $this->_age = $val; break;
                        default: throw new Exception("Нет такого свойства!");
                    }
                }
                
                function __get($name){
                    switch($name){
                        case "name": return $this->_name; break;
                        case "age": return $this->_age; break;
                        default: throw new Exception("Нет такого свойства!");
                    }
                }
                
                function __call($name, $args){
                    echo "Call method '$name' with args" . implode(', ', $args);
                }
                
                function __callStatic($name, $args){
                    echo "Call static method '$name' with args" . implode(', ', $args);
                }
                
                function __toString(){
                    return $this->name . ', ' . $this->age;
                    //при вызове объекта класса через echo сработает этот метод и мы покажем свойства через запятую.
                }
                
                //переводим наш объект в массив. foreach может обрабатывать не только массив, но и объекты. В объекте он проходится по свойствам объекта не затрагивая методы. 2й способ перевести в массив указан после слова 'или'
                function toArray(){
                    $arr = [];
                    foreach($this as $v){
                        $arr[] = $v;
                    }
                    return $arr;
                    или
                    return (array)$this;
                }
            }
        </pre>
    </div>
    <p>Теперь пользователь сможет записать или получить значение только для свойства name или age, все остальные интерпритации этих слов будут вызывать наши ошибки и никогда не создадут новых свойств без нашего ведома.</p>
    <p>Также бывает, что пользователь хочет вызвать несуществующий метод и прежде чем выдать ошибку об отсутствии такого метода php смотрит, а нет ли для таких случаев магического метода <b>__call()</b>. Итакже есть магический метод <b>__callStatic()</b> если идёт обращение к статическому методу.</p>
    <p>Все эти 4 магических метода вызываются в случаях когда вызываемых свойств и методов нет, либо они зкрытые от доступа</p>
    <p>Есть такой магический метод <b>__toString()</b>. Он вызывается, когда пользователь пытается вывести на экран объект класса через echo, так как echo приводит к строке, то наш объект не сможет привестись к строке и будет ошибка, на такие случаи и описывают такой метод.</p>
    <p>А если пользователь захочет получить наш объект в виде массива, то мы можем описать свой метод приведения к массиву <b>toArray()</b></p>
    <p>Более редкая вещь это магический метод <b>__invoke()</b>. Посмотреть можно в уровнь 3 день1 -- 03:55:20</p>
    <p>При сериализации нашего объекта есть магические методы <b>__sleep()</b> и <b>__wakeup()</b>. Посмотреть можно в уровнь 3 день1 -- 03:58:00</p>
    
    
    
    
    
    
    
    <h3 class="header-style2">Константы и статические члены класса.</h3>
    <div class="code-style">
        <pre>
            <b><span class="vue-g">class <span class="vue-b">Company</span>{
               //<span class="vue-or">константа класса, к ней нельзя обратиться из объекта класса($obj->NAME - так нельзя и нельзя внутри класса обратиться через $this, так как $this это ссылка на объект), только способами указанными ниже</span>
                const <span class="vue-b">NAME</span> = <span class="vue-r">"Рога и копыта"</span>;
                
                function <span class="vue-b">printName</span>(){
                    //<span class="vue-or">обращение к константе из метода класса</span>
                    echo <span class="vue-b">self</span>::<span class="vue-b">NAME</span>;
                }
            }
            
            //<span class="vue-or">обращение к константе без создания экземпляра класса</span>
            echo <span class="vue-b">Company</span>::<span class="vue-b">NAME</span>;//<span class="vue-or">Рога и копыта</span>
            
            <span class="vue-b">$company</span> = new <span class="vue-b">Company</span>();
            <span class="vue-b">$company</span>-><span class="vue-b">printName</span>();//<span class="vue-or">Рога и копыта</span>
            
            
            
            
            class <span class="vue-b">Worker</span>{
                public <span class="vue-b">name</span>;
                //<span class="vue-or">статическое свойство класса, оно тут как и в функции сохраняет своё значение</span>
                public static <span class="vue-b">$workerCount</span> = 0;
                
                function <span class="vue-b">__construct</span>(<span class="vue-b">$name</span>){
                    if(!<span class="vue-b">$name</span>)
                        throw new <span class="vue-b">Exception</span>(<span class="vue-r">'Ошибка! Укажите имя рабочего'</span>);
                    <span class="vue-b">$this</span>-><span class="vue-b">name</span> = <span class="vue-b">$name</span>;
                    //<span class="vue-or">изменение статического свойства класса</span>
                    ++<span class="vue-b">self</span>::<span class="vue-b">$workerCount</span>;
                }
                
                //<span class="vue-or">статический метод класса, он как и статическое св-во принадлежит только классу</span>
                static function <span class="vue-b">welcome</span>(){
                    //<span class="vue-or">никаких <span class="vue-g">$this</span> в статическом методе</span>
                    echo <span class="vue-r">"Добро пожаловать! Нас уже"</span> . <span class="vue-b">self</span>::<span class="vue-b">$workCount</span>;
                }
            }
            
            <span class="vue-b">Worker</span>::<span class="vue-b">welcome</span>();//<span class="vue-g">0</span>
            <span class="vue-b">$w1</span> = new <span class="vue-b">Worker</span>(<span class="vue-r">'Вася Пупкин'</span>);
            <span class="vue-b">$w2</span> = new <span class="vue-b">Worker</span>(<span class="vue-r">'Дмитрий Иванов'</span>);
            echo <span class="vue-r">'Текущее количество рабочих: '</span> . <span class="vue-b">Worker</span>::<span class="vue-b">$workerCount</span>;//<span class="vue-g">2</span>
            </span></b>
        </pre>
    </div>
    <p>Ещё есть такое слово static вместо self, редко встречается, можно посмотреть уровень 3 день 1 02:38:00</p>
    <hr>
    <p>Небольшой пример кода:</p>
    <div class="code-style">
        <pre>
            	class A{
                    public static $countA = 0;

                    function __construct(){
                        ++self::$countA;
                    }
                }

                class B extends A{
                    public static $countB = 0;

                    function __construct(){
                        ++self::$countA;
                        или
                        parent::$countA;
                        ++self::$countB;
                    }
                }
                $a = new A();
                $b = new A();
                $c = new B();
                echo A::$countA;//3
                echo B::$countB;//1
                //<span class="vue-or">как видим можно к статическому свойству $countA родителя обращаться из наследника через self или parent</span>
        </pre>
    </div>
    
    
    
    
    
    
    <h3 class="header-style2">Магические функции автозагрузки классов</h3>
    <p>Напишем такой код:</p>
    <p><b>$obj = new Simple();</b></p>
    <p>Нам выдастся ошибка, что такого класса нет. Но прежде чем php выдаст эту ошибку, он проверит, а не описал ли я магическую функцию __autoload() и если такая функция есть, php бросит в неё имя вызываемого класса, в нашем случае Simple. Мы пока временно выведем на экран имя класса в этой функции:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">function <span class="vue-b">__autoload</span>(<span class="vue-b">$name</span>){
                echo <span class="vue-b">$name</span>;
            }
            <span class="vue-b">$obj</span> = new <span class="vue-b">Simple</span>();</span>
        </pre>
    </div>
    <p>На экран выведется сначала имя класса, а потом ошибка об отсутствии класса.</p>
    <p>Функция автозагрузки нужна для того, чтобы не запутаться самому подключать к нам в код файлы с классами через include или requare. Делают обычно в одном файле один класс и файл называют также как и класс. Потренируемся. Создадим отдельный файл php с именем Simple и в нём опишем класс Simple:</p>
    <div class="code-style">
        <pre>
            Simple.php
            <span class="vue-g">class <span class="vue-b">Simple</span>{
                function <span class="vue-b">__construct</span>(){
                    echo <span class="vue-r">__CLASS__</span>;
                }
            }</span>
            
            index.php
            <span class="vue-g">function <span class="vue-b">__autoload</span>(<span class="vue-b">$name</span>){
                include <span class="vue-r">"$name.php"</span>;
            }
            <span class="vue-b">$obj</span> = new <span class="vue-b">Simple</span>();</span>
        </pre>
    </div>
    <p>Теперь при запуске кода наш класс подгрузится и код отработает нормально и выведется на экран имя класса.</p>
    
    
    
    <h3 class="header-style2">Обработка исключений try catch</h3>
    <p>В PHP есть встроенные классы как Error так и Exception. Error отличается тем, что этот класс вызывают, когда знают что может произойти грубая ошибка. А Exception использую при не очень грубых ошибках.</p>
    <p>Есть такой код:</p>
    <div class="code-style">
        <pre>
            <b><span class="vue-g">function <span class="vue-b">test</span>(<span class="vue-b">$var</span> = <span class="vue-b">false</span>){
                try{
                    echo <span class="vue-r">"Начинаем\n"</span>;
                    if(!<span class="vue-b">$var</span>){
                        throw new <span class="vue-b">Exception</span>(<span class="vue-r">'$var is false!'</span>);
                    }
                    echo <span class="vue-r">"Продолжаем\n"</span>;
                }catch(<span class="vue-b">Exception $e</span>){
                    echo <span class="vue-r">"Exception: "</span> . <span class="vue-b">$e</span>-><span class="vue-b">getMessage</span>() . <span class="vue-r">"\n"</span>;
                    echo <span class="vue-r">"in file: "</span> . <span class="vue-b">$e</span>-><span class="vue-b">getFile</span>() . <span class="vue-r">"\n"</span>;
                    echo <span class="vue-r">"on line: "</span> . <span class="vue-b">$e</span>-><span class="vue-b">getLine</span>() . <span class="vue-r">"\n"</span>;
                }
                echo <span class="vue-r">"Закончили"</span>;
            }</span></b>
        </pre>
    </div>
    <p>Кратко опишу что как работает. Вызываем функцию и мы заходим в блок try, если внутри произойдёт ошибка, то создастся объект класса Exception и в метод __construct передастся аргумент '$var is false!'. Но как видно присваивания ссылки на объект в какую либо переменную мы не видим, для этого есть оператор throw, который объясняет, что нужно эту ссылку на объект присвоить в блоке catch переменной $e(можем назвать как угодно). Также в блоке catch перед переменной стоит слово Exception, это означает, что мы в переменную $e ожидаем объект именно от класса Exception  и никакой другой. Далее в catch мы выводим на экран информацию. $getMessage() выводит то сообщение, которое передали как аргумент в блоке try, остальные методы по названиям понятно что выводят.</p>
    <p>Если же в блоке try ошибок не было, то код продолжится выполняться пропуская блок catch. Важно! Строка "Закончили" выведется при обоих случаях, при ошибке не выведется строка "Продолжаем"</p>
    <hr>
    <p>От встроенного класса Exception мы можем наследовать свой какой нибудь класс:</p>
    <div class="code-style">
        <pre>
            <b><span class="vue-g">class <span class="vue-b">MathException extends Exception</span>{
                function <span class="vue-b">__construct</span>(<span class="vue-b">$msg</span>){
                    <span class="vue-b">parent</span>::<span class="vue-b">__construct</span>(<span class="vue-b">$msg</span>);
                }
                
                function <span class="vue-b">showClass</span>(){
                    return <span class="vue-b">__CLASS__</span>;
                }
            }
            
            try{
                <span class="vue-b">$x</span> = <span class="vue-b">rand</span>(<span class="vue-b">5</span>, <span class="vue-b">15</span>);
                <span class="vue-b">$y</span> = <span class="vue-b">rand</span>(<span class="vue-b">0</span>, <span class="vue-b">1</span>);
                if(<span class="vue-b">$y</span> == <span class="vue-b">0</span>)//<span class="vue-or">создаём своё исключение</span>
                    throw new <span class="vue-b">MathException</span>(<span class="vue-r">"На 0 делить нельзя"</span>);
                if(<span class="vue-b">$y</span> &lt; <span class="vue-b">0</span>)//<span class="vue-or">создаём встроенное исключение</span>
                    throw new <span class="vue-b">Exception</span>(<span class="vue-r">"Что то случилось"</span>);
                echo <span class="vue-b">$x</span> / <span class="vue-b">$y</span>;
            }cath(<span class="vue-b">MathException $e</span>){
                echo <span class="vue-b">$e</span>-><span class="vue-b">showClass</span>() . <span class="vue-r">":"</span> . <span class="vue-b">$e</span>-><span class="vue-b">getMessage</span>();
            }cath(<span class="vue-b">Exception $e</span>){
                echo <span class="vue-b">$e</span>-><span class="vue-b">getMessage</span>();
            }</span></b>
        </pre>
    </div>
    <p>В примере выше в самом нижнем catch блоке должен быть встроенный класс, потому что если их поменять местами, то в блоке try какой бы не сработал if мы попадём в catch блок с Exception и не попадём в наш MathException catch блок.</p>
    <hr>
    <p>У блока try catch может быть блок finally:</p>
    <div class="code-style">
        <pre>
            <b><span class="vue-g">function <span class="vue-b">test</span>(<span class="vue-b">$var</span> = <span class="vue-b">false</span>){
                try{
                    echo <span class="vue-r">"Try\n"</span>;
                    if(!<span class="vue-b">$var</span>){
                        throw new <span class="vue-b">Exception</span>(<span class="vue-r">'Error'</span>);
                    }
                }catch(<span class="vue-b">Exception $e</span>){
                    echo <span class="vue-r">"Catch";</span>
                }finally{
                    echo <span class="vue-r">"Finally";</span>
                }
            }</span></b>
        </pre>
    </div>
    <p>В блок finally мы попадаем всегда.</p>
    <p>Отличие try catch от других вариантов обработки ошибок - Уровень 3 день 1  01:56:00</p>
    
    
    
    
    
    
    <h3 class="header-style2">Контроль типов(type hinting)</h3>
    <p>Есть в PHP такая фишка как контроль типов:</p>
    <div class="code-style">
        <pre>
            <b>$arr = [1,2,3];
            function sum(<span class="vue-b">array</span> $var){
                //...
            }</b>
        </pre>
    </div>
    <p>Контроль типов уточняет какого типа должен быть аргумент. Если туда передать что то другое, то будет не просто ошибка, а отлавливаемая ошибка.</p>
    <p>Здесь можно рассказать о таком уточнении топов как callable. Спец рассказывает об этом в уровень 3 день 1 -- 04:25:00. Он рассказываект как нужно передавать в параметрах методы из классов, чтобы они стичитались callable.</p>
    
</div>
