<div class="wrap">
   
    <h2 class="header-style">Примеры</h2>

    <ul class="list">
        <li><a href="#arr-azbuka">Масиив с азбукой русских маленьких букв</a></li>
        <li><a href="#define-num">Определить является ли строка числом</a></li>
        <li><b>Работа с массивом</b></li>
        <li><a href="#arr1">Создать случайные числа и добавить их в массив и найти потом наибольшее и наименьшее</a></li>
        <li><a href="#arr2">Сортировка массива от меньшего к большему(метод пузырька) - [4, 2, 5] -> [2, 4, 5]</a></li>
        <li><a href="#arr3">Сортировка массива от большего к меньшему - [2, 5, 1] -> [5, 2, 1]</a></li>
        <li><a href="#arr4">Перемешивание массива - [1, 2, 5] -> [2, 1, 5]</a></li>
        <li><a href="#arr5">Находим факториал числа</a></li>
        <li><a href="#arr6">Найти простые числа среди введённых пользователем естественных (натуральных) чисел</a></li>
        <li><a href="#arr7">Разворачиваем элементы массива в обратную сторону - [1, 2, 3] -> [3, 2, 1]</a></li>
        <li><a href="#arr8">Сортируем в массиве только нечётные числа по возрастанию  - [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] -> [1, 8, 3, 6, 5, 4, 7, 2, 9, 0]</a></li>
        <li><a href="#arr9">Находим наибольшую длину полиндрома из поступивших начертаний</a></li>

        <li><b>Работа со строками</b></li>
        <li><a href="#str1">Разбиваем слово на буквы в массив - "слово" -> ["с", "л", "о", "в", "о"]</a></li>
        <li><a href="#str2">Проверяем является ли введёное слово палиндромом</a></li>
        <li><a href="#str3">Считаем в ведённой пользователем строке кол-во слов, пробелов, знаков препинания</a></li>
        <li><a href="#str4">Пользователь вводит строку, нужно выделить все слова из строки и отсортировать их в порядке возрастания длин этих слов.</a></li>
        <li><a href="#str5">Найти в тексте букву повторяющуюся больше всех.</a></li>
        <li><a href="#str5-a">Вывести количества всех букв из предложения.</a></li>
        <li><a href="#str6">Выделить из строки URL параметры и записать их как ключ и значение в структуру.</a></li>

        <li><b>Про дату</b></li>
        <li><a href="#date1">Разность двух дат представьте в виде количества часов, минут и секунд. Например, "3 ч. 29 мин. 40 с."</a></li>
        <li><a href="#date2">В одной переменной сохраните произвольную дату. В другой переменной вычис-лите девять утра для произвольной даты.</a></li>
        <li><a href="#date3">В одной переменной сохраните произвольную дату. В другой переменной вычис-лите начало следующего понедельника для произвольной даты.</a></li>

        <li><b>Шифры и пароли</b></li>
        <li><a href="#shifr1">Наша программа создаёт текстовый файл, пишет в него строку, потом получает эту строку из файла и шифрует строку</a></li>
        <li><a href="#shifr2">Создание паролей по заданной длине и кол-ву паролей</a></li>
        <li><a href="#shifr3">Вывод чисел Фибоначи через рекурсию</a></li>

        <li><b>Обработки</b></li>
        <li><a href="#processing1">Заполнить реквизит у документов, в табличной части которых есть выбранный товар.</a></li>
        <li><a href="#processing2">Программно обработка изменяет регистр сведений КурсыВалют.</a></li>

        <li><b>ТаблицаЗначений</b></li>
        <li><a href="#table-value">Нужно распределить 40рублей по сумме товаров пропорционально их количество</a></li>
        <li><a href="#"></a></li>
    </ul>



    <h3 class="header-style2" id="arr-azbuka">Масиив с азбукой русских маленьких букв</h3>
    <div class="code-style">
        <pre>
            МассивБукв = ["а", "б", "в", "г", "д", "е", "ё", "ж", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "ч", "ш", "щ", "ъ", "ы", "ь", "э", "ю", "я"];
            
            //буква "а" имеет код - 1072, буква "я" - 1103. Массив можно задать и в цикле через увеличение кода, но тогда буквы "ё" не будет.
            
            //для 1с
            МассивБукв = Новый Массив;
            МассивБукв.Добавить("а"); 
            МассивБукв.Добавить("б"); 
            МассивБукв.Добавить("в"); 
            МассивБукв.Добавить("г"); 
            МассивБукв.Добавить("д"); 
            МассивБукв.Добавить("е"); 
            МассивБукв.Добавить("ё"); 
            МассивБукв.Добавить("ж"); 
            МассивБукв.Добавить("з"); 
            МассивБукв.Добавить("и"); 
            МассивБукв.Добавить("й"); 
            МассивБукв.Добавить("к"); 
            МассивБукв.Добавить("л"); 
            МассивБукв.Добавить("м"); 
            МассивБукв.Добавить("н"); 
            МассивБукв.Добавить("о"); 
            МассивБукв.Добавить("п"); 
            МассивБукв.Добавить("р"); 
            МассивБукв.Добавить("с"); 
            МассивБукв.Добавить("т"); 
            МассивБукв.Добавить("у"); 
            МассивБукв.Добавить("ф"); 
            МассивБукв.Добавить("х"); 
            МассивБукв.Добавить("ц"); 
            МассивБукв.Добавить("ч"); 
            МассивБукв.Добавить("ш"); 
            МассивБукв.Добавить("щ"); 
            МассивБукв.Добавить("ъ"); 
            МассивБукв.Добавить("ы"); 
            МассивБукв.Добавить("ь"); 
            МассивБукв.Добавить("э"); 
            МассивБукв.Добавить("ю"); 
            МассивБукв.Добавить("я"); 
        </pre>
    </div>

    <h3 class="header-style2" id="define-num">Определить является ли строка числом</h3>
    <div class="code-style">
        <pre>
            Функция ЯвляетсяЧислом(Значение) Экспорт
                Если ТипЗнч(Значение) = Тип("Число") Тогда
                    Возврат Истина
                Иначе
                    Если ТипЗнч(Значение) = Тип("Строка") Тогда
                        Если Значение = "" Тогда
                            Возврат Ложь;
                        КонецЕсли;
                    КонецЕсли;

                    Попытка
                        Р = Число(Значение);
                    Исключение
                        Возврат Ложь;
                    КонецПопытки;
                        Возврат Истина;
                КонецЕсли;
            КонецФункции
        </pre>
    </div>

    <h3 class="header-style2" id="arr1">Создать случайные числа и добавить их в массив и найти потом наибольшее и наименьшее</h3>
    <div class="code-style">
        <pre>
            МассивЧисел = Новый Массив();
            ГСЧ = Новый ГенераторСлучайныхЧисел;

            Для Шаг = 0 По 9 Цикл
            СлучайноеЧисло = ГСЧ.СлучайноеЧисло(0, 1000);
                МассивЧисел.Добавить(СлучайноеЧисло);
            КонецЦикла; 
            
            НаибольшееЧисло = 0;
            НаименьшееЧисло = МассивЧисел[0];
            Шаг = 0;
            СуммаВсехЭлементов = 0;
            
            Пока Шаг &lt;= МассивЧисел.Количество() - 1 Цикл
                Если МассивЧисел[Шаг] > НаибольшееЧисло Тогда
                    НаибольшееЧисло =  МассивЧисел[Шаг];
                КонецЕсли;
                
                Если МассивЧисел[Шаг] &lt; НаименьшееЧисло Тогда
                    НаименьшееЧисло = МассивЧисел[Шаг];
                КонецЕсли;
                
                СуммаВсехЭлементов = СуммаВсехЭлементов + МассивЧисел[Шаг];
                
                Шаг = Шаг + 1;
            КонецЦикла;

            СреднеАрифметическое = СуммаВсехЭлементов / МассивЧисел.Количество();

            ОткрытьЗначение(МассивЧисел);

            Сообщить(НаибольшееЧисло);
            Сообщить(НаименьшееЧисло);
            Сообщить(СреднеАрифметическое);
        </pre>
    </div>


    <h3 class="header-style2" id="arr2">Сортировка массива от меньшего к большему(метод пузырька). [2,6,1] => [1,2,6]</h3>
    <div class="code-style">
        <pre>
            МассивЧисел = Новый Массив();
            ГСЧ = Новый ГенераторСлучайныхЧисел;
            КоличествоЧиселВМассиве = 10;

            Для Шаг = 0 По КоличествоЧиселВМассиве Цикл
                СлучайноеЧисло = ГСЧ.СлучайноеЧисло(0, 1000);
                МассивЧисел.Добавить(СлучайноеЧисло);
            КонецЦикла;
            
            
            Шаг1 = 0;
            Шаг2 = шаг1;

            Пока Шаг1 &lt; МассивЧисел.Количество() Цикл
                Число1 = МассивЧисел[Шаг1];

                Пока Шаг2 &lt; МассивЧисел.Количество() Цикл
                    Число2 = МассивЧисел[Шаг2];
                
                    Если Число1 > Число2 Тогда
                        МассивЧисел.Установить(Шаг1, Число2);
                        МассивЧисел.Установить(Шаг2, Число1);
                        Шаг1 = Шаг1 - 1;
                        Прервать;
                    КонецЕсли;
                    Шаг2 = Шаг2 + 1;
                
                КонецЦикла;
                Шаг1 = Шаг1 + 1;
                Шаг2 = Шаг1;

            КонецЦикла;  

            ОткрытьЗначение(МассивЧисел);
        </pre>
    </div>


    <h3 class="header-style2" id="arr3">Сортировка массива от большего к меньшему</h3>
    <p>Тут всё тоже самое что и в примере выше, только меняем знак > на &lt; во втором цикле в проверке Если Число1 > Число2 Тогда</p>


    <h3 class="header-style2" id="arr4">Перемешивание массива</h3>
    <div class="code-style">
        <pre>
            Процедура ПеремешиваниеМассива(М)	
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                Шаг = М.Количество() - 1;
                Пока Шаг >= 0 Цикл			
                    СЧ = ГСЧ.СлучайноеЧисло(0, Шаг);
                    СохрЧисло = М[Шаг];
                    М[Шаг] = М[СЧ];
                    М[СЧ] = СохрЧисло;
                    Шаг = Шаг - 1;			
                КонецЦикла;
                открытьЗначение(М);
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="arr5">Находим факториал числа</h3>
    <p>Вычислить факториал числа очень просто. Для этого нужно перемножить все целые числа от 1 до заданного числа. Например, факториал числа 5 = 1 * 2 * 3 * 4 * 5.</p>
    <div class="code-style">
        <pre>
            ГСЧ = Новый ГенераторСлучайныхЧисел;
            СлучайноеЧисло = ГСЧ.СлучайноеЧисло(1, 15);

            ПроизведениеЧисел = 1;
            Для Шаг = 1 По СлучайноеЧисло Цикл
                ПроизведениеЧисел = ПроизведениеЧисел * Шаг;
            КонецЦикла;

            Сообщить("Факториал числа " + СлучайноеЧисло + " равен " + ПроизведениеЧисел);
        </pre>
    </div>


    <h3 class="header-style2" id="arr6">Найти простые числа среди введённых пользователем естественных чисел</h3>
    <p>Естесственные(натуральные) числа это те числа, которые возникают естесственным способом при счёте: 1, 2, 3, 4, 5, ... . Естесственное число называется простым, если оно оно делится без остатка ТОЛЬКО на 1 и на само себя. Например, 2 простое число, так как делится только на 1 и на само себя, 3 тоже простое, а вот 4 не простое, т.к. кроме того что делится на 1 и на само себя, ещё оно делится на 2 без остатка, 5 простое, 6 не простое(делится ещё на 2 и на 3).</p>
    <div class="code-style">
        <pre>
            Число = 0;
            ВвестиЧисло(Число);

            ПростоеЧисло = Истина;

            Для Шаг = 2 По Число - 1 Цикл
                Если Число % Шаг = 0 Тогда 
                    ПростоеЧисло = Ложь;
                    Прервать;
                КонецЕсли;
            КонецЦикла;

            Если ПростоеЧисло Тогда
                ОткрытьЗначение("Число " + Число + " является простым");
            Иначе	
                ОткрытьЗначение("Число " + Число + " не является простым");
            КонецЕсли;
        </pre>
    </div>


    <h3 class="header-style2" id="arr7">Разворачиваем элементы массива в обратную сторону</h3>
    <div class="code-style">
        <pre>
            Функция ПеревернутьМассив(Массив)
                Для Шаг = 0 По Цел(Массив.Количество()/2) - 1 Цикл
                Эл = Массив[Шаг];
                
                Массив[Шаг] = Массив[Массив.Количество() - 1 - Шаг];
                
                Массив[Массив.Количество() - 1 - Шаг] = Эл;
                КонецЦикла;
                
                Возврат Массив;
            КонецФункции
        </pre>
    </div>


    <h3 class="header-style2" id="arr8">Сортируем в массиве только нечётные числа по возрастанию</h3>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)
                МассивЧисел = Новый Массив;
                МассивЧисел.Добавить(9);
                МассивЧисел.Добавить(8);
                МассивЧисел.Добавить(7);
                МассивЧисел.Добавить(6);
                МассивЧисел.Добавить(5);
                МассивЧисел.Добавить(4);
                МассивЧисел.Добавить(3);
                МассивЧисел.Добавить(2);
                МассивЧисел.Добавить(1);
                МассивЧисел.Добавить(0);

                УпорядМассивЧисел = Новый Массив;

                Для Шаг = 0 По МассивЧисел.Количество() - 1 Цикл
                    Если МассивЧисел[Шаг] % 2 = 0 Тогда
                        Продолжить;
                    КонецЕсли;
                    
                    Для Шаг2 = Шаг По МассивЧисел.Количество() - 1 Цикл                   
                        Если МассивЧисел[Шаг] > МассивЧисел[Шаг2] И МассивЧисел[Шаг2] % 2 <> 0 Тогда
                            Значение = МассивЧисел[Шаг];
                            МассивЧисел.Установить(Шаг, МассивЧисел[Шаг2]);
                            МассивЧисел.Установить(Шаг2, Значение);	
                        КонецЕсли;
                    КонецЦикла;
                КонецЦикла;

                ОткрытьЗначение(МассивЧисел);
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="arr9">Находим наибольшую длину полиндрома из поступивших начертаний</h3>
    <p>На вход поступает строка начертаний - "ыльуьмщмшс", нужно узнать наибольшую длину полиндрома, которую можно составить из этих начертаний. Всё что можно составить тут это полиндром вида "мь.ьм", по центру можно подставить любую букву, т.е. наибольшая длина это 5.  Или другой пример. На вход поступает такая строка с буквами - "оввосссь", всё что тут можно составить это - "овсссво", получается длина 7. Вот набор правил:</p>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)
                Набор = "оввосссьууууу";   
                
                МассивПовторений = Новый Массив;
                МассивБукв = Новый Массив;

                <span class="vue-g">//заполняем массив количествами повторений букв чётными и нечётными</span> 
                КолНачертаний = 0;
                А = 0;
                Для Шаг = 1 По СтрДлина(Набор) Цикл
                    Если МассивБукв.Найти(Сред(Набор, Шаг, 1)) = Неопределено Тогда 	
                        КолНачертаний = КолНачертаний + 1;
                        А = Шаг;
                        Для Шаг2 = А + 1 По СтрДлина(Набор) Цикл
                            Если Сред(Набор, Шаг, 1) = Сред(Набор, Шаг2, 1) Тогда
                                КолНачертаний = КолНачертаний + 1;           
                            КонецЕсли;    
                        КонецЦикла;
                        МассивПовторений.Добавить(КолНачертаний);
                        КолНачертаний = 0;
                        МассивБукв.Добавить(Сред(Набор, Шаг, 1));
                    КонецЕсли;
                КонецЦикла;  
                
                
                <span class="vue-g">//Записываем в длину полиндрома количество нечётных чисел.
                //При этом из каждого нечётного числа убираем единицу, чтобы осталось чётное
                //Почему вычитаем 1, потому что из сочетаний "ссс", "ууууу" попадут в 
                //полиндром чётные "сс" и "уууу" и только у одного из них в центр полиндрома
                //попадёт либо 3й "с", либо 5й "у"
                //т.е. из всех нечётных только одно нечётное попадёт полностью, а от
                //остальных нужно отнять 1.
                //Поэтому дальше мы сразу в переменную ДлинаПолиндрома присвоили эту 1
                //и значит мы тут сразу от всех нечётных вычитаем 1, так как она уже учтена будет дальше. </span>
                КоличествоНечётных = 0;
                Для каждого Элемент Из МассивПовторений Цикл
                    Если Элемент % 2 &lt;> 0  Тогда
                        КоличествоНечётных = КоличествоНечётных + (Элемент - 1);	
                    КонецЕсли;
                КонецЦикла;


                <span class="vue-g">//Записываем в длину полиндрома количество чётных 
                //В переменную ДлинаПалиндрома сразу присваиваем 1, это буква, которая будет стоять по середине палиндрома</span>
                ДлинаПолиндрома = 1;
                Для каждого Элемент Из МассивПовторений Цикл
                    Если Элемент % 2 = 0  Тогда
                        ДлинаПолиндрома = ДлинаПолиндрома + Элемент;
                    КонецЕсли;		
                КонецЦикла;  

                ДлинаПолиндрома = ДлинаПолиндрома + КоличествоНечётных;
                
                Сообщить("Наибольшая длина полиндрома равна " + ДлинаПолиндрома);
            КонецПроцедуры
        </pre>
    </div>















    <h3 class="header-style2" id="str1">Разбиваем слово на буквы в массив</h3>
    <p>В 1с не нашёл пока функцию, которая разбивает слово на буквы в массив. Есть такая функция - СтрРазделить(строка, разделитель);, но что то не пойму какой надо разделитель, чтобы разбить слово на буквы. В JS разделитель просто пустая строка '', а тут это не работает. Поэтому написал свою функцию, которая разбивает слово на буквы и возвращает этот массив.</p>
    <div class="code-style">
        <pre>
            Функция РазделитьСлово(Строка)
                МассивБукв = Новый Массив;
                Слово = НРег(Строка);

                //через цикл Для
                Для Шаг = 1 По СтрДлина(Слово) Цикл
                    Буква = Сред(Слово, Шаг, 1);
                    МассивБукв.Добавить(Буква);	
                КонецЦикла;

                //через цикл Пока
                Шаг = 1;
                Длина = СтрДлина(Слово);
                Пока Шаг &lt;= Длина Цикл
                    МассивБукв.Добавить(Сред(Слово, Шаг, 1));
                	  Шаг = Шаг + 1;
                КонецЦикла;
                
                Возврат МассивБукв;
            КонецФункции
            
            Слово = "Казак";
            МассивБукв = РазделитьСлово(Слово);
            //выводим пользователю в модальном диалоговом окне массив букв       
            ОткрытьЗначение(МассивБукв);  
        </pre>
    </div>


    <h3 class="header-style" id="str2">Проверяем является ли введёное слово палиндромом</h3>
    <p>Палиндром это каогда слово читается взад наперёд одинакого, например - шалаш, казак, потоп</p>
    <p>Блин не соранил код этой задачи. Ну там смысл такой, как решал я. Вверху уже есть готовые функции, которыми я пользовался. Получаем от пользователя строку-слово, разделяю это слово в массив по символам, затем переворачиваю элементы массива задом наперёд и соединяю массив в строку и сравниваю результат с изначальным словом, если совпадают, значит слово палиндром.</p>
    <p>В учебнике немного по другому было. Там сравнивали 1ю букву и последнию, если не совпадали, то сравнение прекращалось и так далее до середины.</p>


    <h3 class="header-style2" id="str3">Считаем в ведённой пользователем строке кол-во слов, пробелов, знаков препинания.</h3>
    <div class="code-style">
        <pre>
            Строка = "";
            ВвестиСтроку(Строка);
            
            ЗнакиПрепинания = "`~!@#$%^&*()-=_+\|[]{};:'"",.&lt;>/?";
            ЗнакПробела = " ";
            КоличествоПробелов = 0;
            КоличествоЗнаковПрепинания = 0;
            КоличествоСлов = 0;
            ЭтоСимвол = Истина;
            СобираемоеСлово = "";
            
            Для Шаг = 1 По СтрДлина(Строка) Цикл
                Символ = Сред(Строка, Шаг, 1);
                
                Если Символ = ЗнакПробела Тогда
                    КоличествоПробелов = КоличествоПробелов + 1;
                    ЭтоСимвол = Ложь;
                КонецЕсли;
                
                Если СтрНайти(ЗнакиПрепинания, Символ) &lt;> 0 Тогда
                    КоличествоЗнаковПрепинания = КоличествоЗнаковПрепинания + 1;	
                    ЭтоСимвол = Ложь;
                КонецЕсли;
                
                Если ЭтоСимвол Тогда
                    СобираемоеСлово = СобираемоеСлово + Символ;
                Иначе
                    Если СтрДлина(СобираемоеСлово) &lt;> 0 Тогда
                        КоличествоСлов = КоличествоСлов + 1;
                        СобираемоеСлово = "";      
                    КонецЕсли;
                    ЭтоСимвол = Истина;
                КонецЕсли;
            КонецЦикла;


            ОткрытьЗначение("Количество слов в строке " + КоличествоСлов);
            ОткрытьЗначение("Количество пробелов в строке " + КоличествоПробелов);
            ОткрытьЗначение("Количество знаков в строке " + КоличествоЗнаковПрепинания);
        </pre>
    </div>


    <h3 class="header-style" id="str4">Пользователь вводит строку, нужно выделить все слова из строки и отсортировать их в порядке возрастания длин этих слов.</h3>
    <div class="code-style">
        <pre>
            Функция СортировкаСлов(МассивСлов)
                Шаг1 = 0;
                Шаг2 = шаг1;

                Пока Шаг1 &lt; МассивСлов.Количество() Цикл
                    Число1 = СтрДлина(МассивСлов[Шаг1]);

                    Пока Шаг2 &lt; МассивСлов.Количество() Цикл
                        Число2 = СтрДлина(МассивСлов[Шаг2]);
                    
                        Если Число1 > Число2 Тогда
                            Память = МассивСлов[Шаг1];
                            МассивСлов.Установить(Шаг1, МассивСлов[Шаг2]);
                            МассивСлов.Установить(Шаг2, Память);
                            Шаг1 = Шаг1 - 1;
                            Прервать;
                        КонецЕсли;
                        Шаг2 = Шаг2 + 1;
                    
                    КонецЦикла;
                    Шаг1 = Шаг1 + 1;
                    Шаг2 = Шаг1;
                КонецЦикла;
                
                Возврат МассивСлов;
            КонецФункции



            ЗнакиПрепинания = "`~!@#$%^&*()-=_+\|[]{};:'"",.&lt;>/?";
            Строка = "";
            ВвестиСтроку(Строка);

            МассивСлов = Новый Массив;
            СобираемоеСлово = "";

            Для Шаг = 1 По СтрДлина(Строка) Цикл
                Символ = Сред(Строка, Шаг, 1);
            
                Если Символ &lt;> " " И СтрНайти(ЗнакиПрепинания, Символ) = 0 Тогда
                    СобираемоеСлово = СобираемоеСлово + Символ;
                Иначе
                    Если СтрДлина(СобираемоеСлово) &lt;> 0 Тогда
                        МассивСлов.Добавить(СобираемоеСлово);
                        СобираемоеСлово = "";      
                    КонецЕсли;
                КонецЕсли;

            КонецЦикла;

            ОтсортированныйМассивСлов = СортировкаСлов(МассивСлов);
            ОткрытьЗначение(ОтсортированныйМассивСлов);
        </pre>
    </div>


    <h3 class="header-style" id="str5">Найти в тексте букву повторяющуюся больше всех</h3>
    <p>На вход в программу подаётся текст, предложения в котором заканчиваются на точку. Нужно написать код, который найдёт в первом предложении самую частую букву и выведет её на экран с её количеством. Нужно искать букву только в первом предложении до точки, после точки уже не ищем. Например:</p>
    <p><b>"Я пошёл за хлебом в магазин. Завтра буду."</b></p>
    <p>Самая частая буква это "а", её 3 штуки в предложении. Если каких то букв будет несколько с одинаковым количеством, то в азбучном порядке вывести первую из них.</p>
    <div class="code-style">
        <pre>
            --моё первое решение

            <span class="vue-b">Процедура ПриНачалеРаботыСистемы()   
                Предложение = <span class="vue-bl">"Я пошёл за хлебом в магазин. Скоро буду."</span>;
                Предложение = СокрЛП(Предложение);
                
                КоличествоБукв = Новый Структура;
                НайденноеЗначение = Неопределено;
                
                <span class="vue-g">//здесь в структуру "КоличествоБукв" записываем
                //все буквы и их количество из предложения</span>
                Для Шаг = 1 По СтрДлина(Предложение) Цикл
                    Буква = Сред(Предложение, Шаг, 1); 
                        
                    Если Буква = " " Тогда
                        Продолжить;
                    КонецЕсли; 
                
                    Если Буква = "." Тогда
                        Прервать;
                    КонецЕсли;
                
                    КоличествоБукв.Свойство(Буква, НайденноеЗначение);
                    Если НайденноеЗначение = Неопределено Тогда
                        КоличествоБукв.Вставить(Буква, 1);
                    Иначе 
                        КоличествоБукв[Буква] = КоличествоБукв[Буква] + 1;
                        НайденноеЗначение = Неопределено;
                    КонецЕсли;	
                КонецЦикла;
                

                <span class="vue-g">//здесь вылавливаем из структуры "КоличествоБукв" те буквы/букву
                //которые имеют наибольшее количество
                //и записываем их в структуру "НужныеБуквы"</span>
                ПредыдущееЧисло = 0;
                НужныеБуквы = Новый Структура;
                Круг = Истина;
                Пока Круг  Цикл 
                    НаибольшееЧисло = 0;
                    НаибольшаяБуква = <span class="vue-bl">""</span>;

                    Для каждого КлючЗначение Из КоличествоБукв Цикл
                        Если КлючЗначение.Значение > НаибольшееЧисло Тогда		
                            НаибольшееЧисло = КлючЗначение.Значение;
                            НаибольшаяБуква = КлючЗначение.Ключ;	
                        КонецЕсли;
                    КонецЦикла;	
                    
                    Если (НужныеБуквы.Количество() = 0) ИЛИ (НужныеБуквы.Количество() > 0 И НаибольшееЧисло = ПредыдущееЧисло) Тогда
                        ПредыдущееЧисло = НаибольшееЧисло;
                        НужныеБуквы.Вставить(НаибольшаяБуква, НаибольшееЧисло);
                        КоличествоБукв.Удалить(НаибольшаяБуква);
                    Иначе
                        Круг = Ложь;
                    КонецЕсли;
                КонецЦикла;   
                        

                <span class="vue-g">//если у нас несколько букв, в структуре НужныеБуквы, с одинаковым
                //количеством, то выбираем ту букву, которая в азбуке стоит выше 
                //если нужно решить проблему с буквой "ё", то вот в этом уикле надо это делать</span> 
                НаименишийКод = 1105;
                Для каждого КлючЗначение Из НужныеБуквы Цикл 
                    КодБуквы = КодСимвола(НРег(КлючЗначение.Ключ), 1);	
                    Если КодБуквы &lt; НаименишийКод Тогда		
                        НаименишийКод = КодБуквы;	
                    КонецЕсли;
                КонецЦикла;

                <span class="vue-g">//найденную букву выводим на экран
                //в этой программе не решена проблема с буквой "ё"(1105), её код не входит в рамки 1072(а) - 1103(я)
                //а потому, если вдруг буква "ё" будет одна самой частой
                //то всё будет нормально, или если есть ещё буквы
                //с таким же количеством и они стоят выше "ё" по азбуке, то тоже всё будет нормально
                //проблемы начнутся, когда есть буквы с таким же количеством 
                //и они стоят ниже буквы "ё", тогда будут выводится эти буквы
                //хоть они и стоят ниже буквы "ё". Например если в структуре
                //2 буквы с одинаковым количеством "ё" - 5  и "я" - 5 , 
                //то выведет на экран "я", хотя "я" стоит ниже по азбуке
                //если прям будет большая нужна исправить это, то можно 
                //немного подшаманить код</span>        
                ЗначениеБуквы = Неопределено;
                НужныеБуквы.Свойство(Символ(НаименишийКод), ЗначениеБуквы);
                Сообщить(<span class="vue-bl">""</span> + Символ(НаименишийКод) + <span class="vue-bl">" "</span> + ЗначениеБуквы); 
            КонецПроцедуры</span>



            --второе моё решение через год
            
            <span class="vue-b">Процедура ПередНачаломРаботыСистемы(Отказ)  
                СлучайныйТекст = "Я пошёл за хлебом в магазин, буду через пару часов, как только, так сразу. Завтра буду.";

                <span class="vue-g">//Отсекаем другие предложения, оставляем только первое до точки</span>
                ПервоеПредложение = Лев(СлучайныйТекст, СтрНайти(СлучайныйТекст, ".") - 1);

                <span class="vue-g">//создаём структуру для хранения букв, которые имееют наибольшее повторение</span>
                СтруктураБукв = Новый Структура;

                ДлинаТекста = СтрДлина(ПервоеПредложение);
                НомерСтроки = 1;
                КоличествоБукв = 1;
                Пока НомерСтроки &lt;> ДлинаТекста + 1 Цикл 
                    <span class="vue-g">//получаем из предложения очередную букву и переводим в нижний регистр</span>
                    БукваСтроки = НРег(Сред(ПервоеПредложение, НомерСтроки, 1)); 
                
                    <span class="vue-g">//если в предложении встречаем пробел или запятую, то 
                    //пропускает круг цикла</span>
                    Если БукваСтроки = " " ИЛИ БукваСтроки = "," Тогда
                        НомерСтроки = НомерСтроки + 1;
                        Продолжить;
                    КонецЕсли;
                    
                    <span class="vue-g">//проверяем, добавляли ли мы ранее в структуру
                    //такую букву, если Да, то пропускаем круг цикла</span>
                    ЕстьТакаяБуква = СтруктураБукв.Свойство(БукваСтроки);	
                    Если ЕстьТакаяБуква Тогда
                        НомерСтроки = НомерСтроки + 1;
                        Продолжить;
                    КонецЕсли;
                    
                    <span class="vue-g">//во втором цикле мы проверяем букву из первого цикла со
                    //всеми буквами предложения, перебираемыми во втором цикле
                    //в первом решении мне больше нравится способ нахождения количества букв</span>
                    НомерСтроки2 = НомерСтроки + 1;
                    Пока НомерСтроки2 &lt;> ДлинаТекста + 1 Цикл
                        Если БукваСтроки = НРег(Сред(ПервоеПредложение, НомерСтроки2, 1)) Тогда
                            КоличествоБукв = КоличествоБукв + 1;
                            СтруктураБукв.Вставить(БукваСтроки, КоличествоБукв); 
                        КонецЕсли;
                        НомерСтроки2 = НомерСтроки2 + 1;
                    КонецЦикла;
                    НомерСтроки = НомерСтроки + 1;
                    КоличествоБукв = 1;
                КонецЦикла;

                <span class="vue-g">//вызываем функцию, которая вернёт структуру содержащую
                //все буквы, которые имеют наибольшее одинаковое количество</span>
                ВремСтруктура = НайтиНаибольшиеЧисла(СтруктураБукв);

                <span class="vue-g">//если букв несколько с одинаковым количеством, то эта функция
                //отберёт только одну букву в азбучном порядке</span>
                ИскомаяСтрока = ОтобратьСтаршуюБукву(ВремСтруктура);

                <span class="vue-g">//сообщаем о такакой букве</span>
                Сообщить(ИскомаяСтрока);	
            КонецПроцедуры
                    



            Функция НайтиНаибольшиеЧисла(СтруктураБукв)
                МассивБукв = Новый Массив;

                НаибольшееЧисло = 0;
                БукваНибольшегоЧисла = ""; 
                Счётчик = 0;
                Для каждого ЭлементСтрк Из СтруктураБукв Цикл 
                    Счётчик = Счётчик + 1;

                    Если Счётчик = 1 Тогда
                        НаибольшееЧисло = ЭлементСтрк.Значение;
                        БукваНибольшегоЧисла = ЭлементСтрк.Ключ;
                        Продолжить;
                    КонецЕсли;
                    
                    Если НаибольшееЧисло &lt; ЭлементСтрк.Значение Тогда
                        НаибольшееЧисло = ЭлементСтрк.Значение;
                        БукваНибольшегоЧисла = ЭлементСтрк.Ключ;	
                    КонецЕсли;		
                КонецЦикла;

                ВремСтруктура = Новый Структура;
                ВремСтруктура.Вставить(БукваНибольшегоЧисла, НаибольшееЧисло);    

                Для каждого КлючЗначение Из СтруктураБукв Цикл
                    Если КлючЗначение.Ключ = БукваНибольшегоЧисла Тогда
                        Продолжить;	
                    КонецЕсли;
                    
                    Если КлючЗначение.Значение = НаибольшееЧисло Тогда
                        ВремСтруктура.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
                    КонецЕсли;
                КонецЦикла;	

                Возврат ВремСтруктура;
            КонецФункции
                                                        

            Функция ОтобратьСтаршуюБукву(ВремСтруктура)
                НаименьшееЧисло = 0; 
                Счётчик = 1;
                Для каждого ЭлементСтрк Из ВремСтруктура Цикл 
                    Если Счётчик = 1 Тогда
                        НаименьшееЧисло = КодСимвола(ЭлементСтрк.Ключ);
                        Счётчик = Счётчик + 1;
                        Продолжить;
                    КонецЕсли;
                    
                    Если НаименьшееЧисло > КодСимвола(ЭлементСтрк.Ключ) Тогда
                        НаименьшееЧисло = КодСимвола(ЭлементСтрк.Ключ);	
                    КонецЕсли;		
                КонецЦикла;	
                
                ИскомаяСтрока = "" + Символ(НаименьшееЧисло) + " " + ВремСтруктура[Символ(НаименьшееЧисло)];

                Возврат ИскомаяСтрока; 
            КонецФункции </span>
        </pre>
    </div>
    <p>А вот другое решение, в котором мы используем язык запросов, чтобы сгруппировать и отсортировать результат. В общем модуле не стал дальше решать, потому что там повторяются действия, нужно будет выгрузить результат в таблицу значений, выбрать сверху коды символов с наибольшим количеством и вывести ту, которая по азбуке стоит выше. Также, чтобы можно было в запросе использовать список значений как параметр таблицу, нужно её поместить во временную таблицу, а потом выбирать из временной таблицы. Для написания программы использую схему Управляемое приложение -> Процедура из общего модулявыполняемая на сервере. Вот видео где решение этой задачи - https://www.youtube.com/watch?v=7mvPPNjeox8:</p>
    <div class="code-style">
        <pre>
            --модуль управляемого приложения
            <span class="vue-b">Процедура ПриНачалеРаботыСистемы()
                Предложение = НРег(СокрЛП(<span class="vue-bl">"Я пошёл за хлебом в магазин. Скоро буду."</span>));

                СписокЗначений = Новый СписокЗначений;

                <span class="vue-g">//тип значения нужно указать, чтобы язык запросов не ругался</span>
                СписокЗначений.ТипЗначения = Новый ОписаниеТипов("Число");

                Для Шаг = 1 По СтрДлина(Предложение) Цикл
                    КодБуквы = КодСимвола(Предложение, Шаг);
                    Если КодБуквы = 46 Тогда
                        Прервать;
                    КонецЕсли;

                    Если КодБуквы = 32 Тогда
                        Продолжить;
                    КонецЕсли;

                    СписокЗначений.Добавить(КодБуквы);
                КонецЦикла;

                ОбработкаНаСервере.ОбработкаСпискаЗначений(СписокЗначений);
            КонецПроцедуры</span>

            --общий модуль ОбработкаНаСервере
            <span class="vue-b">Процедура ОбработкаСпискаЗначений(СЗ) Экспорт
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    <span class="vue-bl">"ВЫБРАТЬ
                    |	СЗ.Значение КАК Значение
                    |ПОМЕСТИТЬ ВТ
                    |ИЗ
                    |	&СЗ КАК СЗ
                    |;
                    |
                    |/////////////////////////////////////
                    |ВЫБРАТЬ
                    |	ВТ.Значение КАК Значение,
                    |	СУММА(1) КАК Количество
                    |ИЗ
                    |	ВТ КАК ВТ
                    |СГРУППИРОВАТЬ ПО
                    |	ВТ.Значение
                    |УПОРЯДОЧИТЬ ПО
                    |	Количество УБЫВ,
                    |	ВТ.Значение"</span>;
                    
                Запрос.УстановитьПараметр("СЗ", СЗ);
                РезультатЗапроса = Запрос.Выполнить();	
            КонецПроцедуры</span>
        </pre>
    </div>


    <h3 class="header-style" id="str5-a">Вывести количества всех букв из предложения</h3>
    <p>На вход подаётся вот такой набор начертаний: "пьвШлста7вТу43двс9соо.". Ввод этих начертаний заканчивается точкой. Нужно написать программу, которая будет из этого набора выводить только буквы в азбучном порядке и их количество, также чтобы они были в нижнем регистре. Программа должна вывести:</p>
    <ul class="list">
        <li>а1</li>
        <li>в3</li>
        <li>д1</li>
        <li>л1</li>
        <li>и так далее</li>
    </ul>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)  
                СлучайныйТекст = "пьпвШлста7вТу43двс9соо.";
                
                <span class="vue-g">//Использую 2 списка значения. В одном буду хранить
                //в значении количество букв, а в представлении саму букву, чтобы потом
                //отсортировать по представлению, но поиска в списке значений нету по 
                //по полю Представление, но есть по полю Значение, поэтому и будем
                //использовать 2й список, в него буду добавлять в значения буквы и искать
                //в нём буквы, которые не нужно повторно записывать</span>
                СЗ = Новый СписокЗначений;
                СЗ2 = Новый СписокЗначений;


                Для Шаг = 1 По СтрДлина(СлучайныйТекст) - 1 Цикл
                    Начертание = НРег(Сред(СлучайныйТекст, Шаг, 1));
                
                    //тут мы с помощью Попытка отсекаем строки, которые содержат цифры
                    //Отсечь цифры можно и путём проверки его кода: КодСимвола(Начертание) &lt; 1072
                    //У цифр всегд код меньше чем код первой буквы русской азбуки
                    Попытка	
                        Начертание = Число(Начертание);
                    Исключение
                        Если СЗ2.НайтиПоЗначению(Начертание) = Неопределено Тогда
                            СЗ.Добавить(0, Начертание);
                            СЗ2.Добавить(Начертание);
                        КонецЕсли;	
                        
                        Для каждого Элемент Из СЗ Цикл
                            Если Элемент.Представление = Начертание Тогда
                                Элемент.Значение = Элемент.Значение + 1;
                            КонецЕсли;
                        КонецЦикла;
                    КонецПопытки;                
                КонецЦикла;

                СЗ.СортироватьПоПредставлению(НаправлениеСортировки.Возр);

                Для каждого Элемент Из СЗ Цикл
                    Сообщить(Элемент.Представление + " " + Элемент.Значение);
                КонецЦикла;	
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style" id="str6">Выделить из строки URL параметры и записать их как ключ и значение в структуру</h3>
    <p>В функцию передаётся строка с адресом, полная или обрезанная это строка будет, без разницы.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Функция РазбитьНаПараметры(СтрокаРесурса)
                НомерВопроса = СтрНайти(СтрокаРесурса, "?");
                ПараметрыРесурса = Новый Структура;

                Если НомерВопроса = 0 Тогда
                    Возврат ПараметрыРесурса;	
                КонецЕсли; 
                ДлинаСтроки = СтрДлина(СтрокаРесурса);
                СтрокаПараметров = Прав(СтрокаРесурса, ДлинаСтроки - НомерВопроса);
                МассивСтрокПараметров = СтрРазделить(СтрокаПараметров,"&", Ложь);

                Для каждого ЭлементМассива Из МассивСтрокПараметров Цикл
                    ВремМассив = СтрРазделить(ЭлементМассива,"=", Ложь);
                    ПараметрыРесурса.Вставить(ВремМассив[0], ВремМассив[1]);	
                КонецЦикла; 

                Возврат ПараметрыРесурса;		
            КонецФункции
        </pre>
    </div>












    
    <h3 class="header-style2" id="date1">Разность двух дат представьте в виде количества часов, минут и секунд. Например, "3 ч. 29 мин. 40 с."</h3>
    <div class="code-style">
        <pre>
            <span class="vue-b">Процедура ПриНачалеРаботыСистемы()
                Дата1 = '20230427220000';
                Дата2 = '20230427164512';   
                
                РезультатВычитания = Дата1 - Дата2;    
                
                <span class="vue-g">//получил часы</span>
                ОстатокЧасов = Цел(РезультатВычитания / 3600);

                <span class="vue-g">//вычел из общего числа секунд полученные часы</span>
                РезультатВычитания = РезультатВычитания - (ОстатокЧасов * 3600);

                <span class="vue-g">//получил минуты</span>
                ОстатокМинут = Цел(РезультатВычитания / 60);

                <span class="vue-g">//вычел из общего числа минуты</span>
                РезультатВычитания = РезультатВычитания - (ОстатокМинут * 60);

                <span class="vue-g">//получил секунды</span>
                ОстатокСекунд = РезультатВычитания;

                <span class="vue-g">//составил строку из переменных</span>
                РазницаМеждуДатами = "" + ОстатокЧасов + "ч. " + ОстатокМинут + "мин. " + ОстатокСекунд + "сек.";

                Сообщить(РазницаМеждуДатами);
            КонецПроцедуры</span>
        </pre>
    </div>



    <h3 class="header-style2" id="date2">В одной переменной сохраните произвольную дату. В другой переменной вычислите девять утра для произвольной даты.</h3>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                ПроизвольнаяДата = '20230426140000';

                УтроОтПроизвольнойДаты = КонецДня(ПроизвольнаяДата) + (9 * 60 * 60) + 1;

                Сообщить(УтроОтПроизвольнойДаты);	
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="date3">В одной переменной сохраните произвольную дату. В другой переменной вычислите начало следующего понедельника для произвольной даты.</h3>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                ПроизвольнаяДата = '20230426140000';

                КонецНеделиОтПроизвольнойДаты = КонецНедели(ПроизвольнаяДата) + 1;

                Сообщить(КонецНеделиОтПроизвольнойДаты);	
            КонецПроцедуры
        </pre>
    </div>

    <h3 class="header-style2" id="date4">Получить тестовое представление месяца и года из даты</h3>
    <p>Для такого представления можно воспользоваться методом ПредставлениеПериода(). Такой метод можно посмотреть в помошнике: Глобальный контекст - Функции форматирования.</p>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                ТекДата = ТекущаяДата();
                НачДата = НачалоМесяца(ТекДата);
                КонДата = КонецМесяца(ТекДата);
                ПредставлениеМесяца = "" + ПредставлениеПериода(НачДата, КонДата, "ФП = Истина"); 
                
                НачДата = НачалоГода(ТекДата);
                КонДата = КонецГода(ТекДата);
                ПредставлениеГода =  "" + ПредставлениеПериода(НачДата, КонДата, "ФП = Истина");

                Сообщить(ПредставлениеМесяца);// Апрель 2023г.
                Сообщить(ПредставлениеГода); // 2023г.
            КонецПроцедуры
        </pre>
    </div>












    <h3 class="header-style2" id="shifr1">Наша программа создаёт текстовый файл, пишет в него строку, потом получает эту строку из файла и шифрует строку</h3>
    <p>1. Шифровать будем по методу Атбаша. Это самый простой шифр, суть его в том, что мы берём русскую азбуку, записываем её в переменную в виде строки и создаём 2ю переменную, в которую записываем тоже русскую азбуку, только задом наперёд. И теперь букве "а" будет соответствовать буква "я", букве "б" соответствует буква "ю" и т.д. Ну и далее алгоритм прост, проходим по строке в цикле и получаем каждый раз символ из строки, находим такой символ в русской азбуке, смотрим его позицию и по этой позиции берём букву из перевёрнутой азбуки и строим новой зашифрованную строку.</p>
    <div class="code-style">
        <pre>
            Функция ШифрованиеТекста(Текст, ПравильнаяАзбука, ПеревернутаяАзбука)
                ЗашифрованныйТекст = "";
                Текст = НРег(Текст);
                
                Для Шаг = 1 По СтрДлина(Текст) Цикл
                    СимволИзТекста =  Сред(Текст, Шаг, 1);
                    ПозСимволаВПравАзбуке = СтрНайти(ПравильнаяАзбука, СимволИзТекста);

                    Если ПозСимволаВПравАзбуке &lt;> 0 Тогда
                        СимволИзПеревАзбуки =  Сред(ПеревернутаяАзбука, ПозСимволаВПравАзбуке, 1);
                        ЗашифрованныйТекст = ЗашифрованныйТекст + СимволИзПеревАзбуки;
                    Иначе
                        ЗашифрованныйТекст = ЗашифрованныйТекст + СимволИзТекста;
                    КонецЕсли;
                КонецЦикла;
                
                Возврат ЗашифрованныйТекст;
            КонецФункции

            Документ = Новый ТекстовыйДокумент;
            Документ.УстановитьТекст("Привет мир2");
            Документ.Записать("c:\Пример.txt");

            ПравильнаяАзбука = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
            ПеревернутаяАзбука="яюэьыъщшчцхфутсрпонмлкйизжёедгвба";

            Документ.Прочитать("c:\Пример.txt");
            Текст = Документ.ПолучитьТекст();

            ЗашифТекст = ШифрованиеТекста(Текст, ПравильнаяАзбука, ПеревернутаяАзбука);
            Сообщить(ЗашифТекст);
        </pre>
    </div>
    <p>2. Вот 2й способ зашифровать ту же строку из файла. алгоритм тут такой, получаем код символа прибавляем 5 к этому коду и обратно получаем символ из получившегося кода и записываем в новую строку.</p>
    <div class="code-style">
        <pre>
            Функция ШифрованиеТекста(Текст)
                ЗашифрованныйТекст = "";
                
                Для Шаг = 1 По СтрДлина(Текст) Цикл
                    КодСимвола = КодСимвола(Текст, Шаг);
                    КодСимвола = КодСимвола + 5;
                    Символ = Символ(КодСимвола);
                    ЗашифрованныйТекст = ЗашифрованныйТекст + Символ;
                КонецЦикла;
                
                Возврат ЗашифрованныйТекст;
            КонецФункции 

            Документ = Новый ТекстовыйДокумент;
            Документ.УстановитьТекст("Привет мир");
            Документ.Записать("c:\Пример.txt");
            Документ.Прочитать("c:\Пример.txt");
            Текст = Документ.ПолучитьТекст();

            ЗашифТекст = ШифрованиеТекста(Текст);
            Сообщить(ЗашифТекст);

            Документ.УстановитьТекст(ЗашифТекст);
            Документ.Записать("c:\out.txt");

        </pre>
    </div>

    <p>Ну и тут же запишем программу, которая расшифровывает текст и записывает его в новый файл "результат.txt", содержимое этого файла должно совпадать с файлом "Пример.txt". В алгоритме всё тоже самое, только отнимаем опять 5 от кода.</p>
    <div class="code-style">
        <pre>
            Функция РашифровкаТекста(Текст)
                РасшифрованныйТекст = ""; 	
                Для Шаг = 1 По СтрДлина(Текст) Цикл
                    КодСимвола = КодСимвола(Текст, Шаг);
                    КодСимвола = КодСимвола - 5;
                    Символ = Символ(КодСимвола);
                    РасшифрованныйТекст = РасшифрованныйТекст + Символ;
                КонецЦикла;
                
                Возврат РасшифрованныйТекст;
            КонецФункции

            Документ = Новый ТекстовыйДокумент;
            Документ.Прочитать("c:\out.txt");
            Текст = Документ.ПолучитьТекст();

            РасшифТекст = РашифровкаТекста(Текст);
            Сообщить(РасшифТекст);

            Документ.УстановитьТекст(РасшифТекст);
            Документ.Записать("c:\Результат.txt");
        </pre>
    </div>
    <p>Делать расшифровку по первому примеру уже не стану, думаю там и так разберусь.</p>












    <h3 class="header-style" id="shifr2">Создание паролей по заданной длине и кол-ву паролей</h3>
    <p>В 2х переменных задаём сколько нам надо паролей и их длину, запускаем функцию которая их создаёт.</p>
    <div class="code-style">
        <pre>
            Функция СозданиеПаролей(СДП, КП, ДП)
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                МассивПаролей = новый Массив;
                СтрокаПароль = "";

                Для Шаг = 1 По КП Цикл
                    Для Шаг2 = 1 По ДП Цикл
                        СлучайноеЧисло = ГСЧ.СлучайноеЧисло(1, СтрДлина(СДП));
                        Символ = Сред(СДП, СлучайноеЧисло, 1);
                        СтрокаПароль = СтрокаПароль + Символ;
                        Если Шаг2 = ДП Тогда
                            МассивПаролей.Добавить(СтрокаПароль);
                            СтрокаПароль = "";
                        КонецЕсли;
                    КонецЦикла;
                КонецЦикла;
                Возврат МассивПаролей;	
            КонецФункции

            СимволыДляПароля = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";
            КоличествоПаролей  = 6;
            ДлинаПаролей = 12;

            МП = СозданиеПаролей(СимволыДляПароля, КоличествоПаролей, ДлинаПаролей);
            ОткрытьЗначение(МП);
        </pre>
    </div>










    <h3 class="header-style" id="shifr3">Вывод чисел Фибоначи через рекурсию</h3>
    <p>Числа Фибоначи это начальные числа 0 и 1 и последующие числа это сумма 2х предыдущих: 0,1,1,2,3,5,8,13,21,34,55....</p>
    <div class="code-style">
        <pre>
            Процедура ВычислитьЧислаФибоначи(А = 0, Б = 1) 
                Если А = 0 Тогда
                    Сообщить(А);
                    Сообщить(Б);
                Иначе
                    Сообщить(Б);	
                КонецЕсли;
                
                С = А + Б;
                
                Если С > 1000 Тогда
                    Возврат;
                Иначе
                    Нажать(Б,С);
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>











    <h3 class="header-style" id="processing1">Заполнить реквизит у документов, в табличной части которых есть выбранный товар.</h3>
    <p>Обработка находится в конфигурации Камкова - Основные Объекты. Обработка называется ИзменениеДокументовПоступления2.
    Также решение подобные есть и в обработке ИзменениеДокументовПоступления.
    </p>
    <div class="code-style">
        <pre>
            //есть в обработке реквизит ВыбратьТовар, в нём выбираем товар. Теперь когда мы запустим
            //эту обработку по кнопке "Изменить" то в реквизит Сообщение документов "ПоступленияТоваров"
            //запишется какое то значение, но только в те документы, в табличной
            //части которых есть такой товар  
            &НаКлиенте
            Процедура Изменить(Команда)
                ИзменитьНаСервере(ВыбратьТовар);
            КонецПроцедуры

            &НаСервереБезКонтекста
            Процедура ИзменитьНаСервере(ВыбратьТовар) 
                Выборка = Документы.ПоступлениеТоваров.Выбрать(); 
                Пока Выборка.Следующий() Цикл
                    Для каждого Строка Из Выборка.Товары Цикл
                        Если Строка.Товар = ВыбратьТовар Тогда
                            ДокументОбъект = Выборка.ПолучитьОбъект();
                            ДокументОбъект.Сообщение = 123;
                            ДокументОбъект.Записать();
                        КонецЕсли;
                    КонецЦикла;	
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style" id="processing2">Программно обработка изменяет регистр сведений КурсыВалют</h3>
    <p>Допустим у нас есть Справочник Валюты, где перечисляются названия заграничных денег. И есть регистр сведений, где мы храним курсы и кратности этих денег во времени(переодический). Нам нужно как то читать и писать в этот регистр.Мы можем писать в него из пользовательской части, можем писать с помощью документа, а бывает нужно писать в него программно, например, из обработки, чтобы загрузить из инета курсы валют и записать в регистр. Создадим обработку, добавим в неё кнопку и по кнопке будем писать в регистр. Код находится в модуле формы обработки.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//эти 2 процедуры обработчики кнопки ЗаписатьКурс</span>
            <span class="vue-b"><b>&НаКлиенте
            Процедура ЗаписатьКурс(Команда)
                ЗаписатьКурсНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ЗаписатьКурсНаСервере()
                <span class="vue-g">//НаборЗаписей теперь содержит некую коллекцию, которая содержит описание каждой записи регистра</span>
                НаборЗаписей = РегистрыСведений.КурсыВалют.СоздатьНаборЗаписей();

                <span class="vue-g">//метод Добавить() создаёт запись в этом наборе и возвращает ссылку на эту запись</span>
                Запись = НаборЗаписей.Добавить();

                <span class="vue-g">//заполняем запись</span>
                Запись.Период = Период;
                Запись.Валюта = Валюта;	
                Запись.Курс = Курс;
                Запись.Кратность = Кратность;

                <span class="vue-g">//даём команду записать запись в БД. У метода Записать() по умолчанию стоит</span>
                <span class="vue-g">//булево значение Истина(Замещать), т.е. при добавлении записи мы замещаем предыдущую запись</span>
                <span class="vue-g">//а нам надо добавлять, поэтому ставим Ложь</span>
                НаборЗаписей.Записать(Ложь);
            КонецПроцедуры</b></span>
        </pre>
    </div>











    <h3 class="header-style">Про таблицы значений</h3>
    <h3 class="header-style2" id="table-value">Нужно распределить 40рублей по сумме товаров пропорционально их количество</h3>
    <p><b>1й способ</b></p>
    <p>Есть вот такая таблица значений:</p>
    <table border="1" style="margin-top: 0px;margin-bottom: 40px">
        <tr>
            <td>Товар</td>
            <td>Количество</td>
            <td>Сумма</td>
        </tr>
        <tr>
            <td>Товар1</td>
            <td>1</td>
            <td>150</td>
        </tr>
        <tr>
            <td>Товар2</td>
            <td>2</td>
            <td>170</td>
        </tr>
        <tr>
            <td>Товар3</td>
            <td>3</td>
            <td>180</td>
        </tr>
    </table>
    <p>Нам дано 40руб. и их нужно программно распределить по суммам всех товаров учитывая пропорции количества до рубля, т.е. без дробных частей. Первое, определяем сколько уйдёт рублей на один товар, для этого нужно 40 разделить на количество всех товаров. Получится 6.7р., округлённое до 1 знака после запятой, уйдёт в сумму на один товар. Ну а дальше нужно прибавить это число к сумме умножая на количество товаров.</p>
    <p>Программно мы это оформим через показ в общей произвольной форме при начале работы системы:</p>
    <div class="code-style">
        <pre>

            --модуль приложения
            <span class="vue-r">Процедура</span> ПриНачалеРаботыСистемы()
                ОткрытьФорму("ОбщаяФорма.ФормаВыводаТЗ");		
            <span class="vue-r">КонецПроцедуры</span>



            --модуль общей произвольной формы "ФормаВыводаТЗ"
            <span class="vue-r">&НаСервере
            Процедура</span> ПриСозданииНаСервере(Отказ, СтандартнаяОбработка) 
                <span class="vue-g">//ТабЗнач это реквизит формы с типом "ТаблицаЗначений"

                //добавляем строки</span>
                НоваяСтрока = ТабЗнач.Добавить();
                НоваяСтрока.Товар = "Товар1";	
                НоваяСтрока.Количество = 1;	
                НоваяСтрока.Сумма = 150;

                НоваяСтрока = ТабЗнач.Добавить();
                НоваяСтрока.Товар = "Товар2";	
                НоваяСтрока.Количество = 2;	
                НоваяСтрока.Сумма = 170;

                НоваяСтрока = ТабЗнач.Добавить();
                НоваяСтрока.Товар = "Товар3";	
                НоваяСтрока.Количество = 3;	
                НоваяСтрока.Сумма = 180;
                

                РаспределяемыеРубли = 40;

                <span class="vue-g">//подсчитаем общее количество товаров</span>
                ОбщееКоличествоТоваров = 0;
                Для каждого СтрокаТЗ Из ТабЗнач Цикл
                    ОбщееКоличествоТоваров = ОбщееКоличествоТоваров + СтрокаТЗ.Количество;
                КонецЦикла;	 
                <span class="vue-g">//или тоже самое через метод Итог
                //ОбщееКоличествоТоваров = ТабЗнач.Итог("Количество");</span>

                <span class="vue-g">//высчитываем сколько рубоей на одит товар выходит. Округляем до 1 знака после запятой</span>
                РаспределённыеРублиНаОдинТовар = Окр(РаспределяемыеРубли / ОбщееКоличествоТоваров, 1); 

                <span class="vue-g">//прибавляем к суммам распределяемые 40 рублей. Тут уже округляем до 0 знаков, чтобы выйти на бездробные числа
                //Округление и там и тут производим как стоит по умолчанию: 1.5 -> 2.0, 1.4 -> 1.0</span>
                Для каждого СтрокаТЗ Из ТабЗнач Цикл
                    СтрокаТЗ.Сумма = Окр(СтрокаТЗ.Сумма + (РаспределённыеРублиНаОдинТовар * СтрокаТЗ.Количество),0);
                КонецЦикла;
            <span class="vue-r">КонецПроцедуры</span>
        </pre>
    </div>
    <p><b>2й способ</b></p>
    <p>Во втором способе разница будет лишь в нахождении коэффициента, чтобы потом этот коэффициент умножить на 40. Нам также понадобится общее количество товара - это 6. Затем количество каждого товара нужно разделить на общее количество(6) и получим коэффициенты для каждого количества товара. Например, коэффициент для первого товара 1 / 6 = 0.1666666666667 и тпк далее:</p>
    <table border="1" style="margin-top: 0px;margin-bottom: 40px;font-size: 9px;">
        <tr>
            <td>Товар</td>
            <td>Количество</td>
            <td>Сумма</td>
            <td>Коэффициент</td>
            <td>Вычисление</td>
            <td>Итоговая сумма</td>
        </tr>
        <tr>
            <td>Товар1</td>
            <td>1</td>
            <td>150</td>
            <td>1 / 6 = 0.1666666666667</td>
            <td>0.1666666666667 * 40 = 6.7</td>
            <td>7 + 150 = 157</td>
        </tr>
        <tr>
            <td>Товар2</td>
            <td>2</td>
            <td>170</td>
            <td>2 / 6 = 0.3333333333333333</td>
            <td>0.3333333333333333 * 40 = 13.3</td>
            <td>13 + 170 = 183</td>
        </tr>
        <tr>
            <td>Товар3</td>
            <td>3</td>
            <td>180</td>
            <td>3 / 6 = 0.5</td>
            <td>0.5 * 40 = 20</td>
            <td>20 + 180 = 200</td>
        </tr>
    </table>
    <p>Если что делал по этому видео, там ещё автор показал как сделать, если точно не выходит до целого рубля - https://www.youtube.com/watch?v=Yra6Shxej70</p>



</div>
