<div class="wrap">
   
    <h2 class="header-style">Примеры</h2>

    <ul class="list">
        <li><a href="#arr-azbuka">Масиив с азбукой русских маленьких букв</a></li>
        <li><a href="#define-num">Определить является ли строка числом</a></li>
        <li><b>Работа с массивом</b></li>
        <li><a href="#arr0">Найти наибольшее число из строки</a></li>
        <li><a href="#arr1">Создать случайные числа и добавить их в массив и найти потом наибольшее и наименьшее</a></li>
        <li><a href="#arr2">Сортировка массива от меньшего к большему(метод пузырька) - [4, 2, 5] -> [2, 4, 5]</a></li>
        <li><a href="#arr3">Сортировка массива от большего к меньшему - [2, 5, 1] -> [5, 2, 1]</a></li>
        <li><a href="#arr4">Перемешивание массива - [1, 2, 5] -> [2, 1, 5]</a></li>
        <li><a href="#arr5">Находим факториал числа</a></li>
        <li><a href="#arr6">Найти простые числа среди введённых пользователем естественных (натуральных) чисел</a></li>
        <li><a href="#arr7">Разворачиваем элементы массива в обратную сторону - [1, 2, 3] -> [3, 2, 1]</a></li>
        <li><a href="#arr8">Сортируем в массиве только нечётные числа по возрастанию  - [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] -> [1, 8, 3, 6, 5, 4, 7, 2, 9, 0]</a></li>
        <li><a href="#arr9">Находим наибольшую длину полиндрома из поступивших начертаний</a></li>

        <li><b>Работа со строками</b></li>
        <li><a href="#str1">Разбиваем слово на буквы в массив - "слово" -> ["с", "л", "о", "в", "о"]</a></li>
        <li><a href="#str2">Проверяем является ли введёное слово палиндромом</a></li>
        <li><a href="#str3">Считаем в ведённой пользователем строке кол-во слов, пробелов, знаков препинания</a></li>
        <li><a href="#str4">Пользователь вводит строку, нужно выделить все слова из строки и отсортировать их в порядке возрастания длин этих слов.</a></li>
        <li><a href="#str5">Найти в тексте букву повторяющуюся больше всех.</a></li>
        <li><a href="#str5-a">Вывести количества всех букв из предложения.</a></li>
        <li><a href="#str6">Выделить из строки URL параметры и записать их как ключ и значение в структуру.</a></li>
        <li><a href="#str7">Определить, одинаковые ли цветом шахматные поля</a></li>

        <li><b>Работа с числами</b></li>
        <li><a href="#int1">Написать программу определяющую цифру десятков и единиц в духзначном числе</a></li>

        <li><b>Про дату</b></li>
        <li><a href="#date1">Разность двух дат представьте в виде количества часов, минут и секунд. Например, "3 ч. 29 мин. 40 с."</a></li>
        <li><a href="#date2">В одной переменной сохраните произвольную дату. В другой переменной вычис-лите девять утра для произвольной даты.</a></li>
        <li><a href="#date3">В одной переменной сохраните произвольную дату. В другой переменной вычис-лите начало следующего понедельника для произвольной даты.</a></li>

        <li><b>Шифры и пароли</b></li>
        <li><a href="#shifr1">Наша программа создаёт текстовый файл, пишет в него строку, потом получает эту строку из файла и шифрует строку</a></li>
        <li><a href="#shifr2">Создание паролей по заданной длине и кол-ву паролей</a></li>
        <li><a href="#shifr3">Вывод чисел Фибоначи через рекурсию</a></li>

        <li><b>Обработки</b></li>
        <li><a href="#processing1">Заполнить реквизит у документов, в табличной части которых есть выбранный товар.</a></li>
        <li><a href="#processing2">Программно обработка изменяет регистр сведений КурсыВалют.</a></li>

        <li><b>ТаблицаЗначений</b></li>
        <li><a href="#table-value">Нужно распределить 40рублей по сумме товаров пропорционально их количество</a></li>
        <li><a href="#"></a></li>

        <li><b>Поиск ошибок и неоптимальностей в коде</b></li>
        <li><a href="#err-1">Пример 1 (задача с собеседования)</a></li>
        <li><a href="#err-2"></a></li>
    </ul>



    <h2 class="header-style">Работа с масивом</h2>
    <h3 class="header-style2" id="arr-azbuka">Масив с азбукой русских маленьких букв</h3>
    <div class="code-style">
        <pre>
            МассивБукв = ["а", "б", "в", "г", "д", "е", "ё", "ж", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "ч", "ш", "щ", "ъ", "ы", "ь", "э", "ю", "я"];
            
            //буква "а" имеет код - 1072, буква "я" - 1103. Массив можно задать и в цикле через увеличение кода, но тогда буквы "ё" не будет.
            
            //для 1с
            МассивБукв = Новый Массив;
            МассивБукв.Добавить("а"); 
            МассивБукв.Добавить("б"); 
            МассивБукв.Добавить("в"); 
            МассивБукв.Добавить("г"); 
            МассивБукв.Добавить("д"); 
            МассивБукв.Добавить("е"); 
            МассивБукв.Добавить("ё"); 
            МассивБукв.Добавить("ж"); 
            МассивБукв.Добавить("з"); 
            МассивБукв.Добавить("и"); 
            МассивБукв.Добавить("й"); 
            МассивБукв.Добавить("к"); 
            МассивБукв.Добавить("л"); 
            МассивБукв.Добавить("м"); 
            МассивБукв.Добавить("н"); 
            МассивБукв.Добавить("о"); 
            МассивБукв.Добавить("п"); 
            МассивБукв.Добавить("р"); 
            МассивБукв.Добавить("с"); 
            МассивБукв.Добавить("т"); 
            МассивБукв.Добавить("у"); 
            МассивБукв.Добавить("ф"); 
            МассивБукв.Добавить("х"); 
            МассивБукв.Добавить("ц"); 
            МассивБукв.Добавить("ч"); 
            МассивБукв.Добавить("ш"); 
            МассивБукв.Добавить("щ"); 
            МассивБукв.Добавить("ъ"); 
            МассивБукв.Добавить("ы"); 
            МассивБукв.Добавить("ь"); 
            МассивБукв.Добавить("э"); 
            МассивБукв.Добавить("ю"); 
            МассивБукв.Добавить("я"); 
        </pre>
    </div>

    <h3 class="header-style2" id="define-num">Определить является ли строка числом</h3>
    <div class="code-style">
        <pre>
            Функция ЯвляетсяЧислом(Значение) Экспорт
                Если ТипЗнч(Значение) = Тип("Число") Тогда
                    Возврат Истина
                Иначе
                    Если ТипЗнч(Значение) = Тип("Строка") Тогда
                        Если Значение = "" Тогда
                            Возврат Ложь;
                        КонецЕсли;
                    КонецЕсли;

                    Попытка
                        Р = Число(Значение);
                        //или
                        Р = 0 + Значение;
                    Исключение
                        Возврат Ложь;
                    КонецПопытки;
                        
                    Возврат Истина;
                КонецЕсли;
            КонецФункции
        </pre>
    </div>

    <h3 class="header-style2" id="arr0">Найти наибольшее число из строки</h3>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)
                ВходСтрока = "234ор993выа3вк33ыва453выа4о44ыва9321цыуавыв99ы";     
                
                МассивЧисел = Новый Массив;
                СтрокаЧисла = "";
                Для Шаг = 1 По СтрДлина(ВходСтрока) Цикл 
                    ЧислоИзСтроки = "";
                    Знак = Сред(ВходСтрока, Шаг, 1);  
                    
                    Попытка
                    ЧислоИзСтроки = Число(Знак);
                    Исключение
                    
                    КонецПопытки;
                    Если ТипЗнч(ЧислоИзСтроки) = Тип("Число") Тогда
                        СтрокаЧисла = СтрокаЧисла + Знак;
                    Иначе
                        Если СтрокаЧисла = "" Тогда
                            Продолжить;
                        КонецЕсли;
                        МассивЧисел.Добавить(Число(СтрокаЧисла));
                        СтрокаЧисла = "";
                    КонецЕсли;	
                КонецЦикла; 
                
                МаксЧисло = НаибольшееЧисло(МассивЧисел);   
                Сообщить(МаксЧисло); 
            КонецПроцедуры           

            Функция НаибольшееЧисло(МассивЧисел)
                МаксЧисло = 1;
                Для каждого Элемент Из МассивЧисел Цикл
                    
                    Если МаксЧисло &lt; Элемент Тогда
                        МаксЧисло = Элемент;
                    КонецЕсли;
                КонецЦикла;	
                
                Возврат МаксЧисло;
            КонецФункции
        </pre>
    </div>

    <h3 class="header-style2" id="arr1">Создать случайные числа и добавить их в массив и найти потом наибольшее и наименьшее</h3>
    <div class="code-style">
        <pre>
            <span class="светло_синий">Процедура ПередНачаломРаботыСистемы(Отказ)
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                
                МассивЧисел = Новый Массив;

                Для Шаг = 1 По 10 Цикл
                    СЧ = ГСЧ.СлучайноеЧисло(1, 100);
                    МассивЧисел.Добавить(СЧ);
                КонецЦикла;

                МинЧисло = 100;
                МаксЧисло = 1;
                Для каждого Элемент Из МассивЧисел Цикл
                    Если МинЧисло > Элемент Тогда
                        МинЧисло = Элемент;
                    КонецЕсли;
                    
                    Если МаксЧисло &lt; Элемент Тогда
                        МаксЧисло = Элемент;
                    КонецЕсли;
                КонецЦикла;

                СтруктураПромежутка = Новый Структура(<span class="серый">"МинЧисло, МаксЧисло"</span>, МинЧисло, МаксЧисло);

                <span class="зелёный">//вызываем процедуру из общего модуля, которая выведет на экран массив с 
                //числами и после закрытия окна выводятся сообщения с наименьшим и наибольшим
                //числом</span>
                ОбщегоНазначения.ПоказатьДанные(СтруктураПромежутка, МассивЧисел);

            КонецПроцедуры </span>


            --общий модуль "ОбщегоНазначения"
            <span class="светло_синий">Процедура ПоказатьДанные(СтруктураПромежутка, МассивЧисел) Экспорт
                Оповещение = Новый ОписаниеОповещения(<span class="серый">"ПриЗакрытииПоказа"</span>, ЭтотОбъект, СтруктураПромежутка);
                ПоказатьЗначение(Оповещение, МассивЧисел);
            КонецПроцедуры


            Процедура ПриЗакрытииПоказа(СтруктураПромежутка) Экспорт
                Сообщить(СтруктураПромежутка.МинЧисло);
                Сообщить(СтруктураПромежутка.МаксЧисло);
            КонецПроцедуры</span>
        </pre>
    </div>


    <h3 class="header-style2" id="arr2">Сортировка массива от меньшего к большему(метод пузырька). [2,6,1] => [1,2,6]</h3>
    <div class="code-style">
        <pre>
            МассивЧисел = Новый Массив();
            ГСЧ = Новый ГенераторСлучайныхЧисел;
            КоличествоЧиселВМассиве = 10;

            Для Шаг = 0 По КоличествоЧиселВМассиве Цикл
                СлучайноеЧисло = ГСЧ.СлучайноеЧисло(0, 1000);
                МассивЧисел.Добавить(СлучайноеЧисло);
            КонецЦикла;
            
            
            Шаг1 = 0;
            Шаг2 = шаг1;

            Пока Шаг1 &lt; МассивЧисел.Количество() Цикл
                Число1 = МассивЧисел[Шаг1];

                Пока Шаг2 &lt; МассивЧисел.Количество() Цикл
                    Число2 = МассивЧисел[Шаг2];
                
                    Если Число1 > Число2 Тогда
                        МассивЧисел.Установить(Шаг1, Число2);
                        МассивЧисел.Установить(Шаг2, Число1);
                        Шаг1 = Шаг1 - 1;
                        Прервать;
                    КонецЕсли;
                    Шаг2 = Шаг2 + 1;
                
                КонецЦикла;
                Шаг1 = Шаг1 + 1;
                Шаг2 = Шаг1;

            КонецЦикла;  

            ОткрытьЗначение(МассивЧисел);
        </pre>
    </div>
    <p>Спустя время это моё другое решение:</p>
    <div class="code-style">
        <pre>
            --модуль приложения
            Процедура ПередНачаломРаботыСистемы(Отказ)
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                
                МассивЧисел = Новый Массив;

                Для Шаг = 1 По 10 Цикл
                    СЧ = ГСЧ.СлучайноеЧисло(1, 100);
                    МассивЧисел.Добавить(СЧ);
                КонецЦикла;

                Для Шаг = 0 По МассивЧисел.Количество() - 1 Цикл
                    Для Шаг2 = Шаг + 1 По МассивЧисел.Количество() -1 Цикл
                        Если МассивЧисел[Шаг] > МассивЧисел[Шаг2] Тогда
                            Временная = МассивЧисел[Шаг];
                            МассивЧисел.Установить(Шаг, МассивЧисел[Шаг2]);
                            МассивЧисел.Установить(Шаг2, Временная);
                        КонецЕсли;
                    КонецЦикла;
                КонецЦикла;

                ОбщегоНазначения.ПоказатьДанные(, МассивЧисел);
            КонецПроцедуры 


            --общий модуль "ОбщегоНазначения"
            Процедура ПоказатьДанные(СтруктураПромежутка = Неопределено, МассивЧисел) Экспорт
                Оповещение = Новый ОписаниеОповещения("ПриЗакрытииПоказа", ЭтотОбъект, СтруктураПромежутка);
                ПоказатьЗначение(, МассивЧисел);
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="arr3">Сортировка массива от большего к меньшему</h3>
    <p>Тут всё тоже самое что и в примере выше, только меняем знак > на &lt; во втором цикле в проверке Если Число1 > Число2 Тогда</p>


    <h3 class="header-style2" id="arr4">Перемешивание массива</h3>
    <div class="code-style">
        <pre>
            Процедура ПеремешиваниеМассива(М)	
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                Шаг = М.Количество() - 1;
                Пока Шаг >= 0 Цикл			
                    СЧ = ГСЧ.СлучайноеЧисло(0, Шаг);
                    СохрЧисло = М[Шаг];
                    М[Шаг] = М[СЧ];
                    М[СЧ] = СохрЧисло;
                    Шаг = Шаг - 1;			
                КонецЦикла;
                открытьЗначение(М);
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="arr5">Находим факториал числа</h3>
    <p>Вычислить факториал числа очень просто. Для этого нужно перемножить все целые числа от 1 до заданного числа. Например, факториал числа 5 = 1 * 2 * 3 * 4 * 5.</p>
    <div class="code-style">
        <pre>
            ГСЧ = Новый ГенераторСлучайныхЧисел;
            СлучайноеЧисло = ГСЧ.СлучайноеЧисло(1, 15);

            ПроизведениеЧисел = 1;
            Для Шаг = 1 По СлучайноеЧисло Цикл
                ПроизведениеЧисел = ПроизведениеЧисел * Шаг;
            КонецЦикла;

            Сообщить("Факториал числа " + СлучайноеЧисло + " равен " + ПроизведениеЧисел);
        </pre>
    </div>


    <h3 class="header-style2" id="arr6">Найти простые числа среди введённых пользователем естественных чисел</h3>
    <p>Естесственные(натуральные) числа это те числа, которые возникают естесственным способом при счёте: 1, 2, 3, 4, 5, ... . Естесственное число называется простым, если оно оно делится без остатка ТОЛЬКО на 1 и на само себя. Например, 2 простое число, так как делится только на 1 и на само себя, 3 тоже простое, а вот 4 не простое, т.к. кроме того что делится на 1 и на само себя, ещё оно делится на 2 без остатка, 5 простое, 6 не простое(делится ещё на 2 и на 3).</p>
    <div class="code-style">
        <pre>
            Число = 0;
            ВвестиЧисло(Число);

            ПростоеЧисло = Истина;

            Для Шаг = 2 По Число - 1 Цикл
                Если Число % Шаг = 0 Тогда 
                    ПростоеЧисло = Ложь;
                    Прервать;
                КонецЕсли;
            КонецЦикла;

            Если ПростоеЧисло Тогда
                ОткрытьЗначение("Число " + Число + " является простым");
            Иначе	
                ОткрытьЗначение("Число " + Число + " не является простым");
            КонецЕсли;
        </pre>
    </div>


    <h3 class="header-style2" id="arr7">Разворачиваем элементы массива в обратную сторону</h3>
    <div class="code-style">
        <pre>
            Функция ПеревернутьМассив(Массив)
                Для Шаг = 0 По Цел(Массив.Количество()/2) - 1 Цикл
                    Эл = Массив[Шаг];
                    Массив[Шаг] = Массив[Массив.Количество() - 1 - Шаг];
                    Массив[Массив.Количество() - 1 - Шаг] = Эл;
                КонецЦикла;
                
                Возврат Массив;
            КонецФункции
        </pre>
    </div>


    <h3 class="header-style2" id="arr8">Сортируем в массиве только нечётные числа по возрастанию</h3>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)
                МассивЧисел = Новый Массив;
                МассивЧисел.Добавить(9);
                МассивЧисел.Добавить(8);
                МассивЧисел.Добавить(7);
                МассивЧисел.Добавить(6);
                МассивЧисел.Добавить(5);
                МассивЧисел.Добавить(4);
                МассивЧисел.Добавить(3);
                МассивЧисел.Добавить(2);
                МассивЧисел.Добавить(1);
                МассивЧисел.Добавить(0);

                УпорядМассивЧисел = Новый Массив;

                Для Шаг = 0 По МассивЧисел.Количество() - 1 Цикл
                    Если МассивЧисел[Шаг] % 2 = 0 Тогда
                        Продолжить;
                    КонецЕсли;
                    
                    Для Шаг2 = Шаг По МассивЧисел.Количество() - 1 Цикл                   
                        Если МассивЧисел[Шаг] > МассивЧисел[Шаг2] И МассивЧисел[Шаг2] % 2 <> 0 Тогда
                            Значение = МассивЧисел[Шаг];
                            МассивЧисел.Установить(Шаг, МассивЧисел[Шаг2]);
                            МассивЧисел.Установить(Шаг2, Значение);	
                        КонецЕсли;
                    КонецЦикла;
                КонецЦикла;

                ОткрытьЗначение(МассивЧисел);
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="arr9">Находим наибольшую длину полиндрома из поступивших начертаний</h3>
    <p>На вход поступает строка начертаний - "ыльуьмщмшс", нужно узнать наибольшую длину полиндрома, которую можно составить из этих начертаний. Всё что можно составить тут это полиндром вида "мь.ьм", по центру можно подставить любую букву, т.е. наибольшая длина это 5.  Или другой пример. На вход поступает такая строка с буквами - "оввосссь", всё что тут можно составить это - "овсссво", получается длина 7. Вот набор правил:</p>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)
                Набор = "оввосссьууууу";   
                
                МассивПовторений = Новый Массив;
                МассивБукв = Новый Массив;

                <span class="vue-g">//заполняем массив количествами повторений букв чётными и нечётными</span> 
                КолНачертаний = 0;
                А = 0;
                Для Шаг = 1 По СтрДлина(Набор) Цикл
                    Если МассивБукв.Найти(Сред(Набор, Шаг, 1)) = Неопределено Тогда 	
                        КолНачертаний = КолНачертаний + 1;
                        А = Шаг;
                        Для Шаг2 = А + 1 По СтрДлина(Набор) Цикл
                            Если Сред(Набор, Шаг, 1) = Сред(Набор, Шаг2, 1) Тогда
                                КолНачертаний = КолНачертаний + 1;           
                            КонецЕсли;    
                        КонецЦикла;
                        МассивПовторений.Добавить(КолНачертаний);
                        КолНачертаний = 0;
                        МассивБукв.Добавить(Сред(Набор, Шаг, 1));
                    КонецЕсли;
                КонецЦикла;  
                
                
                <span class="vue-g">//Записываем в длину полиндрома количество нечётных чисел.
                //При этом из каждого нечётного числа убираем единицу, чтобы осталось чётное
                //Почему вычитаем 1, потому что из сочетаний "ссс", "ууууу" попадут в 
                //полиндром чётные "сс" и "уууу" и только у одного из них в центр полиндрома
                //попадёт либо 3й "с", либо 5й "у"
                //т.е. из всех нечётных только одно нечётное попадёт полностью, а от
                //остальных нужно отнять 1.
                //Поэтому дальше мы сразу в переменную ДлинаПолиндрома присвоили эту 1
                //и значит мы тут сразу от всех нечётных вычитаем 1, так как она уже учтена будет дальше. </span>
                КоличествоНечётных = 0;
                Для каждого Элемент Из МассивПовторений Цикл
                    Если Элемент % 2 &lt;> 0  Тогда
                        КоличествоНечётных = КоличествоНечётных + (Элемент - 1);	
                    КонецЕсли;
                КонецЦикла;


                <span class="vue-g">//Записываем в длину полиндрома количество чётных 
                //В переменную ДлинаПалиндрома сразу присваиваем 1, это буква, которая будет стоять по середине палиндрома</span>
                ДлинаПолиндрома = 1;
                Для каждого Элемент Из МассивПовторений Цикл
                    Если Элемент % 2 = 0  Тогда
                        ДлинаПолиндрома = ДлинаПолиндрома + Элемент;
                    КонецЕсли;		
                КонецЦикла;  

                ДлинаПолиндрома = ДлинаПолиндрома + КоличествоНечётных;
                
                Сообщить("Наибольшая длина полиндрома равна " + ДлинаПолиндрома);
            КонецПроцедуры
        </pre>
    </div>














    <h2 class="header-style">Работа со строками</h2>
    <h3 class="header-style2" id="str1">Разбиваем слово на буквы в массив</h3>
    <p>В 1с не нашёл пока функцию, которая разбивает слово на буквы в массив. Есть такая функция - СтрРазделить(строка, разделитель);, но что то не пойму какой надо разделитель, чтобы разбить слово на буквы. В JS разделитель просто пустая строка '', а тут это не работает. Поэтому написал свою функцию, которая разбивает слово на буквы и возвращает этот массив.</p>
    <div class="code-style">
        <pre>
            Функция РазделитьСлово(Строка)
                МассивБукв = Новый Массив;
                Слово = НРег(Строка);

                //через цикл Для
                Для Шаг = 1 По СтрДлина(Слово) Цикл
                    Буква = Сред(Слово, Шаг, 1);
                    МассивБукв.Добавить(Буква);	
                КонецЦикла;

                //через цикл Пока
                Шаг = 1;
                Длина = СтрДлина(Слово);
                Пока Шаг &lt;= Длина Цикл
                    МассивБукв.Добавить(Сред(Слово, Шаг, 1));
                	  Шаг = Шаг + 1;
                КонецЦикла;
                
                Возврат МассивБукв;
            КонецФункции
            
            Слово = "Казак";
            МассивБукв = РазделитьСлово(Слово);
            //выводим пользователю в модальном диалоговом окне массив букв       
            ОткрытьЗначение(МассивБукв);  
        </pre>
    </div>


    <h3 class="header-style" id="str2">Проверяем является ли введёное слово палиндромом</h3>
    <p>Палиндром это каогда слово читается взад наперёд одинакого, например - шалаш, казак, потоп</p>
    <p>Блин не соранил код этой задачи. Ну там смысл такой, как решал я. Вверху уже есть готовые функции, которыми я пользовался. Получаем от пользователя строку-слово, разделяю это слово в массив по символам, затем переворачиваю элементы массива задом наперёд и соединяю массив в строку и сравниваю результат с изначальным словом, если совпадают, значит слово палиндром.</p>
    <p>В учебнике немного по другому было. Там сравнивали 1ю букву и последнию, если не совпадали, то сравнение прекращалось и так далее до середины.</p>


    <h3 class="header-style2" id="str3">Считаем в ведённой пользователем строке кол-во слов, пробелов, знаков препинания.</h3>
    <div class="code-style">
        <pre>
            Строка = "";
            ВвестиСтроку(Строка);
            
            ЗнакиПрепинания = "`~!@#$%^&*()-=_+\|[]{};:'"",.&lt;>/?";
            ЗнакПробела = " ";
            КоличествоПробелов = 0;
            КоличествоЗнаковПрепинания = 0;
            КоличествоСлов = 0;
            ЭтоСимвол = Истина;
            СобираемоеСлово = "";
            
            Для Шаг = 1 По СтрДлина(Строка) Цикл
                Символ = Сред(Строка, Шаг, 1);
                
                Если Символ = ЗнакПробела Тогда
                    КоличествоПробелов = КоличествоПробелов + 1;
                    ЭтоСимвол = Ложь;
                КонецЕсли;
                
                Если СтрНайти(ЗнакиПрепинания, Символ) &lt;> 0 Тогда
                    КоличествоЗнаковПрепинания = КоличествоЗнаковПрепинания + 1;	
                    ЭтоСимвол = Ложь;
                КонецЕсли;
                
                Если ЭтоСимвол Тогда
                    СобираемоеСлово = СобираемоеСлово + Символ;
                Иначе
                    Если СтрДлина(СобираемоеСлово) &lt;> 0 Тогда
                        КоличествоСлов = КоличествоСлов + 1;
                        СобираемоеСлово = "";      
                    КонецЕсли;
                    ЭтоСимвол = Истина;
                КонецЕсли;
            КонецЦикла;


            ОткрытьЗначение("Количество слов в строке " + КоличествоСлов);
            ОткрытьЗначение("Количество пробелов в строке " + КоличествоПробелов);
            ОткрытьЗначение("Количество знаков в строке " + КоличествоЗнаковПрепинания);
        </pre>
    </div>


    <h3 class="header-style" id="str4">Пользователь вводит строку, нужно выделить все слова из строки и отсортировать их в порядке возрастания длин этих слов.</h3>
    <div class="code-style">
        <pre>
            Функция СортировкаСлов(МассивСлов)
                Шаг1 = 0;
                Шаг2 = шаг1;

                Пока Шаг1 &lt; МассивСлов.Количество() Цикл
                    Число1 = СтрДлина(МассивСлов[Шаг1]);

                    Пока Шаг2 &lt; МассивСлов.Количество() Цикл
                        Число2 = СтрДлина(МассивСлов[Шаг2]);
                    
                        Если Число1 > Число2 Тогда
                            Память = МассивСлов[Шаг1];
                            МассивСлов.Установить(Шаг1, МассивСлов[Шаг2]);
                            МассивСлов.Установить(Шаг2, Память);
                            Шаг1 = Шаг1 - 1;
                            Прервать;
                        КонецЕсли;
                        Шаг2 = Шаг2 + 1;
                    
                    КонецЦикла;
                    Шаг1 = Шаг1 + 1;
                    Шаг2 = Шаг1;
                КонецЦикла;
                
                Возврат МассивСлов;
            КонецФункции



            ЗнакиПрепинания = "`~!@#$%^&*()-=_+\|[]{};:'"",.&lt;>/?";
            Строка = "";
            ВвестиСтроку(Строка);

            МассивСлов = Новый Массив;
            СобираемоеСлово = "";

            Для Шаг = 1 По СтрДлина(Строка) Цикл
                Символ = Сред(Строка, Шаг, 1);
            
                Если Символ &lt;> " " И СтрНайти(ЗнакиПрепинания, Символ) = 0 Тогда
                    СобираемоеСлово = СобираемоеСлово + Символ;
                Иначе
                    Если СтрДлина(СобираемоеСлово) &lt;> 0 Тогда
                        МассивСлов.Добавить(СобираемоеСлово);
                        СобираемоеСлово = "";      
                    КонецЕсли;
                КонецЕсли;

            КонецЦикла;

            ОтсортированныйМассивСлов = СортировкаСлов(МассивСлов);
            ОткрытьЗначение(ОтсортированныйМассивСлов);
        </pre>
    </div>


    <h3 class="header-style" id="str5">Найти в тексте букву повторяющуюся больше всех</h3>
    <p>На вход в программу подаётся текст, предложения в котором заканчиваются на точку. Нужно написать код, который найдёт в первом предложении самую частую букву и выведет её на экран с её количеством. Нужно искать букву только в первом предложении до точки, после точки уже не ищем. Например:</p>
    <p><b>"Я пошёл за хлебом в магазин. Завтра буду."</b></p>
    <p>Самая частая буква это "а", её 3 штуки в предложении. Если каких то букв будет несколько с одинаковым количеством, то в азбучном порядке вывести первую из них.</p>
    <div class="code-style">
        <pre>
            --моё первое решение

            <span class="vue-b">Процедура ПриНачалеРаботыСистемы()   
                Предложение = <span class="vue-bl">"Я пошёл за хлебом в магазин. Скоро буду."</span>;
                Предложение = СокрЛП(Предложение);
                
                КоличествоБукв = Новый Структура;
                НайденноеЗначение = Неопределено;
                
                <span class="vue-g">//здесь в структуру "КоличествоБукв" записываем
                //все буквы и их количество из предложения</span>
                Для Шаг = 1 По СтрДлина(Предложение) Цикл
                    Буква = Сред(Предложение, Шаг, 1); 
                        
                    Если Буква = " " Тогда
                        Продолжить;
                    КонецЕсли; 
                
                    Если Буква = "." Тогда
                        Прервать;
                    КонецЕсли;
                
                    КоличествоБукв.Свойство(Буква, НайденноеЗначение);
                    Если НайденноеЗначение = Неопределено Тогда
                        КоличествоБукв.Вставить(Буква, 1);
                    Иначе 
                        КоличествоБукв[Буква] = КоличествоБукв[Буква] + 1;
                        НайденноеЗначение = Неопределено;
                    КонецЕсли;	
                КонецЦикла;
                

                <span class="vue-g">//здесь вылавливаем из структуры "КоличествоБукв" те буквы/букву
                //которые имеют наибольшее количество
                //и записываем их в структуру "НужныеБуквы"</span>
                ПредыдущееЧисло = 0;
                НужныеБуквы = Новый Структура;
                Круг = Истина;
                Пока Круг  Цикл 
                    НаибольшееЧисло = 0;
                    НаибольшаяБуква = <span class="vue-bl">""</span>;

                    Для каждого КлючЗначение Из КоличествоБукв Цикл
                        Если КлючЗначение.Значение > НаибольшееЧисло Тогда		
                            НаибольшееЧисло = КлючЗначение.Значение;
                            НаибольшаяБуква = КлючЗначение.Ключ;	
                        КонецЕсли;
                    КонецЦикла;	
                    
                    Если (НужныеБуквы.Количество() = 0) ИЛИ (НужныеБуквы.Количество() > 0 И НаибольшееЧисло = ПредыдущееЧисло) Тогда
                        ПредыдущееЧисло = НаибольшееЧисло;
                        НужныеБуквы.Вставить(НаибольшаяБуква, НаибольшееЧисло);
                        КоличествоБукв.Удалить(НаибольшаяБуква);
                    Иначе
                        Круг = Ложь;
                    КонецЕсли;
                КонецЦикла;   
                        

                <span class="vue-g">//если у нас несколько букв, в структуре НужныеБуквы, с одинаковым
                //количеством, то выбираем ту букву, которая в азбуке стоит выше 
                //если нужно решить проблему с буквой "ё", то вот в этом уикле надо это делать</span> 
                НаименишийКод = 1105;
                Для каждого КлючЗначение Из НужныеБуквы Цикл 
                    КодБуквы = КодСимвола(НРег(КлючЗначение.Ключ), 1);	
                    Если КодБуквы &lt; НаименишийКод Тогда		
                        НаименишийКод = КодБуквы;	
                    КонецЕсли;
                КонецЦикла;

                <span class="vue-g">//найденную букву выводим на экран
                //в этой программе не решена проблема с буквой "ё"(1105), её код не входит в рамки 1072(а) - 1103(я)
                //а потому, если вдруг буква "ё" будет одна самой частой
                //то всё будет нормально, или если есть ещё буквы
                //с таким же количеством и они стоят выше "ё" по азбуке, то тоже всё будет нормально
                //проблемы начнутся, когда есть буквы с таким же количеством 
                //и они стоят ниже буквы "ё", тогда будут выводится эти буквы
                //хоть они и стоят ниже буквы "ё". Например если в структуре
                //2 буквы с одинаковым количеством "ё" - 5  и "я" - 5 , 
                //то выведет на экран "я", хотя "я" стоит ниже по азбуке
                //если прям будет большая нужна исправить это, то можно 
                //немного подшаманить код</span>        
                ЗначениеБуквы = Неопределено;
                НужныеБуквы.Свойство(Символ(НаименишийКод), ЗначениеБуквы);
                Сообщить(<span class="vue-bl">""</span> + Символ(НаименишийКод) + <span class="vue-bl">" "</span> + ЗначениеБуквы); 
            КонецПроцедуры</span>



            --второе моё решение через год
            
            <span class="vue-b">Процедура ПередНачаломРаботыСистемы(Отказ)  
                СлучайныйТекст = "Я пошёл за хлебом в магазин, буду через пару часов, как только, так сразу. Завтра буду.";

                <span class="vue-g">//Отсекаем другие предложения, оставляем только первое до точки</span>
                ПервоеПредложение = Лев(СлучайныйТекст, СтрНайти(СлучайныйТекст, ".") - 1);

                <span class="vue-g">//создаём структуру для хранения букв, которые имееют наибольшее повторение</span>
                СтруктураБукв = Новый Структура;

                ДлинаТекста = СтрДлина(ПервоеПредложение);
                НомерСтроки = 1;
                КоличествоБукв = 1;
                Пока НомерСтроки &lt;> ДлинаТекста + 1 Цикл 
                    <span class="vue-g">//получаем из предложения очередную букву и переводим в нижний регистр</span>
                    БукваСтроки = НРег(Сред(ПервоеПредложение, НомерСтроки, 1)); 
                
                    <span class="vue-g">//если в предложении встречаем пробел или запятую, то 
                    //пропускает круг цикла</span>
                    Если БукваСтроки = " " ИЛИ БукваСтроки = "," Тогда
                        НомерСтроки = НомерСтроки + 1;
                        Продолжить;
                    КонецЕсли;
                    
                    <span class="vue-g">//проверяем, добавляли ли мы ранее в структуру
                    //такую букву, если Да, то пропускаем круг цикла</span>
                    ЕстьТакаяБуква = СтруктураБукв.Свойство(БукваСтроки);	
                    Если ЕстьТакаяБуква Тогда
                        НомерСтроки = НомерСтроки + 1;
                        Продолжить;
                    КонецЕсли;
                    
                    <span class="vue-g">//во втором цикле мы проверяем букву из первого цикла со
                    //всеми буквами предложения, перебираемыми во втором цикле
                    //в первом решении мне больше нравится способ нахождения количества букв</span>
                    НомерСтроки2 = НомерСтроки + 1;
                    Пока НомерСтроки2 &lt;> ДлинаТекста + 1 Цикл
                        Если БукваСтроки = НРег(Сред(ПервоеПредложение, НомерСтроки2, 1)) Тогда
                            КоличествоБукв = КоличествоБукв + 1;
                            СтруктураБукв.Вставить(БукваСтроки, КоличествоБукв); 
                        КонецЕсли;
                        НомерСтроки2 = НомерСтроки2 + 1;
                    КонецЦикла;
                    НомерСтроки = НомерСтроки + 1;
                    КоличествоБукв = 1;
                КонецЦикла;

                <span class="vue-g">//вызываем функцию, которая вернёт структуру содержащую
                //все буквы, которые имеют наибольшее одинаковое количество</span>
                ВремСтруктура = НайтиНаибольшиеЧисла(СтруктураБукв);

                <span class="vue-g">//если букв несколько с одинаковым количеством, то эта функция
                //отберёт только одну букву в азбучном порядке</span>
                ИскомаяСтрока = ОтобратьСтаршуюБукву(ВремСтруктура);

                <span class="vue-g">//сообщаем о такакой букве</span>
                Сообщить(ИскомаяСтрока);	
            КонецПроцедуры
                    



            Функция НайтиНаибольшиеЧисла(СтруктураБукв)
                МассивБукв = Новый Массив;

                НаибольшееЧисло = 0;
                БукваНибольшегоЧисла = ""; 
                Счётчик = 0;
                Для каждого ЭлементСтрк Из СтруктураБукв Цикл 
                    Счётчик = Счётчик + 1;

                    Если Счётчик = 1 Тогда
                        НаибольшееЧисло = ЭлементСтрк.Значение;
                        БукваНибольшегоЧисла = ЭлементСтрк.Ключ;
                        Продолжить;
                    КонецЕсли;
                    
                    Если НаибольшееЧисло &lt; ЭлементСтрк.Значение Тогда
                        НаибольшееЧисло = ЭлементСтрк.Значение;
                        БукваНибольшегоЧисла = ЭлементСтрк.Ключ;	
                    КонецЕсли;		
                КонецЦикла;

                ВремСтруктура = Новый Структура;
                ВремСтруктура.Вставить(БукваНибольшегоЧисла, НаибольшееЧисло);    

                Для каждого КлючЗначение Из СтруктураБукв Цикл
                    Если КлючЗначение.Ключ = БукваНибольшегоЧисла Тогда
                        Продолжить;	
                    КонецЕсли;
                    
                    Если КлючЗначение.Значение = НаибольшееЧисло Тогда
                        ВремСтруктура.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
                    КонецЕсли;
                КонецЦикла;	

                Возврат ВремСтруктура;
            КонецФункции
                                                        

            Функция ОтобратьСтаршуюБукву(ВремСтруктура)
                НаименьшееЧисло = 0; 
                Счётчик = 1;
                Для каждого ЭлементСтрк Из ВремСтруктура Цикл 
                    Если Счётчик = 1 Тогда
                        НаименьшееЧисло = КодСимвола(ЭлементСтрк.Ключ);
                        Счётчик = Счётчик + 1;
                        Продолжить;
                    КонецЕсли;
                    
                    Если НаименьшееЧисло > КодСимвола(ЭлементСтрк.Ключ) Тогда
                        НаименьшееЧисло = КодСимвола(ЭлементСтрк.Ключ);	
                    КонецЕсли;		
                КонецЦикла;	
                
                ИскомаяСтрока = "" + Символ(НаименьшееЧисло) + " " + ВремСтруктура[Символ(НаименьшееЧисло)];

                Возврат ИскомаяСтрока; 
            КонецФункции </span>
        </pre>
    </div>
    <p>А вот другое решение, в котором мы используем язык запросов, чтобы сгруппировать и отсортировать результат. В общем модуле не стал дальше решать, потому что там повторяются действия, нужно будет выгрузить результат в таблицу значений, выбрать сверху коды символов с наибольшим количеством и вывести ту, которая по азбуке стоит выше. Также, чтобы можно было в запросе использовать список значений как параметр таблицу, нужно её поместить во временную таблицу, а потом выбирать из временной таблицы. Для написания программы использую схему Управляемое приложение -> Процедура из общего модулявыполняемая на сервере. Вот видео где решение этой задачи - https://www.youtube.com/watch?v=7mvPPNjeox8:</p>
    <div class="code-style">
        <pre>
            --модуль управляемого приложения
            <span class="vue-b">Процедура ПриНачалеРаботыСистемы()
                Предложение = НРег(СокрЛП(<span class="vue-bl">"Я пошёл за хлебом в магазин. Скоро буду."</span>));

                СписокЗначений = Новый СписокЗначений;

                <span class="vue-g">//тип значения нужно указать, чтобы язык запросов не ругался</span>
                СписокЗначений.ТипЗначения = Новый ОписаниеТипов("Число");

                Для Шаг = 1 По СтрДлина(Предложение) Цикл
                    КодБуквы = КодСимвола(Предложение, Шаг);
                    Если КодБуквы = 46 Тогда
                        Прервать;
                    КонецЕсли;

                    Если КодБуквы = 32 Тогда
                        Продолжить;
                    КонецЕсли;

                    СписокЗначений.Добавить(КодБуквы);
                КонецЦикла;

                ОбработкаНаСервере.ОбработкаСпискаЗначений(СписокЗначений);
            КонецПроцедуры</span>

            --общий модуль ОбработкаНаСервере
            <span class="vue-b">Процедура ОбработкаСпискаЗначений(СЗ) Экспорт
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    <span class="vue-bl">"ВЫБРАТЬ
                    |	СЗ.Значение КАК Значение
                    |ПОМЕСТИТЬ ВТ
                    |ИЗ
                    |	&СЗ КАК СЗ
                    |;
                    |
                    |/////////////////////////////////////
                    |ВЫБРАТЬ
                    |	ВТ.Значение КАК Значение,
                    |	СУММА(1) КАК Количество
                    |ИЗ
                    |	ВТ КАК ВТ
                    |СГРУППИРОВАТЬ ПО
                    |	ВТ.Значение
                    |УПОРЯДОЧИТЬ ПО
                    |	Количество УБЫВ,
                    |	ВТ.Значение"</span>;
                    
                Запрос.УстановитьПараметр("СЗ", СЗ);
                РезультатЗапроса = Запрос.Выполнить();	
            КонецПроцедуры</span>
        </pre>
    </div>


    <h3 class="header-style" id="str5-a">Вывести количества всех букв из предложения</h3>
    <p>На вход подаётся вот такой набор начертаний: "пьвШлста7вТу43двс9соо.". Ввод этих начертаний заканчивается точкой. Нужно написать программу, которая будет из этого набора выводить только буквы в азбучном порядке и их количество, также чтобы они были в нижнем регистре. Программа должна вывести:</p>
    <ul class="list">
        <li>а1</li>
        <li>в3</li>
        <li>д1</li>
        <li>л1</li>
        <li>и так далее</li>
    </ul>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)  
                СлучайныйТекст = "пьпвШлста7вТу43двс9соо.";
                
                <span class="vue-g">//Использую 2 списка значения. В одном буду хранить
                //в значении количество букв, а в представлении саму букву, чтобы потом
                //отсортировать по представлению, но поиска в списке значений нету по 
                //по полю Представление, но есть по полю Значение, поэтому и будем
                //использовать 2й список, в него буду добавлять в значения буквы и искать
                //в нём буквы, которые не нужно повторно записывать</span>
                СЗ = Новый СписокЗначений;
                СЗ2 = Новый СписокЗначений;


                Для Шаг = 1 По СтрДлина(СлучайныйТекст) - 1 Цикл
                    Начертание = НРег(Сред(СлучайныйТекст, Шаг, 1));
                
                    //тут мы с помощью Попытка отсекаем строки, которые содержат цифры
                    //Отсечь цифры можно и путём проверки его кода: КодСимвола(Начертание) &lt; 1072
                    //У цифр всегд код меньше чем код первой буквы русской азбуки
                    Попытка	
                        Начертание = Число(Начертание);
                    Исключение
                        Если СЗ2.НайтиПоЗначению(Начертание) = Неопределено Тогда
                            СЗ.Добавить(0, Начертание);
                            СЗ2.Добавить(Начертание);
                        КонецЕсли;	
                        
                        Для каждого Элемент Из СЗ Цикл
                            Если Элемент.Представление = Начертание Тогда
                                Элемент.Значение = Элемент.Значение + 1;
                            КонецЕсли;
                        КонецЦикла;
                    КонецПопытки;                
                КонецЦикла;

                СЗ.СортироватьПоПредставлению(НаправлениеСортировки.Возр);

                Для каждого Элемент Из СЗ Цикл
                    Сообщить(Элемент.Представление + " " + Элемент.Значение);
                КонецЦикла;	
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style" id="str6">Выделить из строки URL параметры и записать их как ключ и значение в структуру</h3>
    <p>В функцию передаётся строка с адресом, полная или обрезанная это строка будет, без разницы.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Функция РазбитьНаПараметры(СтрокаРесурса)
                НомерВопроса = СтрНайти(СтрокаРесурса, "?");
                ПараметрыРесурса = Новый Структура;

                Если НомерВопроса = 0 Тогда
                    Возврат ПараметрыРесурса;	
                КонецЕсли; 
                ДлинаСтроки = СтрДлина(СтрокаРесурса);
                СтрокаПараметров = Прав(СтрокаРесурса, ДлинаСтроки - НомерВопроса);
                МассивСтрокПараметров = СтрРазделить(СтрокаПараметров,"&", Ложь);

                Для каждого ЭлементМассива Из МассивСтрокПараметров Цикл
                    ВремМассив = СтрРазделить(ЭлементМассива,"=", Ложь);
                    ПараметрыРесурса.Вставить(ВремМассив[0], ВремМассив[1]);	
                КонецЦикла; 

                Возврат ПараметрыРесурса;		
            КонецФункции
        </pre>
    </div>



    <h3 class="header-style" id="str7">Определить, одинаковые ли цветом шахматные поля</h3>
    <p>На вход в программу подаются 4 числа, каждое от 1 до 8. Первые 2 числа это номер столбца и строки шахматной доски, другие 2 числа также номер поля доски. В итоге у нас будут случайные 2 поля доски, нужно определить одинаковые ли у них цвета или нет.</p>
    <div class="code-style">
        <pre>
            Процедура ПередНачаломРаботыСистемы(Отказ)
                <span class="vue-g">//первый способ через циклы</span>
                Столбик1 = 8;
                Строка1 = 4;
                Столбик2 = 3;
                Строка2 = 7;

                ЦветПервого = ОпределитьЦвет(Столбик1, Строка1);
                ЦветВторого = ОпределитьЦвет(Столбик2, Строка2);


                Если ЦветПервого = ЦветВторого Тогда
                    Сообщить("Цвета одинаковые");	
                Иначе	
                    Сообщить("Цвета разные");
                КонецЕсли;
            КонецПроцедуры 

            Функция ОпределитьЦвет(Столбик, Строка) 
                Цвет1 = "СК";
                Цвет2 = "ТК";

                ЦветКвадратика = "";

                Флаг = Истина; 

                Для Шаг = 1 По Столбик Цикл
                    Если Шаг = 1 Тогда
                        Продолжить;
                    КонецЕсли;
                    Флаг = НЕ Флаг;
                КонецЦикла; 


                Для Шаг = 1 По Строка Цикл 
                    Если Шаг = 1 Тогда
                        Продолжить;
                    КонецЕсли;
                    Флаг = НЕ Флаг;
                КонецЦикла;

                Если Флаг Тогда
                    ЦветКвадратика = Цвет1;   	
                Иначе	
                    ЦветКвадратика = Цвет2;
                КонецЕсли;

                Возврат ЦветКвадратика;	
            КонецФункции


            <span class="vue-g">//второй способ через условие. Упустил тот миг, что все светлые квадратика в сумме номера столбца и строки
            //имеют чётное число, а тёмные квадратики нечётное. По этой закономерности и решается в одну строку эта задача</span>
            А1 = 2;
            Б1 = 3;
            А2 = 8;
            Б2 = 8;

            Ответ = ?(((А1 + Б1) % 2 = 0 И (А2 + Б2) % 2 = 0) ИЛИ ((А1 + Б1) % 2 &lt;> 0 И (А2 + Б2) % 2 &lt;> 0), "Да", "Нет");
            Сообщить(Ответ);
        </pre>
    </div>










    <h2 class="header-style">Работа с числами</h2>
    <h3 class="header-style2" id="int1">Написать программу определяющую цифру десятков и единиц в духзначном числе</h3>
    <p>Допустим есть число 12, нужно в одну переменную получить цифру десятков - это 1 и в другую переменную цифру единиц - это 2. Решение заключается в том, чтобы для получения цифры десятков мы просто делим число на 10, получаем 1,2, потом округляем до целого числа. А чтобы получить цифру единиц, то получаем остаток от 12 при делении его на 10, т.е. 12 % 10, остаток будет 2.</p>
    <p>Также можно чило привести в строке и разбить его на части с помощью строковых функций.</p>











    
    <h3 class="header-style2" id="date1">Разность двух дат представьте в виде количества часов, минут и секунд. Например, "3 ч. 29 мин. 40 с."</h3>
    <div class="code-style">
        <pre>
            <span class="vue-b">Процедура ПриНачалеРаботыСистемы()
                Дата1 = '20230427220000';
                Дата2 = '20230427164512';   
                
                РезультатВычитания = Дата1 - Дата2;    
                
                <span class="vue-g">//получил часы</span>
                ОстатокЧасов = Цел(РезультатВычитания / 3600);

                <span class="vue-g">//вычел из общего числа секунд полученные часы</span>
                РезультатВычитания = РезультатВычитания - (ОстатокЧасов * 3600);

                <span class="vue-g">//получил минуты</span>
                ОстатокМинут = Цел(РезультатВычитания / 60);

                <span class="vue-g">//вычел из общего числа минуты</span>
                РезультатВычитания = РезультатВычитания - (ОстатокМинут * 60);

                <span class="vue-g">//получил секунды</span>
                ОстатокСекунд = РезультатВычитания;

                <span class="vue-g">//составил строку из переменных</span>
                РазницаМеждуДатами = "" + ОстатокЧасов + "ч. " + ОстатокМинут + "мин. " + ОстатокСекунд + "сек.";

                Сообщить(РазницаМеждуДатами);
            КонецПроцедуры</span>
        </pre>
    </div>


    <h3 class="header-style2" id="date2">В одной переменной сохраните произвольную дату. В другой переменной вычислите девять утра для произвольной даты.</h3>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                ПроизвольнаяДата = '20230426140000';

                УтроОтПроизвольнойДаты = КонецДня(ПроизвольнаяДата) + (9 * 60 * 60) + 1;

                Сообщить(УтроОтПроизвольнойДаты);	
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style2" id="date3">В одной переменной сохраните произвольную дату. В другой переменной вычислите начало следующего понедельника для произвольной даты.</h3>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                ПроизвольнаяДата = '20230426140000';

                КонецНеделиОтПроизвольнойДаты = КонецНедели(ПроизвольнаяДата) + 1;

                Сообщить(КонецНеделиОтПроизвольнойДаты);	
            КонецПроцедуры
        </pre>
    </div>

    <h3 class="header-style2" id="date4">Получить тестовое представление месяца и года из даты</h3>
    <p>Для такого представления можно воспользоваться методом ПредставлениеПериода(). Такой метод можно посмотреть в помошнике: Глобальный контекст - Функции форматирования.</p>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                ТекДата = ТекущаяДата();
                НачДата = НачалоМесяца(ТекДата);
                КонДата = КонецМесяца(ТекДата);
                ПредставлениеМесяца = "" + ПредставлениеПериода(НачДата, КонДата, "ФП = Истина"); 
                
                НачДата = НачалоГода(ТекДата);
                КонДата = КонецГода(ТекДата);
                ПредставлениеГода =  "" + ПредставлениеПериода(НачДата, КонДата, "ФП = Истина");

                Сообщить(ПредставлениеМесяца);// Апрель 2023г.
                Сообщить(ПредставлениеГода); // 2023г.
            КонецПроцедуры
        </pre>
    </div>












    <h3 class="header-style2" id="shifr1">Наша программа создаёт текстовый файл, пишет в него строку, потом получает эту строку из файла и шифрует строку</h3>
    <p>1. Шифровать будем по методу Атбаша. Это самый простой шифр, суть его в том, что мы берём русскую азбуку, записываем её в переменную в виде строки и создаём 2ю переменную, в которую записываем тоже русскую азбуку, только задом наперёд. И теперь букве "а" будет соответствовать буква "я", букве "б" соответствует буква "ю" и т.д. Ну и далее алгоритм прост, проходим по строке в цикле и получаем каждый раз символ из строки, находим такой символ в русской азбуке, смотрим его позицию и по этой позиции берём букву из перевёрнутой азбуки и строим новой зашифрованную строку.</p>
    <div class="code-style">
        <pre>
            Функция ШифрованиеТекста(Текст, ПравильнаяАзбука, ПеревернутаяАзбука)
                ЗашифрованныйТекст = "";
                Текст = НРег(Текст);
                
                Для Шаг = 1 По СтрДлина(Текст) Цикл
                    СимволИзТекста =  Сред(Текст, Шаг, 1);
                    ПозСимволаВПравАзбуке = СтрНайти(ПравильнаяАзбука, СимволИзТекста);

                    Если ПозСимволаВПравАзбуке &lt;> 0 Тогда
                        СимволИзПеревАзбуки =  Сред(ПеревернутаяАзбука, ПозСимволаВПравАзбуке, 1);
                        ЗашифрованныйТекст = ЗашифрованныйТекст + СимволИзПеревАзбуки;
                    Иначе
                        ЗашифрованныйТекст = ЗашифрованныйТекст + СимволИзТекста;
                    КонецЕсли;
                КонецЦикла;
                
                Возврат ЗашифрованныйТекст;
            КонецФункции

            Документ = Новый ТекстовыйДокумент;
            Документ.УстановитьТекст("Привет мир2");
            Документ.Записать("c:\Пример.txt");

            ПравильнаяАзбука = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
            ПеревернутаяАзбука="яюэьыъщшчцхфутсрпонмлкйизжёедгвба";

            Документ.Прочитать("c:\Пример.txt");
            Текст = Документ.ПолучитьТекст();

            ЗашифТекст = ШифрованиеТекста(Текст, ПравильнаяАзбука, ПеревернутаяАзбука);
            Сообщить(ЗашифТекст);
        </pre>
    </div>
    <p>2. Вот 2й способ зашифровать ту же строку из файла. алгоритм тут такой, получаем код символа прибавляем 5 к этому коду и обратно получаем символ из получившегося кода и записываем в новую строку.</p>
    <div class="code-style">
        <pre>
            Функция ШифрованиеТекста(Текст)
                ЗашифрованныйТекст = "";
                
                Для Шаг = 1 По СтрДлина(Текст) Цикл
                    КодСимвола = КодСимвола(Текст, Шаг);
                    КодСимвола = КодСимвола + 5;
                    Символ = Символ(КодСимвола);
                    ЗашифрованныйТекст = ЗашифрованныйТекст + Символ;
                КонецЦикла;
                
                Возврат ЗашифрованныйТекст;
            КонецФункции 

            Документ = Новый ТекстовыйДокумент;
            Документ.УстановитьТекст("Привет мир");
            Документ.Записать("c:\Пример.txt");
            Документ.Прочитать("c:\Пример.txt");
            Текст = Документ.ПолучитьТекст();

            ЗашифТекст = ШифрованиеТекста(Текст);
            Сообщить(ЗашифТекст);

            Документ.УстановитьТекст(ЗашифТекст);
            Документ.Записать("c:\out.txt");

        </pre>
    </div>

    <p>Ну и тут же запишем программу, которая расшифровывает текст и записывает его в новый файл "результат.txt", содержимое этого файла должно совпадать с файлом "Пример.txt". В алгоритме всё тоже самое, только отнимаем опять 5 от кода.</p>
    <div class="code-style">
        <pre>
            Функция РашифровкаТекста(Текст)
                РасшифрованныйТекст = ""; 	
                Для Шаг = 1 По СтрДлина(Текст) Цикл
                    КодСимвола = КодСимвола(Текст, Шаг);
                    КодСимвола = КодСимвола - 5;
                    Символ = Символ(КодСимвола);
                    РасшифрованныйТекст = РасшифрованныйТекст + Символ;
                КонецЦикла;
                
                Возврат РасшифрованныйТекст;
            КонецФункции

            Документ = Новый ТекстовыйДокумент;
            Документ.Прочитать("c:\out.txt");
            Текст = Документ.ПолучитьТекст();

            РасшифТекст = РашифровкаТекста(Текст);
            Сообщить(РасшифТекст);

            Документ.УстановитьТекст(РасшифТекст);
            Документ.Записать("c:\Результат.txt");
        </pre>
    </div>
    <p>Делать расшифровку по первому примеру уже не стану, думаю там и так разберусь.</p>












    <h3 class="header-style" id="shifr2">Создание паролей по заданной длине и кол-ву паролей</h3>
    <p>В 2х переменных задаём сколько нам надо паролей и их длину, запускаем функцию которая их создаёт.</p>
    <div class="code-style">
        <pre>
            Функция СозданиеПаролей(СДП, КП, ДП)
                ГСЧ = Новый ГенераторСлучайныхЧисел;
                МассивПаролей = новый Массив;
                СтрокаПароль = "";

                Для Шаг = 1 По КП Цикл
                    Для Шаг2 = 1 По ДП Цикл
                        СлучайноеЧисло = ГСЧ.СлучайноеЧисло(1, СтрДлина(СДП));
                        Символ = Сред(СДП, СлучайноеЧисло, 1);
                        СтрокаПароль = СтрокаПароль + Символ;
                        Если Шаг2 = ДП Тогда
                            МассивПаролей.Добавить(СтрокаПароль);
                            СтрокаПароль = "";
                        КонецЕсли;
                    КонецЦикла;
                КонецЦикла;
                Возврат МассивПаролей;	
            КонецФункции

            СимволыДляПароля = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";
            КоличествоПаролей  = 6;
            ДлинаПаролей = 12;

            МП = СозданиеПаролей(СимволыДляПароля, КоличествоПаролей, ДлинаПаролей);
            ОткрытьЗначение(МП);
        </pre>
    </div>










    <h3 class="header-style" id="shifr3">Вывод чисел Фибоначи через рекурсию</h3>
    <p>Числа Фибоначи это начальные числа 0 и 1 и последующие числа это сумма 2х предыдущих: 0,1,1,2,3,5,8,13,21,34,55....</p>
    <div class="code-style">
        <pre>
            Процедура ВычислитьЧислаФибоначи(А = 0, Б = 1) 
                Если А = 0 Тогда
                    Сообщить(А);
                    Сообщить(Б);
                Иначе
                    Сообщить(Б);	
                КонецЕсли;
                
                С = А + Б;
                
                Если С > 1000 Тогда
                    Возврат;
                Иначе
                    Нажать(Б,С);
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>











    <h3 class="header-style" id="processing1">Заполнить реквизит у документов, в табличной части которых есть выбранный товар.</h3>
    <p>Обработка находится в конфигурации Камкова - Основные Объекты. Обработка называется ИзменениеДокументовПоступления2.
    Также решение подобные есть и в обработке ИзменениеДокументовПоступления.
    </p>
    <div class="code-style">
        <pre>
            //есть в обработке реквизит ВыбратьТовар, в нём выбираем товар. Теперь когда мы запустим
            //эту обработку по кнопке "Изменить" то в реквизит Сообщение документов "ПоступленияТоваров"
            //запишется какое то значение, но только в те документы, в табличной
            //части которых есть такой товар  
            &НаКлиенте
            Процедура Изменить(Команда)
                ИзменитьНаСервере(ВыбратьТовар);
            КонецПроцедуры

            &НаСервереБезКонтекста
            Процедура ИзменитьНаСервере(ВыбратьТовар) 
                Выборка = Документы.ПоступлениеТоваров.Выбрать(); 
                Пока Выборка.Следующий() Цикл
                    Для каждого Строка Из Выборка.Товары Цикл
                        Если Строка.Товар = ВыбратьТовар Тогда
                            ДокументОбъект = Выборка.ПолучитьОбъект();
                            ДокументОбъект.Сообщение = 123;
                            ДокументОбъект.Записать();
                        КонецЕсли;
                    КонецЦикла;	
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>


    <h3 class="header-style" id="processing2">Программно обработка изменяет регистр сведений КурсыВалют</h3>
    <p>Допустим у нас есть Справочник Валюты, где перечисляются названия заграничных денег. И есть регистр сведений, где мы храним курсы и кратности этих денег во времени(переодический). Нам нужно как то читать и писать в этот регистр.Мы можем писать в него из пользовательской части, можем писать с помощью документа, а бывает нужно писать в него программно, например, из обработки, чтобы загрузить из инета курсы валют и записать в регистр. Создадим обработку, добавим в неё кнопку и по кнопке будем писать в регистр. Код находится в модуле формы обработки.</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//эти 2 процедуры обработчики кнопки ЗаписатьКурс</span>
            <span class="vue-b"><b>&НаКлиенте
            Процедура ЗаписатьКурс(Команда)
                ЗаписатьКурсНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ЗаписатьКурсНаСервере()
                <span class="vue-g">//НаборЗаписей теперь содержит некую коллекцию, которая содержит описание каждой записи регистра</span>
                НаборЗаписей = РегистрыСведений.КурсыВалют.СоздатьНаборЗаписей();

                <span class="vue-g">//метод Добавить() создаёт запись в этом наборе и возвращает ссылку на эту запись</span>
                Запись = НаборЗаписей.Добавить();

                <span class="vue-g">//заполняем запись</span>
                Запись.Период = Период;
                Запись.Валюта = Валюта;	
                Запись.Курс = Курс;
                Запись.Кратность = Кратность;

                <span class="vue-g">//даём команду записать запись в БД. У метода Записать() по умолчанию стоит</span>
                <span class="vue-g">//булево значение Истина(Замещать), т.е. при добавлении записи мы замещаем предыдущую запись</span>
                <span class="vue-g">//а нам надо добавлять, поэтому ставим Ложь</span>
                НаборЗаписей.Записать(Ложь);
            КонецПроцедуры</b></span>
        </pre>
    </div>











    <h3 class="header-style">Про таблицы значений</h3>
    <h3 class="header-style2" id="table-value">Нужно распределить 40рублей по сумме товаров пропорционально их количество</h3>
    <p><b>1й способ</b></p>
    <p>Есть вот такая таблица значений:</p>
    <table border="1" style="margin-top: 0px;margin-bottom: 40px">
        <tr>
            <td>Товар</td>
            <td>Количество</td>
            <td>Сумма</td>
        </tr>
        <tr>
            <td>Товар1</td>
            <td>1</td>
            <td>150</td>
        </tr>
        <tr>
            <td>Товар2</td>
            <td>2</td>
            <td>170</td>
        </tr>
        <tr>
            <td>Товар3</td>
            <td>3</td>
            <td>180</td>
        </tr>
    </table>
    <p>Нам дано 40руб. и их нужно программно распределить по суммам всех товаров учитывая пропорции количества до рубля, т.е. без дробных частей. Первое, определяем сколько уйдёт рублей на один товар, для этого нужно 40 разделить на количество всех товаров. Получится 6.7р., округлённое до 1 знака после запятой, уйдёт в сумму на один товар. Ну а дальше нужно прибавить это число к сумме умножая на количество товаров.</p>
    <p>Программно мы это оформим через показ в общей произвольной форме при начале работы системы:</p>
    <div class="code-style">
        <pre>

            --модуль приложения
            <span class="vue-r">Процедура</span> ПриНачалеРаботыСистемы()
                ОткрытьФорму("ОбщаяФорма.ФормаВыводаТЗ");		
            <span class="vue-r">КонецПроцедуры</span>



            --модуль общей произвольной формы "ФормаВыводаТЗ"
            <span class="vue-r">&НаСервере
            Процедура</span> ПриСозданииНаСервере(Отказ, СтандартнаяОбработка) 
                <span class="vue-g">//ТабЗнач это реквизит формы с типом "ТаблицаЗначений"

                //добавляем строки</span>
                НоваяСтрока = ТабЗнач.Добавить();
                НоваяСтрока.Товар = "Товар1";	
                НоваяСтрока.Количество = 1;	
                НоваяСтрока.Сумма = 150;

                НоваяСтрока = ТабЗнач.Добавить();
                НоваяСтрока.Товар = "Товар2";	
                НоваяСтрока.Количество = 2;	
                НоваяСтрока.Сумма = 170;

                НоваяСтрока = ТабЗнач.Добавить();
                НоваяСтрока.Товар = "Товар3";	
                НоваяСтрока.Количество = 3;	
                НоваяСтрока.Сумма = 180;
                

                РаспределяемыеРубли = 40;

                <span class="vue-g">//подсчитаем общее количество товаров</span>
                ОбщееКоличествоТоваров = 0;
                Для каждого СтрокаТЗ Из ТабЗнач Цикл
                    ОбщееКоличествоТоваров = ОбщееКоличествоТоваров + СтрокаТЗ.Количество;
                КонецЦикла;	 
                <span class="vue-g">//или тоже самое через метод Итог
                //ОбщееКоличествоТоваров = ТабЗнач.Итог("Количество");</span>

                <span class="vue-g">//высчитываем сколько рубоей на одит товар выходит. Округляем до 1 знака после запятой</span>
                РаспределённыеРублиНаОдинТовар = Окр(РаспределяемыеРубли / ОбщееКоличествоТоваров, 1); 

                <span class="vue-g">//прибавляем к суммам распределяемые 40 рублей. Тут уже округляем до 0 знаков, чтобы выйти на бездробные числа
                //Округление и там и тут производим как стоит по умолчанию: 1.5 -> 2.0, 1.4 -> 1.0</span>
                Для каждого СтрокаТЗ Из ТабЗнач Цикл
                    СтрокаТЗ.Сумма = Окр(СтрокаТЗ.Сумма + (РаспределённыеРублиНаОдинТовар * СтрокаТЗ.Количество),0);
                КонецЦикла;
            <span class="vue-r">КонецПроцедуры</span>
        </pre>
    </div>
    <p><b>2й способ</b></p>
    <p>Во втором способе разница будет лишь в нахождении коэффициента, чтобы потом этот коэффициент умножить на 40. Нам также понадобится общее количество товара - это 6. Затем количество каждого товара нужно разделить на общее количество(6) и получим коэффициенты для каждого количества товара. Например, коэффициент для первого товара 1 / 6 = 0.1666666666667 и тпк далее:</p>
    <table border="1" style="margin-top: 0px;margin-bottom: 40px;font-size: 9px;">
        <tr>
            <td>Товар</td>
            <td>Количество</td>
            <td>Сумма</td>
            <td>Коэффициент</td>
            <td>Вычисление</td>
            <td>Итоговая сумма</td>
        </tr>
        <tr>
            <td>Товар1</td>
            <td>1</td>
            <td>150</td>
            <td>1 / 6 = 0.1666666666667</td>
            <td>0.1666666666667 * 40 = 6.7</td>
            <td>7 + 150 = 157</td>
        </tr>
        <tr>
            <td>Товар2</td>
            <td>2</td>
            <td>170</td>
            <td>2 / 6 = 0.3333333333333333</td>
            <td>0.3333333333333333 * 40 = 13.3</td>
            <td>13 + 170 = 183</td>
        </tr>
        <tr>
            <td>Товар3</td>
            <td>3</td>
            <td>180</td>
            <td>3 / 6 = 0.5</td>
            <td>0.5 * 40 = 20</td>
            <td>20 + 180 = 200</td>
        </tr>
    </table>
    <p>Если что делал по этому видео, там ещё автор показал как сделать, если точно не выходит до целого рубля - https://www.youtube.com/watch?v=Yra6Shxej70</p>









    <h3 class="header-style">Поиск ошибок в коде</h3>
    <h3 class="header-style2" id="err-1">Пример 1</h3>
    <p>Задача. Документ ПоступлениеТоваров при проведении делает движения по 2 регистрам:</p>
    <ul class="list">
        <li>приход по регистру накопления ТоварыНаСкладах</li>
        <li>расход по регистру накопления ЗаказыПоставщикам</li>
    </ul>
    <p>Запись в регистр накопления ТоварыНаСкладах делается в рублях (Сумма) и в долларах (СуммаВал). Курс берется на дату партии.</p>
    <p>Документ может содержать в табличной части Товары тысячи строк с различными партиями.</p>
    <p>Ниже представлена обработка проведения документа ПоступлениеТоваров.</p>
    <p>Необходимо указать на ошибки и неоптимальные решения в процедуре проведения.</p>
    <p>Вот код с ошибками, нужно найти не менее 15 ошибок:</p>
    <div class="code-style">
        <pre>
            <span class="светло_синий">Процедура ОбработкаПроведения(Отказ, РежимПроведения)
                Запрос = Новый Запрос;
                Запрос.Текст = 
                <span class="серый">"ВЫБРАТЬ
                |   Товары.Номенклатура КАК Номенклатура,
                |   Товары.Партия КАК Партия,
                |   Товары.Количество КАК Количество,
                |   Товары.Сумма КАК Сумма,
                |   Заказы.КоличествоОстаток КАК КоличествоОстаток
                |ИЗ
                |   Документ.ПоступлениеТоваров.Товары КАК Товары
                |   ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления.ЗаказыПоставщикам.Остатки(&Период, Контрагент = &Контрагент) КАК Заказы
                |   ПО Товары.Номенклатура = Заказы.Номенклатура
                |   И Товары.Партия = Заказы.Партия
                |ГДЕ
                |   Товары.Ссылка = &Ссылка
                |   И (Заказы.Номенклатура, Заказы.Партия) В
                |                                   (ВЫБРАТЬ
                |                                       Товары.Номенклатура,
                |                                       Товары.Партия
                |                                   ИЗ
                |                                       Документ. ПоступлениеТоваров.Товары КАК Товары
                |                                   ГДЕ
                |                                       Товары.Ссылка = &Ссылка)
                |ИТОГИ
                |   СУММА(Количество),
                |   СУММА(Сумма),
                |   СУММА(КоличествоОстаток)
                |ПО
                |   Номенклатура,
                |   Партия"</span>;

                ВыборкаНоменклатура = Запрос.Выполнить().Выбрать();
                Пока ВыборкаНоменклатура.Следующий() Цикл
                    Если ВыборкаНоменклатура.Количество > ВыборкаНоменклатура.КоличествоОстаток Тогда
                        Сообщить(<span class="серый">"Количество в поступлении "</span> + ВыборкаНоменклатура.Количество + <span class="серый">" "</span> + ВыборкаНоменклатура.Номенклатура.ЕдиницаИзмерения + <span class="серый">" превышает остаток по заказам "</span> + ВыборкаНоменклатура.КоличествоОстаток + <span class="серый">" "</span> + ВыборкаНоменклатура.Номенклатура.ЕдиницаИзмерения);
                    Иначе
                        ВыборкаПартия = ВыборкаНоменклатура.Выбрать();
                        Пока ВыборкаПартия.Следующий() Цикл
                            СуммаВал = СуммаВал	+ РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ВыборкаПартия.Партия.Дата, Новый Структура(<span class="серый">"Валюта"</span>, Справочники.Валюты.НайтиПоНаименованию(<span class="серый">"USD"</span>)));
                            Движение = РегистрыНакопления.ЗаказыПоставщикам.Добавить();
                            Движение.ВидДвижения = ВидДвиженияНакопления.Расход;
                            Движение.Период = Дата;
                            Движение.Номенклатура = ВыборкаПартия.Номенклатура;
                            Движение.Количество = ВыборкаПартия.Количество;
                        КонецЦикла;
                        Движение = Движения.ТоварыНаСкладах.Добавить();
                        Движение.Период = Дата;
                        Движение.Номенклатура = ВыборкаНоменклатура.Номенклатура;
                        Движение.Количество = ВыборкаНоменклатура.Количество;
                        Движение.Сумма = ВыборкаНоменклатура.Сумма;
                        Движение.СуммаВал = СуммаВал;
                    КонецЕсли;
                КонецЦикла;
            КонецПроцедуры</span>
        </pre>
    </div>
    <p>Правильные ответы:</p>
    <ol class="list">
        <li>Нет удаления старых движений документа.</li>
        <li>Старые движения удаляем, если дата дока сдвинута вперед.</li>
        <li>Нет установки флага для записи движений в конце транзакции.</li>
        <li>Нет наложения управляемой блокировки.</li>
        <li>Для минимизации времени блокировки запрос при помощи МенеджерВременныхТаблиц необходимо разбить на 2: а) получение ланных документа б) Получение остатков.</li>
        <li>Нет установки параметров запроса.</li>
        <li>В параметре на &период вирт. Таблицы «Остатки» следует использовать МоментВремени.</li>
        <li>В случае оперативного поведения параметр «МоментВремени» следует установить в Неопределено.</li>
        <li>Условие при выборке остатков на (Номенклатуру, Партию) следует делать в параметрах виртуальной таблицы.</li>
        <li>«РегистрыСведений.КурсыВалют.ПолучитьПоследнее(» - запрос в цикле. Курс нужно получать в запросе по таблице документа через макс период партии.</li>
        <li>Первый запрос следует сгруппировать по номенклатуре, партии.</li>
        <li> Итоги не нужны.</li>
        <li>Т.к. остатка в регистре может не быть, поле «Заказы.КоличествоОстаток» следует обернуть в ЕстьNUll</li>
        <li>При выборке запроса не указан параметр «ОбходРезультатаЗапроса.ПоГруппировкам».(хотя идет именно по группировкам).</li>
        <li>Обход по группировкам не нужен.</li>
        <li>В случае превышения "Количество в поступлении" над остатком заказов, списания заказов по данной номенклатуре не происходит, что не логично: либо списываем что есть, либо не проводим документ.</li>
        <li>«ВыборкаПартия.Партия.Дата» - чтение всего объекта «через точку». При необходимости работы с полем дата его нужно добавить в запрос.</li>
        <li>«ВыборкаНоменклатура.Номенклатура.ЕдиницаИзмерения» - аналогично.</li>
        <li>«СуммаВал = СуммаВал + РегистрыСведений.КурсыВалют.ПолучитьПоследнее(» - странный алгоритм. Для вычисления валютной суммы вероятно стоит умножать Сумму в рублях на курс.</li>
        <li>+19 переменная СуммаВал не задана.</li>
        <li>«ЗаказыПоставщикам.Добавить();» - лучше использовать «ДобавитьРасход()»</li>
        <li>Не указан ВидДвижения при добавлении дв-ний ТоварыНаСкладах.</li>
        <li>При списании «ЗаказыПоставщикам» не задается партия.</li>
    </ol>
    <p>От других людей правильные ответы:</p>
    <ol class="list">
        <li>Ошибка. Нет установки параметров для запроса. 3 шт.</li>
        <li>Строка 12-15. СОЕДИНЕНИЕ РегистрНакопления.ЗаказыПоставщикам. a) Нельзя соединяться с виртуальными таблицами в запросе. Следовало бы использовать сначала чтение во временную таблицу.</li>
        <li>Строка 9. Заказы.КоличествоОстаток КАК КоличествоОстаток при левом соединении здесь надо использовать ЕСТЬNULL(, 0). Иначе потом при «ВыборкаНоменклатура.Количество > ВыборкаНоменклатура.КоличествоОстаток» будет исключение о приведении типов</li>
        <li> Строка 34. ВыборкаНоменклатура = Запрос.Выполнить().Выбрать(); Здесь не совсем не точность, скорее просто небольшая оптимизация.  Когда каждая мс выполнения дорога, лучше сначала проверять что РезультатЗапроса не пустой, а потом уже тащить с сервера выборку. Иначе получается, что тащится выборка с сервера, а там пусто.</li>
        <li>Строка 18. И (Заказы.Номенклатура, Заказы.Партия) . Это параметры вирт таблицы, так что нужно их и вынести в параметры, чем писать их в области ГДЕ. + Там еще и лишние записи будут до соедеинения, т.к.</li>
        <li> Строка 23. Документ. ПоступлениеТоваров.Товары – Тут еще раз делается запрос к таблице. Лучше ТЧ товары сначала сохранить в ВТ и потом к ней обращаться.</li>
        <li>Строка 37. Сообщить – это скорее устаревший метод, он не работает на УФ, лучше использовать ОбщегоНазначения.СообщитьПользователю. Результат и на ОФ и На УФ будет одинаковым.</li>
        <li>Строка 39, 43. ВыборкаНоменклатура.Номенклатура.ЕдиницаИзмерения обращение через точку вызовет запрос к СУБД. Там конечно есть, какое то кэширование серверных значений. Но раз уж тут получаются данные через запрос и там будет номенклатура, то лучше сразу перенести в запрос.</li>
        <li>В качестве не оптимальных решений можно так же указать отсутствие установленных БлокировокДанных. Но тут вопрос скорее конфигурации. Может в ней стоит автоматический режим. Может этот документ создается один раз в год и ночью когда никто не работает(хотя это поступление, так что врятли, так что из разряда фантастики)</li>
        <li> Строка 49-50. a) СуммаВал = СуммаВал + РегистрыСведений.КурсыВалют.ПолучитьПоследнее() b) Это тот же запрос, да еще к вирт. таблице, да еще и вызывается в цикле.  Надо переносить в основной запрос. Хотя бы как пакет, а еще лучше рассчитывать суммуВал для каждой строки в запросе.</li>
        <li>Строка 52. Справочники.Валюты.НайтиПоНаименованию(«USD»)  - это в цикле вызывается, и всегда возвращает одно и тоже значение. Лучше перенести поиск до цикла и потом просто его передавать</li>
        <li>Строка 52. Справочники.Валюты.НайтиПоНаименованию(«USD»)  - так же тут идет поиск по наименованию, что не верно. Лучше искать по коду. Или по гуиду. Или вообще завести как предопределенное значение, если его нет в конфе.</li>
        <li>Строка 52 - Новый Структура("Валюта", …)  тут еще момент, если не учитывать п.9 и п.10. То такую структуру лучше объявить до цикла и потом передавать её в функцию и если надо менять параметр. Тут параметр всегда один, так что лучше и все структуру один раз объявить и заполнить</li>
        <li> Строка 54, 61. Движение = РегистрыНакопления.ЗаказыПоставщикам  - перед записью движений надо очищать движения. Т.к. в случае перепроведения коллекция не очистится. Так же, сама коллекция движений явно не записывается, и не установлен флаг Записывать.</li>
        <li>Строка 49 – СуммаВал  = Сумма Вал  - Во первых, не инициализируется переменная. Во вторых – изза того что она не инициализацируется в выборке по номенклатуре её значение не «сбрасывается». К тому же, если цикл  ВыборкаПартия.Следующий() будет пустой, то наверное будет ошибка(вот точно не помню, по идее там неопределено будет, а приведется ли он к 0, не пробовал).</li>
        <li>Строка 52 - ВыборкаПартия.Партия.Дата – это тоже не явный запрос. Как в п.7</li>
        <li>Строка 61 Движения.ТоварыНаСкладах. – не установлен вид движения. Это явно рег. Остатков, так что там надо явно его установить. При проведении должно ругнуться</li>
        <li>Строка 39 ВыборкаНоменклатура.Количество – по одной номенклатуре может быть несколько партий, и ВыборкаНоменклаутра будет иметь итог больше чем запрошенное в документе количество. То же самое и с Суммой при формировании движений. И таже проблема с проверкой остатков ВыборкаНоменклатура.Количество > ВыборкаНоменклатура.КоличествоОстаток</li>
        <li>Ну еще момент в запросе, что нет группировки по номенклатуре и партии. Если в документе будет указаны одинаковые номенклатуры и партии в 2х строках, то будет не корректное списание партий, т.к. там же левое соединение по этим полям.</li>
    </ol>



</div>
