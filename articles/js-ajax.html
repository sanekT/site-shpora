<div class="wrap">
   
    <h2 class="header-style">AJAX</h2>

    <p><b>Если нужно вспомнить о протоколе HTTP, то вот видео от Борисова</b> - https://www.youtube.com/watch?v=fsp825JA90A&t=3229s. Начиная с 01:32:00 очень подробно объясняет об этом протоколе или это видео лежит у меня на компе по адресу D:\Web\JS\Видео. Курс от специалиста\AJAX</p>

    <p><b>Хорошая статья про AJAX - <a href="https://good-code.ru/ajax-zapros/">тут</a></b></p>



    <p><b>Оглавление:</b></p>
    <ul class="list">
        <li><a href="#1">Статус кодов пришедших от сервера</a></li>
        <li><a href="#2">Основы ajax на чистом js</a></li>
        <li><a href="#3">Пример отправки формы без перезагрузки страницы методом POST</a></li>
        <li><a href="#4">Основы ajax на jQuery</a></li>
        <li><a href="#5"></a></li>
    </ul>




    <p>Заголовки запроса, которые посылает браузер не обязательны к исполнению на сервере, а вот заголовки ответа, которые посылает сервер обязательны к исполнению.</p>
    <img src="../img/Ajax, Http/method-GET.png" alt="" class="screen">






    <h3 class="header-style2" id="1">Стутус кодов пришедших от сервера</h3>
    <ul class="list">
        <li><b>200</b> - успешно пришёл ответ</li>
        <li><b>301</b> - постоянная переадресация. Вместе с 301, 302 статусами мы ждём заголовка Location, в котором указан новый адрес, на который надо перейти</li>
        <li><b>302</b> - временная переадресация, говорит о том что сайт временно перемещён в другую папку, поэтому обращаться нужно всё время по старому адресу с перенаправлением, потому как сайт когда то вернётся на старый алрес, а если пришёл 301 статус, то мы как бы делаем выводы, что сайт на постоянку переместили и значит надо обновить его адрес на новый.</li>
        <li><b>304</b> - объект не изменился. Статус с вязан с кешированием(сохранением). Когда пришли с сервера все ресурсы(страница, картинка, стили ит.д.) браузер, если не было никаких команд как кешировать, кеширует по умолчанию эти ресурсы(зависит от браузеров) и когда пользователь снова обращается к этим ремурсам, то браузер видя, что они лежат в кеше пока не показывает их, он отправляет спец. запрос с определённым заголовком If Modified Syns(как то так со слов Борисова), где указывает значение из предыдущего заголовка ответа Last Modified, мол страница изменилась или всё та же, сервер вернёт страницу в случае того если страница изменилась со статусом 200 OK, если нет то сервер просто вернёт статус 304 и браузер вытащит эту страницу из кеша и покажет пользователю. Откуда сервер берёт инфу о том когда менялся файл? Если это статическая html страница, то он просто смотрит в свойствах файла дату изменения(имеется в виду когда мы кликаем на компе правой кнопкой мыши по файлу вылетает контекстное меню и в этом меню в самом низу свойства файла), вот в таких примерно свойствах смотрит сервер. А вот если файл hml динамически создаётся на лету, то тут уже серверу не посмотреть его дату изменения, потому как лежит файл php созданный давно, а html страницы он создаёт и изменяет постоянно, для таких динамических файлов сервер не посылает заголовок Last Modified, а значит и браузер не может послать заголовок валидатор If Modified Syns, из этого вытекает, что такие файлы браузер не кеширует и запрашивает постоянно. Поэтому программисты скрипта php или др. языка должны в созданных на лету страницах принудительно сами посылать заголовок Last Modified раз это не делает сервер, чтобы браузер мог их кешировать.</li>
        <li><b>400</b> - bad request. Такой статус сервер пришлёт если послать запрос без заголовка запроса Host, который обязателен</li>
        <li><b>401</b> - отсутствие авторизации. Четырёхсотые статусы это ошибки клиента(адрес не правильно вбил ну и в таком роде)</li>
        <li><b>403</b> - запрещено. Запрещено исполнение запрашиваемого файла, запрещён просмотр директории.</li>
        <li><b>404</b> - html не найден(страница не найдена). Есть статус похожий на него это 410, он говорит что объект был, но теперь его нет, что позволяет нам сразу понять что мы в адресе не ошиблись, просто объект удалили, а вот при 404 не понятно мы ошиблись или объект удалили и начинаем ковырять этот адрес и так ии сяк теряя время.</li>
        <li><b>404</b> - метод не поддерживается(сервер может ограничить доступ к файлам определённым методам, например POST, только через GET). Сервер Apache не поддерживает этот статус, вместо него он возваращает статус 403, что в корне не верно.</li>
        <li><b>500</b> - ошибка сервера</li>
        <li></li>
        <li></li>
    </ul>








    <h3 class="header-style2" id="2">Основы ajax на чистом js</h3>
    <p>Объект XMLHttpRequest это мини браузер, он делает тоже самое что и браузер, когда мы посылаем форму на сервер, браузер перед посылкой формы собирает все её данные, создаёт соединение, данные запихивает в тело запроса, также создаёт заголовки запроса и т.д.</p>
    <p>Ajax это не только использование браузерного объекта XMLHttpRequest, но это и :</p>
    <ul class="list">
        <li>Динамическое создание дочерних фреймов</li>
        <li>Динамическое создание элемента &lt;script></li>
        <li>Динамическое создание элемента &lt;img>, например, const img = new Image(); img.src = 'img/img.png'; и сразу же создаётся соединение  с сервером и запрашивается картинка по указанному адресу, но тут никто не использует объект XMLHttpRequest. Единственное пока не понятно
        когда именно идёт запрос картинки на сервер, когда уже вставили в DOM дерево этот тег img или когда в js к этому тегу присвоили src и путь.Борисов говорит, что при создании картинки через new Image() и присваивании ему src сразу идёт запрос этой картинки на фоне. И такие запросы идут только с методом GET.</li>
    </ul>
    <p>Потому как веб-сокеты используют тот же способ соединения с сервером, но они это делают без объекта XMLHttpRequest.</p>
    <p>Как работает Ajax? Браузер загрузил страницу и всё, он отдыхает, а вот посылами ajax запросов уже занимается js.</p>
    <div class="code-style">
        <pre>
            //<span class="vue-b">составляем url</span>
            const url = location.href + "form.php" + "?" + дальше тут можно перечислять параметры полученные из формы или ещё откуда то;
            //<span class="vue-b">можно даже в url указать просто имя файла, на который мы делаем запрос, а протокол и наш сайт(домен) добавятся автоматом</span>
            //<span class="vue-b">как я понял запрос можно делать даже к обычным файлам, которые у нас лежат в папке на сервере, например к файлу text.txt и нам вернётся то, что лежит в этом файле</span>

            //<span class="vue-b">создаём объект для работы с сетевыми запросами</span>
            const xhr = <span class="vue-b">new</span> <span class="vue-r">XMLHttpRequest()</span>;
            
            //<span class="vue-b">этот метод подготавливает соединение с сервером</span>
            request.<span class=vue-g>open</span>('method', 'url', false); 
            //<span class="vue-b">method - это способ отправки запроса, например, GET или POST</span>
            //<span class="vue-b">url - это адрес, по которому мы хотим получить ответ</span>
            //<span class="vue-b">false - говорит нам о том , что запрос синхронный, по умолчанию стоит true - асинхронный. Если запрос синхронный то нт смысла отлавливать ответ в событиях.</span>

            <span class="vue-b">указываем, чтобы пришедший ответ в виде json строки сразу распарсился в js объект</span>
            request.<span class=vue-g>responseType</span> = 'json';
            
            request.<span class=vue-g>send</span>(null);// этот метод уже отправляет запрос на сервер, в параметрах стоит null, потому что ушёл GET запрос, если бы был POST, то вместо null мы бы писали бы тело POST запроса.
        </pre>
    </div>
    <p>Ajax есть <b>асинхронный</b> и <b>синхронный</b>. Чем они отличаются? Когда интерпритатор читает код и доходит до строки request.send(), то при синхронном запросе идёт посыл запроса и js на время замирает и код дальше не выполняется, пока не придёт ответ от сервера. Как только пришёл ответ, интерпритатор дальше  исполнять код.</p>
    <p>Когда используют синхронный запрос? Тогда когда нам нужно быть уверенными, что данные пришли с сервера, потому что нижележащий js код зависит от этих данных.</p>
    <p>При <b>асинхронном</b> запросе, данные когда придут тогда и придут. Для этого есть такое событие как <b>onreadystatechange</b>. Когда данные прийдут и сработает это событие, то запустится функция, которая что то там сделает, но это событие срабатывает все 4 раза на все стадии(readyState) состояния запроса.</p>
    <p>А как событие поймёт что нужно сработать? Для этого у объекта XMLHttpRequest есть 4 стадии состояния запроса. Отвечает за эти стадии свойство <b>readyState</b>, которое будет иметь одно из 4х значений это 1, 2, 3 или 4. Первая стадия это послыка данных, вторая это сервер принял, третья это сервер данные отправляет обратно и четвёртая - данные пришли.</p>
    <p>Когда прийдёт ответ от сервера, то текст этого ответа положится в свойство <b>request.responseText</b>. Но в ответе также есть и заголовки ответа(<b>request.getAllResponseHeaders()</b>) и можно получить какой нибудь 1 заголовок ответа(<b>request.getResponseHeader('Last-Modified')</b>) и статус кода ответа(<b>request.status</b>) и  текст статуса кода ответа(<b>request.statusText</b>).:</p>
    <div class="code-style">
        <pre>
            const xhr = <span class="vue-b">new</span> <span class="vue-r">XMLHttpRequest()</span>;
            xhr.<span class="vue-g">onreadystatechange</span> = function(){
                //указываем, что дальше условия код выполнится только при request.readyState === 4, потому как это событие срабатывает на все 4 стадии состояния запроса
                if(xhr.<span class="vue-g">readyState</span> === 4){
        
                    //<span class="vue-b">2 эти строки кода возвращают ответ в виде строки, request.responseText возвращает только тело ответа без заголовков ответа</span>
                    //<span class="vue-b">обычно приходит json строка с объектом внутри, чтобы достать объект из строки мы его парсим JSON.parse(xhr.responseText)</span>
                    //<span class="vue-b">но можно сразу указать тип ответа, например после строки кода с request.open() укажем такую строку - xhr.responseType = 'json'</span>
                    //<span class="vue-b">и нам сразу придёт распарсеный объект</span>
                    console.log(xhr.<span class="vue-g">response</span>);
                    console.log(xhr.<span class="vue-g">responseText</span>);
        
                    //<span class="vue-b">покажет число статуса ответа - 200 404 и т.д.</span>
                    console.log(xhr.<span class="vue-g">status</span>);

                    //<span class="vue-b">при 200 это OK, при 404 это Not Found</span>
                    console.log(xhr.<span class="vue-g">statusText</span>);
        
                    //<span class="vue-b">вывести все заголовки ответа</span>
                    console.log(xhr.<span class="vue-g">getAllResponseHeaders</span>());
        
                    //<span class="vue-b">вывести указанный заголовок ответа</span>
                    console.log(xhr.<span class="vue-g">getResponseHeader</span>('Last-Modified'));
        
                    //<span class="vue-b">пока не знаю</span>
                    console.log(xhr.<span class="vue-g">statusText</span>);
                }
            };
            xhr.<span class="vue-g">open</span>(method, url, true);
            xhr.<span class="vue-g">send</span>(null);
        </pre>
    </div>
    <p>Чтобы отлавливать ошибки мы также воспользуемся событием "onload" или "onreadystatechange", а также "onerror". Внутри этих событий делаем проверки на пришедший код статуса и в соответствии с этим кодом решаем что делать:</p>
    <div class="code-style">
        <pre>
            //<span class="vue-b">тут обрабатываешь статус коды</span>
            request.<span class="vue-g"></span>onload</span> = function(){
                if(request.<span class="vue-g">status</span> >= 400){
                    //<span class="vue-b">тут обрабатываем ошибку</span>
                }
            };

            //<span class="vue-b">а тут обрабатываем ошибки другие, какие уточню как узнаю</span>
            request.<span class="vue-g">onerror</span> = function(){

            };
        </pre>
    </div>

    <p>Чтобы работать нормально с асинхронным кодом, то мы создадим функцию и вернём промис:</p>
    <div class="code-style">
        <pre>
            const requestUrl = 'https://yandex.ru';
            //в эту переменную в объект заполняем данные из формы
            const bodyPost = {
                name: 'Jhon',
                age: 23,
            };

            function sendRequest(method, url, body = null){
                return new Promis(function(resolve, reject){
                    const xhr = new XMLHttpRequest();

                    xhr.open(method, url);
                    xhr.responseType = 'json';
                    xhr.onload = function(){
                        if(xhr.status >= 400){
                            reject(xhr.response);
                        }else{
                            resolve(xhr.response);
                        }
                    };
                    xhr.onload = function(){
                        reject(xhr.response);
                    };

                    xhr.send(JSON.stringify(body));
                });
            }

            sendRequest('POST', requestUrl, bodyPost)
                //если успех то выполняется эта функция
                .then(data => console.log(data))
                //если ошибка то эта
                .catch(err => console.log(err))
        </pre>
    </div>
    <p><b>Маленькое замечание про безопасность</b>. Есть такая штука как origin-policy. Это значит что мы можем сделать запрос только в рамках сайта, на котором и лежит наш скрипт, если в запросе в url не совпадут протокол или домен сайта или порт, то будет ошибка. Данную опцию можно отключить, но делается это на стороне сервера. Можно обращаться на другой сайт, но это надо послать запрос на сервер, там уже php например через прокси обратится на другой сайт и вернёт ответ от него.</p>









    <p>Статья на доработке, ещё не описал толком как отсылать файл через ажакс. Обязательно разабраться что за класс FormData</p>
    <h3 class="header-style2" id="3">Пример отправки формы с помощью AJAX методом POST. В форме будут как обычные инпуты, так и с файлом</h3>
    <div class="code-style">
        <pre>
            //форма в html файле
            &lt;form id="test-form">
                &lt;p>Простое текстовое поле: &lt;input type="text" id="testfield" name="testfield" value="Тестовый ввод">&lt;/p>
                &lt;p>Выберите файл для отправки: &lt;input type="file" id="testfile" name="testfile" accept="image/*">&lt;/p>
                &lt;p>&lt;input type="submit" value="Отправить" onclick="sendForm();return false;">&lt;/p>
            &lt;/form>
            //обратим внимание на то что input type="file" имеет атрибут accept, в котором указываем форматы файлов допустимые для загрузки
            //можно указать как показанно выше, а можно перечислить форматы так - accept=".png,.jpeg,.jpg"
            //чтобы можно было выбрать несколько файлов, нужно указать атрибут - multiple у input type="file"

            let	id_product = 321;
            let qty_product = 2;

            // Создаем экземпляр класса XMLHttpRequest
            const request = new XMLHttpRequest();

            // Указываем путь до файла на сервере, который будет обрабатывать наш запрос 
            //location.href - это адресс текущей страницы
            const url = location.href + "form.php";
            
            // Так же как и в GET составляем строку с данными, но уже без пути к файлу 
            const params = "id_product=" + id_product+ "&qty_product=" + qty_product;
            
            /* Указываем что соединение	у нас будет POST, говорим что путь к файлу в переменной url, и что запрос у нас
            асинхронный, по умолчанию так и есть не стоит его указывать, еще есть 4-й параметр пароль авторизации, но этот
                параметр тоже необязателен.*/ 
            request.open("POST", url, true);
            
            //В заголовке говорим что тип передаваемых данных закодирован.
            //Я так понимаю, чтобы передать файлы, то указываем 2м параметром 'multipart/form-data' 
            request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            
            request.addEventListener("readystatechange", () => {

                if(request.readyState === 4 && request.status === 200) {       
                    console.log(request.responseText);
                }
            });
            
            //	Вот здесь мы и передаем строку с данными, которую формировали выше. И собственно выполняем запрос. 
            request.send(params);
        </pre>
    </div>








    <h3 class="header-style2" id="4">Основы ajax на jQuery</h3>
    <p>https://snipp.ru/jquery/ajax-jquery</p>
    <p>https://it-blog.ru/php/forma-obratnoj-svyazi-na-php-i-ajax/</p>
    <p>http://яжпрограммист.рф/blog/otpravka-faylov-cherez-ajax/</p>
</div>
