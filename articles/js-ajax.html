<div class="wrap">
   
    <h2 class="header-style">AJAX</h2>

    <p><b>Если нужно вспомнить о протоколе HTTP, то вот видео от Борисова</b> - https://www.youtube.com/watch?v=fsp825JA90A&t=3229s. Начиная с 01:32:00 очень подробно объясняет об этом протоколе или это видео лежит у меня на компе по адресу D:\Web\JS\Видео. Курс от специалиста\AJAX</p>

    <p><b>Хорошая статья про AJAX - <a href="https://good-code.ru/ajax-zapros/">тут</a></b></p>



    <p><b>Оглавление:</b></p>
    <ul class="list">
        <li><a href="#note">Разные заметки</a></li>
        <li><a href="#get">Передача данных методом GET через AJAX</a></li>
        <li><a href="#enctype">Кодировка русских букв и пробелов в url для AJAX запроса</a></li>
        <li><a href="#post-file">Передача файла на сервер методом POST через AJAX</a></li>
        <li><a href="#btn-form">Немного не по теме. Как отправить форму по нажатию на кнопку, которая(кнопка) не лежит внутри формы.</a></li>
        <li><a href="#btn-form-cancel">Немного не по теме. Как отменить отправку формы браузером.</a></li>
        <li><a href="#inputs">В этом разделе всё об input в форме, что и как они отправляют на сервер</a></li>
        <li><a href="#1">Статус кодов пришедших от сервера</a></li>
        <li><a href="#2">Основы ajax на чистом js</a></li>
        <li><a href="#3">Пример отправки формы без перезагрузки страницы методом POST</a></li>
        <li><a href="#4">Основы ajax на jQuery</a></li>
        <li><a href="#5"></a></li>
    </ul>






    <h3 class="header-style2" id="note">Разные заметки</h3>
    <p>Для лучшего понимания ajax, я решил в эту статью записывать всё что связанно с протоколом HTTP.</p>
    <p>Такая заметка. Когда у нас есть форма, мы её заполнили и отослали на сервер, а на сервере php файл отработал и вернул ответ, так вот браузер откроет этот ответ на той же странице где была форма. А при ajax запросе, у нас форма останентся на месте, ответ придёт в фоне в объекте xhr, откуда мы его забираем и выводим где нам нужно.</p>
    <p><b>Метод <span id="get">GET</span> и кеширование</b></p>
    <p>Заголовки запроса, которые посылает браузер не обязательны к исполнению на сервере, а вот заголовки ответа, которые посылает сервер обязательны к исполнению.</p>
    <img src="../img/Ajax, Http/method-GET.png" alt="" class="screen">
    <p>Записываю, мои заметки. Если есть форма и в ней мы записываем данные в инпуты и жмём на кнопку "Послать", то при методе GET данные склеиваются в url адрес вот так:</p>
    <div class="code-style">
        <pre>
            &lt;form action="form.php">
                &lt;input type="text" name="name">
                &lt;input type="password" name="pass">
                &lt;input type="submit" value="Послать">
            &lt;/form>

            //url - http://mysite.ru/form.php?name=Jhon&pass=123
        </pre>
    </div>
    <p>А если мы пытаемся отправить форму через ajax, то сначала запретим отправку формы браузером:</p>
    <div class="code-style">
        <pre>
            form.onsubmit = function(){
                return false;
            };
        </pre>
    </div>
    <p>Или просто кнопку выносим из формы или кнопке задаём type=button, вообщем нам надо остановить посыл формы, мы сами через ajax пошлём данные.И уже в ajax, если требуется, склеим url из данных, если нет данных, то просто указываем в url файл, на который мы делаем запрос.</p>
    <p><span id="enctype">Также</span> когда мы отправляем запрос через форму, то она кодирует передаваемый url(кодируются русские буквы, пробелы и т.д.), по умолчанию у формы атрибут <b>enctype</b> установлен в значение <b>application/x-www-form-urlencoded</b>. Так и в ajax нам надо закодировать url, можно использовать для этого конструктор URL:</p>
    <div class="code-style">
        <pre>
            //<span class="vue-b">1й способ кодировки значений</span>
            //добавим к url параметры, вида ?name=value, и правильно закодируем их
            let url = new URL(location.href + 'form.php');
            url.searchParams.set('name', inpName.value);
            url.searchParams.set('pass', inpPass.value);
            //на выходе url будет примерно выглядеть так - "http://tren/form.php?name=%D0%92%D0%B0%D1%81%D1%8F&pass=%D0%98%D0%B2%D0%B0%D0%BD%D0%BE%D0%B2"

            const xhr = new XMLHttpRequest();
            xhr.onload = function(){
                ...
            };
            //и теперь вместо склеивания самому строки url
            //xhr.open('GET', 'form.php?name=' + inpName.value + '&pass=' + inpPass.value);

            //просто передадим объект url, где уже склеины параметры, которые ему передали
            xhr.open('GET', url);
            xhr.send(null);

            //<span class="vue-b">2й способ кодирования без объект URL. Кодируются только значения инпутов. location.href можно не добавлять</span>
            let url = 'form.php?name=' + <span class="vue-g">encodeURIComponent(<span class="vue-r">inpName.value</span>)</span> + '&pass=' + <span class="vue-g">encodeURIComponent(<span class="vue-r">inpPass.value</span>)</span>;
        </pre>
    </div>
    <p>Важно!!! Пробовал отправлять GET запрос без кодирования значений инпутов и во вкладке Сеть видно что браузер отсылает запрос с уже закодированным url. Видимо в настоящее время браузер сам кодирует url. Если узнаю что то больше про это, допишу.</p>
    <p>Это мы рассматриваем пока запрос и посыл данных через метод GET.</p> 
    <p>Борисов рассказывал про такую особенность метода GET, что при этом методе некоторые браузеры кешируют пришедший от сервера ответ. Например такая задача, с помощью ajax мы посылаем запрос на php файл, который возвращает время, мы это время получаем и записываем в какой нибудь тег и вызываем эту функцию запроса времени через setInterval() внутри самой себя, делая как бы рекурсию. Запросы идут и нам каждую секунду возвращается время и у нас в браузере тикает время, но есть браузеры(IE имеется ввиду), которые кешируют сразу же после первого запроса и получается к нам вернулось время и всё оно застыло на месте, а запросы идут. В таких случаях мы в url адресе к файлу php просто приклеиваем какое нибудь число, чтобы запросы шли как бы с разным url, но на один и тот же файл - <b>xhr.open('GET', 'data.php?' + Math.random())</b>, но это считается грубым костылём. Да и вообще он это рассказывал ещё в 2015 году, как сейчас обстоят дела пока не знаю.Попробовал это сделать у себя в яндекс браузере, часы начинают тикать и через несколько секунд виснет вся страница. Короче висла она из за того, что в геометрической прогрессии начали посылаться запросы, т.е. пошёл 1 запрос, потом 2й, затем сразу 3, потом сразу 5 и из за этого переполнялся стек вызова наверно и вис сайт. Вынес setInerval за пределы функции и передал в него вызов этой функции, вроде нормально начал работать. Но чтобы вызывать из самой функции, нужно не setInterval, а setTimeout, попробовал его и всё заработало. Немного от темы отвлёкся, ну ничего полезно будет почитать. Получается, что если в функции setTimeout, то код доходит до него, он отрабатывает вызывая эту же функцию и функция отработала, её больше ничего не держит в памяти и она удаляется, а следующая вызваная эта же функция опять отрабатывает и удаляется. А при setInterval когда до него доходил код и он отрабатывал, то функция не удаляется, потому что в ней работает всё время setInterval и каждый последующий вызов вызывал подобные функции и в каждой работал setInterval, который опять же вызывал всё новые функции и все они висели в памяти и нарастали как снежный ком, поэтому и висло всё. Важно!!! НЕ надо использовать внутри функций setInterval, который вызывает эту же функцию. Как мне кажется сегодня браузеры не кешируют такие ответы как пример выше. Если столкнусь с обратным, допишу.</p>
    <div class="code-style">
        <pre>
            &lt;h2>Тиканье время&lt;/h2>
            &lt;div class="result">&lt;/div>
            &lt;button type="button">Получить&lt;/button>

            ...

            const res = document.querySelector('.result');
            const btn = document.querySelector('button');

            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    res.innerHTML = xhr.responseText;
                }
            };

            btn.addEventListener('click', getTime);

            function getTime(){
                xhr.open('GET', 'time.php');
                xhr.send(null);
                setTimeout(getTime, 1000);
            }
        </pre>
    </div>
    <p>В продолжении темы про кеширование браузером ответа. Из php скрипта можно послать заголовок ответа, который будет запрещать кешировать ответ, это делается функцией - header("Cache-Control: no-cache"). Но этот заголовок отключит кеширование, только когда браузер получил ответ, мы закрыли браузер, открыли и запросили снова ответ, тогда да он пошлёт опять запрос, а не достанет страницу из кеша, но этот заголовок не влияет на страницу, когда она удерживается в памяти. Например мы открыли страницу, потом по ссылке куда то перешли, потом вернулись по стрелке обратно и страница заново не запросилась, а взялась из памяти, где она удерживается. Как видно заголовок не повлиял на такое поведение. Для этого есть другой заголовок -  header("Cache-Control: no-store"). Вот он запрещает кеширование везде, даже в памяти. Вот картинка для установки таких настроек в файлик .htaccess:</p>
    <img src="../img/Ajax, Http/htaccess-set.png" alt="" class="screen">
    <p>Эти настройки делаются в .htaccess чтобы такие настройки действовали всегда на все страницы. Но и браузер также может посылать заголовок запроса "Cache-Control: no-cache", для того чтобы промежуточные прокси сервера у нас на пути к нашему серверу не кешировали наши посылаемые данные. Когда он это делает, тогда когда пользователь жмёт Ctrl + F5.</p>

    <p><b>Метод HEAD</b></p>
    <p>Этот метод такой же как и GET, но возвращает только заголовки ответа без тела ответа. HTTP протокол расширяем. Любой может сделать и послать самодельный заголовок запроса или ответа. И вот как пример возьмём задачу выше, которая по запросу на time.php возвращала время, но там само время возвращалось в теле ответа, а тут мы можем возвратить время в сомодельном заголовке, например назовём заголовок так - <b>header("X-My-Time: " . date("H:i:s"))</b>. X добавляем, чтобы обозначить самодельный заголовок. И теперь мы запрашиваем не всю как бы страницу, а только заголовки, где и наша  дата, что намного быстрее:</p>
    <div class="code-style">
        <pre>
            &lt;h2>Тиканье время&lt;/h2>
            &lt;div class="result">&lt;/div>
            &lt;button type="button">Получить&lt;/button>

            ...

            const res = document.querySelector('.result');
            const btn = document.querySelector('button');

            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    res.innerHTML = xhr.getResponseHeader('X-My-Time');//<span class="vue-b">и тут присваиваем значение заголовка</span>
                }
            };

            btn.addEventListener('click', getTime);

            function getTime(){
                xhr.open('HEAD', 'time.php');//<span class="vue-b">заметим, что метод уже HEAD</span>
                xhr.send(null);
                setTimeout(getTime, 1000);
            }
        </pre>
    </div>
    <p>Метод HEAD нужен для каких то быстрых вещей, например нам не нужна вся страница, а нужна коротенькая инфа с неё или нам нужны только заголоки ответа от неё, ну что то в подобном духе.</p>
    <img src="../img/Ajax, Http/fail-get-head.png" alt="" class="screen">
    
    <p><b>Метод POST</b></p>
    <img src="../img/Ajax, Http/method-post.png" alt="" class="screen">
    <p>Важно отметить, что при таком методе запроса браузер всегда посылает заголовок - "Content-Type: application/x-www-form-urlencoded", если форма отослана из веб-формы. На стороне сервера в глобальный массив $_POST в php данные из формы попадают ТОЛЬКО если они пришли из веб-формы и сервер понимает что они пришли из веб-формы как раз по этому заголовку запроса, либо в заголовке может быть другое значение "Content-Type: multipart/form-data" для файлов, тогда данные раскидываются в $_POST и в $_FILES или только в $_FILES. Т.е. ещё раз, если на сервер пришли данные формы и нету таких заголовков как Content-Type или в них какое то непонятное занчение, то сервер пришедшие данные не раскидает по массивам $_POST, $_FILES.</p>
    <p>Так как форма методом post передаёт тело запроса, то и есть соответствующий заголовок запроса "Content-Length: 76", который в байтах показывает длину этого тела.</p>
    <p>Ещё один важный заголовок при методе post, который посылает браузер из формы это "Referer: http://mysite.local/demo/demo.html". При методе GET он может быть, а может и не быть. Там мы руками набираем в строке запроса адрес и являемся отправителями мы сами, ну или жмём по ссылке, а у ссылке есть адрес, тогда реферер будет. А при методе post отправителем являетя страница где находится форма и этот заголовок браузер пошлёт обязательно.</p>
    <p>Для чего эти заголовки важно знать и нам и на сервере. Например на сервере скрипт может определять, подсоединился к сайту бот или нормальный браузер. Он просто проверяет, что форма послана через метод post и смотрит все эти заголовки запроса, чтобы они были, так как браузер всегда их пришлёт, а бот может какой-то из заголовков пропустить, так не хитрым способом и вычисляют ботов. Хотя думаю что сегодня боты намного умней, чем в 2015 году). Ну и мы хотим посылать данные методом post через XMLHttpRequest, а там далеко не всё он может сделать за нас, поэтому нужно будет вручную посылать все эти заголовки, чтобы нас приняли за нормальный браузер или использовать класс FormData для сбора данных с инпутов, он за нас посылает все эти заголовки.</p>
    <p>Ну и теперь переходим к тому как же послать запрос методом post через ajax. Например возьмём пример с запросом книг от сервера. У нас есть 2 инпута, один просит ввода автора, другой название книги:</p>
    <div class="code-style">
        <pre>
            &lt;form action="books.php" method="post" enctype="application/x-www-form-urlencoded" onsubmit="return false">
                &lt;input type="text" name="name_author" value="">
                &lt;input type="text" name="name_book" value="">
                &lt;button class="btn">Запросить&lt;/button>
            &lt;/form>


            const inpNameAuthor = document.querySelector('input[name=name_author]');
            const inpNameBook = document.querySelector('input[name=name_book]');
            const btn = document.querySelector('.btn');


            const xhr = new XMLHttpRequest();
            xhr.onload = function(){
                //получаем ответ и что то делаем с ним
            };

            btn.addEventListener('click', getRequest);

            function getRequest(){
                let searchString = 'author=' + encodeURIComponent(inpNameAuthor.value) + '&' + 'book=' + encodeURIComponent(inpNameBook.value);

                //указываем 2м параметром просто имя скрипта, на который делаем запрос
                xhr.open('POST', 'books.php');

                //посылаем заголовок Content-Type со значением application/x-www-form-urlencoded, подражая как-будто это браузер послал форму
                //без этого заголовка XMLHttpRequest пошлёт Content-Type со значением text/plain - это 3е значение у формы атрибута enctype
                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

                //когда я посылаю заголовок с количеством байт тела запроса, то браузер ругается что я не могу его установить, потому как это не
                //безопасно. Он сам считает и посылает количество, так что не нужно посылать этот заголовок
                //xhr.setRequestHeader('Content-Length', searchString.length);
                
                //тело с данными передаётся сюда
                xhr.send(searchString);
            }
        </pre>
    </div>
    <p>Заголовок Referer XMLHttpRequest тоже сам посылает, так как посылателем запроса всё равно является страница. Получается, чтобы мы получили на стороне сервера в файле books.php в массиве $_POST переданные от клиента данные через ajax, нужно обязатально послать заголовок Content-Type с одним из 2х значений, иначе мы не обнаружим в массиве $_POST этих данных. Есть наверно другие пути получения этих данных, но пока я их не знаю. Если послать значение text/plain(это 3е значение атрибута enctype у веб-формы) в этом заголовке, то массив $_POST также будет пуст.</p>
    <p><span id="post-file">Теперь</span> посмотрим как передать файл/файлы на сервер с помощью AJAX. У меня уже есть пример, где мы загружаем в браузер выбранные файлы с компьютера, он не до конца сделан, потому что Минин там организовал загрузку на сервер через FireBase. Нужно доделать его и загрузить файлы на php и обработать там их. По этому пути лежит этот пример - D:\Web\JS\A. Скрипты, плагины с объяснениями как и что делается. Итак продолжим. Файлы передаются на сервер методом POST, так как они занимают большой объём данных. Чтобы отправить файл на сервер используется класс FormData, в объект которого мы записываем файл и этот объект отсылаем:</p>
    <div class="code-style">
        <pre>
            //CSS
            .text{
                display: none;
            }
            .img{
                display: none;
            }
            .img img{
                width: 15px;
            }

            //HTML
            &lt;form action="handler.php" method="post" onsubmit="return false">
                &lt;input type="text" name="name">
                &lt;input type="text" name="age">
                &lt;input type="file" id="file">
                &lt;button class="btn">Отправить&lt;/button>
                &lt;span class="text">Отправлен&lt;/span>
                &lt;span class="img">&lt;img src="img/ZKZg.gif" alt="gif">&lt;/span>
                //эта картинка гифка показывает загрузку данных, пока она крутится загрузка идёт
            &lt;/form>


            //JS
            const inpFile = document.querySelector('input#file');
            const inpName = document.querySelector('input[name=name]');
            const inpAge = document.querySelector('input[name=age]');
            const btn = document.querySelector('.btn');
            const spanSendText = document.querySelector('.text');
            const spanImg = document.querySelector('.img');


            const xhr = new XMLHttpRequest();
            xhr.onload = function(){
                if(xhr.response === '1'){
                    //на сервере файл получен, что то там с ним с делали и вернули ответ '1', обозначающий, что файл получен на сервере
                    //если ответ вернулся, то убираем гифку и пишем текст "Отправлен" вызовом функции howSendText()
                    showSendText();
                }
            };

            btn.addEventListener('click', getRequest);

            function getRequest(e){
                //запрещаем кнопке србатывать на событие отправки формы submit(по умолчанию у кнопки тип submit)
                e.preventDefault();

                const file = inpFile.files[0];
                
                if(file != null){
                    const data = new FormData();

                    //в этот объект записываем данные с инпута, заметим, что данные можно смешанные записывать, и с обычных инпутов и с типом "файл"
                    //браузер сам распределит их. И заголовок "Content-type" самостоятельно установит в данном случае в значение multipart/form-data
                    data.append('files', file);
                    data.append('name', inpName.value);
                    data.append('age', inpAge.value);

                    
                    xhr.open('POST', 'handler.php');
                    xhr.send(data);
                    showImg();
                }
            }

            function showSendText(){
                spanImg.style.display = 'none'
                spanSendText.style.display = 'inline';
            }

            function showImg(){
                spanImg.style.display = 'inline'
                spanSendText.style.display = 'none';
            }
        </pre>
    </div>

    <p><b><span id="btn-form">Немного</span> не по теме. Как отправить форму по нажатию на кнопку, которая(кнопка) не лежит внутри формы.</b></p>
    <p>Первый способ это задать форме id и далее кнопке задать атрибут form в значение которого вставляем значение id формы:</p>
    <div class="code-style">
        <pre>
            &lt;form action="" id="abc">
                &lt;input type="text" name="name">
            &lt;/form>
            &lt;button form="abc">Отправить&lt;/button>
        </pre>
    </div>
    <p>Второй способ это через js, находим кнопку, находим форму и вешаем на кнопку событие клика и по клику посылаем форму:</p>
    <div class="code-style">
        <pre>
            &lt;form action="" id="abc">
                &lt;input type="text" name="name">
            &lt;/form>
            &lt;button form="abc">Отправить&lt;/button>

            const f = document.querySelector('f');
            const b = document.querySelector('button');

            b.addEventListener('click', function(){
                f.submit();
            });
        </pre>
    </div>


    <p><b><span id="btn-form-cancel">Немного</span> не по теме. Как отменить отправку формы браузером</b></p>
    <p>Первое это задать форме событие submit и в обработчике этого события вернуть false или вызвать e.preventDefault()</p>
    <p>Второе, если кнопка отправки лежит в форме, то при клике по ней вызвать в её обработчике также e.preventDefault()</p>



     
   
   <h3 class="header-style2" id="inputs">В этом разделе всё об input в форме, что и как они отправляют на сервер</h3>
    <p><b>input[type="checkbox"]</b></p>
    <p>Когда я пытался через AJAX отправить состояние чекбокса на сервер, то он всё время выдывал в значении value - on. Это значение установленно по умолчанию. Я включаю чекбокс или выключаю, всё равно отправляет на сервер значение "on". Когда мы отправляем значение чекбокса через форму, то при выключенном чекбоксе форма просто не отправляет его значение, а при включенном отправляет "on". Через AJAX что то не получается отправить значение при выключенном состоянии, поэтому советуют использовать атрибут "checked" у этого инпута. При включённом checked будет равен true, при выключенном соответственно false. Считываем в AJAX этот атрибут и посылаем булево значение.</p>






    <h3 class="header-style2" id="1">Стутус кодов пришедших от сервера</h3>
    <img src="../img/Ajax, Http/status-code.png" alt="" class="screen">
    <ul class="list">
        <li><b>200</b> - успешно пришёл ответ</li>
        <li><b>301</b> - постоянная переадресация. Вместе с 301, 302 статусами мы ждём заголовка Location, в котором указан новый адрес, на который надо перейти</li>
        <li><b>302</b> - временная переадресация, говорит о том что сайт временно перемещён в другую папку, поэтому обращаться нужно всё время по старому адресу с перенаправлением, потому как сайт когда то вернётся на старый алрес, а если пришёл 301 статус, то мы как бы делаем выводы, что сайт на постоянку переместили и значит надо обновить его адрес на новый.</li>
        <li><b>304</b> - объект не изменился. Статус с вязан с кешированием(сохранением). Когда пришли с сервера все ресурсы(страница, картинка, стили ит.д.) браузер, если не было никаких команд как кешировать, кеширует по умолчанию эти ресурсы(зависит от браузеров) и когда пользователь снова обращается к этим ремурсам, то браузер видя, что они лежат в кеше пока не показывает их, он отправляет спец. запрос с определённым заголовком If Modified Syns(как то так со слов Борисова), где указывает значение из предыдущего заголовка ответа Last Modified, мол страница изменилась или всё та же, сервер вернёт страницу в случае того если страница изменилась со статусом 200 OK, если нет то сервер просто вернёт статус 304 и браузер вытащит эту страницу из кеша и покажет пользователю. Откуда сервер берёт инфу о том когда менялся файл? Если это статическая html страница, то он просто смотрит в свойствах файла дату изменения(имеется в виду когда мы кликаем на компе правой кнопкой мыши по файлу вылетает контекстное меню и в этом меню в самом низу свойства файла), вот в таких примерно свойствах смотрит сервер. А вот если файл hml динамически создаётся на лету, то тут уже серверу не посмотреть его дату изменения, потому как лежит файл php созданный давно, а html страницы он создаёт и изменяет постоянно, для таких динамических файлов сервер не посылает заголовок Last Modified, а значит и браузер не может послать заголовок валидатор If Modified Syns, из этого вытекает, что такие файлы браузер не кеширует и запрашивает постоянно. Поэтому программисты скрипта php или др. языка должны в созданных на лету страницах принудительно сами посылать заголовок Last Modified раз это не делает сервер, чтобы браузер мог их кешировать.</li>
        <li><b>400</b> - bad request. Такой статус сервер пришлёт если послать запрос без заголовка запроса Host, который обязателен</li>
        <li><b>401</b> - отсутствие авторизации. Четырёхсотые статусы это ошибки клиента(адрес не правильно вбил ну и в таком роде)</li>
        <li><b>403</b> - запрещено. Запрещено исполнение запрашиваемого файла, запрещён просмотр директории.</li>
        <li><b>404</b> - html не найден(страница не найдена). Есть статус похожий на него это 410, он говорит что объект был, но теперь его нет, что позволяет нам сразу понять что мы в адресе не ошиблись, просто объект удалили, а вот при 404 не понятно мы ошиблись или объект удалили и начинаем ковырять этот адрес и так ии сяк теряя время.</li>
        <li><b>404</b> - метод не поддерживается(сервер может ограничить доступ к файлам определённым методам, например POST, только через GET). Сервер Apache не поддерживает этот статус, вместо него он возваращает статус 403, что в корне не верно.</li>
        <li><b>500</b> - ошибка сервера</li>
        <li></li>
        <li></li>
    </ul>












    <h3 class="header-style2" id="2">Основы ajax на чистом js</h3>
    <p>Объект XMLHttpRequest это мини браузер, он делает тоже самое что и браузер, когда мы посылаем форму на сервер, браузер перед посылкой формы собирает все её данные, создаёт соединение, данные запихивает в тело запроса, также создаёт заголовки запроса и т.д. Несмотря на наличие слова «XML» в названии, XMLHttpRequest может работать с любыми данными, а не только с XML. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое. На сегодняшний день не обязательно использовать XMLHttpRequest, так как существует другой, более современный метод fetch. В современной веб-разработке XMLHttpRequest используется по трём причинам:</p>
    <ol class="list">
        <li>Существует много кода, использующего XMLHttpRequest, который нужно поддерживать.</li>
        <li>Необходимость поддерживать старые браузеры и нежелание использовать полифилы</li>
        <li>Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.</li>
    </ol>
    <p>Ajax это не только использование браузерного объекта XMLHttpRequest, но это и :</p>
    <ul class="list">
        <li>Динамическое создание дочерних фреймов</li>
        <li>Динамическое создание элемента &lt;script></li>
        <li>Динамическое создание элемента &lt;img>, например, const img = new Image(); img.src = 'img/img.png'; и сразу же создаётся соединение  с сервером и запрашивается картинка по указанному адресу, но тут никто не использует объект XMLHttpRequest. Единственное пока не понятно
        когда именно идёт запрос картинки на сервер, когда уже вставили в DOM дерево этот тег img или когда в js к этому тегу присвоили src и путь.Борисов говорит, что при создании картинки через new Image() и присваивании ему src сразу идёт запрос этой картинки на фоне. И такие запросы идут только с методом GET.</li>
    </ul>
    <p>Потому как веб-сокеты используют тот же способ соединения с сервером, но они это делают без объекта XMLHttpRequest.</p>
    <p>Как работает Ajax? Браузер загрузил страницу и всё, он отдыхает, а вот посылами ajax запросов уже занимается js:</p>
    <div class="code-style">
        <pre>
            //<span class="vue-b">составляем url</span>
            const url = location.href + "form.php" + "?" + дальше тут можно перечислять параметры полученные из формы или ещё откуда то;
            //<span class="vue-b">можно даже в url указать просто имя файла, на который мы делаем запрос, а протокол и наш сайт(домен) добавятся автоматом</span>
            //<span class="vue-b">как я понял запрос можно делать даже к обычным файлам, которые у нас лежат в папке на сервере, например к файлу text.txt и нам вернётся то, что лежит в этом файле</span>

            //<span class="vue-b">создаём объект для работы с сетевыми запросами, у конструктора нет аргументов</span>
            const xhr = <span class="vue-b">new</span> <span class="vue-r">XMLHttpRequest()</span>;
            
            //<span class="vue-b">этот метод подготавливает запрос</span>
            request.<span class=vue-g>open</span>(method, url, [async, user, password]); 
            //<span class="vue-b">method - это способ отправки запроса, например, GET или POST</span>
            //<span class="vue-b">url - это адрес, по которому мы хотим получить ответ. Может быть и объект URL</span>
            //<span class="vue-b">async - если указать false, тогда запрос будет выполнен синхронно, по умолчанию true</span>
            //<span class="vue-b">user, password – логин и пароль для базовой HTTP-авторизации (если требуется).</span>

            <span class="vue-b">указываем, чтобы пришедший ответ в виде json строки сразу распарсился в js объект</span>
            request.<span class=vue-g>responseType</span> = 'json';
            
            //<span class="vue-b">этот метод устанавливает соединение и отсылает запрос к серверу, null - запрос отсылается методом GET, иначе передаём body - тело запроса при методе POST</span>
            request.<span class=vue-g>send</span>(null);
        </pre>
    </div>
    <p>Ajax есть <b>асинхронный</b> и <b>синхронный</b>. Чем они отличаются? Когда интерпритатор читает код и доходит до строки request.send(), то при синхронном запросе идёт посыл запроса и js на время замирает и код дальше не выполняется, пока не придёт ответ от сервера. Как только пришёл ответ, интерпритатор дальше  исполнять код.</p>
    <p>Когда используют синхронный запрос? Тогда когда нам нужно быть уверенными, что данные пришли с сервера, потому что нижележащий js код зависит от этих данных.</p>
    <p>При <b>асинхронном</b> запросе, данные когда придут тогда и придут. Для этого есть такое событие как <b>onreadystatechange</b>. Когда данные прийдут и сработает это событие, то запустится функция, которая что то там сделает, но это событие срабатывает все 4 раза на все стадии(readyState) состояния запроса.</p>
    <p>А как событие поймёт что нужно сработать? Для этого у объекта XMLHttpRequest есть 4 стадии состояния запроса. Отвечает за эти стадии свойство <b>readyState</b>, которое будет иметь одно из 4х значений это 1, 2, 3 или 4. Первая стадия это послыка данных, вторая это сервер принял, третья это сервер данные отправляет обратно и четвёртая - данные пришли.</p>
    <p>Когда прийдёт ответ от сервера, то текст этого ответа положится в свойство <b>request.responseText</b>. Но в ответе также есть и заголовки ответа(<b>request.getAllResponseHeaders()</b>) и можно получить какой нибудь 1 заголовок ответа(<b>request.getResponseHeader('Last-Modified')</b>) и статус кода ответа(<b>request.status</b>) и  текст статуса кода ответа(<b>request.statusText</b>).:</p>
    <div class="code-style">
        <pre>
            //<span class="vue-b">чтобы получить ответ есть 4 события - readystatechange, load, error, progress</span>
            //<span class="vue-b">load - происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.</span>
            //<span class="vue-b">error - когда запрос не может быть выполнен, например, нет соединения или невалидный URL.</span>
            //<span class="vue-b">progress - происходит периодически во время загрузки ответа, сообщает о прогрессе.</span>

            xhr.<span class="vue-g">onload</span> = function() {
                alert(`Загружено: ${xhr.status} ${xhr.response}`);
            };

            //<span class="vue-b">происходит, только когда запрос совсем не получилось выполнить</span>
            xhr.<span class="vue-g">onerror</span> = function() { 
                alert(`Ошибка соединения`);
            };

            // <span class="vue-b">запускается периодически</span>
            xhr.<span class="vue-g">onprogress</span> = function(event) { 
                // <span class="vue-b">event.loaded - количество загруженных байт</span>
                // <span class="vue-b">event.lengthComputable = равно true, если сервер присылает заголовок Content-Length</span>
                // <span class="vue-b">event.total - количество байт всего (только если lengthComputable равно true)</span>
                alert(`Загружено ${event.loaded} из ${event.total}`);
            };

            xhr.<span class="vue-g">onreadystatechange</span> = function(){
                //указываем, что дальше условия код выполнится только при request.readyState === 4, потому как это событие срабатывает на все 4 стадии состояния запроса
                if(xhr.<span class="vue-g">readyState</span> === 4){
        
                    //<span class="vue-b">2 эти строки кода возвращают ответ в виде строки, request.responseText возвращает только тело ответа без заголовков ответа</span>
                    //<span class="vue-b">обычно приходит json строка с объектом внутри, чтобы достать объект из строки мы его парсим JSON.parse(xhr.responseText)</span>
                    //<span class="vue-b">но можно сразу указать тип ответа, например после строки кода с request.open() укажем такую строку - xhr.responseType = 'json'</span>
                    //<span class="vue-b">и нам сразу придёт распарсеный объект</span>
                    console.log(xhr.<span class="vue-g">response</span>);
                    console.log(xhr.<span class="vue-g">responseText</span>);
        
                    //<span class="vue-b">покажет число статуса ответа - 200 404 и т.д.</span>
                    console.log(xhr.<span class="vue-g">status</span>);

                    //<span class="vue-b">при 200 это OK, при 404 это Not Found, Forbidden для 403, и так далее</span>
                    console.log(xhr.<span class="vue-g">statusText</span>);
        
                    //<span class="vue-b">вывести все заголовки ответа</span>
                    console.log(xhr.<span class="vue-g">getAllResponseHeaders</span>());
        
                    //<span class="vue-b">вывести указанный заголовок ответа</span>
                    console.log(xhr.<span class="vue-g">getResponseHeader</span>('Last-Modified'));
        
                    //<span class="vue-b">пока не знаю</span>
                    console.log(xhr.<span class="vue-g">statusText</span>);

                }
            };
            xhr.<span class="vue-g">open</span>(method, url, true);
            xhr.<span class="vue-g">send</span>(null);

            // <span class="vue-b">мы можем также указать таймаут – промежуток времени, который мы готовы ждать ответ. Если запрос не успевает выполниться в установленное время, то он прерывается, и происходит событие timeout.</span>
            xhr.<span class="vue-g">timeout</span> = 10000;

            xhr.<span class="vue-g">ontimeout</span> = function(){
                xhr.<span class="vue-g">abort</span>();
                console.log('Запрос окончен за истечением времени ожидания');
            };
        </pre>
    </div>
    <p>Вот полный пример:</p>
    <div class="code-style">
        <pre>
            // 1. Создаём новый XMLHttpRequest-объект
            let xhr = new XMLHttpRequest();

            // 2. Настраиваем его: GET-запрос по URL /article/.../load
            xhr.open('GET', '/article/xmlhttprequest/example/load');

            // 3. Этот код сработает после того, как мы получим ответ сервера
            xhr.onload = function() {
                if (xhr.status != 200) { // анализируем HTTP-статус ответа, если статус не 200, то произошла ошибка
                    alert(`Ошибка ${xhr.status}: ${xhr.statusText}`); // Например, 404: Not Found
                } else { // если всё прошло гладко, выводим результат
                    alert(`Готово, получили ${xhr.response.length} байт`); // response -- это ответ сервера
                }
            };

            xhr.onprogress = function(event) {
                if (event.lengthComputable) {
                    alert(`Получено ${event.loaded} из ${event.total} байт`);
                } else {
                    alert(`Получено ${event.loaded} байт`); // если в ответе нет заголовка Content-Length
                }
            };

            xhr.onerror = function() {
                alert("Запрос не удался");
            };

            // 4. Отсылаем запрос
            xhr.send();

        </pre>
    </div>




    <p>Чтобы работать нормально с асинхронным кодом, то мы создадим функцию и вернём промис:</p>
    <div class="code-style">
        <pre>
            const requestUrl = 'https://yandex.ru';
            //в эту переменную в объект заполняем данные из формы
            const bodyPost = {
                name: 'Jhon',
                age: 23,
            };

            function sendRequest(method, url, body = null){
                return new Promis(function(resolve, reject){
                    const xhr = new XMLHttpRequest();

                    xhr.open(method, url);
                    xhr.responseType = 'json';
                    xhr.onload = function(){
                        if(xhr.status >= 400){
                            reject(xhr.response);
                        }else{
                            resolve(xhr.response);
                        }
                    };
                    xhr.onload = function(){
                        reject(xhr.response);
                    };

                    xhr.send(JSON.stringify(body));
                });
            }

            sendRequest('POST', requestUrl, bodyPost)
                //если успех то выполняется эта функция
                .then(data => console.log(data))
                //если ошибка то эта
                .catch(err => console.log(err))
        </pre>
    </div>
    <p><b>Маленькое замечание про безопасность</b>. Есть такая штука как origin-policy. Это значит что мы можем сделать запрос только в рамках сайта, на котором и лежит наш скрипт, если в запросе в url не совпадут протокол или домен сайта или порт, то будет ошибка. Данную опцию можно отключить, но делается это на стороне сервера. Можно обращаться на другой сайт, но это надо послать запрос на сервер, там уже php например через прокси обратится на другой сайт и вернёт ответ от него.</p>









    <p>Статья на доработке, ещё не описал толком как отсылать файл через ажакс. Обязательно разабраться что за класс FormData</p>
    <h3 class="header-style2" id="3">Пример отправки формы с помощью AJAX методом POST. В форме будут как обычные инпуты, так и с файлом</h3>
    <div class="code-style">
        <pre>
            //форма в html файле
            &lt;form id="test-form">
                &lt;p>Простое текстовое поле: &lt;input type="text" id="testfield" name="testfield" value="Тестовый ввод">&lt;/p>
                &lt;p>Выберите файл для отправки: &lt;input type="file" id="testfile" name="testfile" accept="image/*">&lt;/p>
                &lt;p>&lt;input type="submit" value="Отправить" onclick="sendForm();return false;">&lt;/p>
            &lt;/form>
            //обратим внимание на то что input type="file" имеет атрибут accept, в котором указываем форматы файлов допустимые для загрузки
            //можно указать как показанно выше, а можно перечислить форматы так - accept=".png,.jpeg,.jpg"
            //чтобы можно было выбрать несколько файлов, нужно указать атрибут - multiple у input type="file"

            let	id_product = 321;
            let qty_product = 2;

            // Создаем экземпляр класса XMLHttpRequest
            const request = new XMLHttpRequest();

            // Указываем путь до файла на сервере, который будет обрабатывать наш запрос 
            //location.href - это адресс текущей страницы
            const url = location.href + "form.php";
            
            // Так же как и в GET составляем строку с данными, но уже без пути к файлу 
            const params = "id_product=" + id_product+ "&qty_product=" + qty_product;
            
            /* Указываем что соединение	у нас будет POST, говорим что путь к файлу в переменной url, и что запрос у нас
            асинхронный, по умолчанию так и есть не стоит его указывать, еще есть 4-й параметр пароль авторизации, но этот
                параметр тоже необязателен.*/ 
            request.open("POST", url, true);
            
            //В заголовке говорим что тип передаваемых данных закодирован.
            //Я так понимаю, чтобы передать файлы, то указываем 2м параметром 'multipart/form-data' 
            request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            
            request.addEventListener("readystatechange", () => {

                if(request.readyState === 4 && request.status === 200) {       
                    console.log(request.responseText);
                }
            });
            
            //	Вот здесь мы и передаем строку с данными, которую формировали выше. И собственно выполняем запрос. 
            request.send(params);
        </pre>
    </div>








    <h3 class="header-style2" id="4">Основы ajax на jQuery</h3>
    <p>https://snipp.ru/jquery/ajax-jquery</p>
    <p>https://it-blog.ru/php/forma-obratnoj-svyazi-na-php-i-ajax/</p>
    <p>http://яжпрограммист.рф/blog/otpravka-faylov-cherez-ajax/</p>
</div>
