<div class="wrap">
   
    <h2 class="header-style">AJAX</h2>
    <h3 class="header-style2">Основы ajax приложений</h3>
    <p>Ajax это не только использование браузерного объекта XMLHttpRequest, но это и :</p>
    <ul class="list">
        <li>Динамическое создание дочерних фреймов</li>
        <li>Динамическое создание элемента &lt;script></li>
        <li>Динамическое создание элемента < img></li>
    </ul>
    <p>Потому как веб-сокеты используют тот же способ соединения с сервером, но они это делают без объекта XMLHttpRequest.</p>
    <p>Как работает Ajax? Браузер загрузил страницу и всё, он отдыхает, а вот посылами ajax запросов уже занимается js.</p>
    <p><b>Методы</b></p>
    <div class="code-style">
    <pre>
        let request = new XMLHttpRequest();
        
        request.<span class=vue-g>open</span>('method', 'url', false); //этот метод подготавливает соединение с сервером
        //method - это способ отправки запроса, например, GET или POST
        //url - это адрес, по которому мы хотим получить html файл с ответом
        //false - говорит нам о том , что запрос синхронный
        
        request.<span class=vue-g>send</span>(null);// этот метод уже отправляет запрос на сервер, в параметрах стоит null, потому что ушёл GET запрос, если бы был POST, то вместо null мы бы писали бы тело POST запроса.
    </pre>
    </div>
    <p>Ajax есть <b>асинхронный</b> и <b>синхронный</b>. Чем они отличаются? Кода интерпритатор читает код и доходит до строки request.send(), то при синхронном запросе идёт посыл запроса и js на время замирает и код дальше не выполняется, пока не придёт ответ от сервера. Как только пришёл ответ, интерпритатор дальше  исполнять код.</p>
    <p>Когда используют синхронный запрос? Тогда когда нам нужно быть уверенными, что данные пришли с сервера, потому что нижележащий js код зависит от этих данных.</p>
    <p>При <b>асинхронном</b> запросе, данные когда придут тогда и придут. Для этого есть такое событие как <b>onreadystatechange</b>. Когда данные прийдут и сработает это событие, то запустится функция, которая что то там сделает:</p>
    <div class="code-style">
    <pre>
        request.<span class="vue-g">onreadystatechange</span> = function(){};
    </pre>
    </div>
    <p>А как событие поймёт что нужно сработать? Для этого у объекта XMLHttpRequest есть 4 этапа посыла и возвращение запроса. Отвечает за эти этапы свойство <b>readyState</b>, котрое будет иметь одно из 4х значений это 1, 2, 3 или 4. Первый этап это послыка данных, второй это сервер принял, третий это данные идут обратно и четвёртый - данные пришли.</p>
    <p>Когда прийдёт ответ от сервера, то текст этого ответа положится в свойство <b>request.responseText</b>. Но в ответе также есть и заголовки ответа(<b>request.getAllResponseHeaders()</b>) и можно получить какой нибудь 1 заголовок ответа(<b>request.getResponseHeader('Last-Modified')</b>) и статус ответа(<b>request.status</b>) и  текст статуса ответа(<b>request.statusText</b>).:</p>
    <div class="code-style">
    <pre>
        let request = new XMLHttpRequest();
        request.<span class="vue-g">onreadystatechange</span> = function(){
            if(request.readyState === 4){
                console.log(request.responseText);
                console.log(request.status);// покажет число статуса ответа - 200 404 и т.д.
                console.log(request.getAllResponseHeaders());
                console.log(request.getResponseHeader('Last-Modified'));
                console.log(request.statusText);
            }
        };
        request.open('method', 'url', true);
        request.send(null);
    </pre>
    </div>
    <p><b>Маленькое замечание про безопасность</b>. Есть такая штука как origin-policy. Это значит что мы можем сделать запрос только в рамках сайта, на котором и лежит наш скрипт, если в запросе в url не совпадут протокол или домен сайта или порт, то будет ошибка. Данную опцию можно отключить, но делается это на стороне сервера.</p>
</div>