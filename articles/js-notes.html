<div class="wrap">
   
    <h2 class="header-style">Разные заметки в JS</h2>
    
    <div class="note">При работе методов <b>querySelector()</b> и <b>querySelectorAll()</b> в ответ мы получаем псевдомассив NodeList. Это псевдомассив умеет работать с методом forEach(). А вот при работе методов <b>getElementsByTagName()</b> и ему подобных возвращается HTMLCollection, это тоже псевдомассив, но самообновляющийся и он уже не может работать с методо forEach(). Откуда у псевдомассива NodeList есть методы массивов пока не знаю, узнаю допишу.</div>




    <div class="note"><b>Object.keys</b> возвращает только собственные ключи</div>





    <div class="note">Цикл <b>for..in</b> проходит не только по собственным, но и по унаследованным свойствам объекта. Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.  for..in игнорирует символьные и неперечислимые свойства(свойства у которых enumerable установлен в false). Встроенный метод toString в объектах – неперечислимый, его не видно в цикле <b>for..in</b>. Но если мы напишем свой собственный метод toString, цикл for..in будет выводить его по умолчанию. Если мы этого не хотим, можно установить для свойства enumerable: false. Тогда оно перестанет появляться в цикле for..in аналогично встроенному toString:
    <div class="code-style">
        <pre>
            let user = {
                name: "John",
                toString() {
                    return this.name;
                }
                };
                
                Object.defineProperty(user, "toString", {
                enumerable: false
                });
                
                // Теперь наше свойство toString пропало из цикла:
                for (let key in user) alert(key); // name
        </pre>
    </div>
    Неперечислимые свойства также не возвращаются Object.keys(user).
    </div>




    <div class="note">Есть такое утверждение, что <b>стрелочные ф-ии</b> не имеют <b>this</b>. Что это значит? Это значит то, что обычные ф-ии и методы при вызове создают лексическое окружение и в него также записывается this = объект перед точкой вызвавший эту ф-ю или метод, а вот при вызове стрелочной ф-ии в его лекс. окр-е this не записывается, this воспринимается просто как внешняя переменная, которую нужно пойти и взять из первого внешнего лекс. окр-я. То же самое и с переменной <b>arguments</b>, стрелочная ф-я его также не имеет и берёт из внешнего лес. окр-я. Ну и стрелочная ф-я не подходит для создания из неё функции-конструктора, она не работает с <b>new</b>.</div>


    <h3 class="header-style2">Различия в циклах</h3>
    <div class="note">
        <ol class="list">
            <li>Если в массиве есть пустые значения равные undefined, то при переборе его в обычном for(), эти значения undefined тоже выведутся, в for...in они не выведутся, в for...of выведутся.</li>
            <li>Отличие for...in от for...of  в том, что в переменную key попадает ключ, а в for...of туда попадает сразу значение(for...of используется тогда, когда не нужны ключи)</li>
            <li></li>
        </ol>
    </div>

</div>
