<div class="wrap">
   
    <h2 class="header-style">Разные заметки в JS</h2>

    <ul class="list">
        <li><a href="#1">Различия в циклах for(), for...in, for...of</a></li>
        <li><a href="#2">JQuery плагины</a></li>
        <li><a href="#3">Затыки со Swiper, которые мне встречаются</a></li>
        <li><a href="#4">Заметки про метод <b>addEventListener</b></a></li>
        <li><a href="#5">Как затемнить фон в блоке html</a></li>
        <li><a href="#6">Как зафиксировать блок при прокрутке</a></li>
        <li><a href="#7">Как подключить шрифт локально, а не удалённо</a></li>
        <li><a href="#8"></a></li>
        <li><a href="#9"></a></li>
        <li><a href="#10"></a></li>

    </ul>
    
    <div class="note">При работе методов <b>querySelector()</b> и <b>querySelectorAll()</b> в ответ мы получаем псевдомассив NodeList. Это псевдомассив умеет работать с методом forEach(). А вот при работе методов <b>getElementsByTagName()</b> и ему подобных возвращается HTMLCollection, это тоже псевдомассив, но самообновляющийся и он уже не может работать с методо forEach(). Откуда у псевдомассива NodeList есть методы массивов пока не знаю, узнаю допишу.</div>

   
   
    <div class="note">Есть такое утверждение, что <b>стрелочные ф-ии</b> не имеют <b>this</b>. Что это значит? Это значит то, что обычные ф-ии и методы при вызове создают лексическое окружение и в него также записывается this = объект перед точкой вызвавший эту ф-ю или метод, а вот при вызове стрелочной ф-ии в его лекс. окр-е this не записывается, this воспринимается просто как внешняя переменная, которую нужно пойти и взять из первого внешнего лекс. окр-я. То же самое и с переменной <b>arguments</b>, стрелочная ф-я его также не имеет и берёт из внешнего лес. окр-я. Ну и стрелочная ф-я не подходит для создания из неё функции-конструктора, она не работает с <b>new</b>.</div>
   


    <h3 class="header-style2" id="1">Различия в циклах</h3>
    <div class="note">
        <ol class="list">
            <li>Если в массиве есть пустые значения равные undefined, то при переборе его в обычном for(), эти значения undefined тоже выведутся, в for...in они не выведутся, в for...of выведутся.</li>
            <li>Отличие for...in от for...of  в том, что в переменную key попадает ключ, а в for...of туда попадает сразу значение(for...of используется тогда, когда не нужны ключи)</li>
            <li>>Цикл <b>for..in</b> проходит не только по собственным, но и по унаследованным свойствам объекта. Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.  for..in игнорирует символьные и неперечислимые свойства(свойства у которых enumerable установлен в false). Встроенный метод toString в объектах – неперечислимый, его не видно в цикле <b>for..in</b>. Но если мы напишем свой собственный метод toString, цикл for..in будет выводить его по умолчанию. Если мы этого не хотим, можно установить для свойства enumerable: false. Тогда оно перестанет появляться в цикле for..in аналогично встроенному toString:
                <div class="code-style">
                    <pre>
                        let user = {
                            name: "John",
                            toString() {
                                return this.name;
                            }
                            };

                            Object.defineProperty(user, "toString", {
                            enumerable: false
                            });

                            // Теперь наше свойство toString пропало из цикла:
                            for (let key in user) alert(key); // name
                       </pre>
                   </div>
                   Неперечислимые свойства также не возвращаются Object.keys(user).
               </li>
               <li><b>Object.keys</b> возвращает только собственные ключи.</li>
        </ol>
    </div>




    <h3 class="header-style2" id="2">JQuery плагины</h3>
    <div class="note">
        <ul class="list">
            <li><b>DatePicker</b> - это мощный и простой в использовании jQuery плагин, который позволяет добавлять к простому текстовому полю виджет — календарь для выбора даты.</li>
        </ul>
    </div>



    <h3 class="header-style2" id="3">Затыки со Swiper, которые мне встречаются</h3>
    <div class="note">
        <ul class="list">
            <li>Была такая ситуация, был flex контейнер и в нём было 2 flex элемента - левый сайдбар и правый с содержимым. Вот в правой части я разместил swiper, но при адаптиве правая сторона просто отказывалась сжиматься, в инете нашёл что нужно flex элементу правому или обоим задать min-width: 0; min-height: 0;. Решение нашёл вот тут - https://askdev.ru/q/pochemu-elementy-flex-ne-umenshayutsya-do-razmera-soderzhimogo-15277/?</li>
        </ul>
    </div>
   
   
   
   
   
   <h3 class="header-style2" id="4">Заметки про метод <b>addEventListener</b></h3>
   <div class="note">Опишу тут немного про этот метод, потому что у него 3м параметром передаётся объект с интересными настройками. Например:
   <div class="code-style">
      <pre>
          function handler(){ ... }
      
          //<span class="vue-g">передавая свойство once: true мы задаём возможность сработать событию на элементе 1 раз, после чего событие удаляется с этого элемента</span>
          //<span class="vue-g">как по мне это очень удобно бывает в ситуациях, когда я вешаю событие transitionend, и после срабатывания этого события иногда нужно это событие сразу удалять через removeEventListener(),
          //<span class="vue-g">но как я понимаю можно не вызывать метод удаления, а просто передать 3м параметром это свойство once: true и событие transitionend после 1 раза срабатывания само удалится</span>
          element.addEventListener('transitionend', handler, {once: true});
          
          
          //<span class="vue-g">также есть вот такое сво-во, которое запрещает использовать в обработчике метод event.preventDefault(), даже если в обработчике этот метод вызван, то он пропускается, как-будто его нет</span>
          element.addEventListener('click', handler, {passive: true});
      </pre>
   </div>
   <p>Про парочку дугих настроек этого метода потом допишу, так как пока толком не пноимаю что они значат.</p>
   <p>Кстати допишу тут про то, что будет, если в метод addEventListener передать обработчиком стрелочную функцию и в этой функции вывести в консоль this. Выведется скорее всего объект Window(ну или тот объект, в методе которого и создана стрелочная функция), а вот если обработчиком передать старую добрую функцию, то выведется тот объект, который и вызывает метод addEventListener. Почему то метод addEventListener передаёт в функцию-обработчик, написанную по старому через слово function, текущий контекст this, а вот в стрелочную не передаёт. Хоть эти 2е функции созданы в глобальной области видимости, т.е в объекте Window(или в др. объекте), но одной передаётся контекст от метода addEventListener, а стрелочной нет, поэтому стрелочная идёт вверх и ищет переменную this в лексическом окружении той функции, в которой она была создана.</p>
    <div class="code-style">
        <pre>
		let item1 = document.querySelector('.wrap-items div:first-child');

		let obj = {};

		obj.abc = function(){
			item1.addEventListener('click', () => console.log(this)); // => this = obj
			item1.addEventListener('click', function(){console.log(this)}); // => this = item1
		};

		obj.abc();
        </pre>
    </div>
   </div>




    <h3 class="header-style2" id="5">Как затемнить фон в блоке html</h3>
    <div class="note">
        background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('../img/head-bg.jpg');<br>
        background-position: 50% 50%;<br>
        background-size: cover;<br>
        background-repeat: no-repeat;<br>
        <p>Так как есть возможность указать несколько фонов, то градиент используется как фоновое изображение, а не фоновый цвет. Фоновые изображения указываются по порядку через запятую. Первый фон будет самым ближним по слоям к пользователю, остальные фоны через запятую становятся на задний план. Делаем первым фоном градиент и указываем ем у от и до один и тот же прозрачный фон, он и будет покрывать остальные фоновые изображения. Такой способ экономит кучу строк кода, не надо растягивать какой нибудь псевдоэлемент поверх фонового изображения и задавать ему прозрачность.</p>
    </div>
      





    <h3 class="header-style2" id="6">Как зафиксировать блок при прокрутке</h3>
    <div class="note">
        <p>Например есть блок родитель и в нём есть блок дочерний, который мы и хотим при прокрутке затормозить на месте. Для этого блоку родитель задаём position: relative, а блоку дочернему задаём position: sticky; и саму позицию с которой ему тормозиться - top: 0;</p>

        .parent{<br>
        position: relative;<br>
        }<br>

        .child{<br>
        position: sticky;<br>
        top: 0;<br>
        }<br>
    </div>





    <h3 class="header-style2" id="7">Как подключить шрифт локально, а не удалённо</h3>
    <div class="note">
        <p>Чтобы подключить шрифт вручную, нужно скачать сами шрифты в проект в папку fonts и в файле css прописать примерно такое правило под наши шрифты:</p>
        <div class="code-style">
            <pre>
                @font-face {
                    font-family: 'insta';
                    src:  url('../fonts/insta.eot?bg6zsb');
                    src:  url('../fonts/insta.eot?bg6zsb#iefix') format('embedded-opentype'),
                          url('../fonts/insta.ttf?bg6zsb') format('truetype'),
                          url('../fonts/insta.woff?bg6zsb') format('woff'),
                          url('../fonts/insta.svg?bg6zsb#insta') format('svg');
                    font-weight: normal;
                    font-style: normal;
                    font-display: block;
                }
            </pre>
        </div>
    </div>
    
</div>
