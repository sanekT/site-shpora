<div class="wrap">
   
    <h2 class="header-style">Vue.js</h2>
    <h3 class="header-style2">Вычисляемые свойства</h3>
    
    <p>Встраиваемые в шаблоны выражения удобны, но могут предназначаться только для простых операций. При усложнении логики их труднее поддерживать. Вот пример уже усложнёной немного логики в шаблоне {{}}:</p>
    <div class="code-style">
    <pre>
    < div id="example">
      {{ message.split('').reverse().join('') }}
    < /div>
    </pre>
    </div>
    <p>Чтобы эти вычисления вынести из шаблона, на помощь приходят <span class="vue-g">вычисляемые свойства</span>, которые пишутся в свойстве computed в виде метода. Название метода внутри этого свойства также становится геттером, теперь к нему с помощью объекта wm можно обратиься как к свойству, также как и свойства объекта data становятся геттерамми. Т.е. мы можем обратиться wm.reversedMessage, wm.message.</p>
    <div class="code-style">
    <pre>
    HTML:
        < div id="example">
          < p>Изначальное сообщение: «{{ message }}»< /p>
          < p>Сообщение задом наперёд: «{{ reversedMessage }}»< /p>
        < /div>
    
    JS:
        var vm = new Vue({
          el: '#example',
          data: {
            message: 'Привет'
          },
          <span class="vue-g">computed</span>: {
            reversedMessage: function () {
              return this.message.split('').reverse().join('')
            }
          }
        })
    
    Результат:
    
    Изначальное сообщение: "Привет"
    Сообщение задом наперёд: "тевирП"
    </pre>
    </div>
    <p>Значение vm.reversedMessage всегда зависит от значения vm.message. В шаблонах можно обращаться к вычисляемым свойствам также как и к обычным. Vue знает, что vm.reversedMessage зависит от vm.message, поэтому при обновлении vm.message обновятся и все зависящие от него элементы, в нашем случае обновится vm.reversedMessage</p>
    
    
    <h3 class="header-style2">Кеширование вычисляемых свойств</h3>
    <p>В примере выше такого же результата можно было достичь и с помощью метода:</p>
    <div class="code-style">
    <pre>
    HTML:
        < p>Сообщение задом наперёд: «{{ reversedMessage() }}»< /p>
    
    JS:
        var vm = new Vue({
          el: '#example',
          data: {
            message: 'Привет'
          },
          <span class="vue-g">methods</span>: {
            reversedMessage: function () {
              return this.message.split('').reverse().join('')
            }
          }
        })
    </pre>
    </div>
    <p>С точки зрения конечного результата, оба подхода делают одно и то же. Но есть важное отличие: <b>вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях</b>. Вычисляемое свойство пересчитывается лишь тогда, когда изменится одна из его реактивных зависимостей. Поэтому, пока message остаётся неизменным, многократное обращение к reversedMessage будет каждый раз возвращать единожды вычисленное значение, не запуская функцию вновь</p>
    <p>Использование метода, напротив, будет запускать функцию всегда, при каждом обращении к нему.</p>
    
    
    <h3 class="header-style2">Сеттеры вычисляемых свойств</h3>
    <p>По умолчанию вычисляемые свойства работают только на чтение, но при необходимости можно также указать и сеттер:</p>
    <div class="code-style">
    <pre>
    computed: {
      fullName: {
        // геттер:
        get: function () {
          return this.firstName + ' ' + this.lastName
        },
        // сеттер:
        set: function (newValue) {
          var names = newValue.split(' ')
          this.firstName = names[0]
          this.lastName = names[names.length - 1]
        }
      }
    }
    </pre>
    </div>
    <p>Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.</p>
</div>