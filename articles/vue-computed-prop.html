<div class="wrap">
   
    <h2 class="header-style">Вычисляемые свойства и слежение</h2>







    <h3 class="header-style2">Вычисляемые свойства</h3>
    <p>Встраиваемые в шаблоны выражения удобны, но могут предназначаться только для простых операций. При усложнении логики их труднее поддерживать. Вот пример уже усложнёной немного логики в шаблоне {{}}:</p>
    <div class="code-style">
    <pre>
    &lt;div id="example">
        {{ message.split('').reverse().join('') }}
    &lt;/div>
    </pre>
    </div>
    <p>Чтобы эти вычисления вынести из шаблона, на помощь приходят <span class="vue-g">вычисляемые свойства</span>, которые пишутся в свойстве computed в виде метода. Название метода внутри свойства computed также становится геттером этого метода, теперь к нему с помощью объекта wm можно обратиться как к свойству, также как и свойства объекта data становятся геттерамми. Т.е. мы можем обратиться wm.reversedMessage, wm.message.</p>
    <div class="code-style">
    <pre>
    HTML:
        &lt;div id="example">
            &lt;p>Изначальное сообщение: «{{ message }}»&lt;/p>
            &lt;p>Сообщение задом наперёд: «{{ reversedMessage }}»&lt;/p>
        &lt;/div>
    
    JS:
        var vm = new Vue({
            el: '#example',
            data: {
                message: 'Привет'
            },
            <span class="vue-g">computed</span>: {
                // геттер вычисляемого значения
                reversedMessage: function () {
                    // `this` указывает на экземпляр vm
                    return this.message.split('').reverse().join('')
                }
            }
        })
    
    Результат:
    
    Изначальное сообщение: "Привет"
    Сообщение задом наперёд: "тевирП"
    </pre>
    </div>
    <p>Значение vm.reversedMessage всегда зависит от значения vm.message. В шаблонах можно обращаться к вычисляемым свойствам также как и к обычным. Vue знает, что vm.reversedMessage зависит от vm.message, поэтому при обновлении vm.message обновятся и все зависящие от него элементы, в нашем случае обновится vm.reversedMessage</p>
    
    
    <h3 class="header-style2">Кеширование вычисляемых свойств</h3>
    <p>В примере выше такого же результата можно было достичь и с помощью обычного метода:</p>
    <div class="code-style">
    <pre>
    HTML:
        &lt;p>Сообщение задом наперёд: «{{ reversedMessage() }}»&lt;/p>
    
    JS:
        var vm = new Vue({
            el: '#example',
            data: {
                message: 'Привет'
            },
            <span class="vue-g">methods</span>: {
                reversedMessage: function () {
                    return this.message.split('').reverse().join('')
                }
            }
        })
    </pre>
    </div>
    <p>С точки зрения конечного результата, оба подхода делают одно и то же. Но есть важное отличие: <b>вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях</b>. Вычисляемое свойство пересчитывается лишь тогда, когда изменится одна из его реактивных зависимостей. Поэтому, пока message остаётся неизменным, многократное обращение к reversedMessage будет каждый раз возвращать единожды вычисленное значение, не запуская функцию вновь. Использование метода, напротив, будет запускать функцию всегда, при каждом обращении к нему. Это значит, что даже если мы не трогаем участок кода, где стоит вычисляемое сво-во, а трогаем совсем другое место, то при перерисовке страницы это вычисляемое свойство не трогается, а отображается только то что уже было вычислено. Метод же даже будет запускаться в том месте, если мы там даже не касаемся.</p>
    <p>Вот например есть такой пример:</p>
    <div class="code-style">
        <pre>
            computed: {
                now: function () {
                    return Date.now()
                }
              }
        </pre>
    </div>
    <p>Date.now() не является реактивной зависимостью и поэтому это выч. сво-во запустится один раз и всё. Тут подойдёт как раз использование метода.</p>
    <p>Зачем нужно кэширование? Представьте, есть «дорогое» вычисляемое свойство A, требующее цикла по огромному массиву и выполняющее множество вычислений. И пусть ещё будут другие вычисляемые свойства, в свою очередь, зависящие от A. Без кэширования геттер A будет запускаться куда чаще необходимого! В тех же случаях, когда кэширования нужно избежать — используйте методы.</p>
    
    
    <h3 class="header-style2">Сеттеры вычисляемых свойств</h3>
    <p>По умолчанию вычисляемые свойства работают только на чтение, но при необходимости можно также указать и сеттер:</p>
    <div class="code-style">
    <pre>
    computed: {
        fullName: {
            // геттер:
            get: function () {
                return this.firstName + ' ' + this.lastName
            },
            // сеттер:
            set: function (newValue) {
                var names = newValue.split(' ')
                this.firstName = names[0]
                this.lastName = names[names.length - 1]
            }
        }
    }
    </pre>
    </div>
    <p>Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.</p>











    <h3 class="header-style2">Методы-наблюдатели(слежение)</h3>
    <p>Хотя в большинстве случаев лучше использовать вычисляемые свойства, иногда необходимы пользовательские методы-наблюдатели. Поэтому Vue предоставляет более общий способ реагирования на изменения в данных через опцию watch. Эта возможность полезна для «дорогих» или асинхронных операций, выполняемых в ответ на изменение данных.</p>
    <p>Свойство watch отслеживает изменения в выбранном свойстве(модели), например есть select с опциями, через v-model мы записываем в свойство prop значения выбранной опции. И теперь будем отслеживать свойство prop через watch и выводить на экран то что лежит в prop. Для этого надо отслеживаемое свойство сделать методом: </p>
    <div class="code-style">
    <pre>
    &lt;template>
        &lt;div class="wrapper">
            &lt;select v-model="valueOption">
                &lt;option value="all">Все&lt;/option>
                &lt;option value="compieted">Завершённые&lt;/option>
                &lt;option value="not-completed">Не завершённые&lt;/option>
            &lt;/select>
        &lt;/div>
    &lt;/template>

    &lt;script>
    export default{
        data() {
            return {
                valueOption: 'all'
            }
        },
        watch: {
            //при отслеживании модели valueOption нам внутри метода доступны 2 параметра: newValue и oldValue. В них соответственно лежит
            //новое значение и старое
            prop(newValue){
                console.log(newValue);
            }
        }
    }
    &lt;/script>
    </pre>
    </div>
    <p>Как отслеживать объекты, внутри которых изменяются поля. Если мы будем следить за объектом и менять внутри него поля, то наблюдение не будет срабатывать, потому как меняется не сам объект, а его внутренности. Для этого есть такой синтаксис, при котором наша отслеживаемая модель становится не функцией, а объектом, внутри которой объявляем метод handler, этот метод и будет выполняться при изменении модели, и поле deep со значением true, котрое говорит, что нужно глубоко отслеживать изменения в модели:</p>
    <div class="code-style">
    <pre>
    &lt;template>
        &lt;div id="app">
            &lt;button @click="writeTitle">Записать в заголовок&lt;/button>
            &lt;button @click="writeBody">Записать в описание&lt;/button>
            &lt;div>{{obj.title}}&lt;/div>
        &lt;/div>
    &lt;/template>

    &lt;script>
    export default{
        data() {
            return {
                obj: {
                    title: '',
                    body: ''
                }
            }
        },
        methods: {
            writeTitle(){
                this.obj.title = Date.now();
            },
            writeBody(){
                this.obj.body = Date.now();
            }
        },
        watch: {
            obj: {
                handler(newValue){
                    console.log(newValue)
                },
                deep: true
            }
        }
    }
    &lt;/script>
    </pre>
    </div>
    <p>Теперь когда мы будем менять в модели obj любое его поле, хоть title, хоть body нажимая по соответствующим кнопкам, то у нас в консоль будет выводиться примерно такое - Proxy {title: 1664992265877, body: 1664992262629}, т.е. будет выводится вся модель obj обёрнутая в Proxy</p>



</div>
