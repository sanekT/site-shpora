<div class="wrap">
   
    <h2 class="header-style">Вычисляемые свойства и слежение</h2>







    <h3 class="header-style2">Вычисляемые свойства</h3>
    <p>Встраиваемые в шаблоны выражения удобны, но могут предназначаться только для простых операций. При усложнении логики их труднее поддерживать. Вот пример уже усложнёной немного логики в шаблоне {{}}:</p>
    <div class="code-style">
    <pre>
    &lt;div id="example">
        {{ message.split('').reverse().join('') }}
    &lt;/div>
    </pre>
    </div>
    <p>Чтобы эти вычисления вынести из шаблона, на помощь приходят <span class="vue-g">вычисляемые свойства</span>, которые пишутся в свойстве computed в виде метода. Название метода внутри свойства computed также становится геттером этого метода, теперь к нему с помощью объекта wm можно обратиться как к свойству, также как и свойства объекта data становятся геттерамми. Т.е. мы можем обратиться wm.reversedMessage, wm.message.</p>
    <div class="code-style">
    <pre>
    HTML:
        &lt;div id="example">
            &lt;p>Изначальное сообщение: «{{ message }}»&lt;/p>
            &lt;p>Сообщение задом наперёд: «{{ reversedMessage }}»&lt;/p>
        &lt;/div>
    
    JS:
        var vm = new Vue({
            el: '#example',
            data: {
                message: 'Привет'
            },
            <span class="vue-g">computed</span>: {
                // геттер вычисляемого значения
                reversedMessage: function () {
                    // `this` указывает на экземпляр vm
                    return this.message.split('').reverse().join('')
                }
            }
        })
    
    Результат:
    
    Изначальное сообщение: "Привет"
    Сообщение задом наперёд: "тевирП"
    </pre>
    </div>
    <p>Значение vm.reversedMessage всегда зависит от значения vm.message. В шаблонах можно обращаться к вычисляемым свойствам также как и к обычным. Vue знает, что vm.reversedMessage зависит от vm.message, поэтому при обновлении vm.message обновятся и все зависящие от него элементы, в нашем случае обновится vm.reversedMessage</p>
    
    
    <h3 class="header-style2">Кеширование вычисляемых свойств</h3>
    <p>В примере выше такого же результата можно было достичь и с помощью обычного метода:</p>
    <div class="code-style">
    <pre>
    HTML:
        &lt;p>Сообщение задом наперёд: «{{ reversedMessage() }}»&lt;/p>
    
    JS:
        var vm = new Vue({
            el: '#example',
            data: {
                message: 'Привет'
            },
            <span class="vue-g">methods</span>: {
                reversedMessage: function () {
                    return this.message.split('').reverse().join('')
                }
            }
        })
    </pre>
    </div>
    <p>С точки зрения конечного результата, оба подхода делают одно и то же. Но есть важное отличие: <b>вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях</b>. Вычисляемое свойство пересчитывается лишь тогда, когда изменится одна из его реактивных зависимостей. Поэтому, пока message остаётся неизменным, многократное обращение к reversedMessage будет каждый раз возвращать единожды вычисленное значение, не запуская функцию вновь. Использование метода, напротив, будет запускать функцию всегда, при каждом обращении к нему. Это значит, что даже если мы не трогаем участок кода, где стоит вычисляемое сво-во, а трогаем совсем другое место, то при перерисовке страницы это вычисляемое свойство не трогается, а отображается только то что уже было вычислено. Метод же даже будет запускаться в том месте, если мы там даже не касаемся.</p>
    <p>Вот например есть такой пример:</p>
    <div class="code-style">
        <pre>
            computed: {
                now: function () {
                    return Date.now()
                }
              }
        </pre>
    </div>
    <p>Date.now() не является реактивной зависимостью и поэтому это выч. сво-во запустится один раз и всё. Тут подойдёт как раз использование метода.</p>
    <p>Зачем нужно кэширование? Представьте, есть «дорогое» вычисляемое свойство A, требующее цикла по огромному массиву и выполняющее множество вычислений. И пусть ещё будут другие вычисляемые свойства, в свою очередь, зависящие от A. Без кэширования геттер A будет запускаться куда чаще необходимого! В тех же случаях, когда кэширования нужно избежать — используйте методы.</p>
    
    
    <h3 class="header-style2">Сеттеры вычисляемых свойств</h3>
    <p>По умолчанию вычисляемые свойства работают только на чтение, но при необходимости можно также указать и сеттер:</p>
    <div class="code-style">
    <pre>
    computed: {
        fullName: {
            // геттер:
            get: function () {
                return this.firstName + ' ' + this.lastName
            },
            // сеттер:
            set: function (newValue) {
                var names = newValue.split(' ')
                this.firstName = names[0]
                this.lastName = names[names.length - 1]
            }
        }
    }
    </pre>
    </div>
    <p>Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.</p>











    <h3 class="header-style2">Методы-наблюдатели(слежение)</h3>
    <p>Хотя в большинстве случаев лучше использовать вычисляемые свойства, иногда необходимы пользовательские методы-наблюдатели. Поэтому Vue предоставляет более общий способ реагирования на изменения в данных через опцию watch. Эта возможность полезна для «дорогих» или асинхронных операций, выполняемых в ответ на изменение данных.</p>
    <p>Свойство watch отслеживает изменения в выбранном свойстве, например есть select с опциями, через v-model мы записываем в свойство prop значения выбранной опции. И теперь будем отслеживать свойство prop через watch и выводить на экран то что лежит в prop. Для этого надо отслеживаемое свойство сделать методом: </p>
    <div class="code-style">
    <pre>
        &lt;div class="wrapper">
          &lt;select v-model="prop">
			&lt;option value="all">Все&lt;/option>
			&lt;option value="compieted">Завершённые&lt;/option>
			&lt;option value="not-completed">Не завершённые&lt;/option>
		  &lt;/select>
        &lt;/div>
       

        new Vue({
            el: '.wrapper',
            data: {
                prop: 'all'
            },
            watch: {
                prop(value){
                    console.log(value);
                }
            }
        });
    </pre>
    </div>



</div>
