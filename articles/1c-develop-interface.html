<div class="wrap">
   
    <h2 class="header-style">Здесь будет описано как разрабатывать интерфейс прикладного решения по книге Радченко и Хрусталёвой "Разработка интерфейса прикладных решений на 1С" с моими заметками.</h2>

    <p><span class="vue-r">Если картики будет плохо видно, то через контекстное меню открыть их в новой вкладке, там она в полный размер будет.</span></p>

    <p>Обозначения: КИ - командный интерфейс</p>
    <p>Обозначения: ПР - прикладное решение</p>

    <p>Книга состоит из пяти частей. Каждая из них посвящена определённой области разработки.</p>
    <p><span class="vue-d-b">В первой части</span> книги рассказывается о принципах, на основе которых платформа формирует командный интерфейс, и о том, как разработчик может влиять на его формирование.</p>
    <p><span class="vue-d-b">Во второй части</span> рассматриваются различные возможности статического создания форм в конфигураторе.</p>
    <p><span class="vue-d-b">В третьей части</span> рассказывается о возможностях использования встроенного языка для решения различных интерфейсных задач</p>
    <p><span class="vue-d-b">В четвёртой части</span> рассматриваются основные принципы и подходы, позволяющие формам работать быстро и производительно.</p>
    <p><span class="vue-d-b">В пятой части</span> рассказывается о том, как присобачить интерфейс прикладного решения для работы в мобильном клиенте. Мобильные устройства имеют маленькие экраны, поэтому платформе нужны доп. подсказки от разработчика, чтобы она могла подстроить внешний вид формы под маленький экран.</p>

    <p>Перейти к оглавлению:</p>
    <ul class="list">
        <li><a href="#chap2">Часть 2</a></li>
        <li><a href="#chap3">Часть 3</a></li>
        <li><a href="#chap4">Часть 4</a></li>
    </ul>

    <h3 class="header-style2">Часть 1. Конструирование интерфейса.</h3>
    <ul class="list">
        <li><a href="#chapter1.1">Глава 1.1 Пользователь, интерфейс, команда</a></li>
        <li><a href="#chapter1.2">Глава 1.2 Прикладное решение глазами пользователя</a>
            <ul class="list2">
                <li><a href="#chapter1.2.1">Основное окно приложения</a></li>
                <li><a href="#chapter1.2.2">Окно клиентского приложения</a></li>
            </ul>
        </li>
        <li><a href="#chapter1.3">Глава 1.3 Командный интерфейс системы</a>
            <ul class="list2">
                <li><a href="#chapter1.3.1">Структура командного интерфейса</a></li>
                <li><a href="#chapter1.3.2">Влияние подсистем</a></li>
                <li><a href="#chapter1.3.3">Формирование состава глобального командного интерфейса. <b>Роли и права</b> для них. Влияние на отображение функциональных опций. Пользовательские настройки для отображения команд.</a></li>
            </ul>
        </li>
        <li><a href="#chapter1.4">Глава 1.4 Настраиваем состав команд</a></li>
        <li><a href="#chapter1.5">Глава 1.5 Настраиваем доступность команд по ролям</a></li>
        <li><a href="#chapter1.6">Глава 1.6 Редактирование командного интерфейса</a></li>
        <li><a href="#chapter1.7">Глава 1.7 Влияние функциональных опций на командный интерфейс</a></li>
        <li><a href="#chapter1.8">Глава 1.8 Пользовательская настройка интерфейса</a></li>
        <li><a href="#chapter1.9">Глава 1.9 Настраиваем представление команд</a></li>
        <li><a href="#chapter1.10">Глава 1.10 Модель разработки глобального командного интерфейса</a></li>
        <li><a href="#chapter1.11">Глава 1.11 Создаём произвольные команды. Свойства <b>"Группа"</b> и <b>"Тип параметра команды"</b>.</a>
            <ul class="list2">
                <li><a href="#chapter1.11.1">Создадим произвольную подчинённую команду для объекта конфигурации</a></li>
                <li><a href="#chapter1.11.2">Особенности размещения</a></li>
                <li><a href="#chapter1.11.3">Развитие функциональности ценообразования. Создаём общую произвольную независимую команду. Размещаем её. Настраиваем её видимость. Заботимся о пользователе делая подсказки о том, что это за команда(настроили представление команды). Эта команду будет печатать все виды цен на все товары. Практика</a></li>
                <li><a href="#chapter1.11.4">Развитие функциональности ценообразования. Теперь создаём подчинённую параметризуемую команду. Эта команда будет печатать только определённый вид цены на товары. Практика</a></li>
                <li><a href="#chapter1.11.5">Произвольные группы. Объект "Группа команд". Практика</a></li>
            </ul>
        </li>
        <li><a href="#chapter1.12">"Командуем" <b>формами</b></a>
            <ul class="list2">
                <li><a href="#chapter1.12.1">Необходимые сведения о <b>форме</b></a></li>
                <li><a href="#chapter1.12.2">Функциональность по умолчанию</a></li>
                <li><a href="#chapter1.12.3">Команды формы</a>
                    <ul class="list2">
                        <li><a href="#chapter1.12.3.1">Для обработки данных формы - стандартные команды формы. Вкладка <b>"Стандарные команды".</b></a></li>
                        <li><a href="#chapter1.12.3.2">Для работы со связанными данными - глобальные параметризуемые команды. Вкладка <b>"Глобальные команды".</b></a></li>
                        <li><a href="#chapter1.12.3.3">Для работы с функциональностью приложения - глобальные независимые команды. Вкладка <b>"Глобальные команды".</b></a></li>
                    </ul>
                </li>
                <li><a href="#chapter1.12.4">Способы формирования состава команд формы</a></li>
                <li><a href="#chapter1.12.5">Автоматическое формирование состава команд формы</a></li>
                <li><a href="#chapter1.12.6">Доступность команд формы для пользователя</a></li>
                <li><a href="#chapter1.12.7">Управляем командами формы. Стандартные команды формы. Создаём элемент формы "Кнопка" и связываем её со стандартной командой. Глобальные команды формы.</a></li>
                <li><a href="#chapter1.12.8">Краткие итоги</a></li>
            </ul>
        </li>
        <li><a href="#"></a></li>
    </ul>
    





    <h3 class="header-style2" id="chap2">Часть 2. Конструирование форм.</h3>
    <p>Стр. 237</p>
    <ul class="list">
        <li><a href="#chapter2.1">Глава 2.1 Что такое форма</a>
            <ul class="list2">
                <li><a href="#chapter2.1.1">Концепция построения форм</a></li>
                <li><a href="#chapter2.1.2">Среда существование формы. Этапы создания формы на сервере и передача её на клиент</a></li>
            </ul>
        </li>
        <li><a href="#chapter2.2">Глава 2.2 Создание формы</a>
            <ul class="list2">
                <li><a href="#chapter2.2.1">Создание формы с помощью конструктора</a></li>
                <li><a href="#chapter2.2.2">Создание формы методом копирования</a></li>
            </ul>
        </li>
        <li><a href="#chapter2.3">Глава 2.3 Редактирование формы</a>
            <ul class="list2">
                <li><a href="#chapter2.3.1">Описание редактора формы</a></li>
                <li><a href="#chapter2.3.2">Иерерхия элементов формы</a></li>
                <li><a href="#chapter2.3.3">Свойства формы</a>
                    <ul class="list2">
                        <li><a href="#chapter2.3.3.1">"Заголовок", "Автоматический заголовок", "Отображать заголовок"</a></li>
                        <li><a href="#chapter2.3.3.2">"Положение командной панели"</a></li>
                        <li><a href="#chapter2.3.3.3">"Доступность"</a></li>
                        <li><a href="#chapter2.3.3.4">"Режим открытия окна"</a></li>
                        <li><a href="#chapter2.3.3.5">"Проверять заполнение автоматически"</a></li>
                        <li><a href="#chapter2.3.3.6">"Условное офофрмление"</a></li>
                        <li><a href="#chapter2.3.3.7">"Разрешить изменять форму"</a></li>
                        <li><a href="#chapter2.3.3.8">"Группировка"</a></li>
                        <li><a href="#chapter2.3.3.9">"Вертикальная прокрутка"</a></li>
                        <li><a href="#chapter2.3.3.10">"Вариант масштаба", "Масштаб"</a></li>
                        <li><a href="#chapter2.3.3.11">"Список групп"</a></li>
                    </ul>
                </li>
                <li><a href="#chapter2.3.4">Виды элементов формы. Вкладка "Элементы" в редакторе формы</a></li>
                <li><a href="#chapter2.3.5">Контекстное меню элементов формы</a></li>
                <li><a href="#chapter2.3.6">Свойства элементов формы</a></li>
                <li><a href="#chapter2.3.7"></a></li>
            </ul>
        </li>
        <li><a href="#chapter2.4">Глава 2.4 Влияние объектов конфигурации на форму</a>
            <ul class="list2">
                <li><a href="#chapter2.4.1">Заголовок формы</a></li>
                <li><a href="#chapter2.4.2">Интерфейсные свойства реквизитов объектов конфигурации</a></li>
                <li><a href="#chapter2.4.3">Стандартные реквизиты объектов конфигурации</a></li>
            </ul>
        </li>
        <li><a href="#chapter2.5">Глава 2.5 Реквизиты формы</a></li>
        <li><a href="#chapter2.6">Глава 2.6 Командный интерфейс окна клиентского приложения</a>
            <ul class="list2">
                <li><a href="#chapter2.6.1">Панель навигации</a></li>
                <li><a href="#chapter2.6.2">Командная панель основной формы</a></li>
                <li><a href="#chapter2.6.3">Команды формы</a></li>
            </ul>
        </li>
        <li><a href="#chapter2.7">Глава 2.7 Управление видимостью элементов формы</a>
            <ul class="list2">
                <li><a href="#chapter2.7.1">Влияние прав и ролей пользователя на элементы формы</a></li>
                <li><a href="#chapter2.7.2">Влияние функциональных опций на элементы формы</a></li>
            </ul>
        </li>
        <li><a href="#chapter2.8">Глава 2.8 Окно сообщений клиентского приложения</a></li>
        <li><a href="#chapter2.9">Глава 2.9 Примеры конструирования форм</a>
            <ul class="list2">
                <li><a href="#chapter2.9.1"></a></li>
                <li><a href="#chapter2.9.2"></a></li>
                <li><a href="#chapter2.9.3"></a></li>
                <li><a href="#chapter2.9.4"></a></li>
                <li><a href="#chapter2.9.5"></a></li>
                <li><a href="#chapter2.9.6"></a></li>
                <li><a href="#chapter2.9.7"></a></li>
                <li><a href="#chapter2.9.8"></a></li>
                <li><a href="#chapter2.9.9"></a></li>
                <li><a href="#chapter2.9.10"></a></li>
                <li><a href="#chapter2.9.11"></a></li>
            </ul>
        </li>
        <li><a href="#chapter2.10">Глава 2.10 Начальная страница</a></li>
    </ul>









    <h3 class="header-style2" id="chap3">Часть 3. Программирование форм и интерфейса.</h3>
    <p>Стр. 433</p>
    <ul class="list">
        <li><a href="#chapter3.1">Глава 3.1. Форма как элемент клиент-серверного взаимодействия. Стр 437</a>
            <ul class="list2">
                <li><a href="#chapter3.1.1">Клиент-серверная архитектура</a></li>
                <li><a href="#chapter3.1.2">Форма - клиент-серверный объект</a></li>
                <li><a href="#chapter3.1.3">Общий подход к программированию форм</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.2">Глава 3.2. Параметры и реквизиты формы. Стр 444 </a>
            <ul class="list2">
                <li><a href="#chapter3.2.1">Реквизиты</a></li>
                <li><a href="#chapter3.2.2">Параметры</a></li>
                <li><a href="#chapter3.2.3">Выводы</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.3">Глава 3.3. Открытие форм. Стр 446</a>
            <ul class="list2">
                <li><a href="#chapter3.3.1">Последовательность событий при открытии формы</a></li>
                <li><a href="#chapter3.3.2">Общая методика открытия форм. Метод ОткрытьФорму() и его параметры.</a></li>
                <li><a href="#chapter3.3.3">Основная форма нового объекта</a></li>
                <li><a href="#chapter3.3.4">Форма констант</a></li>
                <li><a href="#chapter3.3.5">Форма группы</a></li>
                <li><a href="#chapter3.3.6">Произвольная форма</a></li>
                <li><a href="#chapter3.3.7">Форма существующего объекта</a></li>
                <li><a href="#chapter3.3.8">Открыть список, чтобы курсор был на нужном элементе</a></li>
                <li><a href="#chapter3.3.9">Список подчинённого справочника с отбором по владельцу</a></li>
                <li><a href="#chapter3.3.10">Передача параметров в произвольный запрос динамического списка</a></li>
                <li><a href="#chapter3.3.11">Метод "ПолучитьФорму()"</a></li>
                <li><a href="#chapter3.3.12">Открытие формы в блокирующем режиме без использования модальности</a></li>
                <li><a href="#chapter3.3.13">Открытие и запуск отчёта</a></li>
                <li><a href="#chapter3.3.14">Переопределение открываемой формы</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.4">Глава 3.4. Преобразование прикладных данных в данные формы. Стр 471</a></li>
        <li><a href="#chapter3.5">Глава 3.5. Исполнение модуля формы на клиенте и на сервере. Стр 476</a>
            <ul class="list2">
                <li><a href="#chapter3.5.1">Переменные модуля формы</a></li>
                <li><a href="#chapter3.5.2">Экспортируемые процедуры формы</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.6">Глава 3.6. Контекстные и внеконтекстные серверные вызовы. Стр 482</a></li>
        <li><a href="#chapter3.7">Глава 3.7. Работа с данными объекта в форме. Стр 486</a>
            <ul class="list2">
                <li><a href="#chapter3.7.1">Пример 1</a></li>
                <li><a href="#chapter3.7.2">Пример 2</a></li>
                <li><a href="#chapter3.7.3">Пример 3</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.8">Глава 3.8. Последовательность событий при открытии формы существующего объекта. Стр 491</a>
            <ul class="list2">
                <li><a href="#chapter3.8.1">Чтение данных прикладного объекта</a></li>
                <li><a href="#chapter3.8.2">Событие "При чтении на сервере"</a></li>
                <li><a href="#chapter3.8.3">Событие "При создании на сервере". Примеры для чего нужен параметр "СтандартнаяОбработка".</a></li>
                <li><a href="#chapter3.8.4">Событие "При открытии"</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.9">Глава 3.9. Последовательность событий при записи объекта из формы. Стр 496</a>
            <ul class="list2">
                <li><a href="#chapter3.9.1">Событие "Перед записью"</a></li>
                <li><a href="#chapter3.9.2">Проверка заполнения</a></li>
                <li><a href="#chapter3.9.3">Событие "Перед записью на сервере"</a></li>
                <li><a href="#chapter3.9.4">Запись данных в базу данных. События "Перед записью", "При записи", "При записи на сервере"</a></li>
                <li><a href="#chapter3.9.5">Событие "После записи на сервере"</a></li>
                <li><a href="#chapter3.9.6">Передача формы на клиент</a></li>
                <li><a href="#chapter3.9.7">Событие "После записи"</a></li>
                <li><a href="#chapter3.9.8">Событие "Перед закрытием". Подробно расписано.</a></li>
                <li><a href="#chapter3.9.9">Событие "При закрытии"</a></li>
                <li><a href="#chapter3.9.10">Параметры записи</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.10">Глава 3.10. Начальное заполнение. Стр 512</a>
            <ul class="list2">
                <li><a href="#chapter3.10.1">Свойство "Значение заполнения"</a></li>
                <li><a href="#chapter3.10.2">Свойство "Заполнять из данных заполнения"</a></li>
                <li><a href="#chapter3.10.3">Событие "Обработка заполнения"</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.11">Глава 3.11. Проверка заполнения. Стр 525</a>
            <ul class="list2">
                <li><a href="#chapter3.11.1">Заполнение и проверка заполнения</a></li>
                <li><a href="#chapter3.11.2">Свойство "Проверка заполнения"</a></li>
                <li><a href="#chapter3.11.3">Программная обработка проверки заполнения</a></li>
                <li><a href="#chapter3.11.4">Вывод сообщений с привязкой к элементам формы</a></li>
                <li><a href="#chapter3.11.5">Проверка заполнения и функциональные опции. Подробно рассказывается про независимые и параметризуемые функциональные опции.</a></li>
                <li><a href="#chapter3.11.6">Проверка заполнения и проверка при записи</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.12">Глава 3.12. Сообщения пользователю. Стр 553</a></li>
        <li><a href="#chapter3.13">Глава 3.13. Способы информирования пользователя. Методы - СообщениеПользователю(), Состояние()(есть пример как сделать протекание процентов, пока что то делается), ПоказатьОповещениеПользователя(), ПоказатьПредупреждение(). Стр 568</a></li>
        <li><a href="#chapter3.14">Глава 3.14. Обновление данных в динамических списках. Стр 576</a>
            <ul class="list2">
                <li><a href="#chapter3.14.1">Метод "ОповеститьОбИзменениях()"</a></li>
                <li><a href="#chapter3.14.2">Метод "Оповестить()"</a></li>
                <li><a href="#chapter3.14.3">Обновление формы извне. ПолучитьФорму().</a></li>
                <li><a href="#chapter3.14.4">Коллекция окон. ПолучитьОкна().</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.15">Глава 3.15. Оформление списков. Стр 584</a>
            <ul class="list2">
                <li><a href="#chapter3.15.1">Динамические списки. Немного про "КомпановкаДанных"</a>
                    <ul class="list2">
                        <li><a href="#chapter3.15.1.1">Отбор</a></li>
                        <li><a href="#chapter3.15.1.2">Сортировка</a></li>
                        <li><a href="#chapter3.15.1.3">Группировка</a></li>
                        <li><a href="#chapter3.15.1.4">Условное оформление</a></li>
                    </ul>
                </li>
                <li><a href="#chapter3.15.2">Табличная часть</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.16">Глава 3.16. Дополнительные колонки в списках. Стр 607</a>
            <ul class="list2">
                <li><a href="#chapter3.16.1">Динамический список</a></li>
                <li><a href="#chapter3.16.2">Дополнительная обработка данных, получаемых динамическим списком. Событие обработчика "ПриПолученииДанныхНаСервере" таблицы формы</a></li>
                <li><a href="#chapter3.16.3">Табличная часть</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.17">Глава 3.17. Работа с таблицей в форме. Как указать выделенную строку в таблице формы(это я дописал своё).  Стр 624</a>
            <ul class="list2">
                <li><a href="#chapter3.17.1">Ввод данных по колонкам</a></li>
                <li><a href="#chapter3.17.2">Сохранение текущей строки после загрузки данных</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.18">Глава 3.18. Работа с файлами и картинками. Стр 636</a>
            <ul class="list2">
                <li><a href="#chapter3.18.1">Стандартные возможности</a></li>
                <li><a href="#chapter3.18.2">Расширенные возможности</a></li>
                <li><a href="#chapter3.18.3">Получение файла и сохранение его в базе данных</a></li>
                <li><a href="#chapter3.18.4">Картинка товара в форме</a></li>
                <li><a href="#chapter3.18.5">Картинки, используемые для оформления</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.19">Глава 3.19. Поле ввода. Стр 667</a>
            <ul class="list2">
                <li><a href="#chapter3.19.1">Ввод по строке</a>
                    <ul class="list2">
                        <li><a href="#chapter3.19.1.1">Последовательность событий при вводе по строке.</a></li>
                        <li><a href="#chapter3.19.1.2">Формирование собственного списка выбора</a></li>
                        <li><a href="#chapter3.19.1.3">Событие "Обработка получения данных выбора"</a></li>
                        <li><a href="#chapter3.19.1.4">Метод "ПолучитьДанныеВыбора()"</a></li>
                        <li><a href="#chapter3.19.1.5">Событие "Обработка выбора"</a></li>
                        <li><a href="#chapter3.19.1.6">Событие "Начало выбора"</a></li>
                    </ul>
                </li>
                <li><a href="#chapter3.19.2">История выбора при вводе</a></li>
                <li><a href="#chapter3.19.3">Создание при вводе</a>
                    <ul class="list2">
                        <li><a href="#chapter3.19.3.1">Стандартная проверка при выборе значения</a></li>
                        <li><a href="#chapter3.19.3.2">Передача дополнительных параметров выбора в форму нового элемента</a></li>
                        <li><a href="#chapter3.19.3.3">Собственная проверка при выборе значения</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="#chapter3.20">Глава 3.20. Программное изменение формы (программное добавление реквизита, элемента и установка обработчика для элемента формы). Стр 702</a>
            <ul class="list2">
                <li><a href="#chapter3.20.1">Общие подходы</a></li>
                <li><a href="#chapter3.20.2">Добавление поля</a></li>
                <li><a href="#chapter3.20.3">Добавление динамического списка</a></li>
                <li><a href="#chapter3.20.4">Добавление колонки в таблицу</a></li>
                <li><a href="#chapter3.20.5">Добавление команды</a></li>
            </ul>
        </li>
        <li><a href="#chapter3.21">Глава 3.21. Программная настройка интерфейса. Стр 723</a>
            <ul class="list2">
                <li><a href="#chapter3.21.1">Настройка состава панелей интерфейса</a></li>
                <li><a href="#chapter3.21.2">Настройка состава форм на начальной странице</a></li>
            </ul>
        </li>
    </ul>



    <h3 class="header-style2" id="chap4">Часть 4. Наладка клиент-серверного взаимодействия в формах.</h3>
    <p>Стр. 739</p>
    <ul class="list">
        <li><a href="#chapter4.1">Глава 4.1. Общие советы по наладке клиент-серверного взаимодействия. Стр 741</a></li>
        <li><a href="#chapter4.2">Глава 4.2. Инструменты, используемые при наладке клиент-серверного взаимеодействия. Стр 744</a>
            <ul class="list2">
                <li><a href="#chapter4.2.1">Показатели производительности</a></li>
                <li><a href="#chapter4.2.2">Режим низкой скорости соединения</a></li>
                <li><a href="#chapter4.2.3">Имитация задержек при вызове сервера</a></li>
                <li><a href="#chapter4.2.4">Отображение серверных вызовов в замерах производительности</a></li>
                <li><a href="#chapter4.2.5">Проверка серверных вызовов в обработчиках событий</a></li>
            </ul>
        </li>
        <li><a href="#chapter4.3">Глава 4.3. Примеры наладки клиент-серверного взаимодействия. Стр 760</a>
            <ul class="list2">
                <li><a href="#chapter4.3.1">Объединение нескольких вызовов сервера в один</a></li>
                <li><a href="#chapter4.3.2">Использование внеконтекстных серверных процедур в модуле формы</a></li>
                <li><a href="#chapter4.3.3">Использование клиентских процедур для небольших расчётов данных формы</a></li>
                <li><a href="#chapter4.3.4">Использование контекстных серверных процедур для пересчёта данных коллекций форм</a></li>
                <li><a href="#chapter4.3.5">Управление открываемой формой путём передачи параметров. Тут пример как передать выбранное значение из формы выбора в владельца этой формой(в данном случае владелец табличная часть документа)</a></li>
                <li><a href="#chapter4.3.6">Воплощение функциональности в клиентских и серверных обработчиках событий формы в зависимости от их назначения</a></li>
                <li><a href="#chapter4.3.7">Использование стандартных полей запроса в динамических списках на клиенте</a></li>
                <li><a href="#chapter4.3.8">Использование стандартного параметра формы отчёта для самостоятельного формирования отчёта при его открытии</a></li>
                <li><a href="#chapter4.3.9">Получение предопределённых значений на клиенте</a></li>
                <li><a href="#chapter4.3.10">Запись данных объекта в единой транзакции за один серверный вызов</a></li>
                <li><a href="#chapter4.3.11">Использование временного хранилища для передачи данных между формами</a></li>
                <li><a href="#chapter4.3.12">Пересчёт данных объекта в модуле объекта или в модуле формы в зависимости от логики объекта</a></li>
                <li><a href="#chapter4.3.13">Изменение оформительских свойств элементов формы, не требуюущих обращения к серверу</a></li>
            </ul>
        </li>





        <h3 class="header-style2" id="chap5">Часть 5. Мобильный клиент.</h3>
        <p>Стр. 868</p>
        <ul class="list">
            <li><a href="#chapter5.1">Глава 5.1. Что такое мобильный клиент. Стр 869</a></li>
            <li><a href="#chapter5.2">Глава 5.2. Адаптация конфигураций для работы в мобильном клиенте. Стр 871</a></li>
        </ul>
    </ul>










    <h2 class="header-style">Коструирование интерфейса</h2>
    <h3 class="header-style2" id="chapter1.1">Глава 1.1 Пользователь, интерфейс, команда</h3>
    <p><span class="vue-d-b">Пользователь</span> - человек, работающий с прикладным решением в режиме 1С:Предприятие. для обеспечения удобной и безопасной работы, для пользователя создаются пользовательские интерфейсы.</p>
    <p><span class="vue-d-b">Пользовательский интерфейс в 1С</span> - кнопочки, формочки на экране, обеспечивающие передачу информации между пользователем и программным обеспечением 1С. Составной частью пользовательского интерфейса является командный интерфейс, обеспечивающий доступ к функциональности программы.</p>
    <p><span class="vue-d-b">Команда</span> - это кнопка или ссылка, клик по которой побуждает программу выполнять какое то действие. При этом команда может быть отдата только пользователем, который имеет на это право.</p>
    <p><span class="vue-d-b">Командный интерфейс</span> - совокупность команд(кнопок, ссылок), доступных пользователю, при помощи которых он отдаёт приказы системе на выполнение действий.</p>
    <p>Команды бывают разные: одни позволяют перемещаться между функциональными блоками программы, другие вызывают различные формы, третьи выполняют действия с данными. В связи с тем, что различные пользователи выполняют различные задачи, права на использование обрабатываемой системной информацией и состав доступных команд для них будут различаться.</p>
    <p>Таким образом, при разработке командного интерфейса необходимо решить две основные задачи:</p>
    <ul class="list">
        <li>из множества команд, исполняемых программой, выделить подмножество команд, доступных конкретному пользователю;</li>
        <li>предоставить возможность пользователю вызывать доступные команды;</li>
    </ul>








    <h3 class="header-style2" id="chapter1.2">Глава 1.2 Прикладное решение глазами пользователя</h3>
    <p>В данной главе рассматривается структура пользовательского интерфейса прикладного решения под названием "Такси".</p>
    <p>При запуске показательной базы "Глава 1.2. Прикладное решение глазами пользователя" открывается основное окно приложения. В рабочей области основного окна мы видим <span class="vue-d-b">начальную страницу</span>, с которой начинается работа пользователя с прикладным решением.</p>
    <p>Задача начальной страницы - быстрое включение пользователя в работу. На начальной странице находятся формы, которые наиболее часто используются в данном решении. Например, список продаж товаров, расчёты с контрагентами, курсы валют и т.д. Причём каждый пользователь видит те формы, которые соотвествуют специфике его работы.</p>
    <p>Состав форм на начальной странице настраивается при разработке конфигурации(в т.ч. программно). Однако пользователь также может изменить состав форм из списка доступных форм, предназначенных для этого разработчиком. Подробно о настройке пользователем будет рассказано в главе 2.10</p>
    <p class="title-size16"><b id="chapter1.2.1">Основное окно приложения</b></p>
    <p>Речь в этой подглаве ведётся о том, где расположенны панели, с помощью которых пользователь осуществялет навигацию по приложению.</p>
    <p>Показ этих панелейможет быть включён/выключен как при разработке, так и в пользовательском режиме. При этом и разработчик и пользователь могут настраивать расположение этих панелей в основном окне так, как им удобно.</p>
    <p>Состав панелей интерфейса:</p>
    <ul class="list">
        <li>область системных команд;</li>
        <li>панель разделов;</li>
        <li>панель функций текущего раздела;</li>
        <li>панель интсрументов;</li>
        <li>панель избранного;</li>
        <li>панель истории;</li>
        <li>панель открытых;</li>
        <li>рабочая область;</li>
        <li>информационная панель;</li>
    </ul>
    <img src="../img/1С-1/2023-07-10_22-38-29.png" class="screen" alt="">
    <p>В самом верху окна находится <span class="vue-d-b">область системных команд</span>. В этой области выводится заголовок приложения и располагаются системные команды, состав которых не зависит от конкретного прикладного решения. Системные команды обеспечивают выполнение общих действий по управлению прикладным приложением. Например, обеспечивают доступ к главному меню прикладного решения, расположенного в правой части области системных команд. Слева от заголовка находится <span class="vue-d-b">меню функций</span>(в виде 3х полосок), при нажатии на него покажутся функции(команды) текущего раздела. Также меню функций покажется если нажать 2 раза на раздел.</p>
    <p>Если в информационной базе ведётся список пользователей, то в области системных команд отображается гиперссылка с именем пользователя, при нажатии на которую появляется диалог с информацией о текущем пользователе.</p>
    <p>Отображение остальных панелей может настраиваться как в конфе в целом для решения, так и пользователем под себя в режиме "1С:Предприятие".</p>
    <p>Под областью системных команд расположена <span class="vue-d-b">панель разделов</span>. Разделы делаят всю функциональность приложения на части, каждая из которых содержит набор команд, объединённых прикладным смыслом. Разделы приклданого решения соотвествуют подсистемам верхнего уровня. Если подсистем в конфигурации нет, то панель разделов не будет отображаться в основном окне приложения.</p>
    <p>Для повышения наглядности каждой подсистеме можно установить картинку. Причём и в конфе, и в режиме "1С:Предприятие" при настройке панели разделов можно установить расположение текста под картинкой или справа от неё.</p>
    <p>Первым разделом всегда является основной раздел, который называется Главное. В него помещаются команды, котрые всегда должны быть под рукой у конкретного пользователя в зависимости от его роли.</p>
    <p>Состав и порядок остальных разделов стандартно настраиваются разработчиком в конфе, но пользователь в режиме "1С:Предприятие" может изменить их по своему желанию.</p>
    <p>Под панелью разделов расположена <span class="vue-d-b">панель функций текущего раздела</span>. В начале панели обычно расположены команды, открывающие формы различных списков.</p>
    <p>Команды в этой панели, которые не в группах Создать, Отчеты и Сервис называются <span class="vue-d-b">командами навигации</span>, а вск команды что в этих группах называются <span class="vue-d-b">командами действия</span>.</p>
    <p>Команды навигации в этой панели могут распологаться в 3х стандартных невидимых группах: "Важное", "Обычное", "См. также". В группе "Важное" команды выделены жирным шрифтом и располагаются в самом начале, потом по важности идёт группа "Обычное" и за ней "См. также". Если все команды навигации не помещаются в этой панели, то в конце появится меню Ещё, где расположатся остальные команды навигации.</p>
    <p>В группаз Создать, Отчеты и Сервис сгруппированы команды, позволяющие выполнять различные действия: создавать новые элементы данных, формировать различные отчёты или выполнять какие-то обработки. После них могут находится произвольные группы команд, созданные разработчиком. Если команды в какой то группе отсутствуют, то эта группа не отображается на панели.</p>
    <p><span class="vue-d-b">Меню функций</span>, как уже писал выше открывается по кнопке в самом верху слева, либо при повторном клике по разделу. Меню функций содержит всё то же , что и панель функций текущего раздела, только немного в другом виде. В меню функций при подведении курсора к команде слева появляется звёздочка, при нажатии на которую команда попадёт в избранное.</p>
    <p>В правом верхнем углу меню функций находятся поле ввода для поиска и меню настроек. После ввода букв в поле ввода для поиска во всех разделах прикладного решения выполняется поиск функций, в представлении которых содержатся искомые буквы.</p>
    <p>Дальше рассказ про панель интсрументов. Инструмент <span class="vue-d-b">Избаранное, История, Поис</span>к. С помощью специального языка выражений для поиска можно выполнять полнотекстовый поиск по началу слов, "неточный" поиск, поиск по синонимам и т.д.</p>
    <p>Из панели инструментов пользователь может открыть <span class="vue-d-b">центр оповещений</span>, который предназначен для работы с оповещениями пользователя. Стандартно последние 3 оповещения показываются на несколько секунд в правом нижнем углу рабочей области основного окна, после чего пропадают. Но важные сообщения пользователю запоминаются в центре оповещений "1С:Предприятия". Если у пользователя появились новые важные сообщения, то в панели интсрументов рядом со значком появится оранжевая точка. Самые последние оповещения всегда находятся вверху списка. Оповещения можно удалить кнопкой очистки.</p>
    <p>Удобным интсрументом для переключения между окнами, открытыми в текущем сеансе работы с прикладным решением, является <span class="vue-d-b">панель открытых</span>. По умолчанию она не видна в интерфейсе приложения.</p>
    <p>В подвале основного окна приложения отображается <span class="vue-d-b">информационная панель</span>, которая показывает, включён ли режим имитации задержек при вызове сервера и показатели производителности системы. Они нужны для анализа и оптимизации клиент-серверного взаимодействия, о котором речь пойдёт в 4й части.</p>
    <p>Далее подглава рассказывает о настройке расположения панелей в интерфейсе через конфигуратор и в пользовательском режиме.</p>
    <P>Затем подглава рассказывает о 4х режимах основного окна приложения: Обычный, Рабочее место, Полноэкранное рабочее место и Киоск.</P>

    <p class="title-size16"><b id="chapter1.2.2">Окно клиентского приложения</b></p>
    <p>Для отображения форм, созданных в прикладном решении, используются <span class="vue-d-b">окна клиентского приложения</span>. При работе в интерфейсе "Такси" большинство форм открываются в окнах клиентского приложения, которые расположены в рабочей области основного окна приложения. Исключением являются блокирующие окна, которые могут блокировать как окно владельца, так и сразу весь интерфейс приложения.</p>
    <p>Если окно клиентского приложения открыто в режиме блокирования окна владельца, система не позволит переключиться на окно, из которого было открыто блокирующее, до тех пор, пока последнее не будет закрыто.</p>
    <p>Окна, блокирующие весь интерфейс, обеспечивают работу приложения без использования модальных окон. Отказ от модальности есть необходимым условием для работы "1С:Предприятия" в веб-клиенте и на мобильных устройствах, а также по ряду других причин.</p>
    <p>При закрытии окна клиентского приложения не происходит завершения работы прикладного решения.</p>
    <p>В окне клиентского приложения можно выделить <span class="vue-d-b">основную форму</span>, которая показывается в разделе "Основное" панели навигации окна клиентского приложения. При нажатии на другие ссылки в панели навигации окна клиентского приложения будут открываться <span class="vue-d-b">вспомогательные формы</span>.</p>
    <p>Структура окна клиентског оприложения следующая:</p>
    <img src="../img/1С-1/2023-07-11_22-02-27.png" class="screen" alt="">
    <p><span class="vue-d-b">Команды перехода между открытыми окнами клиенсткого приложения</span> позволяют перейти к начальной странице. Радом с ними находится кнопка в виде звёздочки, с помощью которой можно поместить форму в избранное или удалить её из избранного.</p>
    <p><span class="vue-d-b">Панель навигации окна клиентского приложения</span> позволяет просматривать различные сведения, логически связанные с данными, которые отображает основная форма окна. В панели навигации первой всегда является команда "Основное", которая предназначена для открытия основной формы окна клиентского приложения. Затем следуют остальные команды, с помощью которых можно открыть вспомогательные формы. Если все команды панели навигации не помещаются, то в конце будет подменю "Ещё", которое будет содержать оставшиеся команды.</p>
    <p><span class="vue-d-b">Командная панель формы</span> содержит команды, непосредственно связанные с объектом, который отображается в основной форме</p>











    <h3 class="header-style2" id="chapter1.3">Глава 1.3 Командный интерфейс системы</h3>
    <p>Какие команды бывают? Все команды можно разделить по <span class="vue-d-b">источникам</span> и по <span class="vue-d-b">области видимости</span>:</p>
    <img src="../img/1С-1/2023-07-07_17-45-36.png" class="screen" alt="">
    <p>Данная картинка не даёт исчерпывающие данные о командах, потому что эти команды, в зависимости от условий, можно назвать и по другому. Например, "что команды делают" - изменяют состав данных или изменяют сами данные; "необходимость в параметрах" - одни команды не требуют для своего исполнения параметров, а другим надо передавать параметры.</p>
    <p>По источникам команды можно разделить на 3 группы:</p>
    <ul class="list">
        <li>системные команды;</li>
        <li>стандартные команды объектов и расширений форм и некоторых элементов формы(таблица, табличный документ и т.д.);</li>
        <li>произвольные команды</li>
    </ul>
    <p><span class="vue-d-b">Системные команды</span> предопределены на уровне технологичесткой платформы и предоставляются автоматически. Их состав и выполняемые действия одинаковы для любого прикладного решения и не могут быть измененены разработчиком.</p>
    <p><span class="vue-d-b">Стандартные команды</span> предопределены на уровне объекта конфигурации (или расширения формы) и предоставляются автоматически. Состав стандартных команд зависит от того, какие объекты присутствуют в конфигурации и какие значения заданы для свойств этих объектов. Выполняемые действия также предопределены, но разработчик может в какой то мере повлиять на них, для этого используется механизм событий.</p>
    <p><span class="vue-d-b">Произвольные команды</span> полностью создаются разработчиком. Для этого существует объект конфигурации Команда. Для создания универсального функционала используются <span class="vue-d-b">общие</span> команды. Для создания функционала, специфического для того или иного объекта, используются команды <span class="vue-d-b">подчинённые</span> этому объекту.</p>
    <p>По области видимости команды делятся:</p>
    <ul class="list">
        <li>на глобальные;</li>
        <li>локальные команды формы;</li>
    </ul>
    <p><span class="vue-d-b">Глобальные команды</span> предназначены для выбора пользователем той или иной функциональности в рамках приложения в целом. В состав глобальных команд входят системные команды, стандартные команды объектов конфигурации, а также общие и подчинённые произвольные команды.</p>
    <p><span class="vue-d-b">Локальные команды формы</span> предназначены для выполнения действий в форме. В состав локальных команд входят стандартные команды формы, команды расширений некоторых элементов формы, а также произвольные команды формы. Эти команды доступны только в подтексте той или иной формы.</p>
    <p>Глобальные команды формируют <span class="vue-d-b">глобальный командный интерфейс</span> прикладного решения. Локальные команды формы и, возможно, часть глобальных команд формируют <span class="vue-d-b">командный интерфейс форм</span></p>
    <p>Каждому пользователю предоставлены только те команды, которые ему необходимы для решения своих конкретных задач.</p>
    <p>Как же "ужимается" командный интерфейс? Для этого давайте разберёмся с тем, как система формирует командный интерфейс пользователя.</p>

    <p class="title-size16"><b id="chapter1.3.1">Структура командного интерфейса</b></p>
    <p>При запуске прикладного решения для пользователя формируется <span class="vue-d-b">индивидуальный глобальный командный интерфейс</span>. Его структура, т.е. размещение команд, <span class="vue-d-b">однозначно определяется иерархией подсистем конфигурации и свойствами самих команд</span>. Состав же команд, включённых в командный интерфейс, определяется правами пользователя, значениями функциональных опций и видимостью по ролям.</p>
    <p>Кроме того, выполнение настроек командного интерфейса пользователем под себя, также влияют на размещение и состав команд командного интерфейса этого пользователя.</p>
    <p>Структура глобального командного интерфейса:</p>
    <img src="../img/1С-1/2023-07-12_08-18-57.png" class="screen" alt="">
    <p>Все системные команды размещаются в области меню системных команд основного окна приложения.</p>
    <p>В панели разделов размещаются команды для выбора разделов.</p>

    <p class="title-size16"><b id="chapter1.3.2">Влияние подсистем</b></p>
    <p>Почему же иерархия подсистем однозначно определяет структуру КИ? Да потому, что это логично.</p>
    <p>Обычно с помощью подсистем описываются различные виды деятельности, т.е. с их помощью формируется <span class="vue-d-b">функциональная структура</span> ПР. Под функционально структурой понимается все команды, которые есть в разделе(открытие форм справочников, документов, отчётов и т.д.)</p>
    <p>В одной подсистеме имеет смысл собирать объекты конфигурации, создающие тесно связанную функциональность. При этом состав подсистем верхнего уровня иерархии отражает наиболее общее разделение функциональности ПР. Например, разработчик может определеить подсистему Запасы и собрать в ней функции управления складскими запасами, а в подсистеме Взаиморасчёты объединить функции управления взаиморасчётами с контрагентами и т.д.</p>
    <p>Функциональность же КИ обеспечивают команды. Для того, чтобы КИ был удобным, не перегруженным и не содержал "лишних" команд, разработку ПР рекомендуется начинать с определения его функциональной структуры.</p>
    <p>Это значит, что перед созданием функциональности(создание объектов конфигурации, написанием кода) разработчик должен эту функциональность описать иерархией элементов. Корень иерархии будет соответствовать создаваемому ПР(корневому элементу конфигурции), а элементы - объектам конфигупации Подсистема.</p>
    <p>У подсистемы, для которой был сформирован раздел, могут существовать подчинённые подсистемы. В этом случае для каждой из подчинённых подсистем будет сформирован  <span class="vue-d-b">подраздел</span>, отображаемый группой в меню функций. В подразделах отображаются команды объектов, включённых в соответствующую подчинённую подсистему.</p>
    <img src="../img/1С-1/2023-07-08_17-18-21.png" class="screen" alt="">
    <p>Также из картинки видно, что команды включённые в сам раздел и те команды, которые включены в подраздел никак друг от друга не разделены, а идут друг за другом.</p>
    <p>Отдельно стоит обратить внимание на КИ раздела Главное. Этот раздел предназначен для отображения наиболее важных и часто используемых пользователем команд. Именно этот раздел активизируется при запуске ПР.</p>
    <p>В связи с тем, что для разных пользователей состав важной информации различен, раздел Главное не связан с какой-либо из подсистем. По той же причине состав доступных команд формируется вручную разработчиком.</p>
    <p>Для наполнения раздела Главное командами используется <span class="vue-d-b">редактор командного интерфейса</span> основного раздела. О нём поговорим позже.</p>

    <p class="title-size16"><b id="chapter1.3.3">Формирование состава глобального командного интерфейса. Роли и права для них. Влияние на отображение функциональных опций. Пользовательские настройки для отображения команд.</b></p>
    <p>Страница 37, кратко опишу. Система при наполнении командного интерфейса командами смотрит на права пользователя, на функциональные опции(что включено, а что выключено). Рассказывается немного про права и как настроить роль для пользователя, что разрешить, что запретить и т.д. Также рассказывается доступ команд по функциональным опциям. И ещё рассказывается как пользователь может сам настроить отображение тех или иных команд под себя.</p>
    <p>В конце главы краткие итоги и картинка обобщающая как формируется глобальный командный интерфейс.</p>









    
    <h3 class="header-style2" id="chapter1.4">Глава 1.4 Настраиваем состав команд</h3>
    <p>Для показа механизмов конструирования командного интерфейса мы будем использовать демо базу "Глава 1.2. Прикладное решение глазами пользователя". Результат решения этой задачи будет в демо базе "Глава 1.4. Настраиваем состав команд".</p>
    <p><b>Постановка задачи</b>.</p>
    <p>На предприятии процесс ценообразования вынесен в отдельный функциональный блок и управлением ценами занимаются специально выделенные сотрудники. В демо базе операции управления ценами совмещены с операциями управления товарными запасами в подсистеме Товарные запасы.</p>
    <img src="../img/1С-1/2023-07-12_09-18-52.png" class="screen" alt="">
    <p>Нужно выделить функционал управления ценами в отдельную подсистему и создать командный интерфейс для сотрудников, работающих с этой подсистемой.</p>
    <p><b>Состав разделов</b>.</p>
    <p>Как уже было сказано, состав команд панели разделов определяется составом объектов конфигурации Подсистема верхнего уровня иерархии. Однако создание в дереве конфигурации подсистемы верхнего уровня ещё не гарантирует, что для неё при построении командного интерфейса будет создан раздел.</p>
    <p>Формирование раздела командного интерфейса для подсистемы верхнего уровня иерархии управляется свойством подсистемы "Включать в командный интерфейс".</p>
    <img src="../img/1С-1/2023-07-12_09-30-22.png" class="screen" alt="">
    <p>Данное свойство оказывает влияние на формирование раздела командного интерфейса для всех пользователей прикладного решения, независимо от назначенных им ролей. Если для подсистемы это свойство установлено, то для неё будет сформирован отдельный раздел, а стандартные команды объектов конфигурации, включённых в подсистему, будут учитываться при формировании командного интерфейса пользователя. Если же свойство не установлено, то не будет сформирован раздел и команд не будет видно.</p>
    <p>Продолжим решать поставленную задачу.</p>
    <p>Создадим подсистему верхнего уровня "Ценообразование". В редакторе зададим имя и синоним. Далее вспомним, что доступность раздела для пользователя определяется значением права "Просмотр", установленным у роли пользователя для соответствующей подсистемы. Проконстролируем значение этого права для роли Администратор - право должно быть установлено.</p>
    <img src="../img/1С-1/2023-07-12_09-46-52.png" class="screen" alt="">
    <p>Право для новых объекто устанавливается автоматически, потому что у роли Администратор установлен флажок "Устанавливать права для новых объектов".</p>
    <p>Следующим действием по созданию раздела является его наполнение командами.</p>
    <p><b>Стандартные команды</b>.</p>
    <p>Для начала разберёмся, какими же командами может быть наполнен раздел командного интерфейса.</p>
    <p><span class="vue-d-b">В раздел командного интерфейса включаются стандартные команды тех объектов конфигурации, которые принадлежат соответствующей подсистеме верхнего уровня(и подсистемам, иерархически ей подчинённым)</span>.</p>
    <p>Что же подразумевается под <span class="vue-d-b">стандартной командой</span>? Каждый объект конфигурации имеет стандартный набор свойств, определяющий его поведение по умолчанию. Для доступа к функциональности объекта платформа предоставляет некоторый набор команд. Вот эти команды и являются стандартными. Для стандартных команд выполняемые действия определены на уровне платформы и не могут быть изменены разработчиком.</p>
    <p>Например, для объекта конфигупрации Товары, добавленного в состав какой-нибудь подсистемы Запасы, платформа сама добавит в этот раздел команду Товары, которая будет открывать форму списка справочника Товары. Вот команда Товары в разделе Запасы будет стандартной командой.</p>
    <p>От чего зависит состав стандартных команд? Он зависит от класса объектов, которому принадлежит объект конфигурации. Например, объект Товары создан от класса объектов Справочники, а значит плаформа предоставит несколько стандартных команд для этого объекта: Товары - отрывает форму списка товаров, Товар - откроет форму создания нового товара, Товары: создать группу - откроет форму создания новой группы. А вот объект конфигурации Остатки товаров, созданный от класса Отчеты, предоставит только одну стандартную команду - Остатки товаров, которая открывает форму отчёта.</p>
    <img src="../img/1С-1/2023-07-12_10-11-13.png" class="screen" alt="">
    <p>Как видно из картинки, мы можем видеть какие стандартные команды предоствляет система для объекта конфигурации и также можно настраивать их отображение в редакторе командного интерфейса.</p>
    <p>Стандартная команда Товары: создать группу по умолчанию невидима в командном интерфейсе.</p>
    <p>Кроме класса на состав команд объекта конфигурации влияют и значение свойств этого объекта. Например, справочник Товары предоставляет стандартные команды как для создания элемента, так и для создания группы, а справочник Склады - только команду создания нового элемента.</p>
    <p>А причина заключается в том, что у справочника Товары установленно свойство "Иерархический сповочник" со значением "Иерархия групп и элементов", а у справочника Склады это свойство сброшено.</p>
    <p>Также как и с подсистемами, наличие объекта в дереве конфигурации ещё не гарантирует наличие его команд в командном интерфейсе. Чтобы платформа могла сама добавить стандартные команды объекта в раздел, нужно чтобы у объекта конфигурации было установленно свойтсво "Использовать стандартные команды". По умолчанию это свойство установлено.</p>
    <img src="../img/1С-1/2023-07-12_12-32-15.png" class="screen" alt="">
    <p>Пришло время обеспечить подсистему Ценообразование командами, но для начала определимся, какими объектами создан создан функционал управления ценами. В демо базе их 3:</p>
    <ul class="list">
        <li>Справочник Товары - хранит список товаров и услуг, для которых могут назначяться цены.</li>
        <li>Справочник Виды цен - хранит список видов цен, которые могут быть назначены каждому товару(услуге).</li>
        <li>Регистр сведений Цены товаров - хранит значения цен в разрезе товаров и видов цен.</li>
    </ul>
    <p>Включим каждый из указанных объектов в нашу подсистему. Для этого надо заполнить свойство Состав подсистемы Ценообразование.</p>
    <p>Как и для подсистем, доступность для пользователя объектов и их стандартных команд определяется значением прав, установленных у роли пользователя для этих объектов. Проконтролируем значения прав для этих 3х объектов. Готово. </p>









    <h3 class="header-style2" id="chapter1.5">Глава 1.5 Настраиваем доступность команд по ролям</h3>
    <p>Страница 65. В этой главе рассматривается система прав доступа  и её влияние на командный интерфейс. Когда будет необходимость, то почитать про права в этой главе.</p>








    <h3 class="header-style2" id="chapter1.6">Глава 1.6 Редактирование командного интерфейса</h3>
    <p>Страница 62. В основном рассказывается о командах, какие бывают команды: навигационные, параметризированные, независимые. В каких категориях можно разместить команды: Важное, Обычное, См. также. Какие бывают стандартные группы команд: Создать, Отчеты, Сервис. Разработчик также может создать свою группу команд через объект конфигурации "Группы команд", она разместится после стандартных групп.</p>
    <p>В панели команд текущего раздела распологаются <i style="text-decoration: underline;">независимые глобальные навигационные команды</i>.</p>
    <p>В стандартных группах располагаются <i style="text-decoration: underline;">независимые глобальные команды действий</i>.</p>
    <p>Если открыть какую нибудь форму справочника или документа, то в панели навигации располагаются <i style="text-decoration: underline;">параметризированные навигационные глобальные команды</i>.</p>
    <p>Также в форме справочника или документа ниже панели навигации есть панель команд, в ней распологаются <i style="text-decoration: underline;">параметризированные глобальные команды действий</i>.</p>
    <p>Со страницы 97 пошло объяснение как настраивать отображение команд и размещение их в командном интерфейсе в редакторе. Для этого в конфигураторе либо у корня, либо у подсистемы в контекстном меню выбираем командный интерфейс и там уже передвигаем, ставим галочки для команд.</p>
    <p>Чтобы настроить размещение и отображение команд в основном разделе, то у корня в контекстном меню выбираем "Открыть командный интерфейс основного раздела" и настраиваем.</p>
    <p>Далее идёт подробное объяснение как в этом редакторе настраивать команды. Очень полезно почитать, когда такая информация понадобится.</p>









    <h3 class="header-style2" id="chapter1.7">Глава 1.7 Влияние функциональных опций на командный интерфейс</h3>
    <p>Страница 116.</p>









    <h3 class="header-style2" id="chapter1.8">Глава 1.8 Пользовательская настройка интерфейса</h3>
    <p>Страница 126. Пропустил пока.</p>










    <h3 class="header-style2" id="chapter1.9">Глава 1.9 Настраиваем представление команд</h3>
    <p>Страница 140. Пропустил пока.</p>










    <h3 class="header-style2" id="chapter1.10">Глава 1.10 Модель разработки глобального командного интерфейса</h3>
    <p>Страница 147. Пропустил пока.</p>








    <h3 class="header-style2" id="chapter1.11">Глава 1.11 Создаём произвольные команды</h3>
    <p>Помимо стандартных команд "1С:Предприятие" позволяет разработчику создавать произвольные команды и размещать их в интерфейсе такими же способами, которыми размещаются стандартные команды. Действия, выполняемые этими произвольными командами, разработчик описывает на встроенном языке в специальных модулях - модулях команд.</p>
    <p>Объект конфигурации Команда предназначен для создания в ПР <i style="text-decoration: underline;">нестандартных действий</i> с возможностью использования <i style="text-decoration: underline;">стандартных механизмов</i> включения этих действий в командный интерфейс.</p>
    <p>Платформа никак не ограничивает состав произвольных команд и написанных к ним действий.</p>
    <p>При создании произвольной команды разработчик должен установить её свойства, определяющие правила включения команды в интерфейс. И также написать программный код, определяющий выполняемые командой действия. Этим и отличаются произвольные команды от стандартных. Для последних и свойства и выполняемые действия определены самой платформой.</p>
    <p>В конфигурации произвольные команды могут быть созданы или как независимые объекты - общие команды, или как команды, подчинённые другим объектам.</p>
    <p><span class="vue-d-b">Общие произвольные команды</span> позволяют создать нестандартные действия, относящиеся в целом к прикладному решению. В этом случае произвольная команда создаётся как независимый объект конфигурации, принадлежащий классу <span class="vue-b">Общие команды</span>:</p>
    <img src="../img/1С-1/2023-07-09_08-13-30.png" alt="">
    <p><span class="vue-d-b">Подчинённые произвольные команды</span> позволяют создать нестандартные действия для какого-либо объекта конфигурации.</p>
    <p>На торговых предприятиях часто требуется автоматизировать процесс записи продаваемого товара. Для этого используются сканеры штрихкодов. Однако платформа ничего "не знает" об этих устройствах и не имеет средств работы с ними. Значит, для работы со сканерами требуется подключать специальную программу - драйвер. В показательной базе для подключения такого драйвера создана общая произвольная команда "Установить сканер штрихкодов". Установив определённые значения свойств этой команды, разработчик обеспечивает её доступность пользователям. Имеется ввиду, когда разработчик устанавливает в свойстве Группа, палитры свойств этой команды, значение - "Панель действий.Сервис", т.е помещает команду в группу Сервис.</p>
    <p>Функции работы со сканером являются общими для всего ПР, т.е. не относятся к какому-то конкретному объекту конфигурации, поэтому произвольная команда создана как общая.</p>
    <p>Ещё одной распространённой задачей является получение печатных копий электронных документов. Естественно, в платформе невозможно предусмотреть всё многообразие документов и варианты их печатных форм. Для того чтобы "научить" документ "переносить" себя на бумагу, можно воспользоваться произвольной командой.</p>

    <p class="title-size16"><b id="chapter1.11.1">Создадим произвольную подчинённую команду для объекта конфигурации</b></p>
    <p>В демо базе для получения печатной формы документа "РасходТовара" создана подчинённая команда "ПечатьРасходнойНакладной". Обычно команды с функцией печати помещают в группу, которую разработчик сам и создаёт и называют её Печать, а затем в эту группу собираются вместе все команды с функционалом печати.</p>
    <p>Для того чтобы создать свою группу существует класс <span class="vue-b">Группа команд</span> в ветке Общие, создаём такую группу:</p>
    <img src="../img/1С-1/2023-07-09_09-21-17.png" class="screen" alt="">
    <p>Как видно на картинке группа Печать была размещена в Категории "Командная панель формы". Это значит, что группу Печать будет распологаться в командной панели какой то формы.</p>
    <p>Вот так выглядит созданная команда "ПечатьРасходнойНакладной":</p>
    <img src="../img/1С-1/2023-07-09_09-40-21.png" class="screen" alt="">
    <p>В свойстве Группа указываем ранее созданную группу Печать, т.е. мы помещаем нашу команду в эту группу. Так как наша команда помещается в форму, то значит наша команда параметрозависимая и значит нужно указать и второе свойство "Тип параметра команды".</p>
    <p>Значение свойства "Тип параметра команды" задаёт тип данных для аргумента процедуры ОбработкаКоманды - ПараметрыКоманды. Этот параметр идёт первым в процедуре. Когда в форме документа мы нажмём на команду "ПечатьРасходнойНакладной" в меню Печать, то сработает эта процедура и в парметр ПараметрыКоманды попадёт ссылка конкретно на текущий документ.</p>
    <img src="../img/1С-1/2023-07-09_18-29-17.png" class="screen" alt="">
    <p>Видимо система получив тип данных ДокументСылка.РасходТоваров, понимает, что нужно разместить группу Печать с командой внутри в формах связанных с документом "РасходТоваров", а именно в форме спика, в форме документа, может ещё в каких формах связанным с этим документом. Готово.</p>
    <p>Продолжаем. Ещё одним специфическим способом использования произвольных команд является расширение или переопределение стандартной функуиональности стандартной команды. Такие задачи возникают, например, вследствии требования сократить количество ручных операций или изменить стандартное поведение объектов.</p>
    <p>Приведём пример с обработкой. Есть обработка "АдминСервис", у неё есть форма какая то. По умолчанию система сама расположит команду открытия формы обработки среди команд действий группы Сервис. Нам не надо, чтобы команда была в группе Сервис, а мы хотим расположить её в командах навигации текущего раздела. Если забылось, то напомню, что в панели команд текущего раздела всё что не в группах это навигационные команды, а то что в группах это команды действия.</p>
    <p>Итак, нужно разместить команду вызова формы обработки в навигационных командах раздела. Для этого в конфигураторе откроем редоктор объекта обработки АдминСервис и перейдём на закладку Команды, там внизу есть галочка "Использовать стандартные команды". Эта установленная галочка как раз и говорит системе, чтобы она сама размещала обработки в группе Сервис. Уберём эту галку и создадим свою произвольную команду "АдминСервис", в свойствах этой команды в Группа выберем место, куда мы хотим поместить её, выберем Панель навигации.Обычное. Всё, если посмотрим в пользовательском режиме, то увидим эту команду среди других глобальных команд навигации раздела. В подсистему также не забыть добавить обработку.</p>
    <p>Чтобы команда открывала форму обработки, то в модуле команды можно раскоментировать заготовку, там как раз уже есть код открытия формы.</p>

    <p class="title-size16"><b id="chapter1.11.2">Особенности размещения</b></p>
    <p>Особенностью произвольных команд по сравнению со стандартными является необходимость описания места их размещения разработчиком по умолчанию в командном интерфейсе.</p>
    <p>В остальных же точках(аспектах) управления произвольными командами: доступность по ролям, управление видимостью команды, настройка зависимости от функциональных опций и т.д. - соответствуют управлению стандартными командами.</p>
    <p>Размещение в командном интерфейсе для произвольных команд определяется:</p>
    <ul class="list">
        <li>категорией и группой, назначенной команде;</li>
        <li>принадлежность команды к подсистеме конфигурации(для независимых команд);</li>
        <li>типом параметра команды(для параметризуемых команд);</li>
    </ul>
    <p>Категория и группа устанавливаются в свойстве Группа этой команды.</p>
    <p>При выборе группы для команды следует обращать внимание на необходимость в передаче параметров команде и на действия, выполняемые командой. Тут можно придерживаться тех же правил, которые используются для стандартных команд:</p>
    <ul class="list">
        <li>Если команда для своего исполнения не требует параметров, то для неё выбирают группу с категорией "Панель навигации" или "Панель действий".</li>
        <li>Если команда для своего исполнения требует передачи параметра, то для неё необходимо выбрать группу с категорией "Панель навигации формы" или "Командная панель формы".</li>
        <li>Для команд, выполнение которых приводит к изменению информации, отображаемой в рабочей области того же окна, следует выбирать категорию "Панель навигации" для незавизимых команд или "Панель навигации формы" для параметризуемых команд.</li>
        <li>Дла команд, выполнение которых приводит к изменению данных в информационной базе, следует выбирать категорию "Панель действий" для независимых команд или "Командная панель формы" для параметризуемых команд. Также эту категорию стоит выбирать для команд, которые приводят к открытию блокирующих окон.</li>
    </ul>
    <p>Для включения <i style="text-decoration: underline;">общей независимой команды</i> в тот или иной раздел командного интерфейса необходимо указать её принадлежность к соответствующим подсистемам.</p>
    <p>Подчинённую же команду непосредственно включить в подсистему невозможно. Поэтому <i style="text-decoration: underline;">подчинённые независимые команды</i> автоматически включаются в командный интерфейс тех подсистем, в которые включён объект - владелец команды. Тут у меня вопрос. Как команда может быть подчинённая и в то же время независимая? Как выглядит такая команда? Могу предположить как пример такой команды был описан выше в виде обработки. Там мы для обработки создали подчинённую команду, в модуле команды задали открытие формы этой обработки. Хотя в процедуре ОбработкаКоманды есть параметры, но в данном случае они не нужны, чтобы открыть форму. Получается команда подчинена Объекту конфигурации Обработки, поэтому подчинённая, но располагается в панели команд раздела(подсистемы), а значит не имеет параметров, поэтому независимая.</p>
    <p>А вот параметризуемые произвольные команды, как общие, так и подчинённые, включаются в командный интерфейс иначе. Связано это с тем, что значение своего параметра команда может получить только из данных формы. Причём это значение должно иметь тип данных, допустимый для параметра. Состав допустимых типов параметра устанавливается в свойстве "Тип  параметра команды"</p>
    <p>Вот следующее предложение отвечает на мой вопрос как влияет свойство "Тип параметра команды" на то в каких формах отображать команду. Сравнивая состав типов, заданных в свойстве "Тип параметра команды", с типами реквизитов формы, система принимает решение о включении команды в ту или иную форму. Вот поэтому команда "ПечатьРасходнойНакладной" и появилась в форме списка документа, потому что там есть реквизиты с такими типами данных как задано в этом свойстве, а именно реквизит Ссылка имеет такой тип как ДокументСсылка.ПродажаТоваров.</p>
    <p><i style="text-decoration: underline;">Параметризуемая произвольная команда включается в форму только тогда, когда форма имеет хотя бы один рекизит с типом, входящим в состав допустимых.</i> При проверке учитываются и реквизиты, подчинённые основному реквизиту формы. Состав проверяемых подчинённых реквизитов ограничен первым уровнем подчинения.</p>

    <p class="title-size16"><b id="chapter1.11.3">Развитие функциональности ценообразования. Создаём общую произвольную независимую команду. Настраиваем её видимость. Заботимся о пользователе делая подсказки о том, что это за команда.</b></p>
    <p>Вернёмся к решению нашей задачи по выделению функционала работы с ценами в отдельную подсистему. Кроме назначения цен нам потребуется и возможность распечатывать цены на товары. При этом нужно сделать 2 режима:</p>
    <ul class="list">
        <li>печать ценников на все товары по всем видам цен</li>
        <li>печать ценников на все товары по одному виду цен</li>
    </ul>
    <p>Стандартные команды объектов конфигурации не могут обеспечить нас этими возможностями. Значит нам нужно сделать дополнительную функциональность. Будем использовать произвольные команды.</p>

    <p><b>Общая произвольная независимая команда</b>.</p>
    <p>Функционал печати всех ценников, на первый взгляд, должен расширять возможности справочника Товары. Однако этот объект конфигурации описывает <i style="text-decoration: underline;">множество</i> объектов данных информационной базы. Если мы сделаем команду как подчинённую справочнику, то мы "научим" каждый из объектов данных печатать ценники на все товары. А это уже лишнее. Объект данных должен быть ответственнен только за себя. Поэтому команду будет общей.</p>
    <p>Используя контекстное меню объекта <i style="text-decoration: underline;">Общие команды</i> дерева конфигурации, добавим новую команду. Для новой команды откроются палитра свойств и модуль команды с заготовкой. Задаим имя команды - "ПечатьЦенниковТовары".</p>
    <p>Следующий шаг выбор категории команды и группы для её размещения по умолчанию.</p>
    <p>Наша команда для своего исполнения не требует параметров - она <i style="text-decoration: underline;">независимая</i>. Команда выполняет <i style="text-decoration: underline;">действия</i> по обработке данных, хранимых в инфобазе, с целью получения набора ценников. Следовательно, для команды установим категорию "Панель действий". А в какой группе она будет отображаться? Логичнее всего поместить её в группу Сервис.</p>
    <img src="../img/1С-1/2023-07-18_09-07-02.png" class="screen" alt="">
    <p>Заметим, что ниже 3 свойства стали не доступны, потому что они нужны для параметризуемых команд.</p>
    <p>Созданная нами команда явялется независимой, а значит ей нужно указать подсистему, в которой она будет видна. Команда должна быть видна в тех разделах, в которых можно выполнять действия по управлению ценами. В нашем случае это подсистемы: Ценообразование, Цены, Предприятие. Подсистема Цены является подчинённой подсистемой для подсистемы Товарные запасы. Чтобы быстро указать в какие подсистемы добавить нашу команду, можно в подтекстном меню команды выбрать Дополнительно и откроются все подсистемы.</p>
    <p>Следующая задача - назначение прав на использование команды. Наша команда доступна пользователям с ролью Администратор за счёт установленного свойства роли "Устанавливать права для новых объектов". От нас требуется её обеспечить и для роли Менеджер по ценам.</p>
    <p>Как и для других объектов конфигурации, для общей команды настройку доступности можно выполнить в окне редактирования роли, а можно в уже открытом окне Дополнительно на закладке Права. В списке Роли выбираем роль и в списке Права устанавливаем право Просмотр для созданной команды.</p>
    <p>Наша команда по умолчанию должна быть видна пользователю с ролью Менеджер по ценам, а от пользователя с ролью Администратор её необходимо скрыть. Для этого в редакторе командного интерфейса подсистемы Ценообразование снимем флажок общей видимости в колонке Видимость. Это обеспечит нам невидимость команды для всех ролей. А для роли Менеджер по ценам установим флажок:</p>
    <img src="../img/1С-1/2023-07-18_12-08-11.png" class="screen" alt="">
    <p>Если запустить пользовательский режим от имени Менеджара по ценам, то увидим в разделе Управление ценами(синоним подсистемы Ценообразование) группу Сервис с командой внутри.</p>
    <p>Таким образом, для произвольной общей независимой команды:</p>
    <ul class="list">
        <li>размещение в командном интерфейсе по умолчанию определяется значением свойства Группа;</li>
        <li>включение в раздел командного интерфейса определяется принадлежностью к соответсвующей подсистеме;</li>
        <li>доступность для пользователя определяется значением права Просмотр.</li>
    </ul>
    <p>Команду мы создали. А как рассказать пользователю о том, какие действия выполняет эта команда? Ответ очевиден - описать назначение команды в документации к прикладному решению. Также назначение команды можно описать во встроенной электронной справке. Для работы со справочной информацией предназначены свойства общей команды в палитре свойств на закладке <b>Справочная информация</b>. Или то же самое можно вызвать из контекстного меню кликнув Справочная информация. Откроется окно, в котором пишется поясняющая информация.</p>
    <p>Однако поиск описания команды в документации или во встроенной справке - процесс длительный. К тому же, чтобы увидеть справочную информацию, пользователю нужно будет лишний раз нажать кнопку со знаком вопроса. Можно помочь пользователю быстро вспомнить назначение команды, выбрав для неё говорящее представление - Синоним. Сейчас команда представленна текстом "Печать ценников товары", и это представление достаточно информативно. Но в дальнейшем мы добавим в прикладное решение ещё одну команду печати ценников - по виду цен. Поэтому стоит подумать над таким представлением команды, которое подскажет пользователю, какой вариант печати ценников будет выполнен. Например, этот будет "Печать всех ценников".</p>
    <p>Ещё одним способом напоминания пользователю о назначении команды является использование свойства <i style="text-decoration: underline;">Подсказка</i>. Текст, заданный в этом свойстве, отображается во всплывающей подсказке при наведении указателя мыши на команду. Для свойства Подсказка зададим текст "Печать ценников на все товары по всем видам цен".</p>
    <img src="../img/1С-1/2023-07-18_20-19-10.png" class="screen" alt="">
    <p>На данный миг мы создали команду, настроили её расположение, доступность и представление. Нам осталось сделать функционал команды - действия, которая она должна делать. Но делать функционал мы не будем, книга не об этом.</p>

    <p class="title-size16"><b id="chapter1.11.4">Подчинённая параметризуемая команда.</b></p>
    <p>Теперь сделаем функциональность печати ценников по одному виду цен. Для этого также будем использовать произвольную команду.</p>
    <p>В отличии от предыдущей эта команда расширяет функциональные возможности справочника "Виды цен". Любой из элементов этого справочника (объектов данных, хранимых в БД) должен знать, как распечатать цены на товары по своему виду цены. Поэтому команду сделаем подчинённой справочнику "Виды цен".</p>
    <p>Идём в объект конфы "Виды цен" и добавим подчинённую команду "ПечатьЦенниковПоВидуЦены". В отличии от произвольной общей команды у подчинённой нет в свойствах Справочной инофрмации, она теперь находится у объекта владельца команды.</p>
    <p>Для свойства Группа пока установим значение <i style="text-decoration: underline;">Панель действий.Сервис</i>. Этим мы определили произвольную подчинённую <i style="text-decoration: underline;">независимую</i> команду <i style="text-decoration: underline;">действия</i>. Это как мы выше делали для обработки, создавали подчинённую команду, но без параметров и размещали не в форме обработки, а в командной панели раздела(подсистемы).</p>
    <p>Подчинённая команда включается в те же разделы интерфейса, что и владелец-объект. Следовательно, созданная команда включена в раздел "Предприятие", раздел "Управление ценами" и подраздел "Цены" раздела "Товарные запасы" за счёт принадлежности справочника "Виды цен" соответствующим подсистемам.</p>
    <p>Теперь давайте вспомним, что команда должна выполнять действия по печати ценников только для выбранного вида цен. Этот вид цены команда принимает как параметр, т.е. команда <i style="text-decoration: underline;">параметризуемая</i>. Поэтому изменим значение свойства Группа на <i style="text-decoration: underline;">Командная панель формы.Важное</i>. Команда по умолчанию распологается в группе "Важное" командной панели формы. В качестве параметра наша команда принимает ссылку на тот вид цен(элемент справочника "Виды цен"), для которого необходимо распечатать ценники. Поэтому в качестве значение свойства "Тип параметра команды" зададим тип данных СправочникСсылка.ВидыЦен.</p>
    <p>Исходя из типа параметра, наша команда будет доступна как минимум в двух формах:</p>
    <ul class="list">
        <li>в форме списка справочника "Виды цен", где параметром будет ссылка на текущую строку списка;</li>
        <li>в форме элемента того же справочника, параметром будет ссылка на элемент справочника, который мы открыли.</li>
    </ul>
    <p>А если команде потребуется передать не одно значение параметра, а несколько? В этом случае необходимо установить значение "Множественный" для свойства "Режим использования параметра", тогда в параметр "ПараметрыКоманды" процедуры ОбработкаКоманды будет попадать не ссылка, а массив с ссылкой или ссылками. Ссылки в массиве могут быть не в том порядке, в котором они выделены в списке.</p>
    <p>Ещё одно свойство, которое определено для параметризуемых команд, явялется свойство "Изменяет данные". Если это свойство установленно, то система пытается заблокировать данные формы для редактирования. В случае успеха для формы устанавливается признак модифицированности. Такое поведение позволяет сымитировать интерактивное изменение данных в форме. <span class="vue-r">Тут это свойство вообще не понял, что делает</span>.</p>
    <p>Как и для команды печати всех ценников, для нашей команды тоже надо выполнить назначение прав на её использование. Команда должна быть доступна пользователям с ролью "Менеджер по ценам".</p>
    <p>Для этого у команды справочника "Виды цен" в контекстном меню жмём "Дополнительно" и на заладке "Права" для роли МенеджерПоЦенам установим право "Просмотр".</p>
    <p>Если право "Просмотр" будет сброшено, система не включит подычинённую команду в командный интерфейс пользователя. Даже в том случае, когда роль обладает полными правами на объект-владелец(установлены все права на этот объект).</p>
    <p>В результате выполненных настроек, наша команда будет видна в форме списка и в форме элемента справочника "Виды цен" для роли "Менеджер по ценам".</p>
    <p>Таким образом, для произвольной подчинённой параметризуемой команды:</p>
    <ul class="list">
        <li>размещение в командном интерфейсе определяется значением свойства "Группа"</li>
        <li>состав форм, в которых будет доступна команда, определяется значением свойства "Тип параметра команды"</li>
        <li>доступность для пользователя определяется значением права "Просмотр", устанавливаемого для подчинённой команды</li>
    </ul>
    <p>Нам осталось настроить представление команды в интерфейсе и написать процедуру исполнения команды.</p>
    <p>Для настройки представления заполним свойство "Синоним" тестом "Печать ценников для вида цен", своство "Подсказка" - текстом "Печать ценников на товары по выбранному виду цены".</p>
    <p>В процедуре просто выведем сообщения для показа того, что код реагирует на клик по кнопке.</p>
    <p>Помимо свойств "Синоним" и "Подсказка" на представление команды влияют свойства "Картинка" и "Отображение". На данный миг свойство "Картинка" не заполнено, а свойство "Отображение" имеет значение "Авто". В этом случае команда представлена синонимом.</p>
    <p>Свойство "Картинка" содержит пиктограмму, которая, в зависимости от значения свойства "Отображение", может представлять команду в интерфейсе. В качестве пиктограммы может быть выбрана любая стандартная или общая картинка. Давайте для команды зададим стандартную картинку "Печать".</p>
    <p>Свойство "Отображение" задаёт способ отображения команды:</p>
    <ul class="list">
        <li>Текст - в представлении команды присутствует только текст</li>
        <li>Картинка - в пердставлении команды присутствует только пиктограмма</li>
        <li>Картинка и текст - в представлении команды присутствует и картинка и текст</li>
        <li>Авто - решение о представлении команды принимает система(в командных панелях, связанных с интерфейстными элементами, присутствуют пиктограмма; в пунктах меню присутствуют текст и пиктограмма)</li>
    </ul>
    <p>Установим для свойства значение "Картика и текст".</p>
    <p>!! Свойства "Картинка" и "Отображение" используются только для команд, размещённых в командной панели формы. При размещении в других панелях команды представлены синонимом или именем, если синоним не заполнен.</p>
    <p>У произвольных команд есть ещё свойство, которое мы не рассмотрели, - "Сочетание клавиш". Это свойство позволяет назначить команде клавиатурную комбинацию для её быстрого вызова. Для назначения сочетания клавишь нужно выбрать это свойство и нажать клавиши.</p>
    <p>Дальше тут идёт небольшое описание как поставить нашу команду в зависимость от ффункциональной опции.</p>

    <p class="title-size16"><b id="chapter1.11.5">Произвольные группы.</b></p>
    <p>По умолчанию команды располагаются в стандартных группах и при необходимости разработчик может расширить стандартный состав групп. Для этого используются объекты конфигурации "Группы команд" в ветке Общие.</p>
    <p>Произвольные группы команд используются для объединения команд, выполняющих похожие действия. Например группа "Печать", в которую объединяются команды печати разных печатных форм.</p>
    <p>Для определения места размещения произвольной группы используется свойство "Категория". Если не установить значение этого свойства, то система сама установить произвольную группу в "Панель навигации".</p>
    <p>Выбранная категория определяет, где будет размещена группа, и, следовательно, команды, принадлежащие этой группе.</p>
    <p>Для формирования представления группы команд в командном интерфейсе используются свойства "Синоним", "Отображение", "Подсказка" и "Картинка"</p>
    <p>Из особенностей объекта "Группы команд" необходимо отметить, что для него не назначаются права, не определяется принадлежность к подсистемам и зависимость от функциональных опций. Произвольная группа будет представленна в командном интерфейсе пользователю только в том случае, когда в нём доступна хотя бы одна из команд, включённых в группу.</p>












    <h3 class="header-style2" id="chapter1.12">Глава 1.12 "Командуем" формами</h3>
    <p>В данной главе мы рассмотрим формирование набора команд, доступных для использования в подтексте формы. Здесь же изложены основные сведения о форме, необходимые для понимания этого механизма.</p>

    <p class="title-size16"><b id="chapter1.12.1">Необходимые сведения о формах.</b></p>
    <p>Формы предназначенны для взаимодействия пользователя с данными информацинной базы. Для этого формы наполняются необходимой функциональностью.</p>
    <p>Функциональность формы определяется составом её реквизитов и команд. <span class="vue-d-b">Реквизиты формы</span> - это данные, с которыми работает форма. <span class="vue-d-b">Команды формы</span> - это действия, которые может выполнить форма над данными.</p>
    <p>Однако наличие команды в форме ещё не даёт возможности использовать её функциональность. Как и реквизиты сами по себе не обеспечивают возможности отображения и редактирования данных.</p>
    <p>Для использования команд, для отображения и редактирования данных, хранимых в реквизитах, служат <span class="vue-d-b">элементы формы</span>. Это можно предстаить в виде такой упрощённой схемы:</p>
    <img src="../img/1С-1/2023-07-27_21-50-46.png" alt="">
    <p>Во-первых, форма не прорисовывается детально разработчиком, а строится системой автоматически. Разработчик же в режиме конфигурирования:</p>
    <u class="list">
        <li>определяет состав формы в виде дерева элементов;</li>
        <li>описывает поведение формы, задавая значения для её свойств и/или делая процедуры на встроенном языке;</li>
    </u>
    <p>При построении интерфейса для того или иного пользователя система использует это <i style="text-decoration: underline;">декларативное описание</i> для создания формы и размещения её элементов.</p>
    <p>Во-вторых, при создании формы используется <i style="text-decoration: underline;">модель управления доступностью и видимостью элементов формы</i>. При этом учитываются :</p>
    <ul class="list">
        <li>настройка прав в разрезе ролей пользователей;</li>
        <li>зависимость от элементов формы от функциональных опций;</li>
        <li>настройка формы, выполненная разработчиком на этапе конфигурирования прикладного решения;</li>
        <li>настройка формы, выполненная пользователем во время работы с прикладным решением;</li>
    </ul>

    <p class="title-size16"><b id="chapter1.12.2">Функциональность по умолчанию.</b></p>
    <p>Разработчик может не создавать формы для представления и обработки объектов данных. В этом случае при выполнении команд открытия форм система сама, на лету, создаст необходимую форму. Созданная форма будет обладать функциональностью и представлением по умолчанию. Что же определяет представление и функциональность формы?</p>
    <p><i style="text-decoration: underline;">Стандартное представление и функциональность формы определяют объект встроенного языка <span class="vue-d-b">Управляемая форма</span>(например, способность формы закрываться) и <span class="vue-d-b">расширение формы</span>(например, способность записывать данные формы в инфобазу).</i></p>
    <p><span class="vue-d-b">Расширение формы</span> - это дополнительные свойства, методы, параметры и команды, которые появляются у объекта <i style="text-decoration: underline;">Управляемая форма</i>, когда ей назначен основной реквизит.</p>
    <p>Важно понимать следующее:</p>
    <ul class="list">
        <li>Дополнительная предоставляемая функциональность включается в объект "Управляемая форма", т.е. становится её неотъемлемой частью</li>
        <li>Состав дополнительных возможностей определяется типом основного реквизита формы, т.е. типом тех данных, для редактирования которых предназначена форма.</li>
    </ul>
    <p>Расширения могут присутствовать и у элементов формы. Как и для самой формы, состав расширения, т.е. дополнительные свойства, методы и т.д., элемента формы определяется типов реквизита, с которым элемент связан.</p>
    <p>При необходимости сделать что то на свой лад, разработчик может сам разработать форму в конфигураторе. Для разработки используется <i style="text-decoration: underline;">редактор форм</i>. С помощью этого редактора можно создать свой набор реквизитов и команд, а также элементы формы, которыми они отображаются.</p>

    <p class="title-size16"><b id="chapter1.12.3">Команды формы.</b></p>
    <p>Для знакомства с командами формы создадим ещё одну форму для документа "Расход товара". В книге дальше описано как создать и что жать, не стал писать, вроде и так знаю это.</p>
    <p>В редакторе формы мы видим командную панель формы, командную панель табличной части, команды внутри меню "Ещё", всё это команды формы.</p>
    <p>Чем руководствуется система при формировании команд формы? Какие команды должны быть в форме? Для ответа на эти вопросы нужно вспомнить основное назначение формы - взаимодействие пользователя с формой для обработки данных. Значит, в форме должны быть команды, предоставляющие пользователю возможность обработать данные формы и возможность обратиться к данным, связанным с обрабатываемыми.</p>

    <p><b id="chapter1.12.3.1">Для обработки данных формы - стандартные команды формы</b></p>
    <p>В форме должны присутствовать команды для обработки данных и для управления формой. Эти возможности обеспечивают <i style="text-decoration: underline;">стандартные локальные команды формы</i>. В редакторе форм они представлены на закладке "Стандартные команды" редактора команд.</p>
    <img src="../img/1С-1/2023-07-31_16-13-14.png" class="screen" alt="">
    <img src="../img/1С-1/2023-07-31_16-15-23.png" class="screen" alt="">
    <p>Состав команд, предоставляяемых формой, является стандартным и не зависит от данных формы - это команды Справка, Показать в списке, Изменить форму..., Закрыть, Сохранить параметры..., Восстановить параметры...</p>
    <p>Состав команд, предоставляемых расширением формы, зависит от типа основного реквизита формы. В нашем случае основным реквизитом формы назначен реквизит Объект с типом данных (ДокументОбъект.РасходТовара). Расширение этого типа данных предоставило команды - Провести и закрыть, Перечитать, Скопировать, Пометить на удаление/Снять пометку, Удалить, Провести и Отменить проведение.</p>
    <p>Если в составе элементов формы присутствуют таблицы, форматированные документы, табличные документы и др. источники команд, то в состав стандартных локальных команд формы добавляются команды, обеспечивающие обработку данных, отображаемых в этих элементах.</p>
    <p>У документа "Расход товаров" есть табличная часть, которая в данных формы представленна реквизитом Товары. Для отображения списка товаров в форме используется элемент Товары, имеющий тип "Таблица формы". В состав стандартных локальных команд формы включены команды обработки табличных данных - узел Товары на вкладке "Стандартные команды".</p>
    <img src="../img/1С-1/2023-07-31_16-35-04.png" class="screen" alt="">

    <p><b id="chapter1.12.3.2">Для работы со связанными данными - глобальные параметризуемые команды</b></p>
    <p>При обработке данных формы может возникнуть необходимость просмотреть данные, связанные с обрабатываемыми. Это может быть, например, набор записей в регистре взаиморасчётов с контрагентами, подчинённый обрабатываемому документу, или список цен на продаваемый товар и т.д.</p>
    <p>Также может потребоваться выполнить какую-либо обработку связанных данных - например, ввести документ оплаты на основании документа продажи или напечатать штрихкоды продаваемого товара и т.д.</p>
    <p>Доступ к связанным данным обеспечивают <i style="text-decoration: underline;">глобальные параметризуемые навигационные команды</i>, а обработку связанных данных - <i style="text-decoration: underline;">глобальные параметризуемые команды действий</i>. В редакторе формы они представлены на вкладке "Глобальные команды" редактора команд.</p>
    <img src="../img/1С-1/2023-07-31_18-36-29.png" class="screen" alt="">
    <p>Эти команды предоставлены глобальным командным интерфейсом прикладного решения. Состав команд, доступный в форме, зависит от типа параметра параметризуемой команды.</p>
    <p>В редакторе команд источник параметра для команды указывается в скобках после команды. Например, для команды открытия списка регистра продажи параметром выступает ммылка на редактируемый документ:</p>
    <img src="../img/1С-1/2023-07-31_18-46-41.png" class="screen" alt="">
    
    <p><b id="chapter1.12.3.3">Для работы с функциональностью приложения - глобальные независимые команды</b></p>
    <p>При обработке данных формы может возникнуть необходимость воспользовать функциональностью приложения, не связанной напрямую  с обрабатываемыми данными.</p>
    <p>Например, при обработке данных документа нам необходимо выполнить поиск в данных или ввести новый вид цен. Выполнить эти операции помогут <i style="text-decoration: underline;">глобальные независимые команды</i>.</p>
    <img src="../img/1С-1/2023-07-31_21-14-26.png" class="screen" alt="">
    <p>Глобальные независимые команды предоставлены глобальным командным интерфейсом. </p>

    <p class="title-size16"><b id="chapter1.12.4">Способы формирования состава команд формы</b></p>
    <p>Познакомившись с источниками команд формы, давайте посмотрим, какие способы предоставляет нам система для формирования состава команд формы.</p>
    <p>В самом общем случае существует 3 способа:</p>
    <ul class="list">
        <li>Автоматический - состав команд формы определяется системой полностью автоматом.</li>
        <li>Смешанный - состав команд формы определяется системой автоматически, а разработчик, используя редактор форм, поправляет его.</li>
        <li>Ручной - состав команд формы определяется полностью разработчиком.</li>
    </ul>
    <p>Автоматический способ фостроения состава команд является самым быстрым и наименее затратным сточки зрения разработки прикладного решения.</p>
    <p>Смешанный способ, вероятно, используется чаще всего. При таком подходе разработчик вмешивается в работу системы только тогда, когда набор команд, сформированный системой, не обеспечивает требуемых функциональных возможностей по обработке данных формы. В подавляющем большинстве случаев вмешательство выражается в простом расширении состава команд формы.</p>
    <p>Ручной же способ предоставляет максимум возможностей по управлению составом команд формы и их размещением. Однако он требует от разработчика выполнения значительного объёма работы.</p>

    <p class="title-size16"><b id="chapter1.12.5">Автоматическое формирование состава команд формы</b></p>
    <p>Пропустил</p>

    <p class="title-size16"><b id="chapter1.12.6">Доступность команд формы для пользователя</b></p>
    <p>Пропустил</p>

    <p class="title-size16"><b id="chapter1.12.7">Управляем командами формы</b></p>
    <p>Начнём с настройки командной панели формы. Её отображением для пользователя (и её положением) может управлять разработчик. Размещение командной панели в форме определяет значение свойства формы <i style="text-decoration: underline;">Положение командной панели</i> на закладке Использование. По умолчанию значением свойства является Авто и командная панель присутствует в форме. Если же для свойства установить значение Нет, то в форме командной панели не будет. Естественно, в этом случае будут не доступны все команды, размещаемые в командной панели.</p>
    <p>Кроме возможности полного отключения командной панели разработчик может управлять наполнением её командами. Для этого используется свойство командной панели <i style="text-decoration: underline;">Автозаполнение</i>.</p>
    <p>В случае, когда флажок Автозаполнение сброшен, состав команд панели формируется разработчиком вручную. Если отображение командной панели включено, но она пустая, то в форме она не отображается.</p>
    <p><b>Стандартные команды формы</b></p>
    <p>Состав используемых стандартных команд формы можно определить в свойстве формы (и в свойстве таблицы) <i style="text-decoration: underline;">Состав команд</i>. Настройка выполняется в окне Состав, вызываемом через ссылку Открыть.</p>
    <img src="../img/1С-1/2023-08-01_10-21-33.png" class="screen" alt="">
    <p>Для исключения команды необходимо снять флажок рядом с соответствующей командой. Снимем флажки  у команд Перечитать и Скопировать. Эти команды исключены и из состава доступных пользователю, и из состава команд формы в редакторе команд, т.е. они становятся недоступными и разработчику.</p>
    <img src="../img/1С-1/2023-08-01_10-25-42.png" class="screen" alt="">
    <p>Теперь отобразим  в форме стандартную команду, например, команду Закрыть, которая ранее не отображалась. Для добавления команды в форму необходимо создать элемент формы Кнопка. Форма -> Командная панель -> Добавить -> Кнопка.</p>
    <img src="../img/1С-1/2023-08-01_10-42-13.png" class="screen" alt="">
    <p>Элемент Кнопка позволяет выполнить команду и связать с этим элементом добавляемую команду Закрыть. Обычно Кнопка располагается в командной панели и подчинена узлу "Командная панель" в окне элементов формы. Команда, вызываемая кнопкой, задаётся в свойстве кнопки <i style="text-decoration: underline;">ИмяКоманды</i>. По клику на это свойство откроется окно с редактором команд формы и во вкладке "Стандартные команды" выберем команду Закрыть:</p>
    <img src="../img/1С-1/2023-08-01_11-11-53.png" class="screen" alt="">
    <p>НО проще всего перетащить команду Закрыть из окна редактора команд в командную панель или в дерево элементов формы. В этом случае создание кнопки и связывание кнопки с командой выполняется автоматически.</p>
    <p>В результате в дереве элементов формы появился новый элемент формы с именем "ФормаЗакрыть" вида "Кнопка командной панели", подчинённый элементу "Командная панель". Свойтсво "ИмяКоманды" автоматически заполнилось значением Закрыть - командой, которую мы перетащили в командную панель.</p>
    <p>Для добавленной вручную команды разработчик может настроить доступность  и видимость, её расположение и представление, способ отображения команды и другие точки её поведения.</p>
    <p>Настройка выполняется путём задания значений свойствам того элемента формы, с которым команда связана.</p>
    <p>Место отображения добавленной команды в командной панели можно настроить. Для этого используется свойство кнопки <i style="text-decoration: underline;">Положение в командной панели</i>. Значения описывать не буду, там по названиям понятно.</p>
    <p>Для настройки представления команды используются свойства <i style="text-decoration: underline;">Заголовок, Отображение, Вид, Фигура, Положение картинки</i> и др. свойства кнопки.</p>
    <p><i style="text-decoration: underline;">Заголовок</i> позволяет задать текст, представляющий команду. Для кнопки "ФормаЗакрыть" зададим текст "Закрыть форму".</p>
    <p>Свойство <i style="text-decoration: underline;">Вид</i> позволяет задать способ отображения кнопки в виде обычной кнопки или гиперссылки. Установим свойство Вид у кнопки "ФормаЗакрыть" как "Гипперссылка командной панели".</p>
    <p>Свойство <i style="text-decoration: underline;">Отображение</i> позволяет задать способ представления команды: только текст, только картинка, картинка и текст и авто. Выберем "Только текст".</p>
    <p>Команда "ФормаЗакрыть" отображается в командной панели в виде гиперссылки с текстом "Закрыть форму". В подменю Ещё, если для кнопки определена картинка, то в любом случае отображается и текст, и картинка.</p>
    <p>Кроме размещения может потребоваться настроить доступность команды, без удаления её из командной панели. Для этого используется свойство <i style="text-decoration: underline;">Доступность</i> кнопки. Если для команды Закрыть снять флажок в свойстве Доступность, то команда станет недоступной для выбора пользователемю, т.е. станет бледной и перестанет реагировать на мышь.</p>
    <p>Кроме доступности разработчик может управлять и видимостью команды. Для этого используются свойства кнопки <i style="text-decoration: underline;">Видимость</i> и <i style="text-decoration: underline;">Пользовательская видимость</i>.</p>
    <p>Свойство "Пользовательсякая видимость" определяет, какие команды в форме будут видимы по умолчанию, а какие скрыты. Состав видимых по умолчанию команд можно настроить в резрезе ролей:</p>
    <img src="../img/1С-1/2023-08-01_16-52-26.png" class="screen" alt="">
    <p>При настройке видимости можно:</p>
    <ul class="list">
        <li>установить общую видимость по умолчанию - флажок Видимость, определяет видимость для тех ролей, у которых флажок установлен в "третье" значение(серый фон)</li>
        <li>установить видимость по умолчанию команды для конкретной роли пользователя - если рядом в списке Видимость по ролям флажок установлен, то команда видима для роли, если сброшен, то не видима, если же флажок установлен в "третье" значение(на сером фоне), то для роли используется значение общей видимости.</li>
    </ul>
    <p>При определении видимости по умолчанию для конкретного пользователя значения, установленные для его ролей, складываются по логического ИЛИ.</p>
    <p>При работе в прикладном решении пользователь видит только те команды, для которых разработчик установил свойство Видимость и Пользовательская видимость и которые доступны ему в соответствии в его ролями и не отключены функциональными опциями.</p>
    <p>Затем в пользовательском режиме каждый конкретный пользователь может выполнить настройку пользовательской видимости "под себя" и тем самым скрыть те команды/элементы формы, которыми он не пользуется.</p>
    <p>Таким образом, установка свойства Видимость - это инструмент разработчика, а установка свойства Пользовательская видимость - инструмент пользователя. При этом разработчик может задать в конфигураторе пользовательскую видимость в разрезе ролей по умолчанию, которую пользователь может потом донастроить по своему усмотрению.</p>
    <p>давайте для команды Закоыть свойство Видимость установим,  а пользовательскую видимость определим следующим образом:</p>
    <ul class="list">
        <li>Общая видимость установлена</li>
        <li>Для роли Менеджер по ценам видимость сброшена</li>
        <li>Для остальных ролей видимость имеет "третье" значение</li>
    </ul>
    <p>Теперь при запуске системы от имени Менеджера по ценам команда Закрыть по умолчанию невидима, а для остальных ролей она видима.</p>
    <img src="../img/1С-1/2023-08-08_10-20-16.png" class="screen" alt="">
    <p>При настройке размещения команды в командной панели можно объединять в логические группы. Для этого используется элемент формы с типом <i style="text-decoration:underline;">Группа</i>.</p>
    <p>Давайте выделим в отдельную группу команду Закрыть. Сначала добавим в командную панель подчинённую ей группу кнопок. Для этого выделим в дереве элементов формы элемент "Командная панель", нажмём кнопку "Добавить" и выберем тип группы <i style="text-decoration:underline;">Группа кнопок</i>.</p>
    <p>В дереве элементов появится новая группа, и для неё откроется окно свойств. Заполним её свойства:</p>
    <ul class="list">
        <li>Имя - ГруппаЗакрыть</li>
        <li>Заголовок - "Группа закрыть", используется когда группа имеет вид "Подменю"</li>
        <li>Подсказка - "Команды закрытия формы"</li>
    </ul>
    <p>Теперь перетащим в группу кнопку "ФормаЗакрыть". А в свойстве этой кнопки "Вид" установим значение "Кнопка командной панели".</p>
    <p>В результате нашей настройки команда "Закрыть форму" выглядит как обычная кнопка командной панели. Но поскольку она помещена в группу, то в командной панели формы эта команда на вид отделена отступами или разделителями в подменю "Ещё".</p>
    <img src="../img/1С-1/2023-08-08_10-51-32.png" class="screen" alt="">
    <p>Как и для кнопки, для группы кнопок можно настраивать доступность и видимость. Настройки, сделанные для группы, будут применены ко всем командам, включённым в эту группу.</p>
    <p>Помимо командной панели кнопку можно расположить и непосредственно в форме - подчинить узлу Форма в дереве элементов формы. Это можно сделать также, как и при заполнении командной панели - перетаскиванием команды. Только перетащить команду надо не в узел "Командная панель", а в узел "Форма" в дереве элементов формы. Или можно воспользоваться командой "Добавить" у узла "Форма" и выбрать добавляемый элемент формы с типом "Кнопка". Нужно помнить, что при таком добавлении кнопки не происходит автоматом связывание кнопки и команды, нужно вручную связать, как описано выше.</p>
    <p>Далее по книге идёт создание кнопки, только уже не в командной панели, а под ней. В принципе всё тоже самое.</p>
    <p><b>Глобальные команды</b></p>
    <p>Разработчик может расширить (по сравнению с автоматически размещёнными) состав глобальных команд, доступных в форме. При этом система не ограничивает разработчика в выборе места размещения добавляемой команды.</p>
    <p>Однако следует учитывать, что в панели навигации окна клиентского приложения рекомендуется располагать "безопасные" команды - те, которые не приводят в изменению данных, не запускают обработки и т.д. Основное назначение команд в панели навигации - сформировать контекст выполнения каких-либо действий по обработке данных.</p>
    <p>Соответственно, в командной панели формы рекомендуется размещать команды, которые обрабатывают данные: заполняют, пересчитывают, печатают, записывают в инфобазу и т.д.</p>
    <p>С другой стороны, система не позволит удалить из формы автоматически включённые глобальные команды. Она позволит лишь настроить их видимость и размещение.</p>
    <p>Как и для стандартных, добавление глобальных команд проще всего выполнить перетаскиванием требуемой команды из редактора команд(закладка "Глобальные команды") в редактор командного интерфейса(закладка "Командный интерфейс"), в узел "Панель навигации" или в узел "Командная панель".</p>
    <img src="../img/1С-1/2023-08-08_12-29-02.png" class="screen" alt="">
    <p>Например, добавим в форму глобальную параметризованную команду "Печать штрихкода", которая подчинена справочнику Товары. Команда выполняет печать, поэтому добавим её в группу "Печатные формы" командной панели формы.</p>
    <img src="../img/1С-1/2023-08-09_20-06-40.png" class="screen" alt="">
    <p>При необходимости разработчик может настроить видимость и размещение глобальных параметризованных команд.</p>
    <p>При этом для команд, помещённых в форму автоматически, необходимо сбросить соответствующие признаки - <i style="text-decoration: underline;">Автовидимость</i> и <i style="text-decoration: underline;">Автоположение</i>. Иначе будут использованы видимость и размещение команд, формируемые системой по умолчанию.</p>
    <p>Настройку размещения можно выполнить перетаскиванием команды мышью в нужную группу. Настройка видимости выполняется в окне "Настройка видимости" по правилам, совпадающим с настройкой видимости, показанной ранее для элементов формы Кнопка.</p>
    <p>Давайте переместим команду "Печать расходной накладной" в группу "Важное" и сделаем её невидимой по умолчанию для роли "Менеджер по ценам":</p>
    <img src="../img/1С-1/2023-08-09_21-19-41.png" class="screen" alt="">
    <p>Слово "Одинаковая" появляется тогда, когда видимость стоит для всех ролей, если для какой то роли видимость убрана, то будет слово "Различная".</p>
    <p>Теперь добавим в форму глобальную параметризованную команду "Цены товаров". Эта команда не предназначена для обработки данных, поэтому добавим её в панель навигации окна клиентского приложения, после всех команд панели навигации.</p>
    <p>Настройка видимости и размещения команд в панели навигации выполняется также как и настройка команд в командной панели. Видимость по умолчанию для команды изменять не будем - она будет видима всем ролям.</p>
    <img src="../img/1С-1/2023-08-09_21-40-10.png" class="screen" alt="">
    <p><b>Если не хватает стандартных команд</b></p>
    <p>В случае, когда для создания функциональных возможностей формы стандартных команд не хватет, разработчик может создать необходимое количество <i style="text-decoration: underline;">произвольных команд формы</i>. Такие команды создаются в редакторе команд на закладке "Команды формы".</p>
    <p>Давайте создадим произвольную команду подбора товаров в документе "РасходТовара".</p>
    <p>Для создания такой команды нажмём "Добавить" на закладке "Команды формы", откроется палитра свойств для неё. Выберем имя(ПодборТовара), синоним(Подбор товара), подсказку(Подбор товара для продажи), назначим обработчик.</p>
    <p>Для предоставления пользователю доступ к созданной команде нужно связать нашу команду с элементом формы "Кнопка".</p>
    <p><span class="vue-r">Оказывается в редакторе команд все эти команды: произвольные, стандартные, глобальные это всё просто логика(действия) и их нужно связывать с элементом формы "Кнопка". Выше конечно писалось об этом, но я не задумывался, что и произвольные команды также работают. Раньше просто перетаскивал свою команду в элементы формы и всё, а оказывается для моей команды система также создаёт кнопку и связывает её с моей командой, просто делает это автоматически при перетаскивании.</span></p>
    <p>Перетащим нашу произвольную команду в окно элементов формы в командную панель таблицы "Товары". Кроме того зададим свойства для оформления новой кнопки в интерфейсе. Установим жёлтый цвет фона кнопки(свойство "ЦветФона"), отображение заголовка кнопки курсивом(свойство "Шрифт"), свойство "Фигура" в значение "Овальная":</p>
    <img src="../img/1С-1/2023-08-10_08-29-09.png" class="screen" alt="">
    <p>Если в начале пропустили связывание команды с процедурой исполнения, то её можно связать по нажатию на лупу у свойства "Действие" в свойствах команды, именно в свойствах команды, а не в свойствах элемента формы кнопки.Дальше выбираем директиву испольнения обработчика и откроется шаблон процедуры, который заполняем кодом.</p>
    <p>Настройка размещения и видимости произвольных команд выполняется также как и для стандартных команд. Как стандартная так и произвольная команда связывается с элементов формы типа "Кнопка". А доступность и видимость уже настраиваются уже для этого элемента.</p>
    <p>Колме настройки доступности элемента формы, для произвольной команды рабзработчик может настроить её доступность в разрезе ролей с помощью свойства <i style="text-decoration: underline;">Использование</i> у самой команды.</p>
    <p>При этом разработчик может определить:</p>
    <ul class="list">
        <li>Общую доступность команды - если флажок "Использование" в диалоговом окне установлен, то команда доступна всем ролям с "третьим" значением флажка.</li>
        <li>Доступность команды для конкретной роли пользователя - если рядом с ролью в списке "Использование по ролям" флажок установлен, то команда доступна для роли, если сброшен, то не доступна, если же флажок установлен в "третье" значение(на сером фоне), то для роли используется значение общей доступности.</li>
    </ul>
    <p>Например, для пользователя с ролью "Менеджер по ценам" команда "Подбор товара" недоступна (флажок сброшен). Для этого пользователя в командной панели таблицы Товары команды нет.</p>
    <img src="../img/1С-1/2023-08-10_08-43-19.png" class="screen" alt="">
    <p>Доступность произвольных команд также можно поставить в зависимость от значений функциональных опций. Для такой настройки используется свойство команды "Функциональные опции".</p>
    <p>Например, зададим зависимость команды "Подбор товара" от значения функциональной опции "Работа с торговым оборудованием":</p>
    <img src="../img/1С-1/2023-08-10_08-56-09.png" class="screen" alt="">
    <p>Для одного и того же пользователя при истинном значении функциональной опции команда доступна, а при ложном - недоступна.</p>
    <p><span class="vue-r">Внимание! Свойcтва команды "Доступность" и "Функциональные опции" имеют приоритет перед свойствами элемента управления "Кнопка".</span></p>

    <p class="title-size16"><b id="chapter1.12.8">Краткие итоги</b></p>
    <p>Все команды, которые могут присутствовать в форме, можно разделить на два класса:</p>
    <ul class="list">
        <li>Локальные команды формы - обеспечивают доступ к функциональности формы</li>
        <li>Глобальные команды - обеспечивают доступ к функциональности приложения</li>
    </ul>
    <img src="../img/1С-1/2023-08-10_09-20-07.png" class="screen" alt="">
    <p>В состав команд формы входят:</p>
    <ul class="list">
        <li>Стандартные команды формы - обеспечивают работу с формой</li>
        <li>Стандартные команды расширения основного реквизита формы - обеспечивают обработку данных формы.</li>
        <li>Стандартные команды расширений некоторых элементов формы - обеспечивают обработку формы.</li>
        <li>Произвольные команды формы - назначение команды поределяется разработчиком.</li>
    </ul>
    <p>Глобальные команды, доступные в форме, включают в себя:</p>
    <ul class="list">
        <li>Независимые глобальные команды</li>
        <li>Часть параметризованных глобальных команд - те, для которых в форме существует источник параметра требуемого типа.</li>
    </ul>
    <p>При разработке командного интерфейса формы разработчик должен ответить на вопросы:</p>
    <ul class="list">
        <li>Какие действия нужно будет выполнять с данными - для обработки данных используются команды формы;</li>
        <li>Какие дополнительные данные(помимо данных формы) должны быть доступны и какие дополнительные действия (помимо обработки данных формы) необходимо выполнить - для обеспечения этой функциональности используется подмножество глобальных команд;</li>
        <li>каким пользователям будут доступны команды - выполнить ролевую настройку доступности;</li>
        <li>как должна выглядеть форма - настроить размещение и видимость команд.</li>
    </ul>
    <p>Для редактирования состава команд формы, их расположения и видимости используется редактор формы. В редакторе формы описывается состав команд командной панели формы и состав команд панели навигации формы.</p>
    <p>Часть команд в командную панель и панель навигации помещается системой автоматически. В редакторе форм разработчик эти команды удалить не может, но он может настроить видимость этих команд в разрезе ролей пользователей.</p>
    <p>Для того чтобы пользователь смог вызвать команду, она должна быть связана с элементом формы "Кнопка"(закладка "элементы" редактора форм) или помещена в командный интерфейс(закладка "Командный интерфейс" редактора форм).</p>












    <h2 class="header-style">Конструирование форм</h2>
    <p>Оглавление 2 части на 236 странице</p>

    <h3 class="header-style2" id="chapter2.1">Глава 2.1 Что такое форма</h3>

    <p class="title-size16"><b id="chapter2.1.1">Концепция построения формы</b></p>
    <p>В данном разделе будет рассматриваться вопрос создания и построения форм в режиме конфигуратор.</p>
    <p>Форма является важнейшим связующим звеном в цепи "пользователь - данные". Именно в формах мы редактируем данные, вводим новую информацию, видим результаты.</p>
    <p>Формы "1С:Предприятия" наделены различными возможностями как построения, так и отображения данных. В большинстве случаев от разработчика не требуется заботится о том, как на экране будет выглядеть тот или иной элемент. Система сама может позаботится об этом. От разработчика требуется правильно настроить интерфейстные свойства объекта конфигурации, на основании которых и будет построенно нужное представление.</p>
    <p>Управляя размещение элементов в форме, разработчик должен указать системе те или иные способы группировки элементов, поряд их размещения. Задача разработчика состоит не в детальном, "попиксельном", размещении элементов на форме, не в описании сложных привязок, а в логическом описании состава формы.</p>
    <p>Разработчик может влиять на расположение и внешний вид элементов формы. Для этого у него в руках инструмент свойств элементов формы. Существует возможность перенастройки командной панели формы, дополнительных кнопок у элементов формы, объединение элементов в группы, распределение их по страницам, настройки колонок списков. Однако все эти возможности призваны лишь помочь системе в построении формы, а не польностью заменить это построение ручным способом.</p>
    <p>Помимо простого открытия форм для просмотра или редактирования данных существует возможность открытия с установленным отбором, с выделением каких-либо конкретных данных из общего числа. Помочь в этом могут, например, программная установка отбров и параметризуемые команды.</p>
    <p>При построении форм системой учитываются не только настройки самой формы, сделанные разработчиком. Влияние на поведение формы  и её элементов оказывают настройки прав пользователей, применяемые к сеансу работы приложения функциональналье опции, настройки, которые сделал сам пользователь в сеансе своей работы.</p>
    <p>Отдельно стоит упомянуть о возможностях форм сообщать пользователю об ошибках, возникающих в процессе работы. Например, это может быть сообщение о незаполненном поле, данные в которое должны быть внесены обязательно. Система сообщить о таком типе ошибки, выделив и активизировав именно этот элемент.</p>
    <p><b>Формы как элемент общения программы с пользователем</b></p>
    <p>Помимо "стандартных" форм различных объектов конфигурации(справочники, документы, регистры и т.д.) существует одна особенная форма - <i style="text-decoration: underline;">начальная страница</i>. Именно с неё и начинается работа пользователя с системой.</p>
    <p>Можно сказать, что начальная страница призвана быть лицом разрабатываемого приложения. Именно на начальную страницу необходимо выносить всю нужную в первую очередь информацию. Это могут быть списки часто используемых документов, справочников, данные отчётов, формы обработок.</p>
    <p>На начальной странице отображаются формы других объектов конфигурации. А значит на начальную страницу оказывает влияние всё то, что сопособно повлиять на любую форму: права доступа, функциональные опции, настройки пользователя. Подробнее о настройке начальной страницы будет дальше.</p>
    <p>Для формы может быть назначен основной реквизит, который частично определяет поведение формы, то, какие данные в такой форме можно просматривать, редактированть, как будет вести себя форма в той или иной ситуации.</p>
    <p>При работе в интерфейсе "Такси", который рассматривается в книге, большинство форм открывается  в <i style="text-decoration: underline;">окнах клиентского приложения</i>, которые расположены в рабочей области основного окна приложения. Этих окон может быть открыто сколько угодно, но, поскольку интерфейс "Такси" - однооконный, каждое следующее окно замещает предыдущее. Поэтому в каждый миг времени пользователь видит перед собой только одно окно.</p>
    <p>Исключением являются <i style="text-decoration: underline;">блокирующие окна</i>, которые могут блокировать как окно владельца, так и сразу весь интерфейс приложения. Блокирующие окна применяются для вспомогательных задач (например, ввода и выбора каких-либо данных) или для взаимодействия с пользователем.</p>
    <p></p>

    <p class="title-size16"><b id="chapter2.1.2">Среда существования формы</b></p> 
    <p>Подробнее про создание формы на сервере можно посмотреть в этом видео - https://www.youtube.com/watch?v=yVz6N1y3eSk&list=PLkdnTy1CsgR1phYcN8Ts1HD2AugrAVgRd&index=55  начиная с 19 минуты.</p>
    <p>Форма существует и на сервере и на клиенте. Связь элементов формы с данными инфобазы осуществляется с помощью <i style="text-decoration: underline;">реквизитов формы</i>(данные формы). Все данные, которые планируется отображать или редактировать в форме, должны быть обязательно описаны в виде реквизитов.</p>
    <p>Процесс создания и открытия формы, отображающей объектные данные(у формы определён основной реквизит), выглядит так:</p>
    <ul class="list">
        <li>Объект считывается из базы данных на сервере</li>
        <li>Объект конвертируется в данные формы (создание формы на сервере)</li>
        <li>Объект удаляется из памяти</li>
        <li>Данные формы передаются на клиент(создание формы на клиенте)</li>
    </ul>
    <p>Запись данных формы в инфобазу происходит только на сервере:</p>
    <ul class="list">
        <li>Данные формы получаются с клиента и отправляются на сервер</li>
        <li>Данные формы конвертируются в объект</li>
        <li>Объект записывается в базу данных</li>
        <li>Объект удаляется из памяти</li>
    </ul>
    <p>На схеме это выглядит так:</p>
    <img src="../img/1С-1/2023-08-15_07-57-29.png" class="screen-2" alt="">
    <p>В процессе своего создания форма проходит определённое просеивание через настроки системы, влияющих на её внешний вид:</p>
    <img src="../img/1С-1/2023-08-15_07-57-28.png" class="screen" alt="">
    <p>Между клиентом и сервером происходит обмен не только данными формы, но и её оформительскими свойствами. К оформительским относятся все свойства формы, влияющие на её внешний вид. Таким образом достигается полное соответствие внешнего вида формы и на клиенте и на сервере.</p>







    





    <h3 class="header-style2" id="chapter2.2">Глава 2.2 Создание формы</h3>

    <p class="title-size16"><b id="chapter2.2.1">Создание формы с помощью конструктора</b></p>
    <p>Создание новой формы начинается с <i style="text-decoration: underline;">конструктора формы</i>:</p>
    <img src="../img/1С-1/2023-08-17_16-07-16.png" class="screen" alt="">
    <p>Изменение формы осуществляется в редакторе формы, о нём будет в следующей главе.</p>
    <p>В конфигурации могут существовать формы, подчинённые объектам конфигурации, и общие формы. Общие формы располагаются в дереве конфигурации, в ветке Общие - Общие формы. Конструктор форм различает, какая форма будет создаваться: подчинённая объекту или общая.</p>
    <p>При создании общей формы конструктор предлагает выбрать тип формы из следующих типов:</p>
    <img src="../img/1С-1/2023-08-17_16-12-31.png" class="screen" alt="">
    <p>При выборе произвольной формы разработчик самостоятельно в процессе разработки будет определять данные, с которыми будет взаимодействовать форма. В зависимости от этого конструктор автоматически добавляет в форму соответствующие данные и интерфейсные элементы, сокращая дальнейшие действия разработчика.</p>
    <p>По умолчанию конструктор общих форм предлагает создать произвольную форму. Связано это с тем, что в подавляющем большинстве случаев разработчик будет создавать именно произвольные общие формы.</p>
    <p>Флажок <i style="text-decoration: underline;">"Использовать стандартные команды"</i> в конструкторе общих форм позволяет автоматически добавить команды для открытия общей формы в интерфейсе  той подсистемы, в состав которой она будет входить.</p>
    <p><span class="vue-b">Далее по книге рассказывается о 3х способах создать форму подчинённую объекту конфигурации. Не стал это описывать, вроде и так знаю. Если что страница 243. Далее идёт показ картинок, как отличаются конструкторы форм разных объектов конфигурации(справочники, документы и т.д.).</span></p>
    <p>Кроме всех перечисленных форм для любого из объектов конфигурации можно создать тип формы <i style="text-decoration: underline;">Произвольная</i>. Такая форма после создания не связана ни с какими данными конфигурации. Действия, которые можно будет выполнять в такой форме, целеком и полностью будут зависеть от желания и способностей разработчика формы.</p>
    <p>Формы, связанные через свой основной реквизит с объектами конфигурации, уже наделены определёнными свойствами, характеристиками, методами. Состав таких свойств, характеристик, методов зависит от объекта конфигурации.</p>
    <p>Например, форму редактирования констант можно создать с помощью контекстного меню ветви конфигурации "Константы". Созданная таким образом форма будет размещаться в ветви конфигурации "Общие формы".</p>
    <img src="../img/1С-1/2023-08-17_19-11-39.png" class="screen-2" alt="">
    <p>При выборе того или иного типа создаваемой формы конструктор форм автоматически формирует Имя и Синоним формы. При формировании учитывается наличие у объекта конфигурации формы с таким именем. Если такая форма существует, то к имени создаваемой формы добавится числовой показатель. Имя формы можно изменить. Синооим формы - имя, под которым форма может фигурировать в интерфейсепользователей прикладного решения.</p>
    <p>При необходимости можно определитьсоздаваемую форму в качестве основной формы для объекта конфигурации. Основная форма - это та форма, которая будет открываться стандартными командами, размещёнными в интерфейсе. Если разработчик хочет открыть форму, не назначенную основной, то для этого ему нужно создать собственную команду, которая будет открывать эту форму.</p>
    <p>Чтобы назначить форму основной, в конструкторе форм необходимо установить соответствующий флажок. Если для объекта конфигурации создаваемый тип формы ещё не создавался, то флажок "Назначить форму основной", будет стоять автоматом.</p>
    <img src="../img/1С-1/2023-08-17_19-11-40.png" class="screen" alt="">
    <p>Для некоторых типов форм конструктор предоставляет возможность использовать их одновременно в качестве формы элемента и фформы группы. Это удобно в тех случаях, когда и элемент, и группа имеют одинаковый состав реквизитов и одинаковые алгоритмы их заполнения. Не нужно создавать две разные формы.</p>
    <p>На этом работу с конструктором форм можно закончить(кнопка Готово) или перейти к следующему шагу(кнопка Далее), который позволит продолжить конструирование формы.На этом шаге разработчик даёт указания конструктору форм на необходимость использования реквизитов объекта(или состава констант для формы констант) в создаваемой формы. Делается это с помощью соответствющего флажка. Здесь же можно определить, сколько колонок с элементами формы будет применяться для отображения данных.</p>

    <p class="title-size16"><b id="chapter2.2.2">Создание формы методом копирования</b></p> 
    <p>Кроме создания форм с помощью конструктора разработчику прикладного решения доступен вариант создания формы с помощью метода копирования.</p>
    <p>Через буфер обмена операционной системы можно скопировать форму текущей кнфигурации или любой другой конфигурации. При этом если платформа не может правильно сопоставить какие-либо свойства формы, свойства её реквизитов, типы значений и прочее, то разработчик получит сообщение об ошибке: "Обнаружены неразрешимые ссылки".</p>
    <p>Кроме копирования доступен метод перетаскивания форм мышью.</p>
    <p>Копируемые формы можно подчинять другим объектам конфигурации. Мы можем скопировать форму некоего объекта в другой объект. Если в объекте, куда осуществляется копирование, уже существует форма с таким именем, то новой форме будет присвоено имя, к которому добавится порядковый номер.</p>
    <p>При копированиее формы происходит только лишь переподчинение в дереве конфигурации. Назначение формы, данные, с которыми она взаимодействует, при копировании не изменяются. Это означает, что, например, если скопировать форму справочника в другой справочник, то форма по прежнему будет работать с данными первого справочника.</p>











    <h3 class="header-style2" id="chapter2.3">Глава 2.3 Редактирование формы</h3>

    <p class="title-size16"><b id="chapter2.3.1"></b>Описание редактора формы</p>
    <p>Окно редактора формы разбито на 3 области, каждая из которых отвечает за ту или иную функциональность будущей формы.</p>
    <p><i style="text-decoration: underline;">В первой области</i> описываются состав и порядок элементов формы, команды интерфейса, которые могут выполняться в форме.</p>
    <p><i style="text-decoration: underline;">Во второй области</i> описывается состав реквизитов и параметров формы, а также команды, выполняемые внутри формы.</p>
    <p><i style="text-decoration: underline;">В третьей области</i> представлен внешний вид формы, как она может выглядеть на экране пользователя, с учётом описанных реквизитов, элементов, команд формы.</p>
    <p>В модуле формы располагаются обработчики событий формы, элементов формы, команд формы. Разработчик может создвать и свои процедуры и функции.</p>
    <p><span class="vue-b">Стр. 260. Дальше идёт описание кнопок управления элементами формы и реквизитами(удаление, перемещение и т.д.). Затем рассказывается коротко о размерах экрана, на которых будет отображаться форма(ПК, мобилки и др.)</span></p>

    <p class="title-size16"><b id="chapter2.3.2">Иерерхия элементов формы</b></p>
    <p>Форма олписывается разработчиком прикладного решения в виде иерархического дерева на закладке "Элементы" редактора формы.</p> 
    <img src="../img/1С-1/2023-08-18_08-26-15.png" class="screen-2" alt="">
    <p>Все элементы формы подчинены корневому элементу "Форма". Свойства элементов дерева зависят от свойств, которыми наделены элементы вышестоящего уровня. При этом каждый из элементов обладает своими уникальными свойствами, характерными только для него.</p>
    <p>Влияние свойств элементов дерева друг на друга(имеется в виду одинаковые свойства, например Ширина) являются обоюдными. Таким образом, свойства нижнего уровня могут оказывать влияние на свойства верхнего уровня, и наоборот. Примеры влияния свойств элементов дерева друг на друга расскатриваются в главе 2.9.</p>

    <p class="title-size16"><b id="chapter2.3.3">Свойства формы</b></p> 
    <p>Форма обладает рядом свойств, которые ей присущи всегда. Кроме того, ряд свойств формы определяется её основным реквизитом. Именно основной реквизит формы определяет её поведение, вид, состав команд, другие дополнительные возможности, предоставляемые разработчику формы и её пользователю.</p>
    <p>Для редактирования свойств формы нужно воспользоваться пунктом контекстного меню "Свойства" ветви "Форма" в окне элементов формы или просто дважды щёлкнуть мышью на корне дерева элементов.</p>
    <img src="../img/1С-1/2023-08-18_08-42-30.png" class="screen" alt="">
    <p>Палитра свойств формы содержит множество свойств, собранных в группе "Основные", "Использование", "Оформление" и др. Рассмотрим наиболее важные из них.</p>
    <p><b id="chapter2.3.3.1">"Заголовок", "Автоматический заголовок", "Отображать заголовок"</b></p>
    <p>Свойство "Заголовок" определяет заголовок формы, как его будут видеть разработчик в окне предварительного просмотра формы и пользователь во время работы с формой. Заголовок формы может быть дополнен системной информацией, полученной из свойств объекта конфигурации, связанных с расширеным представлением объектов, списков. Такое влияние на свойство "Заголовок" возможно, если установленно свойство "АвтоЗаголовок" и рассматривается в главе 2.4.</p>
    <p>Например, задам свойству "Заголовок" значение "МояФорма" у формы документа "ПродажаТоваров" и тогда пользователь увиидит такой заголовк:</p>
    <img src="../img/1С-1/2023-08-18_08-56-03.png" class="screen" alt="">
    <p>Как видно наш заголовок добавился системной информацией в виде представления ссылки документа. Если свойство "Заголовок" не заполнено, а свойство "АвтоЗаголовок" включено, то заголовок формы будет сформирован полностью автоматически, т.е. будет состоять из того, что справа от двоеточия на картинке.</p>
    <p>С помощью свойства "Отображать заголовок" можно управлять показом заголовка формы(включая автозаголовк формы и признак изменения). Например, сняв флажок "Отображать заголовок", можно сэкономить рабочее пространство экрана. Это особенно актуально для специализированных режимов основного окна приложения "Рабочее место", "Полноэкранное рабоче место" и "Киоск".</p>
    <p>В режиме основного окна приложения "Обычный" свойство "Отображать заголовок" применяется только для форм, расположенных на начальной странице.</p>
    <p>Когда на начальной странице расположено несколько форм, то вверху всегда выводится надпись "Начальная страница", а над каждой формой - её собственный заголовк. Можно при желании отключить показ заголовков форм на начальной странице:</p>
    <img src="../img/1С-1/2023-08-18_09-12-39.png" class="screen" alt="">
    <img src="../img/1С-1/2023-08-18_09-18-23.png" class="screen" alt="">
    <p>Если же на начальной странице только одна форма, то вместо надписи "Начальная страница" отображается заголовок этой формы. Если свойство "Отображать заголовок" выключено, то отображается надпись "Начальная страница".</p>
    <p><b id="chapter2.3.3.2">"Положение командной панели"</b></p>
    <p>Свойство "Положение командной панели" определяет положение командной панели формы. Оно может принимать одно из 4х значение: "Нет", "Авто", "Верх", "Низ". По умолчанию стоит "Авто", значит платформа сама принимает решение о расположении панели. По остальным значениям и так понятно расположение.</p>
    <p><b id="chapter2.3.3.3">"Доступность"</b></p>
    <p>Снятие флажка у свойства "Доступность" означает, что все элементы формы недоступны для редактирования пользователем. Кроме того, ограничить доступность формы можно с помощью свойства "Только просмотр", которое доступно только из встроенного языка.</p>
    <p><b id="chapter2.3.3.4">"Режим открытия окна"</b></p>
    <p>Свойство "Режим открытия окна" определяет, в каком окне будет открываться форма. Возможны значения "Независимый", "Блокировать окно владельца" и "Блокировать весь интерфейс".</p>
    <p>В режиме "Независимый" форма открывается в рабочей области основного окна приложения. При этом окно формы не препятствует возможности переключения между окнами приложения. В таком режиме форма живёт своей, не мешающей остальным формам жизнью.</p>
    <p>В режиме "Блокировать окно владельца" форма открывается в блокирующем окне, при этом работа с формой, из которой было открыта текущая форма, блокируется. Данный режим предназначен для форм, в которых вводится мало информации и работа с которыми не требует длительного времени, например, для ввода элементов справочника, содержащих небольшое количество реквизитов. Этот режим внешне аналогичен модальному открытию формы, однако при открытии из встроенного языка работа модуля не останавливается на время работы открываемой формы. При открытии происходит только блокировка родительского окна, другие окна приложения остаются доступными.</p>
    <p>В режиме "Блокировать весь интерфейс" форма открывается в блокирующем окне, при этом блокируется работа не только с родительской формой, но и со всем интерфейсом прикладного решения. Окна, блокирующие весь интерфейс, обеспечивают работу без использования модальных окон. Отказ от модальности является необходимым условием для работы "1С:Предприятия" в веб-клиенте и на мобильных устройствах, а также по ряду других причин. Подробнее об этом будет рассказано в разделе "Открытие формы в блокирующем режиме без использования модальности". <span class="vue-r">Тут надо сделать ссылку на эти подробности, когда дойду до них и опишу</span></p>
    <p><b id="chapter2.3.3.5">"Проверять заполнение автоматически"</b></p>
    <p>Установленный флажок у этого свойства означает автоматическую проверку заполнения реквизитов формы при работе пользователя.</p>
    <p>Механизм проверки реквизитов формы рассматривается в главе 2.8 и в главе 3.11. <span class="vue-r">Тут надо сделать 2 ссылки на подробности, когда дойду до них и опишу</span>.</p>
    <p><b id="chapter2.3.3.6">"Условное оформление"</b></p>
    <p>Гипперссылка "Открыть" у этого свойства позволяет открыть окно "Настройка условного оформления". В данном окне можно настроить, например, выделение цветом некоторого элемента в зависимости от значений других элементов формы. Примеры рассматриваются в разделе "Как настроить условное оформление динамического списка" и в главе 3.15. <span class="vue-r">Тут надо сделать 2 ссылки на подробности, когда дойду до них и опишу</span>.</p>
    <p><b id="chapter2.3.3.7">"Разрешить изменять форму"</b></p>
    <p>Свойство определяет возможность изменения формы в пользовательском режиме работы.</p>
    <p>Настройка форм в пользовательском режиме работы является стандартной возможностью, предоставлямой платформой. Это означает, что пользователь может изменить порядок элементов формы, перегруппировать их, изменить их видимость. С помощью этого свойства такую возможность можно пресечь.</p>
    <p>Вместо запрещения изменения всей формы разработчик может применять "точечные" запреты для конкретных элементов формы. Свойства, с помощью которых можно запрещать изменения элементов формы, рассматриваются в разделах данной главы, посвящённых элементам формы. Примеры настройки свойств рассматриваются в разделе "Как и зачем объединять элементы формы в группы". <span class="vue-r">Тут надо сделать ссылку на подробности, когда дойду до них и опишу</span>.</p>
    <p><b id="chapter2.3.3.8">"Группировка"</b></p>
    <p>Свойство определяет режим группировки подчинённых элементов формы. Возможные значения свойства: "Вертикальная", "Горизонтальная" и "Горизонтальная если можно".</p>
    <img src="../img/1С-1/2023-08-20_20-38-35.png" class="screen" alt="">
    <p>Настройка влияет только на элементы верхнего уровня иерархии подчинённых элементов. Порядок расположения элементов формы, находящихся внутри групп, определяется свойством "Группировка" соответствующей группы элементов.</p>
    <p><b id="chapter2.3.3.9">"Вертикальная прокрутка"</b></p>
    <p>С помощью этого свойства можно управлять отображением вертикальной прокрутки формы, а также тем, как будут вести себя элементы формы в том случае, если форма будет сжиматься по вертикали.</p>
    <p>Возможны следующие режимы включения вертикальной прокрутки формы:</p>
    <ul class="list">
        <li>"Использовать" - полоса вертикальной прокрутки появится после того, как вертикальный размер элементов формы достигнет размера, который был задан при редактировании формы в конфигураторе</li>
        <li>"Использовать без растягивания" - при растягивании формы элементы формы не будут реагировать на изменение размера формы</li>
        <li>"Использовать при необходимости" - перед появлением полосы прокрутки элементы формы будут сжиматься по вертикали до своего минимального размера. Если они всё таки не поместятся в форме, появится полоса прокрутки.</li>
        <li>"Авто" - поведение формы зависит от типа основного реквизита формы. Если основной реквизит формы имеет тип "Динамический список" или "Отчет", то свойство "Вертикальная прокрутка" принимает значение "Использовать при необходимости". В остальных случаях - значение "использовать".</li>
    </ul>
    <img src="../img/1С-1/2023-08-20_21-08-23.png" class="screen" alt="">
    <p>При значении "Использовать" вертикальная прокрутка появляется сразу же, как только форма сжимается по вертикали относительно своего исходного размера.  При этом все элементы формы, в т.ч. картинка товара, имеют свой настоящий размер.</p>
    <p>При значении "Использовать при необходимости" элементы формы сжимаются так, чтобы избежать вертикальной прокрутки формы. В частности, при такой же высоте формы, что и в предыдущем случае, картинка сжимается и полоса прокрутки отсутствует. Но если элементы формы сжаты максимально и всё равно не умещаются по высоте формы, то вертикальная прокрутка формы появляется.</p>
    <p>Стандартно свойство "Вертикальная прокрутка" устанавливается в значение Авто. Менять его, как правило нет необходимости. Исключением являются формы, имеющие поля для вывода HTML документов, форматированных документов, текстовых документов, табличных документов(кроме форм отчётов). Для таких форм свойство "Вертикальная прокрутка" должно быть установлено в значение "Использовать при необходимости".</p>
    <p><b id="chapter2.3.3.10">"Вариант масштаба", "Масштаб"</b></p>
    <p>Свойство "Вариант масштаба" определяет, каким образом форма будет отображаться в интерфейсе "Такси":</p>
    <ul class="list">
        <li>"Авто" - режим отображения формы определяется автоматически на основе анализа значения свойства "ВариантМасштабаФормКлиентскогоПриложения" объекта "НастройкаКлиентскогоПриложения". Если в данном свойстве не указано конкретное значение варианта масштаба, то в интерфейсе "Такси" значение "Авто" будет трактоваться как "Обычный"</li>
        <li>"Обычный" - форма выглядит стандартно для интерфейса такси. На размер формы влияет свойство "Масштаб"</li>
        <li>"Компактный" - в этом случае форма выглядит "почти" как в интерфейсе 8.2. Свойство "Масштаб" не оказывает влияния на размер формы.</li>
    </ul>
    <p>С помощью свойства "Вариант масштаба" можно управлять отображением одной формы, разрабатываемой в конфигураторе. Она может выглядеть в обычном или компактном виде. </p>
    <p>Чтобы изменить вариант масштаба сразу всех форм прикладного решения, нужно программно установить значение свойства "ВариантМасштабаФормКлиентскогоПриложения" объекта "НастройкаКлиентскогоПриложения".</p>
    <p>Компактный вариант масштаба может использоваться для быстрого перевода сложных насыщенных форм с интерфейса 8.2 на интерфейс "Такси". Чтобы не переделывая саму форму, быстро уменьшить масштаб её отображения примерно на 80%.</p>
    <p>Но если форма будет использоваться только в интерфейсе Такси, то вместо этого лучше уменьшить/увеличить масштаб формы с помощью свойства "Масштаб". Данное свойство указывает, каким должен быть масштаб данной формы относительно её основного размера(в процентах). Значение свойства может изменяться от 10 до 400. Свойство "Масштаб" не применяется для форм с компактным изображением.</p>
    <p>Масштаб, установленный в клиентском приложении, накладывается на масштаб, указанный в конфигураторе для каждой формы. Таким образом, если в конфигураторе установлен масштаб формы 70%, а в клиентском приложении установлен масштаб 50%, то итоговый масштаб будет 35% от реального размера формы.</p>
    <p><b id="chapter2.3.3.11">"Список групп"</b></p>
    <p>С помощью свойства "Список групп" можно поддерживать автоматическую синхронизацию данных в форме, когда в ней отображаются одновременно список групп и собственно содержимое иерархического справочника. Это свойство становится доступным в том случае, если основным реквизитом формы выступает реквизит типа "Динамический список".</p>
    <p>Пока не понял это свойство, если что дочитать про него можно на странице 276.</p>


    <p class="title-size16"><b id="chapter2.3.4">Виды элементов формы</b></p> 
    <p>В форме используются следующие элементы:</p>
    <ul class="list">
        <li>Группа:
            <ul class="list2">
                <li>Группа - Обычная группа;</li>
                <li>Группа - Обычная группа без отображения;</li>
                <li>Группа - Страницы;</li>
                <li>Группа - Командная панель;</li>
                <li>Группа - Подменю;</li>
                <li>Группа - Группа колонок;</li>
            </ul>
        </li>
        <li>Поле</li>
        <li>Кнопка</li>
        <li>Таблица</li>
        <li>Декорация:
            <ul class="list2">
                <li>Декорация - Надпись;</li>
                <li>Декорация - Картинка;</li>
            </ul>
        </li>
        <li>Дополнение элемента формы</li>
    </ul>
    <p>Для того чтобы добавить в состав формы новый элемент определённого вида, необходимо воспользоваться одним из этих элементов. Для отображения различных данных прикладного решения необходимо изменять свойство элемента формы - "Вид".</p>
    <p>При добавлении нового элемента редактором формы будет проанализировано свойство "ПутьКДанным"(с каким реквизитом будет связан элемент формы).</p>
    <p><span class="vue-r">Тут, как и раньше было описано с элементом формы "Кнопка", также если мы добавляем элемент Поле, то его нужно связать с данными, которые будут в нём отображаться. Данные указываются в свойстве "ПутьКДанным".Можно и не создавать элемент формы Поле, а просто перенести из редактора реквизитов какой-нибудь реквизит, в этом случае система сама создаст элемент с типом Поле, пропишет какие данные в нём отображаются, всё как и с командой и элементом Кнопка.</span></p>
    <p><b>Поле</b></p>
    <p>Элемент формы Поле предназначен для отображения простых типов данных, текстовых, табличных, HTML-документов, диаграмм, календарей, индикаторов и др. Типы данных, которые отображает элемент Поле, влияют на то, какие значения может принимать его свойство "Вид".</p>
    <ul class="list">
        <li><i style="text-decoration: underline;">Поле надписи</i>. Поле, недоступное для непосредственного изменения в пользовательском режиме работы. Надпись изменяется из встроенного языка. Для отображения надписи в форме нужно создать реквизит типа Строка и связать его с элементом формы Поле вида "Поле надписи". Как я понял, элемент формы "Поле" вида "Поле надписи" связанный с реквизитом типа Строка это не одно и то же, что элемент формы "Декорация - надпись". Декорация не связывается с реквизитом и не содержит пути к данным. Ниже объясняется, что Декорация - Надпись это просто текст для пояснения пользователю чего либо, оно не связано с реквизитами и не может меняться из встроенного языка.
        <div class="code-style">
            <pre>
                <span class="vue-b"><span class="vue-r">&НаКлиенте
                Процедура</span> ДобавитьВНадпись<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                    <span class="vue-g">//создал элемент формы Поле, затем создал реквизит Реквизит1 с типом "Строка"
                    //связал Поле с этим реквизитом через свойство "ПутьКДанным"
                    //можно вставить значение для этого поля
                    //а можно поменять заголовок поля</span>
                    Реквизит1 <span class="vue-r">=</span> <span class="vue-bl">"АБВ"</span><span class="vue-r">;</span> 
                    Элементы<span class="vue-r">.</span>Надпись<span class="vue-r">.</span>Заголовок <span class="vue-r">=</span> <span class="vue-bl">"АБВ"</span><span class="vue-r">;
                КонецПроцедуры</span>
            </pre>
        </div>
        <img src="../img/1С-1/2023-08-29_20-58-30.png" class="screen-2" alt="">
        </li>
        <li><i style="text-decoration: underline;">Поле ввода</i>. Поле, допускающее изменение данных. Это могут быть как простые типы данных(например, число), так и ссылочные данные(например, ссылки на элементы справочника). Для отображения поля ввода в форме нужно создать реквизит требуемого типа и связать его с элементом формы Поле вида "Поле ввода".
        <img src="../img/1С-1/2023-08-29_21-26-03.png" class="screen" alt="">
        </li>
        <li><i style="text-decoration: underline;">Поле переключателя</i>. Поле, позволяющее выбрать одно из нескольких разновидностей значения с помощью отметки нужного. Для отображения переключателя в форме нужно создать реквизит типа Число или Строка, связать его с полем формы вида "Поле переключателя" и задать у этого поля список значений для выбора в свойстве "Список выбора" на закладке "Использование". А можно задать реквизиту тип "ПеречислениеСсылка.ПолСотрудника" и в свойстве "Список выбора" нажать кнопку "Заполнить" и список заполнится значениями перечисления:
        <img src="../img/1С-1/2023-08-29_21-41-43.png" class="screen-2" alt=""></li>
        <li><i style="text-decoration: underline;">Поле флажка</i>. Поле, предназначенное для отображения или установки одного из значений. Для отображения флажка в форме нужно создать реквизит типа Булево или Число и связать его с полем формы вида "Поле флажка".</li>
        <li><i style="text-decoration: underline;">Поле индикатора</i>. Поле, предназначенное для графического отображения текущего состояния реквизита формы. Для отображения индикатора в форме нужно создать реквизит типа Число и связать его с полем формы вида "Поле индикатора". В коде просто задаём для реквизита значение 10 и поле заполнится на 10%. 
        <img src="../img/1С-1/2023-08-29_22-04-47.png" class="screen-2" alt=""></li>
        <li><i style="text-decoration: underline;">Поле полосы регулирования</i>. Поле, предназначенное для ввода числовых данных с помощью шкалы. Для отображения полосы регулирования в форме нужно создать реквизит типа Число и связать его с полем формы вида "Поле полосы регулирования":
        <img src="../img/1С-1/2023-08-30_08-39-11.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле картинки</i>. Поле, отображающее картинку. Для отображения картинки в форме нужно создать реквизит типа "Картинка" и связать его с полем вида "Поле картинки". Если картинка хранится в реквизите объекта, можно прочитать навигационную ссылку на картинку в строковый реквизит формы и связать поле формы вида "Поле картинки" с этим реквизитом.</li>
        <li><i style="text-decoration: underline;">Поле календаря</i>. Поле, предназначенное для выбора и отображения даты в виде календаря. Для отображения календаря в форме нужно создать реквизит типа Дата и связать его с полем формы вида "Поле календаря".</li>
        <li><i style="text-decoration: underline;">Поле текстового документа</i>. Поле для редактирования и просмотра текстовых данных. Для отображения текстовго документа в форме нужно создать реквизит типа "ТекстовыйДокумент" или "Строка" и связать его  с полем вида "Поле текстового документа".</li>
        <li><i style="text-decoration: underline;">Поле табличного документа</i>. Поле табличного вида, в котором отображаются и редактируются данные. Как правило, используется для отображения результатов работы отчётов и печатных форм. Может использоваться для ввода данных. Для отображения табличного документа в форме нужно создать реквизит типа "Табличный документ" и связать его с полем вида "Поле табличного документа".</li>
        <li><i style="text-decoration: underline;">Поле форматированного документа</i>. Поле для редактирования и просмотра текстовых данных различных форматов с возможностью их оформления. Для отображения форматированного документа в форме нужно создать реквизит типа "Форматированный документ" и связать его с полем вида "Поле форматированного документа". Это поле позволяет оформлять текст по типу как ворд.</li>
        <li><i style="text-decoration: underline;">Поле HTML-документа</i>. Поле для просмотра и изменения HTML-ресурсов. Для отображения в форме нужно создать реквизит типа "Строка" и связать его с полем вида "Поле HTML-документа". Стрококвый реквизит может содержать адрес для доступа к веб-контенту или сам HTML-код.</li>
        <li><i style="text-decoration: underline;">Поле диаграммы</i>. Поле, отображающее различные виды диаграмм, представляющих данные в графическом виде. Для отображения диаграммы в форме нужно создать реквизит типа "Диаграмма" и связать его с полем формы вида "Поле диаграммы".
        <img src="../img/1С-1/2023-08-30_09-11-04.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле диаграммы Ганта</i>. Диаграмма Ганта является способом отражения длительности и последовательности процессов, которые показываются в виде полос, расположенных вдоль оси времени. Для отображения в форме нужно создать реквизит типа "Диаграмма Ганта" и связать его с полем вида "Поле диаграммы Ганта".
        <img src="../img/1С-1/2023-08-30_09-14-15.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле дендрограммы</i>. Поле, отображающее дендрограмму связей объектов. Представляет из себя графический способ отображения степени сходства объектов. Для отображения так же нужно сделать как и для других.
        <img src="../img/1С-1/2023-08-30_09-17-40.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле графической схемы</i>. Поле для просмотра и изменения графических схем, созданных в специализированном редакторе, входящем в состав "1С:Предприятия". Отображать также как и другие.
        <img src="../img/1С-1/2023-08-30_09-20-28.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле географической схемы</i>. Поле для просмотра итоговых данных в разрезах их географического положения.
        <img src="../img/1С-1/2023-08-30_09-22-46.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле планировщика</i>. Поле для просмотра и изменения запланированных событий, привязанных к дате и времени, с возможностью повторения этих событий с определённой периодичностью. Для отображения планировщика в форме нужно создать реквизит типа "Планировщик" и связать его с полем формы вида "Поле планировщика". 
        <img src="../img/1С-1/2023-08-30_09-26-02.png" class="screen" alt=""></li>
        <li><i style="text-decoration: underline;">Поле периода</i>. Поле для выбора периода дат, кратных месяцу.</li>
    </ul>
    <p><b>Группа</b></p>
    <p>Элемент формы "Группа" предназначен для группировки других элементов формы. Это могут быть группы полей, группы страниц, группы команд. Также для элементов типа "Таблица" можно создавать группы колонок. Группы моогут быть вложенными друг в друга.</p>
    <p>свойство "Вид" элемента формы Группа может принимать значения:</p>
    <ul class="list">
        <li><i style="text-decoration: underline;">Обычная группа</i>. Элемент формы, предназначенный для логической группировки других элементов формы. Элемент "Обычная группа" может не выделяться в форме, выполняя при этом функцию группировки других элементов. Выделением группы управляет свойство "Отображение". За отображение заголовка группы отвечает свойство "Отображать заголовок" на вкладке "Использование".</li>
        <li><i style="text-decoration: underline;">Командная панель</i>. Элемент формы, предназначенный для группировки кнопок и групп команд. Наполнение командной панели конкретными командами определяется свойством "Источник команд". Например, у командной панели таблицы формы источником команд является эта таблица формы, отображающая динамический список. Помимо отдельных кнопок в командной панели можно добавлять подчинённые группы следующего вида:
            <ul class="list2">
                <li><i style="text-decoration: underline;">Подменю</i>. Элемент формы, представляющий собой выпадающее меню.</li>
                <li><i style="text-decoration: underline;">Группа кнопок</i>. Элемент формы, позволяющий сгруппировать кнопки в логические группы. Сам элемент не отображается на форме, но кнопки в группе можно расположить компактно(без отступов друг от друга)
                <img src="../img/1С-1/2023-09-07_21-14-21.png" class="screen" alt=""></li>
            </ul>
        </li>
        <li><i style="text-decoration: underline;">Страницы</i>. Элемент формы, предназначенный для организации панели с закладками. Для того чтобы добавить на такую панель страницы, нужно добавить столько вложенных групп вида "Страница", сколько закладок должно быть у панели</li>
        <li><i style="text-decoration: underline;">Группа колонок</i>. Позволяет объединять колонки в таблице. С помощью группы этого вида можно изменять правило группировки колонок. 
        <img src="../img/1С-1/2023-09-07_21-23-13.png" class="screen" alt=""></li>
    </ul>
    <p><b>Таблица</b></p>
    <p>Элемент формы "Таблица" предназначен для отображения и редактирования различных табличных данных. Это может быть динамический список, табличная часть, список значений и т.д. У таблицы формы могут быть свои командные панели, контекстные меню. Поля колонок элемента "Таблица" могут быть сгруппированы как показано на картинке выше.</p>
    <p><b>Кнопка</b></p>
    <p>Элемент формы "Кнопка" предназначен для отображения кнопок и гиперссылок, при нажатии на которые выполняются связанные с ними команды. Кнопки могут быть подчинены командной панели. </p>
    <p><b>Декорация</b></p>
    <p>Элемент формы "Декорация" представляет собой оформительский элемент формы. Декорация может представлять собой надпись или картинку.</p>
    <img src="../img/1С-1/2023-09-09_21-39-53.png" class="screen" alt="">
    <p>Декорация не связана с данными (реквизитами формы) и обычно выводится для текстовых пояснений, не изменяемых из встроенного языка.</p>
    <p><b>Дополнение элемента формы</b></p>
    <p>Дополнение элемента формы предназначено для отображения дополнительных свойств элемента формы (на миг написания книги это дополнения для таблицы, отображающей данные динамического списка) и управления этими элементами. Существуют следующие дополнения:</p>
    <ul class="list">
        <li>Отображение строки поиска. Позволяет настроить отображение строки поиска.</li>
        <li>Состояние просмотра. Позволяет настроить отображение перечня применённых поисковых запросов. Не может располагаться в командной панели.</li>
        <li>Управления поиском. Позволяет настроить внешний вид кнопки управления поиском.</li>
    </ul>

    <p class="title-size16"><b id="chapter2.3.5">Контекстное меню элементов формы</b></p> 
    <p>Для всех элементов формы характерно наличие контекстного меню, вызываемого с помощью мыши или клавиатуры. В большинтсве случаев во время работы приложения контекстные меню формируются платформой автоматиески. Однако разработчик может вмешаться в этот процесс и повлиять на состав контекстного меню.</p>
    <p>Чтобы получить доступ к контекстному меню элемента формы, нужно из контекстного меню элемента формы в редакторе формы выполнить команду "Показать контекстное меню".</p>
    <img src="../img/1С-1/2023-09-09_22-33-32.png" class="screen" alt="">
    <p>После этого появится возможность добавлять в контекстное меню элемента собственные команды.</p>
    <p>Если разработчик желает изменить автоматически формируемое контекстное меню элемента формы, то флажок у свойства "Автозаполнение" снимать не следует. В случае необходимости формирования полностью своего контекстного меню флажок следует снять.</p>

    <p class="title-size16"><b id="chapter2.3.6">Свойства элементов формы</b></p> 
    <p>Свойства элементов формы оказывают влияние как на внешний вид элементов в пользовательском режиме работы, так и на функциональность этих элементов. Описание всех свойств элементов формы не входят в задачи книги. В рамках текущей главы будут рассмотренны лишь некоторые из них. Свойства, связанные с проверкой заполнения элементов формы, рассматриваются в главе 2.9. Свойства, оказывающие влияние на видимость элементов формы, рассматриваются в главе 2.8.</p>
    <p><b>Общие свойства</b></p>
    <p>Свойство элемента формы <i style="text-decoration: underline;">Имя</i> предназначено для задания уникального имени в пределах формы. По имени можно обращаться к элементам формы из встроенного языка.</p>
    <p>Свойство <i style="text-decoration: underline;">Заголовок</i> позволяет системе сформировать понятную для пользователя подпись элемента формы. Для многих элементов формы доступно свойство <i style="text-decoration: underline;">ПоложениеЗаголовка</i> со значениями: Нет, Авто, Лево, Верх, Право, Низ, которое позволяет управлять расположением подписи элемента формы.</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ПутьКДанным</i> определяется связь элемента формы с теми данными, которые будут в нём отображаться и редактироваться. Если эта связь не задана, элемент не будет отображаться в форме.</p>
    <p>Таким же образом, если для кнопки в свойстве <i style="text-decoration: underline;">ИмяКоманды</i> не назначена команда, которая будет выполняться при её нажатии, то кнопка в форме не будет отображаться.</p>
    <p>При установленном свойстве <i style="text-decoration: underline;">ПропускатьПриВводе</i> элемент пропускается при обходе формы клавишей Энтер.</p>
    <p>Поставить фокус на элемент при открытии формы можно, установив свойство <i style="text-decoration: underline;">АктивизироватьПоУмолчанию</i>. Это поможет избавить пользователя от лишних действий по переходу на нужный элемент формы и обратит внимание на самый важный элемент.</p>
    <p>Элемент формы может находится в режиме, запрещающем любые его изменения, если в конфигураторе или с помощью встроенного языка у него (или у группы, в которую он входит) установленно свойство <i style="text-decoration: underline;">ТолькоПросмотр</i>. Или же если реквизит формы, связанный с этим элементом, имеет признак <i style="text-decoration: underline;">СохраняемыДанные</i> и у формы установлен режим ТолькоПросмотр.</p>
    <p>Практически у всех элементов есть свойства <i style="text-decoration: underline;">АвтоМаксимальнаяШирина, АвтоМакчимальнояВысота</i>. Если эти свойства включены, то система сама расчитает макчимальную ширину/высоту данного элемента.</p>
    <p>Стандартно эти свойства включены, и в большинстве случаев не советуется их отключать: это может плохо повлиять на размер и выравнивание элементов в форме. Также крайне не советуется указывать закреплённую ширину и высоту элементов в свойстве <i style="text-decoration: underline;">Ширина, Высота</i>.</p>
    <p>У всех элементов формы есть свойства <i style="text-decoration: underline;">Подсказка, ОтображениеПодсказки и РасширеннаяПодсказка</i>, с помощью которых можно пояснить пользователю назначение элемента. Во многих случаях наличие подсказок может избавить пользователя от чтения инструкций.</p>
    <p>Краткую подсказку можно задать в свойстве Подсказка и сделать её всплывающей при наведении указателя мыши на элемент. Для этого свойство ОтображениеПодсказки нужно установить в значение "Всплывающая" или "Авто".</p>
    <p>Кроме того, у элемента формы можно задать более подробную расширенную подсказку. Такая подсказка может быть оформлена в виде форматированного текста, включать картинки и ссылки.</p>
    <p>Для получения доступа к расширенной подсказке элемента формы нужно из контекстного меню элемента в дереве элементов формы выполнить команду "Показать расширенную подсказку".</p>
    <img src="../img/1С-1/2023-10-12_14-02-20.png" class="screen" alt="">
    <p>Затем нужно задать заголовок расширенной подсказке, установив флажок "Форматированная строка":</p> 
    <img src="../img/1С-1/2023-10-12_18-53-10.png" class="screen" alt="">
    <p>И в свойствах самого элемента формы установить свойство "ОтображениеПодсказки" в значение "Кнопка":</p>
    <img src="../img/1С-1/2023-10-12_19-02-54.png" class="screen" alt="">
    <p>В результате в пользовательском режиме рядом с элементов формы появится кнопка  в виде вопросительного знака, при нажатии на которую откроется подробная, красиво оформленная подсказка, поясняющая назначение этого элемента.</p>
    <p>Если у элемента формы заданы и обычная и расширенная подсказка, то при нажатии на кнопку вопроса будет показана расширенная подсказка. Помимо этого у полей ввода можно задать подсказку ввода. Это свойство будет рассмотренно ниже, в разделе "Свойства поля".</p>
    <p><b>Свойства групп. Группа - Обычная группа, Группа - Страницы, Группа - Командная панель, Группа - Группа кнопок</b></p>
    <p>Давайте познакомимся с некоторыми свойствами элемента формы Группа вида Обычная группа:</p>
    <ul class="list">
        <li><i style="text-decoration: underline;">Группировка</i> - свойство может принмать значения: "Горизонтальная", "Горизонтальная если возможно" и "Вертикальная". Определяет, как будут группироваться подчинённые элементы. По умолчанию новая группа содаётся со значением "Горизонтальная если возможно". С этим значением элементы выстраиваются горизонтально, если хватает ширины, если нет, то вертикально.</li>
        <li><i style="text-decoration: underline;">Отображение</i> - свойство, оказывающее влияние на внешний вид группы. Свойство может принимать значения: "Нет", "Слабое выделение", "Обычное выделение", "Сильное выделение". В зависимости от значения различным образом выделяется заголовок группы, за показ которого отвечает свойство "Отображать заголовок".</li>
    </ul>
    <p>Например:</p>
    <img src="../img/1С-1/2023-10-13_20-08-35.png" class="screen" alt="">
    <p>Обычную группу можно настроить таким образом, что пользователь сможет сворачивать и разворачивать такую группу. Например, можно разместить в сворачиваемой группе информацию, которая не важна при частой работе с формой, но иногда может потребоваться для просмотра и анализа.</p>
    <p>Для этого нужно установить ряд свойств группы:</p>
    <ul class="list">
        <li><i style="text-decoration: underline;">Поведение</i> - свойство, которое управляет поведением группы(Обычная или Свертываемая, Всплывающая).</li>
        <li><i style="text-decoration: underline;">Свернута</i> - галочка определяет начальное состояние группы(свёрнута или развёрнута), при открытии формы.</li>
        <li><i style="text-decoration: underline;">ОтображениеУправления</i> - определяет элемент (Картинка или Гиперссылка заголовка), при нажатии на который пользователь может управлять состоянием группы(сворачивать/разворачивать). По умолчанию свойство принимает значение "Гиперссылка заголовка".</li>
        <li><i style="text-decoration: underline;">ЗаголовкСвернутогоОтображения</i> - заголовок, который будет отображаться в том случае, если группа находится в свернутом состоянии. Если свойство "Свернутый заголовок" не заполнено, то в свернутом состоянии будет отображаться обычный заголовок группы.</li>
    </ul>
    <p>Например:</p>
    <img src="../img/1С-1/2023-10-13_20-39-35.png" class="screen" alt="">
    <p>Теперь в пользовательском режиме всё что в группе "Прочее" будет свёрнуто при открытии формы и по клику развернётся.</p>
    <p>Разновидностью свёртываемой группы является всплывающая группа. В начальном состоянии всплывающая группа отображается в свёрнутом виде. При нажатии на заголовок такой группы она "всплывает" над родительской формой в специальном окне. В форме может существовать несколько всплывающих групп, но в один миг времени может быть открыта только одна из них.</p>
    <p>Для такой группы свойство "Поведение" должно быть установлено в значение "Всплывающая". Кроме того, у всплывающей группы должен быть задан заголовок. Заголовок выступает в роли текста гиперссылки, нажатие на которую приводит к отображению окна с содержимым группы.</p>
    <p>Свойство <i style="text-decoration: underline;">ТолькоПросмотр</i> влияет на все элементы, подчинённые группе.</p>
    <p>Свойство группы <i style="text-decoration: underline;">РазрешитьИзменениеСостава</i> управляет возможностью изменять состав группы в процессе настройки формы пользователем. Если свойство выключено, то пользователь не может изменять состав и менять порядок элементов внутри группы. Однако свойство не влияет на возможность пользователя изменить видимость элементов, входящих в состав группы.</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ВыравниваниеЗаголовковИЭлементов</i> задаётся тип выравнивания элементов и их заголовков внутри группы (а также страницы или самой формы). Свойство может принимать значения: Авто (занчение по умолчанию), Нет, "Элементы лево, заголовки лево", "Элементы право, заголовки лево", "Элементы право, заголовки право", "Элементы лево, заголовки право", "Элементы авто, заголовки лево".</p>
    <p>Для того, чтобы выровнять элементы из разных групп вдоль воображаемой опорной линии формы, используется свойство группы <i style="text-decoration: underline;">СквозноеВыравнивание</i>. Это свойство может принимать значения: Авто, Использовать, "Не использовать". По умолчанию данное свойство устанавливается в значение Авто. Это значит, что сквозное выравнивание определяется системой самостоятельно. Явное указание для данного свойства значения "Не использовать" приведёт к тому, что в таком группирующем элементе не будет выполнятся выравнивание с учётом элементов, не входящих в текущую группу. Сквозное выравнивание элементов используется только для групп с обычным поведением.</p>
    <p>Все новые группы по умолчанию создаются с установленным свойством <i style="text-decoration: underline;">Объединенная</i>. В помощью этого свойства можно создавать группы, состоящие из нескольких колонок и строк одновременно, с поддержкой вырвнивания элементов во сех колонках и строках:</p>
    <ul class="list">
        <li>свойство установлено - группа считается единым элементом;</li>
        <li>свойство сброшено - каждый элемент, входящий в состав группы со сброшенным свойством, считается отдельным элементом.</li>
    </ul>
    <p>Для элемента формы Группа вида "Страницы" интерес представляет свойство <i style="text-decoration: underline;">ОтображениеСтраниц</i>. Данное свойство управляет положением закладок страницы. Если выбрано значение "Нет", то при наличии нескольких страниц их переключение можно осуществлять только средствами встроенного языка.</p>
    <p>Если у группы вида "Страница" или "Обычная группа" указано свойство <i style="text-decoration: underline;">ПутьКДаннымЗаголовка</i>, то эти данные будут отображаться в заголовке группы после самого заголовка, если он задан:</p>
    <img src="../img/1С-1/2023-10-30_09-34-14.png" class="screen" alt="">
    <p>У элемента формы Группа вида "Страница" или "Обычная группа", а также у самой формы есть свойства <i style="text-decoration: underline;">ГоризонтальныйИнтервал</i> и <i style="text-decoration: underline;">ВертикальныйИнтервал</i>. Изменяя эти свойства, можно добиться необходимой плотности элементов формы (а также отдельной группы или страницы) как по вертикали, так и по горизонтали. Свойства принимают значения: "Нет", "Авто", "Половинный", "Одинарный", "Полуторный", "Двойной". Значение "Авто", установленное у любого из этих свойств, означает, что интервал будет определяться по родительскому группирующему элементу. Для формы значение интервала "Авто" определяет система.</p>
    <p>С помощью свойств <i style="text-decoration: underline;">ГоризонтальноеПоложениеПодчиненных</i>, <i style="text-decoration: underline;">ВертикальноеПоложениеПодчиненных</i> (Авто, Лево, Центр, Право) можно управлять относительным расположением элементов обычной группы (а также страницы или самой формы).</p>
    <p>У элемента формы Группа вида <b>"Командная панель"</b> есть свойство <i style="text-decoration: underline;">Источник команд</i>, с помощью которого можно указать элемент формы, который будет предоставлять "свои" команды для отображения в командной панели.</p>
    <p>Источником команд может быть как сама форма, так и элементы формы типа "Таблица" и поля вида "Поле табличного документа", "Поле форматированного документа", "Поле графической схемы", "Поле планировщика". Состав команд для отображения в командной панели регулируется свойством <i style="text-decoration: underline;">Состав команд</i> элемента формы, являющегося источником команд.</p>
    <img src="../img/1С-1/2023-10-30_18-22-38.png" class="screen" alt="">
    <p>Свойство <i style="text-decoration: underline;">ГоризонтальноеПоложение</i> позволяет управлять выравниваем кнопок в командной панели. Возможны значения: Лево, Право, Центр.</p>
    <img src="../img/1С-1/2023-10-30_18-38-59.png" class="screen" alt="">
    <p>Если в командную панель входит подчинённая группа вида "Группа кнопок", то с помощью свойства <i style="text-decoration: underline;">Отображение</i> можно задать "Обычное" или "Компактное" отображение группы кнопок в командной панели.</p>
    <img src="../img/1С-1/2023-10-30_18-49-38.png" class="screen" alt="">
    <p><b>Свойства поля</b></p>
    <p>Наибольший интерес (в плане разнообразия свойств и частоты использования) представляет элемент формы Поле вида "Поле ввода".</p>
    <p>Свойство <i style="text-decoration: underline;">ВыбиратьТип</i> влияет на поведение системы при выборе типа данных реквизита, который отображает поле ввода. Проявляется это в случае использования реквизита составного типа данных.</p>
    <p>Допустим у нас есть поле ввода "Поставщик" и у него 2 типа: СправочникСсылка.Контрагенты и СправочникСсылка.РасчетныеСчета. Свойство "Выбрать Тип" оставим включённым, в пользовательской части у нас будет кнопка с 3мя точками для выбора типа, после выбора типа сразу откроется форма выбора элементов справочника:</p>
    <img src="../img/1С-1/2023-10-30_22-02-09.png" class="screen" alt="">
    <p>В пользовательской части:</p>
    <img src="../img/1С-1/2023-10-30_22-04-04.png" class="screen" alt="">
    <p>Если же свойство "ВыбиратьТип" выключить, то кнопка с 3мя точками пропадёт и окошко с выбором типов данных нельзя открыть, остаётся только выбор из формы выбора справочника контрагентов. Почему именно из контрагентов не знаю.</p>
    <p>Свойство <i style="text-decoration: underline;">Маска</i> позволяет задать маску для ввода символов. Например, можно задать маску для ввода телефона.</p>
    <img src="../img/1С-1/2023-10-30_22-12-51.png" class="screen" alt="">
    <p>Свойство <i style="text-decoration: underline;">РежимПароля</i> при установке значения Да будет заменять вводимые символы звёздочками.</p>
    <p>Свойство <i style="text-decoration: underline;">СписокВыбора</i> позволяет задать список, из которого можно выбирать значения в поле ввода. Для того чтобы поле ввода работало как поле выбора, нужно установить свойство <i style="text-decoration: underline;">РежимВыбораИзСписка</i>. В этом случае кнопка выпадающего списка появится у поля автоматически, хотя по умолчанию в поле ввода она не показывается.</p>
    <img src="../img/1С-1/2023-10-30_22-40-17.png" class="screen" alt="">
    <p>Если же флажок у свойства <i style="text-decoration: underline;">РежимВыбораИзСписка</i> снят, то можно явно задать наличие кнопки выпадающего списка у поля ввода, установив свойство <i style="text-decoration: underline;">КнопкаВыпадающегоСписка</i> в значение Да. Хотя сам список выбора всё равно будет открываться при переходе к полю и без кнопки выпадающего списка, но многим пользователям с ней привычнее и сразу понятно, что это поле для выбора из списка значений.</p>
    <p>!!!Когда у поля ввода тип данных "Строка", то мы сами вот так вводим данные для списка выбора, но если задать тип данных ссылка на значения перечисления, то при открытии окошка списка можно нажать на кнопку "Заполнить" и значения из перечисления сами заполняться.</p>
    <p>Для элементов формы, отображающих простые типы данных Число, Дата, Булево, свойство <i style="text-decoration: underline;">ФорматРедактирования</i> позволяет задать формат вводимых данных с помощью "Контсруктора форматной строки".</p>
    <p>Свойства <i style="text-decoration: underline;">МинимальноеЗначение</i> и <i style="text-decoration: underline;">МаксимальноеЗначение</i> позволяют ограничить ввод числовых значений.</p>
    <p>Свойство <i style="text-decoration: underline;">ВыборГруппИЭлементов</i> позволяет ограничить выборку данных, например есть реквизит и у него тип СправочникСсылка.Номенклатура, т.е. реквизит открывает форму выбора элементов справочника, в пользовательской части я хочу выбрать из этого реквизита именно группу, но система скажет, что нельзя выбрать группу, нужно выбрать элемент справочника. Так вот чтобы появилась возможность выбирать группу для этого свойства нужно выбрать значение "Групп".</p>
    <p>Свойство <i style="text-decoration: underline;">ПредупреждениеПриРедактировании</i> содержит строку, выдаваемую в качестве предупреждения при начале редактирования поля формы в том случае, если <i style="text-decoration: underline;">ОтображениеПредупрежденияПриРедактировании</i> установлено в значение "Отображать".</p>
    <img src="../img/1С-1/2023-11-05_18-47-47.png" class="screen" alt="">
    <p>Если значение свойства "ОтображениеПредупрежденияПриРедактировании" равно "Отображать", а свойство "ПредупреждениеПриРедактировании" не задано, то строка предупреждения формируется системой самостоятельно. Если значение свойства "ОтображениеПредупрежденияПриРедактировании" равно Авто, то для стандартных реквизитов Код и Номер будет использоваться значение "Отображать", а для остальных полей - "Не отображать".</p>
    <p>Свойство <i style="text-decoration: underline;">БыстрыйВыбор</i> позволяет выбирать значения ссылочных типов из выпадающего списка, а не из формы выбора. Например, это могут быть элементы не иерархического справочника, заведомо имеющего небольшой список. Обычно это свойство устанавливается на уровне прикладного объекта конфигурации или реквизита, отображаемого полем, но если у "вышестоящих объектов это свойство не установлено или его действие необходимо переопределить, то можно воспользоваться свойством "БыстрыйВыбор" элемента формы.</p>
    <img src="../img/1С-1/2023-11-05_19-37-34.png" class="screen" alt="">
    <p>Свойство <i style="text-decoration: underline;">ИсторияВыбораПриВводе</i> позволяет сохранять и отображать историю выбора при вводе ссылочных значений в поле формы. История выбора состоит из наиболее часто используемых и последних выбранных значений данного ссылочного типа. Обвчно это свойство устанавливается на уровне прикладного объекта конфигурации или реквизита, отображаемого элементом. Но если действие свойства необходимо переопределить в конкретной форме, то можно впоспользоваться свойством "ИсторияВыбораПриВводе" элемента формы. Подробнее о этом свойстве расказывается в разделе "История выбора при вводе" впереди по книге.</p>
    <p>Свойство <i style="text-decoration: underline;">СвязиПараметровВыбора</i> позволяют задать значение отбора для возможных разновидностей выбора значений ссылочного поля. При установке связи параметров выбора значение, выбранное в одном поле формы, накладывает ограничение на выбор значений в другом поле. Этот отбор будет применяться при открытии формы выбора, при отображении списка быстрого выбора и при выполнении ввода по строке. Подробнее о этом свойстве будет дальше в разделе "Связи параметров выбора".</p>
    <p>Свойство <i style="text-decoration: underline;">ПараметрыВыбора</i> позволяет указать значения параметров, которые будут применяться при выборе значения поля. Но этот выбор будет выполняться не на основании значений других реквизитов формы, на на основании условий, наложенных на свойства самого выбираемого объекта. отбор можно наложить на все реквизиты объекта конфигурации, на который ссылается данное поле. Этот отбор будет применяться при открытии формы выбора, при отображении списка быстрого выбора и при выполнении  ввода по строке. Подробнее дальше.</p>
    <p>Как правило, такие ограничения бизнес-логики, как ограничения выбора, должны быть одинаковыми для всех форм, в которых редактируется тот или иной объект. Поэтому задавать параметры выбора и связи параметров выбора рекомендуется в свойствах объектов конфигурации - в реквизитах справочников, документов и т.п. Однако могут встречаться случаи, когда ограничения выбора могут зависеть от конкретного сценария работы. В таких случаях параметры выбора могут быть уточнены по месту, в конкретной форме.</p>
    <p>Свойство <i style="text-decoration: underline;">КнопкаСоздания</i> определяет наличие кнопки для создания нового элемента в выпадающем списке, открывающемся под ссылочным полем. Обычно возможность создания при вводе устанавливается на уровне прикладного объекта конфигурации или реквизита, отображаемого полем, - у них это свойство называется "СозданиеПриВводе". Но если у "вышестоящих" объектов это свойство не установлено или его действие необходимо переопределить, то можно воспользоваться свойством "КнопкаСоздания" элемента формы.</p>
    <img src="../img/1С-1/2023-11-10_20-19-33.png" class="screen" alt="">
    <p>Свойство <i style="text-decoration: underline;">СвязьПоТипу</i> позволяет указать элемент формы, которым будет определяться тип значения выбираемых в поле данных, ограничивая тип вводимых значений для поля ввода. Настройка связи по типу имеет смысл для реквизитов с составным типом данных, логически связанных с другим реквизитом. Например, когда требуется задать связь типа значения характеристики объекта с видом этой характеристики. Про это свойство будет описанно дальше.</p>
    <p>Свойство <i style="text-decoration: underline;">ФормаВыбора</i> устанавливает форму, которая будет открываться для выбора значения реквизита. Используюется для реквизитов, тип которых образован объектом конфигурации, имеющим подчинённые формы. Стандартно для выбора ссылочного реквизита используется форма, назначенная в качестве основной формы выбора для объекта конфигурации, на который он ссылается. Но с помощью свойства "ФормаВыбора" можно установить для реквизита другую форму, которая будет вызываться при выборе значений в связанном с ним поле.</p>
    <p>Собственную форму выбора, как и связь по типу, также советуется задавать в свойствах самого реквизита, но, если требуется, эти свойства можно переопределить в конкретной форме, в свойствах поля ввода, связанного с реквизитом.</p>
    <p>Свойство <b>поля ввода</b> <i style="text-decoration: underline;">ПодсказкаВвода</i> позволяет указывать подсказку, которая будет формироваться непосредственно "внутри" поля ввода, если тип связанного с полем реквизита не является типом Число или Дата и значение связанного реквизита не содержит значение по умолчанию для данного типа.</p>
    <img src="../img/1С-1/2023-11-11_11-34-52.png" class="screen" alt="">
    <p>Для полей вида <b>"Поле флажка"</b> и <b>"Поле переключателя"</b> существует возможность указывать вид отображения. Это делается с помощью свойства <i style="text-decoration: underline;">ВидФлажка/ВидПереключателя</i> у соответствующего элемента формы. Можно выбрать представление в виде флажка/переключателя или тумблера.</p>
    <img src="../img/1С-1/2023-11-11_11-39-42.png" class="screen" alt="">
    <p>Для поля вида <b>"Поле картинки"</b> интерес представляет свойство <i style="text-decoration: underline;">Масштабировать</i>. Если флажок свойства установлен, то для картинки не помещающейся в области размещения, появляются линейки прокрутки. Изменить размер картинки можно с помощью команд контекстного меню.</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ТекстНевыбраннойКартинки</i> можно задать текст, отображаемый, если картинка не выбрана, по типу текстовой заглушки.</p>
    <img src="../img/1С-1/2023-11-11_17-01-26.png" class="screen" alt="">
    <p>Для поля вида <b>"Поле индикатора"</b> с помощью свойства <i style="text-decoration: underline;">Отображение</i> можно управлять разновидностью управления индикатора. Возможны стили заполнения индикатора "Плавное", "Прерывистое" и "Прерывистое наклонное".</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ОтображатьПроценты</i> можно показывать процент заполнения индикатора.</p>
    <img src="../img/1С-1/2023-11-11_17-14-57.png" class="screen" alt="">
    <p>Для поля вида <b>"Поле полосы регулирования"</b> с помощью свойства <i style="text-decoration: underline;">ОтображениеРазметки</i> можно управлять разновидностью расположения разметки. Возможные значения: "Сверху(слева)", "Снизу(справа)", "С обеих сторон".</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ШагРазметки</i> можно задать значение шага, с которым будет отображаться разметка полосы регулирования.</p>
    <img src="../img/1С-1/2023-11-12_09-39-18.png" class="screen-2" alt="">
    <p>Для поля вида <b>"Поле табличного документа"</b> можно управлять наличием полос прокрутки у табличного документа с помощью свойств <i style="text-decoration: underline;">ВертикальнаяПолосаПрокрутки/ГоризонтальнаяПолосаПрокрутки</i>. Возможны значения:</p>
    <ul class="list">
        <li>Не использовать - полосы прокрутки не используются;</li>
        <li>Использовать всегда - полосы прокрутки всегда есть в табличном документе;</li>
        <li>Использовать автоматически - полосы прокрутки используются в табличном документе только тогда, когда содержимое не помещается в видимой области. Это значение стоит по умолчанию.</li>
    </ul>
    <p>С помощью свойства <i style="text-decoration: underline;">Редактирование</i> можно задать возможность изменения табличного документа. С помощью свойства <i style="text-decoration: underline;">ОтображатьСетку</i> можно управлять отображением сетки в поле табличного документа.</p>
    <p>Для поля вида <b>"Поле календаря"</b> с помощью свойства <i style="text-decoration: underline;">РежимВыделения</i> можно управлять режимом выделения дат. Возможны значения: "Одиночный", "Множественный", "Интервал"(выделение непрерывного интервала дат).</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ОтображатьПанельМесяцев</i> можно показать в поле календаря панель месяцев, которая повышает быстроту и удобство выбора дат из календаря.</p>
    <p>Напомню, что для поля вида календаря нужен реквизит с типом Дата.</p>
    <p>Поле формы вида <b>"Поле табличного документа"</b>, <b>"Поле форматированного документа"</b>, <b>"Поле графической схемы"</b>, <b>"Поле планировщика"</b> являются источником стандартных команд формы. Поэтому рядом с ними можно добавить группу вида "Командная панель" и выбрать соответсвующие поля в качестве источника команд этой панели. Состав команд этих полей настраивается с помощью свойства <i style="text-decoration: underline;">СоставКоманд</i>.</p>
    <img src="../img/1С-1/2023-11-12_19-07-19.png" class="screen" alt="">
    <p><b>Свойства таблицы</b></p>
    <p>Таблица формы является источником стандартных команд, поэтому у таблицы существует собственная командная панель, в которой располагаются эти команды. Состав команд таблицы настраивается с помощью свойства "СоставКоманд".</p>
    <p>Команды, отключенные при изменении данного свойства, становятся недоступными.</p>
    <p>Наличие и расположение командной панели таблицы определяется свойством <i style="text-decoration: underline;">ПоложениеКоманднойПанели</i> в палитре свойств таблицы формы. Возможны значения: "Нет", "Авто", "Верх", "Низ". В форме списка, в форме выбора командная панель таблицы обычно не отображается, поскольку все команды собираются в командную панель самой родительской формы.</p>
    <p>Свойство <i style="text-decoration: underline;">Отображение</i> позволяет установить разновидность отображения данных. Речь идёт о таблице формы, которая отображается как табличная часть в справочниках/документах, как таблица отображающая динамический список, да и вообще о всех таблицах в формах. Разновидность значений этого свойства:</p>
    <ul class="list">
        <li>Список. Данные отображаются в виде обычного (плоского) списка. Если справочник иерархический, то группы расположены вперемешку с элементами;</li>
        <li>Иерерхический список. Данные отображаются в виде списка с учётом иерархии групп и элементов;</li>
        <li>Дерево. Данные отображаются в виде дерева. Если таблица связана с реквизитом типа "ДинамическийСписок", у которого в настройках списка (свойство реквизита формы "Настройка списка") задана группировка, то список всегда будет отображаться в режиме Дерево.</li>
    </ul>
    <p>В пользовательской части для пользователя есть точно такие же настройки списка, они находятся в подменю "Ещё" в пункте "Режим просмотра".</p>
    <p>Для иерархических списков не советуется устанавливать свойство <i style="text-decoration: underline;">НачальноеОтображениеДерева</i> в значение "Раскрывать все уровни", так как это приведёт к существенному снижению скорости открытия больших списков. Следует использовать значения "Не раскрывать" или "Раскрывать верхний уровень".</p>
    <p>Свойство <i style="text-decoration: underline;">Вывод</i> управляет возможностями сохранения, печати и копирования данных, отображаемых элементом формы Таблица.</p>
    <p>Если таблица отображает данные динамического списка, то с помощью свойства <i style="text-decoration: underline;">ОбновлениеПриИзмененииДанных</i> можно управлять обновлением спика при добавлении или изменении данных в пользовательском режиме. Свойство <i style="text-decoration: underline;">Автообновление</i> содержит признак необходимости автообновления данных в таблице через иетервал, заданный в свойстве <i style="text-decoration: underline;">ПериодАвтообновления</i>.</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ФиксацияВТаблице</i>(Лево, Право, Нет) можно зафиксировать некоторые столбцы в таблице(отменить их прокрутку). Например, в табличной части документа можно зафиксировать слева колонку "Номер" и "Товар", а колонку "Сумма" прижать к правому краю таблицы.</p>
    <p>В том случае, если область фиксации таблицы формы больше видимой области таблицы, выполняется автоматическое отключение фиксации колонок. Если признак фиксации указан у группы колонок, то прижата будет вся группа (вместе со всеми подчинёнными элементами формы), при этом значение свойства "ФиксацияВТаблице" для подчинённых элементов игнорируется.</p>
    <p>Управлять наличием полос прокрутки у таблицы можно с помощью свойств <i style="text-decoration: underline;">ВертикальнаяПолосаПрокрутки</i>, <i style="text-decoration: underline;">ГоризонтальнаяПолосаПрокрутки</i>. Возможны значения:</p>
    <ul class="list">
        <li>Не использовать - полосы прокрутки не используются;</li>
        <li>Использовать всегда - полосы прокрутки всегда присутствуют в таблице формы;</li>
        <li>Использовать автоматически - используются в таблице только тогда, когда содержимое таблицы по соотвествующему измерению не помещается в видимой области. Стоит по умолчанию.</li>
    </ul>
    <p>С помощью свойства <i style="text-decoration: underline;">ВариантУправленияВысотой</i> можно управлять высотой таблицы формы. Возможны значения:</p>
    <ul class="list">
        <li>В строках формы - в этом случае высота таблицы задаётся в спомощью свойства "Высота" таблицы формы. Для ограничения максимальной высоты используются свойства "АвтоМаксимальнаяВысота" и "МаксимальнаяВысота".</li>
        <li>В строках таблицы - в этом случае высота таблицы задаётся с помощью свойства "ВысотаВСтрокахТаблицы" таблицы формы. Для ограничения максимальной высоты таблицы используются свойства "АвтоМаксимальнаяВысотаВСтрокахТаблицы" и "МаксимальнаяВысотаВСтрокахТаблицы".</li>
        <li>По содержимому - если таблица связана с динамическим списком, то высота таблицы задаётся значением свойства "ВысотаВСтрокахТаблицы". Если значение этого свойства равно 0, то высота таблицы определяется значением сойства "Высота".</li>
    </ul>
    <p>Если таблица не отображает данные динамического списка, то, установив свойство "ВариантУправленияВысотойТаблицы" в значение "По содержимому", можно разработать форму, в которой таблица будет отображать то количество строк, которое в ней находится, тем самым уменьшив количество полос прокрутки в форме и сделалв саму форму более компактной.</p>

    <p><b>Свойства кнопки</b></p>
    <p>Свойство <i style="text-decoration: underline;">ТолькоВоВсехДействиях</i>(Да, Нет, Авто) определяет, будет ли отображаться кнопка ещё где-нибудь (в местах, определеённых разработчиком формы) кроме подменю "Ещё".</p>
    <p>Если у кнопки установлено свойство <i style="text-decoration: underline;">Пометка</i>, она отображается как нажатая.</p>
    <p>Свойство <i style="text-decoration: underline;">Отображение</i> определяет разновидность отображения кнопки на экране (Авто, Текст, Картинка, Картинка и текст).</p>
    <p>Если выбрано отображение "Картинка и текст", то картинка, расположенная на кнопке, может располагаться слева или справа относительно текста кнопки. Для управления этим расположением предназначено свойство кнопки <i style="text-decoration: underline;">ПоложениеКартинки</i> (Право, Лево, Авто). При авто система помещает картинку слева.</p>
    <p>С помощью свойства <i style="text-decoration: underline;">Фигура</i> (Авто, обычная, Овальная) можно задать обычную или овальную фмгуру для отображении кнопки.</p>
    <p>С помощью свойства <i style="text-decoration: underline;">ОтображениеФигуры</i> можно указать несколько различных способов отображения фигуры кнопки.</p>
    <ul class="list">
        <li>Авто - в этом случае для стандартных кнопок используется вариант отображения, заданый для команды. В остальных случаях трактуется как "Всегда";</li>
        <li>Всегда - в этом случае фигура кнопки отображается;</li>
        <li>При активности - в этом случае в обычном состоянии кнопка отображается без фона и рамки. В том случае, если курсор мыши указывает на кнопку, на ней установлен фокус ввода или у кнопки установлено свойство "Пометка" - отображается стандартная кнопка с заданными цветами рамки и фона;</li>
        <li>Нет - в этом случае в обычном состоянии кнопка отображается без фона и рамки. При наведении курсора у заголовка кнопки появляется подчёркивание и зименяется курсор мыши.</li>
    </ul>
    <p>Свойство "ОтображениеФигуры" не действует на команды, расположенные в подменю.</p>
    <p>Кроме того, для кнопки так же, как и для других элеметов формы, можно задать свойства: "ЦветФона", "ЦветТекста", "ЦветРамки" и "Шрифт".</p>











    <h3 class="header-style2" id="chapter2.4">Глава 2.4 Влияние объектов конфиурации на форму</h3>
    <p>Объекты конфигурации определяют не только функциональность будущей формы через её основной реквизит, но и оказывают влияние на внешний вид формы, на поведение её элементов. На форму влияют как свойства самого объекта конфигурации, так и свойства его реквизитов.</p>

    <p class="title-size16"><b id="chapter2.4.1">Заголовок формы</b></p>
    <p>Прежде всего, с помощью свойств объектов конфигурации формируется заголовок формы. Однако такое влияние на заголовок формы оказывается не всегда. У разработчика приложения остаётся возможность ручного формирования заголовка формы.</p>
    <p>Рассмотрим небольшой пример, в котором будут задействованы свойства объекта конфигурации, оказывающие влияние на формирование заголовка формы объекта(формы элемента справочника, формы документа, формы задачи).</p>
    <p>По умолчанию для вновь созданной формы её заголовок формируется полностью в самостоятельном режиме. Это означает, что свойство формы "Заголовок" не заполнено, а в свойстве "АвтоЗаголовок" установлена галочка. При таком раскладе на самостоятельность формируемого заголовка формы оказывает влияние свойство объекта конфигурации "Синоним".</p>
    <img src="../img/1С-1/2023-11-27_09-05-25.png" class="screen" alt="">
    <p>При создании нового объекта его синоним показывается в заголовке формы - при условии, что представление объекта не заданы. Если задано расширенное представление объекта, то в заголовке формы будет показано именно оно, а не синоним.</p>
    <p>После записи такого элемента в информационную базу в формировании заголовка формы учавствует ещё и свойство объекта "Основное представдение". По умолчанию оно установленно в "В виде наименования". Теперь если открыть существующий уже элемент справочника, то заголовок будет самостоятельно сформирован из наименования текущего элемента справочника и в скобках синоним самого объекта конфигурации.</p>
    <img src="../img/1С-1/2023-11-27_09-25-01.png" class="screen" alt="">
    <p>У объектов конфигурации есть ряд интерфейсных свойств, влияющих на заголовок формы в пользовательском режиме работы. Речь далее пойдёт о таких свойствах как "Представление объекта", "Расширенное представление объекта", "Представление списка", "Расширенное представление списка".</p>
    <p>При формировании заголовка формы объекта, если <b>"Представление объекта"</b> заполнено, то важность отдаётся именно ему.</p>
    <img src="../img/1С-1/2023-11-27_09-42-37.png" class="screen-2" alt="">
    <p>Свойство задаётся в единственном числе и показывает как название одного объекта, например: Контрагент для справочника Контрагенты, Организация для справочника Организации, Договор для справочника Договоры, ФизЛицо для справочника ФизическиеЛица. Свойство участвует в формировании названия команды в интерфейсе приложения, а именно для команды создания нового элемента в Группе команд "Создать".</p>
    <p>В случае использования свойства <b>"Расширенное представление объекта"</b> в заголовке формы отображается именно оно.</p>
    <img src="../img/1С-1/2023-11-27_09-55-32.png" class="screen-2" alt="">
    <p>Остальные рассмотренные свойства ("Представление объекта", "Синоним") могут использоваться платформой только в том случае, если расширенное представление объекта не задано.</p>
    <p>Таким образом, можно сказать, что свойство "Представление объекта" отвечает за формирование команд, а "Расширенное представление объекта" - за отображение в заголовке формы. Например: "ФизЛицо" - команда создания элемента и "ФизЛицо предприятия" заголовок формы объекта. Но если эти представления совпадают, тогда можно задать только представление объекта, и оно же автоматически будет использоваться в заголовке формы.</p>
    <p>С представлениями списка используется тот же принцип.</p>
    <p>Если возникает необходимость задания собственного заголовка формы, то возможности самостоятельного формирования заголовка можно совмещать с текстом, введённым вручную. Для этого нужно оставить "АвтоЗаголовок" включённым и применить свой "Заголовок" формы.</p>
    <img src="../img/1С-1/2023-11-27_10-17-43.png" class="screen" alt="">
    <p>Если для формы нужно применить только свой собственный заголовок, то свойство "АвтоЗаголовок" необходимо снять. Тогда и для создаваемого и для открываемого элемента заголовка будет сформирован заголовок только наш:</p>
    <img src="../img/1С-1/2023-11-27_10-59-00.png" class="screen-2" alt="">
    <p><span class="vue-b">Немного по другим правилам формируются заголовки форм документа и задачи</span>.</p>
    <p>При создании <b>нового документа</b> (так же как и для справочника) используется его расширенное представление(если оно задано).</p>
    <p>После <b>записи документа</b> в базу данных заголовок формируется по правилу: "Пердставление объекта"(если не задано, то Синоним) плюс представление ссылки на документ.</p>
    <img src="../img/1С-1/2023-11-27_13-34-22.png" class="screen" alt="">
    <p>При формировании формы объекта конфигурации система руководствуется наименованием задачи, её номером, датой и одним из свойств объекта конфигурации, отвечающих за представление объекта.</p>
    <img src="../img/1С-1/2023-11-27_13-45-54.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter2.4.2">Интерфейсные свойства реквизитов объектов конфигурации</b></p> 
    <p>Наиболее важные интерфейсные свойства существуют не только у элементов формы, но и у реквизитов объектов конфигурации. Это означает, что при установке такого свойства для реквизита оно автоматически действует на все формы, в которых данный реквизит отображается(при условии использования объекта в качестве основного реквизита формы). Если у элемента формы есть подобное свойство, то оно позволяет переопределить для данной формы свойство реквизита объекта.</p>
    <p><span class="vue-r">Если свойство существует у реквизита объекта и у элемента формы, то использовать советуют свойство реквизита объекта. Если же нужно переопределить свойство реквизита в форме, тогда используется подобное свойство у элемента формы.</span></p>
    <p>Некоторые свойства существуют и на более высоком уровне - у прикладных объектов конфигурации, соответствующих типу реквизита. Если свойство существует и у реквизита объекта, и у соответствующего ему прикладного объекта, то советуют использовать именно свойство самого объекта. Но если нужно, то можно переопределить значение свойства у конкретного реквизита. имеющего тип этого объекта конфигурации.</p>
    <img src="../img/1С-1/2023-12-01_10-23-30.png" class="screen" alt="">
    <p>Большинство свойств реквизита, которые влияют на поведение элемента формы, находятся во вкладке "Представление".</p>
    <p><b>Выбор групп и элементов</b></p>
    <p>При открытии формы выбора выборку можно ограничить с помощью настройки свойства реквизита <i style="text-decoration: underline;">ВыборГруппИЭлементов</i>. Возможны значение: "Элементы", "Группы" и "Группы и элементы". Т.е. если у свойства стоит значение "Элементы", то выбрать из формы выбора можно только элементы, группы нельзя выбрать.</p>
    <p><b>Быстрый выбор</b></p>
    <p>Часто для повышения производительности действий пользователей и удобства их работы выбор элементов удобно делать не в отдельном окне формы выбора, а в выпадающем списке. Сделать подобную настройку выбора элементов можно с помощью установки свойства <i style="text-decoration: underline;">БыстрыйВыбор</i></p>
    <p>За способ выбора объектов при заполнении полей ввода отвечают свойства прикладных объектов "СпособВыбора" и "БыстрыйВыбор". Свойство "БыстрыйВыбор" отвечает за режим выбора по умолчанию. Свойство "СпособВыбора" может принимать значения "Обоими способами", "Из формы" и "Быстрый выбор".</p>
    <p>Допустим в конфигурации есть справочник "Склады". У него свойство "СпособВыбора" равно "Обоими способами", а также установлено свойство "БыстрыйВыбор". В этом случае по умолчанию выбор из значений справочника "Склады" будет по быстрому выбору.</p>
    <p>Если требуется переопределить режим выбора для реквизита в каком то конкретном месте прикладного решения, нужно установить у него свойство "БыстрыйВыбор" в значение "Использовать" или "Не использовать". При этом значение свойства "СпособВыбора" прикладного объекта не должно ему противоречить, т.к. оно явялется определяющим.</p>
    <p>Т.е. если нужно запретить быстрый выбор для реквизита, то нужно установить у него свойство "БыстрыйВыбор" в значение "Не использовать". При этом свойство "СпособВыбора" прикладного объекта должно принимать значения "Обоими способами" или "Из формы". Если же нужно разрешить быстрый выбор для реквизита, то нужно установить у него свойство "БыстрыйВыбор" в значение "Использовать". При этом свойство "СпособВыбора" прикладного объекта должно принимать значения "Обоими способами" или "Быстрый выбор".</p>
    <p>Свойство "БыстрыйВыбор" существует также и у элемента формы, связанного с рекизитом.</p>
    <p>Таким образом, получается трёхуровневая схема управления режимом выбора:</p>
    <ul class="list">
        <li>Сначала платформа анализирует свойство "БыстрыйВыбор" элемента формы.</li>
        <li>Если значение свойства равно "Авто", то оно анализируется у реквизита объекта.</li>
        <li>Если значение свойства равно "Авто", выполняется анализ свойств "СпособВыбора" и "БыстрыйВыбор" прикладного объекта, соответствующего типу реквизита. Если на каком-то из первых двух уровней(элемент формы или реквизит объекта) значение свойства "БыстрыйВыбор" отлично от "Авто", анализ прекращается и выполняется выбор в определённом в них режиме.</li>
    </ul>
    <p><b>История выбора при вводе</b></p>
    <p>Свойство <i style="text-decoration: underline;">ИсторияВыбораПриВводе</i> позволяет сохранять и отображать историю выбора при вводе ссылочных значений в поле формы. История выбора состоит из наиболее часто используемых и последних выбранных значений данного ссылочного типа. Может принимать значения "Авто" и "Не использовать".</p>
    <p>Управление историей выбора сделано с помощью трёхуровневой схемы:</p>
    <ul class="list">
        <li>Сначала платформа анализирует свойство "ИсторияВыбораПриВводе" для поля ввода формы.</li>
        <li>Если значение "Авто", то выполняется анализ этого свойства у реквизита, отображаемого полем ввода.</li>
        <li>Если значение "Авто", выполняется анализ свойства у объекта конфигурации, соответствующего типу реквизита.</li>
    </ul>
    <p>Если на всех уровнях принятия решений свойство установлено в значение "Авто", то история выбора при вводе в ссылочное поле будет сохраняться и отображаться в том случае, если это поле не находится в режиме выбора из списка или в режиме быстрого выбора.</p>
    <p>Иногда требуется отключить историю выбора ссылочных значений в каком-то конкретном месте прикладного решения. В этом случае нужно запретить показ истории выбора при вводе на уровне реквизита объекта конфигурации.</p>
    <p>Обычно историю выбора советуется отключать в свойствах объекта конфигурации, если её использование не соответствует прикладной логике. Т.е. когда требуется выбирать всё время новые значения, которые ещё не использовались ранее, - например, когда необходимо выбирать и закрывать заказы покупателей.</p>
    <p>Затем, чтобы пользователю перед началом выбора в поле ввода не отображалось окно со ссылкой "Показать все" для вызова формы выбора, надо во всех ссылающихся на этот реквизит полях ввода установить следующие свойства в указанные ниже значения:</p>
    <ul class="list">
        <li>"КнопкаВыпадающегоСписка" - Нет;</li>
        <li>"КнопкаВыбора" - Да;</li>
        <li>"ОтображениеКнопкиВыбора" - "В поле ввода".</li>
    </ul>
    <img src="../img/1С-1/2023-12-07_10-04-43.png" class="screen" alt="">
    <p><b>Связи параметров выбора</b></p>
    <p>В ряде задач, решаемых пользователями с помощью элементов формы, необходимо ограничивать количество предлагаемых для выбора данных. Так, например, в документе оплаты поставщику товаров, при выборе расчётного счёта поставщика желательно видеть не все расчётные счета контрагентов, которые есть в соответствующем справочнике, а только счета того поставщика, которому совершается оплата. Сделать это можно с помощью настройки свойства <i style="text-decoration: underline;">СвязиПараметровВыбора</i>.</p>
    <p>Например, на показанном ниже рисунке для реквизита "РасчетныйСчетПоставщика" документа "Оплата" свойство "СвязиПараметровВыбора" установлено в значение Поставщик для отбора по полю Владелец(Отбор.Владелец).</p>
    <p>Этот отбор будет применяться при открытии формы выбора, при отображении списка быстрого выбора и при выполнении ввода по строке.</p>
    <p>Пример использования свойства будет дальше.</p>
    <p><b>Параметры выбора</b></p>
    <p>Свойство <i style="text-decoration: underline;">ПараметрыВыбора</i> позволяет задать значения параметров для отбора при выборе значения реквизита. Но этот выбор будет выполняться не на основании значений других реквизитов формы, а на основании условий, наложенных на свойства самого выбираемого объекта. Значениями отбора могут выступать ссылки на значения справочников, перечислений, планов видов характеристик, значения примитивных типов данных и список значений фиксированного массива.</p>
    <p>Например, при учёте поступления товаров(документ ПриходТовара, реквизит табличной части Товар) необходимо запретить выбор услуг, т.е. ограничит выбор только теми товарами, у которых реквизит "Вид" равен значению "Перечисление.ВидТоваров.Товар".</p>
    <p>Этот отбор будет применяться при открытии формы выбора, при отображении списка быстрого выбора и при выполнении ввода по строке.</p>
    <p>Если имя у какого-либо параметра свойства "СвязиПараметровВыбора" совпадает с именем какого-либо параметра свойства "ПараметрыВыбора", то важность отдаётся элементу из свойства "СвязиПараметровВыбора"(в том случае, если значение поля, указанного в параметре Реквизит, заполнено).</p>
    <p><b>Создание при вводе</b></p>
    <p>Свойство <i style="text-decoration: underline;">СозданиеПриВводе</i> определяет наличие кнопки для создания нового элемента в выпадающем списке, открывающемся под ссылочным полем.</p>
    <p>Допустим, в конфигурации есть справочник Товары. У него свойство "СозданиеПриВводе" установлено в значение "Использовать". В этом случае по умолчанию во всём прикладном решении при выборе товаров в выпадающем списке, открывающемся под соответствующим полем, будет присутствовать кнопка создания нового элемента справочника Товары.</p>
    <img src="../img/1С-1/2023-12-07_21-05-57.png" class="screen" alt="">
    <p>При наличии кнопки создания в выпадающем списке удобно сразу начинать ввод нового элемента справочника в поле ввода. Если совпадений с новым значением не найдено, можно нажать кнопку создания нового элемента и продолжить ввод наименования в цпециальной форме. При этом введёные ранее символы уже будут подставлены в наименование нового элемента справочника.</p>
    <p>После записи нового элемента ссылка на этот элемент сама подставится в поле ввода.</p>
    <p>При создании элемента из выпадающего списка, связанного  с полем ввода, существует возможность автоматической и программной проверки созданного элемента на соответствие параметрам выбора и связям параметров выбора, которые использовались при открытии формы нового элемента. Если элемент не соответствует параметрам выбора, будет выдано диагностическое сообщение и созданный элемент не будет помещён в поле ввода.</p>
    <p><b>Связь по типу</b></p>
    <p>Свойство <i style="text-decoration: underline;">СвязтьПоТипу</i> позволяет указать реквизит объекта, который будет поставлять тип значения для текущего реквизита. Указание такой связи используется в том случае, если необходимо, например, дать возможность пользователям самим определять дополнительные свойства тех или иных объектов базу данных. Настройка связи по типу имеет смысл для реквизитов  с составным типом данных, логически связанных с другим реквизитом.</p>
    <p>Например, в конфигурации есть план видов характеристик, который хранит виды характеристик товаров. Значения характеристик могут быть различного типа(Число, Дата, Булево, СправочникСсылка.&lt;Имя> и др.). Значения характеристик хранятся в регистре сведений, измерением которого является вид характеристики.</p>
    <p>Для ресурса "Значение" регистра сведений "ХарактеристикиТоваров" устанавливается связь по типу с измерением "ВидХарактеристики". В результате тип значения выбранной характеристики определяется типом, который задан для неё в плане видов характеристик.</p>
    <p><b>Форма выбора</b></p>
    <p>В свойстве <i style="text-decoration: underline;">ФормаВыбора</i> можно указать, какая из форм объекта будет использоваться в качестве основной формы выбора значения реквизита. Используется для реквизитов, тип которых образован объектом конфигурации, имеющим подчинённые формы.</p>
    <p><b>Проверка заполнения</b></p>
    <p>Свойство <i style="text-decoration: underline;">ПроверкаЗаполнения</i> отвечает за автоматическую проверку заполнения реквизита. При установке свойства реквизита в значение "Выдавать ошибку" у связанного с ним элемента формы изменится видимое представление - элемент будет подчёркнут красной линией. В случае необходимости переопределения свойства нужно будет воспользоваться обработчиком события "ПроверкаЗаполнения" прикладного объекта, на который ссылается данные реквизит.</p>
    <p><b>Значение заполнения</b></p>
    <p>Свойство <i style="text-decoration: underline;">ЗначениеЗаполнения</i> позволяет указать начальное значение реквизита. Для выбора доступны значения, созданные разработчиком в конфигураторе(значения перечислений, предопределённые лементы).</p>
    <p>Примером использования свойства может служить установка вида товара(товар или услуга) при создании нового элемента справочника. По умолчанию реквизит устанавливается в значение Товар перечисления ВидыТоваров.</p>
    <p><b>Заполнять из данных заполнения</b></p>
    <p>Не менее интересным является свойство <i style="text-decoration: underline;">ЗаполнятьИзДанныхЗаполнения</i>. При определённых обстоятельствах данный флажок может отменять значение свойства "ЗначениеЗаполнения". Для некоторых реквизитов флажок "ЗаполнятьИзДанныхЗаполнения" устанавливается автоматически. Если разработчик заинтересован в том, чтобы его данные из свойства "ЗначениеЗаполнения" использовались всегда, флажок "ЗаполнятьИзДанныхЗаполнения" должен быть снят.</p>
    <p>Если флажок "ЗаполнятьИзДанныхЗаполнения" установлен и происходит интерактивное создание нового объекта, то реквизит будет заполняться с учётом установленного отбора. Пример такого заполнения рассматривается дальше по книге.</p>
    <p>При интерактивным вводе на основании в структуру данных заполнения формы передаётся ссылка на объект-основание, и реквизиты создаваемого объекта заполняются исходя из значений реквизитов основания.</p>
    <p>Программно объект можно заполнить, вызвав его метод Заполнить(). У метода существует параметр "ДанныеЗаполнения", исходя из которого и происходит заполнение реквизитов объекта.</p>
    <p>Ещё одним из способов заполнения реквизитов формы первоначальными данными является вызов глобального метода ОткрытьФорму(). Если в метод передать параметр формы ЗначенияЗаполнения, то форма будет открываться с учётом переданных в параметре значений.</p>

    <p class="title-size16"><b id="chapter2.4.3">Стандартные реквизиты объектов конфигурации</b></p> 
    <p>У каждого из классов объектов конфигурации существует свой набор стандартных реквизитов. Например, у справочников это Ссылка, Код, Наименование, ПометкаУдаления и т.п. У документов - Номер, Дата, ПометкаУдаления, Ссылка, Проведён.</p>
    <p>Чтобы открыть и изменить свойства стандартных реквизитов объекта конфигурации, нужно выполнить команду "Стандартные реквизиты" из контекстного меню. Или же можно нажать кнопку "Стандратные реквизиты" на закладке "Данные" окна редактирования свойств объекта конфигурации.</p>
    <p>Состав свойств каждого из этих реквизитов различается и зависит от типа данных реквизита. Большинство свойств стандартных реквизитов совпадают со свойствами обычных реквизитов объектов и свойствами элементов формы.</p>
    <p>Для стандартных реквизитов объектов конфигурации, автоматически поставляемых платформой, так же  как и для обычных реквизитов, создаваемых разработчиком, можно изменять их свойства, влияющие на интерфейс приложения.</p>
    <p>Например, для реквизита Родитель иерархического справочника Товары можно задать значение свойства "Синоним" как "Группа". В результате в режиме 1С:Предприятие во всех формах, где используется реквизит Родитель, вместо непонятного для пользователя заголовок "Родитель" он будет иметь заголовок "Группу".</p>








    <h3 class="header-style2" id="chapter2.5">Глава 2.5 Реквизиты формы</h3>
    <p>Достаточно часто при разработке прикладных решений перед разработчиками стоит задача размещения на форме различных данных, не связанных с каким-либо определённым объектом. Это могут быть данные подчинённых справочников, регистров, таблицы, полученные в результате работы процедур встроенного языка.</p>
    <p><spa class="vue-b">В формах все данные, предназначенные для изменения, должны быть описаны в редакторе формы в виде реквизитов.</spa></p>
    <p>Во многих главах книги уже неоднократно упоминался основной реквизит формы. Такой реквизит автоматически добавляется конструктором форм, если форма создаётся подчинённой объекту конфигурации и выбирается вид формы этого объекта(флома списка, форма элемента/документа), а не произвольная форма. По умолчанию у такой формы после её создания есть только один реквизит, который и является основным. В окне реквизитов формы он выделен жирным шрифтом.</p>
    <img src="../img/1С-1/2023-12-10_21-57-32.png" class="screen" alt="">
    <p>Флажок "Использовать всегда" позволяет влиять на передачу данных формы в процессе её работы между клиентской частью и серверной.</p>
    <p>Флажок оказывает влияние на внутреннее наполнение формы и не влияет на пользовательское представление.</p>
    <p>По умолчанию платформа устанавливает этот флажок для всех данных, отображаемых в форме. И снимать его не нужно. Но если, например, какая-то колонка динамического списка не отображается в форме, но используется в коде, то будет получена ошибка. Потому что в этом случае данные колонки не будут переданы с сервера на клиент. Чтобы избежать ошибки, нужно установить флажок "Использовать всегда" всегда у тех данных, которые не отображаются в интерфейсе, но к которым обращаются из встроенного языка.</p>
    <p>Добавление нового реквизита формы выполняется стандартным способом - с помощью кнопки командной панели в окне реквизитов редактора формы. Реквизиты формы обладают набором свойств, позволяющих влиять на их поведение.</p>





    <h3 class="header-style2" id="chapter2.6">Глава 2.6 Командный интерфейс окна клиентского приложения.</h3>
    <img src="../img/1С-1/2023-07-11_22-02-27.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter2.6.1">Панель навигации</b></p>
    <p>Командный интерфейс окна клиентского приложения формируется системой частично автоматически, на основании анализа объектов конфигурации. При этом разработчик имеет возможность добавить в него какие-то команды или, наоборот, скрыть. А также настроить их ролевую видимость.</p>
    <p>Так, например, после добавления в дерево конфигурации подчинённого справочника или регистра сведений, у которого тип значения измерения является ссылкой на текущий справочник и при этом установлени признак свойства измерения "Ведущее", в форме  текущего справочника системой самостоятельно будут сформированы команды в панели навигации для открытия форм объектов конфигурации, содержащих зависимые данные:</p>
    <img src="../img/1С-1/2024-01-10_15-22-37.png" class="screen" alt=""> 
    <p>В режиме разработки формы такие команды можно увидеть и отредактировать в редакторе формы. Они будут находится на закладке "Командный интерфейс". При этом у разработчика формы есть возможность повлиять на видимость таких команд в пользовательском режиме работы:</p>
    <img src="../img/1С-1/2024-01-10_15-47-18.png" class="screen-2" alt="">
    <p>После этого платформа в пользовательском режиме может ограничить состав команд, заданный в конфигураторе, в зависимости от прав пользователей.</p>

    <p class="title-size16"><b id="chapter2.6.2">Командная панель основной формы</b></p>
    <p>Если на основании какго-либо объекта инфобазы можно вводить новые данные (например, на основании элемента справочника "Контрагенты" можно ввести документ "РасходТовара"), то в форме элемента-основания системой формируется предопределённое подменю "Создать на основании".</p>
    <p>В пользовательском режиме работы такое подменю формируется в командной панели основной формы окна клиентского приложения. Такой способ ввода новый объектов базы данных позволяет значительно повысить производительность работы пользователей, уменьшить количество допущенных в работе ошибок, избавить от постоянного нудного и однообразного ввода одних и тех же данных.</p>
    <p>Управлять видимостью подменю "Создать на основании", а также его составом можно в процессе разработки формы на закладке "Командный интерфейс":</p>
    <img src="../img/1С-1/2024-01-10_16-08-33.png" class="screen-2" alt="">
    
    <p class="title-size16"><b id="chapter2.6.3">Команды формы</b></p>
    <p>Помимо заполнения каких-либо элементов формы пользователю достаточно часто приходится командовать форме, что сделать в том или ином случае. Все команды, которые могут быть назначены кнопкам и использованы в форме, сгруппированы во вкладке "Команды".</p>
    <p>При этом для удобства разработчика все команды разделены на три категории:</p>
    <ul class="list">
        <li>Команды формы. Именно в данном окне с помощью кнопки "Добавить" можно создавать новые команды формы. При этом все создаваемые команды являются "программируемыми". Описание алгоритма работы команд выполняется разработчиком в модуле формыЮ с помощью встроенного языка.</li>
        <li>Стандартные команды. В данном разделе собраны все команды, которые предоставляются самой формой и основными реквизитами формы. Если в форме есть элементы, отображающие списки(наборы записей, динамические списки, табличные части объектов и так далее), а также табличные элементы, форматированные элементы, графические схемы или планировщики, то команды таких элементов также присутствуют в данной разделе команд.</li>
        <li>Глобальные команды. Команды этой группы могут являться параметризованными и непараметризованными. Это команды глобального командного интерфейса. Параметризованные команды отображаются в форме, только если для них в форме существует источник с соответствующим типом данных.</li>
    </ul>




    <h3 class="header-style2" id="chapter2.7">Глава 2.7. Управление видимостью элементов формы</h3>

    <p class="title-size16"><b id="chapter2.7.1">Влияние прав и ролей пользователя на элементы формы</b></p>
    <p>Для ограничения доступа к данным инфобазы в пользовательском режиме применяются объекты конфигурации "Роль". Каждая роль, присутствующая в том или ином прикладном решении, описывает набор прав доступа к объектам инфобазы. Так как работа пользователя с объектами инфобазы происходит в формах, права доступа к таким объектам законным образом влияют на внешний вид формы.</p>
    <p><span class="vue-r">Дальше пока не буду описывать, скучная тема. Остановился на Стр 361</span></p>


    <p class="title-size16"><b id="chapter2.7.2">Влияние функциональных опций на элементы формы</b></p>
    <p></p>





    <h3 class="header-style2" id="chapter2.8">Глава 2.8. Окно сообщений клиентского приложения</h3>




    <h3 class="header-style2" id="chapter2.9">Глава 2.9. Примеры конструирования форм</h3>
    <p class="title-size16"><b id="chapter2.9.1"></b></p>




    <h3 class="header-style2" id="chapter2.10">Глава 2.10. Начальная страница. стр 422</h3>











        
        


    <h2 class="header-style">Часть 3. Программирование форм и интерфейса</h2>
    <p>Оглавление 3 части на 433 странице</p>




    <h3 class="header-style2" id="chapter3.1">Глава 3.1 Форма как элемент клиент-серверного взаимодействия. Стр 437</h3>
    <p>Прежде чем рассматривать конкретные примеры программирования в формах, нужно иметь чёткое представление о том, что представляет собой форма. В предыдущих главах книги уже давались общие сведения о её устройстве и функционировании, сейчас же мы рассмотрим форму более подробно и именно с точки зрения её внутреннего, "программного" устройства.</p>

    <p class="title-size16"><b id="chapter3.1.1">Клиент-серверная архитектура</b></p>
    <p>Форма - это программный объект, который создаётся в процессе работы прикладного решения в режиме "1С:Предприятия".</p>
    <p>Форма может быть создана платформой без участия разработчика. Либо она может быть создана по инициативе разработчика в результате выполнения алгоритма, описанного разработчиком на встроенном языке.</p>
    <p>В "1С:Предприятие" нет "единого пространства" для выполнения кода на встроенном языке. Каждый кусок кода выполняется в некотором контексте.</p>
    <p>Не углубляясь в детали, таких контекстов два: это контекст клиенте и контекст сервера.</p>
    <p>С одной стороны, крнтекст определяет "программное окружение", в котором исполняется код: доступные свойства, методы, набор объектов встроенного языка, которые можно использовать.</p>
    <p>С другой стороны, контекст определяет физическое место(конкретный компьютер), на котором выполняется этот код.</p>
    <p><i style="text-decoration: underline;">Клиентское приложение</i> - это программа(толстый клиент, тонкий клиент или веб-клиент), которая обеспечивает взаимодействие системы с пользователем. Она может помимо всего прочего исполнять код на встроенном языке, написанный разработчиком. В этом случае говорят, что код исплняется на клиенте.</p>
    <p><i style="text-decoration: underline;">Сервер "1С:Предприятия"</i> - это один из рабочих процессов, действующих в составе кластера серверов "1С:Предприятия". Он обеспечивает взаимодействие клиентского приложения с хранилищем данных - СУБД. Кроме этого сервер "1С:Предприятия" также может исполнять код на встроенном языке. В этом случае говорят, что код исполняется в контексте сервера или на сервере.</p>
    <p>Первая особенность, которая важна для нас, заключается в том, что на сервере и на клиенте доступны разные свойства, методы, объекта встроенного языка. Грубо говоря, все действия, связанные с доступом к данным СУБД(их чтение и запись), возможны только на сервере, в то время как взаимодействие с пользователем возможны только на клиенте.</p>
    <p>Клиентское приложение работает на компьюторе пользователя - клиентском компьюторе. Сервер "1С:Предприятия" работает на отдельном выделенном компюторе - сервере. СУБД также работает на отдельном компьюторе - сервере базы дынных.</p>
    <p>Как правило, сервер и сервер баз данных находится в пределах одной локальной сети. А вот клиентский компьютер может находится где угодно. Он может находится в этой же сети, а может подключится к серверу через Интернет. При этом каналы связи, используемые для такого подключения, могут быть самыми разными - от широкого и быстрого оптоволоконного подключения до узкого и медленного подключения по каналам сотовой связи.</p>
    <p>Работа системы "1С:Предприятия" всегда начинается на стороне пользователя - пользователь запускает приложение и соединяется с инфобазой. Уже в этот миг в работу вступает северная часть "1С:Предприятия" - выполняется соединение с кластером серверов, аутентификация подключающегося пользователя в инфобазе, формирование основного окна системы, начальной страницы и передача его на клиента. В дальнейшем этот процесс повторяется неоднократно: выполнение каких-либо действий начинается на клиенте, затем управление перекидывается на сервер, он выполняет некоторые действия и возвращает управление на клиент. То есть клиентское приложение вызывает сервер для выполнения каких-либо действий, сервер их выполняет  и возвращает результат и управление обратно на клиента.</p>
    <p>Механизмы платформы, отвечающие за это взаимодействие, налажены так, чтобы обеспечивать приемлемую скорость работы системы даже на низкоскоростных каналах связи.</p>
    <p>Однако кроме платформы такое взаимодействие может вызывать и сам разработчик в результате работы совего алгоритма на встроенном языке. Например, когда из процедуры, исполняющейся на клиенте, он вызывает процедуру, которая должна выполняться на сервере. В этом случае также происходит вызов сервера, управление передаётся на него, выполняется требуемая процедура, и управление возвращается обратно на клиент, в ту процедуру, из которой был осуществлён вызов.</p>
    <p>Поскольку заранее неизвестно, каким именно образом клиент подключён к серверу, такой серверный вызов может быть "совсем незаметным" для системы, или, наоборот, он может быть очень "затратным". Например, в том случае, когда используются мобильные каналы связи. Поэтому к вызовам сервера разработчик должен относится очень внимательно. В противном случае быстродействие и производительность разрабатываемой системы могут оказаться очень низкими.</p>

    <p class="title-size16"><b id="chapter3.1.2">Форма - клиент-серверный объект</b></p>
    <p>Теперь посмотрим, почему эти две особенности так важны именно при программировании форм.</p>
    <p>Как мы сказали в самом начале, форма - это программный объект, существующий в памяти компьютера в какой-то миг работы системы в режиме "1С:Предприятие".</p>
    <p>Раз мы говорим о его "программировании", то это значит, что это программный объект создаётся платформой на основе того описания, которое существует в дереве объектов конфигурации, то есть на основе объекта конфигурации Форма. Потому что в "1С:Предприятии" могут существовать формы, не описанные в конфигурации, - те, которые платформа создаёт самостоятельно. В такие формы разработчик не может добавить свой код.</p>
    <p>Каждый такой объект конфигурации Форма, описанный в дереве объектов конфигурации, имеет модуль, в котором разработчик располагает собственные процедуры на встроенном языке.</p>
    <p>Эти процедуры вызываются в определённые, заранее известные моменты работы формы и определяют её отличное от других форм, поведение и возможности.</p>
    <p>Так вот основная особенность формы как программного объекта заключается в том, что она существует и на клиенте и на сервере. Поэтому для каждой процедуры в модуле формы разработчик в явном виде указывает контекст её исполнения: на сервере или на клиенте.</p>

    <p class="title-size16"><b id="chapter3.1.3">Общий подход к программированию форм</b></p>
    <p>Из этого следует несколько важных выводов, определяющих общий подход к программированию форм.</p>
    <ul class="list">
        <li>Разработчик должен понимать, что он не просто кодирует некий прикладной алгоритм, а в явном виде программирует отдельно клиентскую и отдельно серверную часть приложения.</li>
        <li>Разработчик должен управлять частотой вызовов сервера и объёмом передаваемых данных.</li>
        <li>В разрабатываемой конфигурации код, реализующий бизнес-логику, должен быть чётко отделён от кода, реализующего интерфейс.</li>
        <li>Структура кода должна определяться не прикладной логикой решаемой задачи, а логикой клиент-серверного взаимодействия.</li>
        <li>Клиентский код пишется не как последовательность действий, которую нужно выполнить. Прежде всего он продумывается как сценарий передачи управления с клиента на сервер и обратно.</li>
        <li>Несмотря на то, что форма существует и на клиенте и на сервере, клиент и сервер нужно рассматривать не как единое пространство выполнения приложения, а скорее как два взаимодействующих приложения.</li>
        <li>Полезно мысленно представить вызов сервера как "непростой процесс":
            <ul class="list2">
                <li>Система формирует обращение к серверу, передаёт его по каналу связи, потом выполняет его на сервере, возвращает ответ по каналу связи</li>
                <li>Если тонкий клиент работает, например, через GPRS, то каждый вызов - то примерно 1,5 секунды!</li>
                <li>Хочется, чтобы с прикладным решением работали удалённые пользователи? Тогда нужно думать о каждом вызове сервера!</li>
            </ul>
        </li>
    </ul>
    <p>На протяжении последующих глав, особенно в четвёртой части книги, эти советы будут неоднократно повторятся и объясняться более подробно. Сейчас же важно усвоить следующее: программрование форм - это отдельное непростое занятие, требующее взвешенного и методически грамотного использования имеющихся возможностей платформы.</p>




    <h3 class="header-style2" id="chapter3.2">Глава 3.2 Параметры и реквизиты формы. Стр 444</h3>
    <p>Вы уже знаете, что форма, как правило, содержит некоторое количество реквизитов и некоторое количество параметров.</p>
    <p>И те и другие позволяют хранить некоторые данные, доступны в редакторе формы на соответствующих закладках, и те и другие разработчик может добавить самостоятельно, по своему желанию.</p>
    <img src="../img/1С-1/2024-01-18_09-21-17.png" class="screen-2" alt="">
    <p>В чём различие между параметрами и реквизитами формы? Для каких задач нужно использовать реквизиты, а для каких параметры?</p>

    <p class="title-size16"><b id="chapter3.2.1">Реквизиты</b></p>
    <p>Реквизиты формы предназначены для хранения данных, с которыми работает форма. В реквизитах хранятся те данные, которые отображаются и редактируются в элементах формы, а также те данные, которые не отображаются, но используются формой в процессе работы. Вся совокупность данных, хранящихся в реквизитах формы, называется <i style="text-decoration: underline;">данные формы</i>.</p>
    <p>Каждый элемент формы, позволяющий изменять данные, связан с некоторым реквизитом формы. Когда пользователь изменяет данные в элементе формы, такие же изменения происходят и в связанном с ним реквизите. Верно и обратное. Когда реквизит формы изменяется программно, изменяется и значение, отображаемое в связанном с ним элементе формы.</p>
    <p>Не все реквизиты формы обязательно должны отображаться в форме. Часть реквизитов может быть не связана с элементами формы, а данные, хранящиеся в таких реквизитах, предназначены не для отображения или редактирования пользователем, а для обеспечения внутренних алгоритмов работы формы или для программного взаимодействия с этой формой из встроенного языка.</p>
    <p>Можно сказать, что реквизиты формы составляют часть программного интерфейса форма, с помощью которого строится взаимодействие с этой формой "извне" - из других форм или из фрагментов программного кода.</p>
    <p>Важным являет то, что реквизиты формы существуют на протяжении всего времени существования самой формы.</p>

    <p class="title-size16"><b id="chapter3.2.2">Параметры</b></p>
    <p>Параметры формы, в отличии от реквизитов формы, предназначены для управления функциональностью формы при её открытии и, грубо говоря, существуют лишь в миг создания и открытия формы. После создания или открытия формы все параметры, кроме <i style="text-decoration: underline;">ключевых параметров</i> удаляются, т.к для дальнейшей работы формы они не нужны.</p>
    <p>Ключевые параметры - это особый вид параметров, значения которых могут потребоваться после того, как форма создана. Например, для того чтобы найти этот объект формы среди других открытых форм.</p>

    <p class="title-size16"><b id="chapter3.2.3">Выводы</b></p>
    <p>Итак, подытоживая сказанное, можно отметить, что для хранения, отображения, изменения данных, для взаимодействия с формой извне, для хранения служебных данных нужно использовать реквизиты формы.</p>
    <p>Для того, чтобы создать и открыть форму в том виде и в том состоянии, в котором хочется, нужно использовать параметры формы.</p>
    <p>Следующая глава как раз будет посвящена имеющимся способам открытия форм, и в ней мы будем оперировать различными параметрами формы.</p>





    <h3 class="header-style2" id="chapter3.3">Глава 3.3 Открытие форм. Стр 446</h3>
    <p>В этой главе мы рассмотрим общий подход и несколько конкретных примеров открытия форм в типичных ситуациях.</p>

    <p class="title-size16"><b id="chapter3.3.1">Последовательность событий при открытии формы</b></p>
    <p>При открытии формы нового объекта(элемента справочника, документа и т.п.) и при открытии существующего объекта возникает различная последовательность событий.</p>
    <p>Если открывается форма нового объекта, то сначала происходит начальное заполнение объекта данными(событие "ОбработкаЗаполнения" в модуле объекта, форма которого открывается), а затем вызывается два события формы: сначала на сервере("ПриСозданииНаСервере"), а затем на клиенте("ПриОткрытии"). Эти два события позволяют подготовить форму к открытию.</p>
    <p>Посмотреть картинку с последовательностью событий можно на компе E:\Всё по 1С\1C обработки, отчёты и т.д\ Графики\Жизненый цикл формы объекта\ Схема открытия формы НОВОГО объекта справочника.</p>
    <p>Если открывается форма существующего объекта, то последовательность событий будет иной. Сначала на сервере вызываются два события формы. Одно("ПриЧтенииНаСервере") - чтобы подготовить дополнительные данные, которые зависят от данных объекта, т.е. в этот миг ещё доступен объект с данными(позже он пересоберётся в данные формы и будет уже не доступен). Другое("ПриСозданииНаСервере") - чтобы максимально подготовить форму к открытию(в этом событии уже не существует "объекта с данными", есть только "данные формы"). И, наконец, на клиенте вызывается ещё одно событие формы("ПриОткрытии"), чтобы выполнить действия, связанные с открытием формы, которые на сервере выполнить невозможно. Путь до картинки на компе - E:\Всё по 1С\1C обработки, отчёты и т.д\Графики\Жизненый цикл формы объекта\Схема открытия формы СУЩЕСТВУЮЩЕГО объекта справочника.</p>
    <p>Из всех перечисленных событий нас будет интересовать два события формы: "ПриСозданииНаСервере" и "ПриОткрытии".</p>
    <p>Всё, что можно сделать на сервере для подготовки формы к открытию, нужно делать в обработчике события "ПриСозданииНаСервере".</p>
    <p>В обработчике события "ПриОткрытии" нужно делать только то, что на сервере сделать невозможно. Например, выдать предупреждение, задать вопрос. Или же выполнить те действия, которые выполняются именно тогда, когда форма наверняка открывается. Например, открыть связанную форму, которая сама по себе не существует, а существует, только если открыта родительская форма. Потому что обработчик "ПриОткрытии" - последний перед открытием формы, в котором можно отказаться от её открытия. И если не происходит отказа от открытия родительской формы, то, значит, она наверняка будет открыта. </p>
    <p>Что касается других событий, то, например, о событии "ОбработкаЗаполнения" и механизме начального заполнения объектов мы поговорим подробно в главе 3.10.</p>
    <p>А о событии "ПриЧтенииНаСервере" мы поговорим в главе, описывающей преобразование данных объекта в данные формы и обратно, - в главе 3.4.</p>

    <p class="title-size16"><b id="chapter3.3.2">Общая методика открытия форм</b></p>
    <p>Общий подход к открытию форм следующий. Для открытия формы используется метод глобального контекста ОткрытьФорму(). Он доступен только в контексте клиентов: толстого клиента, тонкого клиента и веб-клиента. На сервере открыть форму нельзя.</p>
    <p>Этот метод содержит ряд параметров, которые позволяют указать, какая именно форма должна быть открыта, и задать некоторые свойства открываемой формы.</p>
    <p>Значения передаваемых параметров либо применяются платформой самостоятельно, либо разработчик может применить их в обработчике события формы "ПриСозданииНаСервере".</p>
    <p>Рассмотрим наиболее типичные случаи.</p>

    <p class="title-size16"><b id="chapter3.3.3">Основная форма нового объекта</b></p>
    <p>Открыть основную форму справочника "Товары" можно следующим образом:</p>
    <div class="code-style">
        <pre>
            ОткрытьФорму("Справочник.Товары.ФормаОбъекта");
        </pre>
    </div>
    <p>Первым параметром метода передаётся имя той формы, которую нужно открыть. Оно образуется по определённым правилам. Сначала указывается полное имя объекта конфигурации(в данном случае Справочник.Товары), а после него, через точку, <i style="text-decoration: underline;">стандарное имя основной формы</i>(ФормаОбъекта). Все стандартные имена основных форм перечислены в синтакс-помощнике в разделе Глобальный контекст - Процедуры и функции интерактивной работы, в описании метода ОткрытьФорму().</p>
    <p>Единственной сложностью тут является то, что имя формы указывается как строка, и поэтому писать его нужно внимательно, не забывая о том, что имя класса объектов конфигурации указывается в единственном числе: Справочник, Документ и т.д. Кстати, если в методе после скобки поставить первые кавычки и начать писать, то система поможет написать правильно имя формы.</p>
    <p>Поскольку кроме имени формы никаких других параметров не указывается, в случае формы объекта будет создан новый объект и открыта его форма.</p>
    <p>В случае же форм списка и выбора просто будут открыты соответствующие формы</p>
    <div class="code-style">
        <pre>
            ОткрытьФорму("Справочник.Товары.ФормаСписка");
            ОткрытьФорму("Справочник.Товары.ФормаВыбора");
            ОткрытьФорму("Справочник.Товары.ФормаВыбораГруппы");
        </pre>
    </div>
    <p>Таким образом можно открыть форму как самостоятельно создаваемые системой, так и формы, которые созданы разработчиком в коныигурации и назначены основными для объектов конфигурации.</p>
    <p>Однако существует две особенности, связанные с открытием стандартных форм, о которых будет сказано далее.</p>

    <p class="title-size16"><b id="chapter3.3.4">Форма констант</b></p>
    <p>Первая особенность связана с формой констант. Из встроенного языка нет возможности открыть самостоятельно создаваемую системой форму констант. Можно открыть 
    только форму констант, созданную в конфигурации. Это связано с тем, что у объекта Константы нет подобъекта Форма, где можно создать форму для константы. Можно создать только общию форму для константы:</p>
    <div class="code-style">
        <pre>
            ОткрытьФорму("ОбщаяФОрма.ФормаКонстант");
        </pre>
    </div>
    <p>Подобным способом можно открыть и другие общие формы конфигурации.</p>

    <p class="title-size16"><b id="chapter3.3.5">Форма группы</b></p>
    <p>Вторая особенность связана с формой группы иерархического справочника или иерархичесткого плана видов характеристик.</p>
    <p>Указывая имя формы в методе ОткрытьФорму(), мы лишь определяем, какая форма должна быть открыта. Но не определяем особенности элемента данных, который будет отображаться в этой форме.</p>
    <p>В случае с документами или линейными справочниками никакой проблемы не возникает. Все элементы данных в таких структурах равнозначны.</p>
    <p>Однако если справочник не линейный, а иерархический, то он содержит как обычные элементы, так и элементы, являющиеся группами.</p>
    <p>Если при открытии формы не делать специальных указаний, платформа стандартно будет создавать именно новый элемент, а не группу. Поэтому если мы хотим открыть форму новой группы, то помимо указания имени открываемой формы нужно ещё указать, что должна создаваться именно новая группа, а не элемент. Для этого используются <i style="text-decoration: underline;">параметры формы</i>.</p>
    <p>Некоторый стандартный набор параметров существует у сасого объекта встроенного языка Форма. В режиме "1С:Предприятие" к этим параметрам, которые существуют у любой формы, добавляются ещё неоторое количество параметров, поставляемых <i style="text-decoration: underline;">расширением формы</i>.</p>
    <p>Параметры формы описаны в синтакс-помощнике: "Интерфейс(управляемый) - Форма клиентского приложения - ФормаКлиентскогоПриложения - Парметры формы". Повторимся, это именно параметры самой формы.</p>
    <p>Все возможные расширения также перечислены в синтакс-помощнике. У каждого из них свой состав параметров, которые они добавляют к параметрам формы:</p>
    <img src="../img/1С-1/2024-01-20_20-05-42.png" class="screen-2" alt="">
    <p>Какое именно расширение будет добавлено к конкретной форме, зависит от типа <i style="text-decoration: underline;">основного реквизита формы</i>. Например, если форма отображает данные элемента справочника, то основной реквизит такой формы будет иметь тип СправочникОбъект.&lt;Имя>, а к форме будет добавлено <i style="text-decoration: underline;">расширение справочника</i>.</p>
    <p>У расширения справочника есть параметр "ЭтоГруппа":</p>
    <img src="../img/1С-1/2024-01-20_20-28-10.png" class="screen-2" alt="">
    <p>Если в этот параметр передать значение Истина, то будет создана именно новая группа, а не новый элемент.</p>
    <p>Параметры формы можно передать вторым параметром метода ОткрытьФорму(). Так как может быть указано сразу несколько параметров, то они передаются в виде структуры. Каждый элемент этой структуры содержит имя параметра и его значение.</p>
    <div class="code-style">
        <pre>
            --открытие основной формы новой группы

            ПараметрыФормы = Новый Структура("ЭтоГруппа", Истина);
            ОткрытьФорму("Справочник.Товары.ФормаГруппы", ПараметрыФормы);
        </pre>
    </div>

    <p class="title-size16"><b id="chapter3.3.6">Произвольная форма</b></p>
    <p>Открыть форму, не назначенную основной для справочника Товары, можно следующим образом:</p>
    <div class="code-style">
        <pre>
            --открытие произвольной формы у справочника Товары

            ОткрытьФорму("Справочник.Товары.Форма.ПроизвольнаяФормаТовара");
        </pre>
    </div>
    <p>здесь первым параметром метода также передаётся полное имя той формы, которую нужно открыть. Но поскольку открываемая форма не назначена основной, то после полного имени объекта конфигурации(Справочник.Товары) нужно указать слово "Форма", а затем - имя нужной формы(ПроизвольнаяФормаТовара), как она названа в конфигураторе.</p>

    <p class="title-size16"><b id="chapter3.3.7">Форма существующего объекта</b></p>
    <p>Чтобы открыть форму существующего элемента, нужно указать, какой именно элемент нас интересует. Для этого также используются параметры формы.</p>
    <p>У расширения справочника есть параметр "Ключ". Если в этот параметр передать ссылку на существующий элемент справочника, то будет открыта форма именно этого элемента, а не нового.</p>
    <p>Например, если из формы списка организаций нужно открыть форму той организации, которая выделена в этом списке, сделать это можно следующим способом:</p>
    <div class="code-style">
        <pre>
            --открытие основной формы существующего объекта

            <span class="vue-g">//получаем ссылку на текущий элемент из списка</span>
            СсылкаНаЭлементСправочника = Элементы.Список.ТекущаяСтрока;

            ПараметрыФормы = Новый Структура("Ключ", СсылкаНаЭлементСправочника);
            ОткрытьФорму("Справочник.Организации.ФормаОбъекта", ПараметрыФормы);
        </pre>
    </div>
    <p>В заключение следует заметить, что в том случае, когда кроме ссылки на объект никакие параметры в открываемую форму передавать не нужно и нужна именно основная форма существующего объекта, можно использовать более простой способ - с помощию функции глобального контекста ПоказатьЗначение():</p>
    <div class="code-style">
        <pre>
            --открытие основной формы существующего объекта

            ПоказатьЗначение(, Элементы.Список.ТекущаяСтрока);
        </pre>
    </div>
    <p>Такой способ обладает меньшей универсальностью, но в некоторых случаях он сберегает много времени и сил.</p>
    <p>Однако нужно внимательно относится к использованию этого метода. В некоторых случаях он может вызывать дополнительные обращения к серверу, например, когда нужно открыть форму элемента иерархического справочника. Платформа будет выполнять дополнительное обращение к серверу, для того чтобы определить, является элемент группой или нет, так для элемента и для группы нужно открывать разные формы.</p>-

    <p class="title-size16"><b id="chapter3.3.8">Открыть список, чтобы курсор был на нужном элементе</b></p>
    <p>Одна из типичных задач при работе с формами списков - это открытие формы с одновременным позоционированием на конкретном элементе списка.</p>
    <p>Из формы объекта это можно сделать с помощью стандартной команды "Показать в списке" из подменю "Ещё". Но если это необходимо, можно спозиционироваться на конкретном элементе списка программно.</p>
    <p>Для этого можно использовать параметр "ТекущаяСтрока", который поставляется расширением динамического списка:</p>
    <img src="../img/1С-1/2024-02-01_09-39-31.png" class="screen-2" alt="">
    <p>Можно создать команду в форме элемента и она будет выполнять код:</p>
    <div class="code-style">
        <pre>
            ПараметрыФормы = Новый Структура("ТекущаяСтрока", Объект.Ссылка);
            ОткрытьФорму("Справочник.Товары.ФормаСписка", ПараметрыФормы);
        </pre>
    </div>

    <p class="title-size16"><b id="chapter3.3.9">Список подчинённого справочника с отбором по владельцу</b></p>
    <p>Другая типичная задача - открытие списка подчинённого справочника.</p>
    <p>Стандартно команды для открытия подчинённых списков или других связанных данных можно выполнить из панели навигации окна, в котором открыта основная форма владельца. Но если необходимо (например, нужно открыть подчинённый список в отдельном окне), то можно сделать эту задачу программно.</p>
    <p>Для этого можно использовать параметр "Отбор", который также поставляется расширением динамического списка.</p>
    <p>В этот параметр нужно передать условие на отбор элементов подчинённого справочника по некоторому владельцу.</p>
    <div class="code-style">
        <pre>
            УсловияОтбора = Новый Структура("Владелец", Объект.Ссылка);
            ПараметрыФормы = Новый Структура("Отбор", УсловияОтбора);
            ОткрытьФорму("Справочник.РасчетныеСчета.ФормаСписка", ПараметрыФормы);
        </pre>
    </div>

    <p class="title-size16"><b id="chapter3.3.10">Передача параметров в произвольный запрос динамического списка</b></p>
    <p>Ещё одна задача, которая может возникать при появлении формы, заключается в том, что динамический список, содержащийся в форме, может содержать произвольный запрос с параметрами. И при открытии формы нужно передать в этот список конкретные значения этих параметров.</p>
    <p>Эта задача тоже решается с помощью параметров формы. Только это будут уже не стандартные параметры формы, предоставляемые платформой, а параметры формы, созданные разработчиком в конфигураторе.</p>
    <p>В эти параметры нужно передать требуемые значения, а в обработчике события формы "ПриСозданииНаСервере" установить эти значения параметрам запроса в динамическом списке.</p>
    <p>Рассмотрим эту задачу на примере регистра сведений "ЦеныПоставщиков"(регистр брал из конфы Камкова- ОсновныеОбъекты и пример там же). По умолчанию открывается основная форма списка этого регистра и она выводит данные основной таблицы этого регистра. Мы создадим свою форму списка и зададим произвольный запрос для  динамического списка:</p>
    <img src="../img/1С-1/2024-02-01_12-40-25.png" class="screen" alt="">
    <p>У этого запроса есть 3 параметра: Товар, НачалоПериода и КонецПериода. Для нормальной работы формы значения этих параметров должны быть заданы при открытии формы, иначе в результате открытия формы будет получена ошибка.</p>
    <p>Чтобы передать наши собственные параметры в форму, желательно создать их и в редакторе формы во вкладке "Параметры":</p>
    <img src="../img/1С-1/2024-02-01_13-47-43.png" class="screen" alt="">
    <p>Вообще говоря, делать это не обязательно. Любые параметры, переданные в метод ОткрытьФорму(), будут доступны в обработчике события формы "ПриСозданииНаСервере". Но всё же лучше создать их у формы в явном виде. Тогда, во-первых, в модуле формы не придётся проверять, существуют такие параметры или нет. А во-вторых, явное создание параметров формы облегчает поддержку прикладного решения теми разработчиками, которые не участвовали в его создании.</p>
    <p>Затем в форме элемента справочника "Номенклатура" мы создадим кнопку "ЦенаТовараЗаЯнварь", которая будет показывать товар с ценой за январь. Набор указаний(код) для кнопки будет такой:</p>
    <div class="code-style">
        <pre>
            --модуль формы элемента справочника "Номенклатура"

            ПараметрыФормы = Новый Структура(
                        "НачалоПериода, КонецПериода, Товар",
                        '20230101000000',
                        '20230131235959',
                        Объект.Ссылка );
            ОткрытьФорму("РегистрСведений.ЦеныПоставщиков.Форма.ФормаСписка2", ПараметрыФормы);
        </pre>
    </div>
    <p>Этой командой мы открываем форму списка регистра сведений и передаём ей значения трёх параметров.</p>
    <p>В самой форме регистра сведений, в обработчике события формы "ПриСозданииНаСервере", установим переданные значения в качестве параметров произвольного запроса динамичесткого списка следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка "ФормаСписка2" регистра сведений "ЦеныПоставщиков"

            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
                Список.Параметры.УстановитьЗначениеПараметра("НачалоПериода", Параметры.НачалоПериода);
                Список.Параметры.УстановитьЗначениеПараметра("КонецПериода", Параметры.КонецПериода);
                Список.Параметры.УстановитьЗначениеПараметра("Товар", Параметры.Товар);	
            КонецПроцедуры
        </pre>
    </div>

    <p class="title-size16"><b id="chapter3.3.11">Метод "ПолучитьФорму()"</b></p>
    <p>Кроме метода ОткрытьФорму() существует и другой метод глобального контекста, который может быть использован для открытия форм - ПолучитьФорму().</p>
    <p>По составу параметров этот метод очень похож на ОткрытьФорму(). Разница заключается в том, что ПолучитьФорму() лишь возвращает форму, не открывая её. В дальнейшем эта форма может быть открыта с помощью своего метода Открыть().</p>
    <p>Такой способ открытия формы можно использовать в тех случаях, когда должны выполняться различные сложные действия в зависимости от того, из какого фрагмента кода открывается форма. В этом случае после получения формы может быть, например, вызвана её экспортируемая процедура, выполняющая настройку формы в зависимости от контекста её вызова:</p>
    <div class="code-style">
        <pre>
            Перем СсылкаНаТаблицуСтилей;

            ФормаРедактора = ПолучитьФорму("Обработка.УниверсальныйРедактор.ФормаРедактора");
            ФормаРедактора.РедактироватьHTMLТекст("Пример HTML-текста", СсылкаНаТаблицуСтилей);
            ФормаРедактора.Открыть();
        </pre>
    </div>
    <p>В данном примере используется форма обработки "УниверсальныйРедактор". Подразумевается, что обработка может редактировать, как обычный текст, так и HTML-текст. Также подразумевается, что в зависимости от того, какой текст передаётся для редактирования, в самой обработке он определённым образом оформляется и подготоавливается для редактирования.</p>
    <p>так как это подготовка текста к редактированию не зависит от контекста, в котором вызван редактор, а определяется лишь видом ректируемого текста, в модуле формы этой обработки существуют две экспортируемые процедуры, позволяющие получить и подготовить к редактированию обычный текст (РедактироватьОбычныйТекст()) и HTML-текст(РедактироватьHTMLТекст())).</p>
    <p>В приведённом примере как раз получается форма этой обработки, и с помощью экспортируемой процедуры РедактироватьHTMLТекст() ей передаётся текст, который нужно подготовить к редактированию. После этого форма обработки открывается.</p>
    <p>Однако надо помнить, что использовать метод ПолучитьФорму() надо только в том случае, если это действительно необходимо. В остальных случаях советуется использовать метод ОткрытьФорму(), передавая необходимые данные при открытии формы в качестве параметров. Такой совет продиктован соображениями повышения устойчивости выполнения кода, а также сохранения единой стилистики кода прикладных решений.</p>
    <p>Очень замудрённо описано, короче , как я понял мы используем метод ПолучитьФорму() только потому, что от её экспортируемых методов этой формы зависит вывод содержимого в этой форме, поэтому и используем этот метод. Если бы вывод в форму содержимого был однозначным, то можно было не парится и использовать сразу ОткрытьФорму().</p>

    <p class="title-size16"><b id="chapter3.3.12">Открытие формы в блокирующем режиме без использования модальности</b></p>
    <p>Во многих случаях форма открывается для того, чтобы пользователь обязательно выполнил какие-то действия или ввёл какие-то данные, без которых дальнейшая работа программы будет невозможна.</p>
    <p>Раньше в таких случаях использовалось открытие формы в модальном режиме методом ОткрытьФормуМодально(). При этом полностью блокировался весь остальной иентерфейс программы, а исполнение программного кода останавливалось до тех пор, пока пользователь не закроет модальное окно.</p>
    <p>Однако с развитием облачных технологий, с появлением веб-клиента и с переходом "1С:Пердприятия" на мобильные платформы использование модальных окон стало вызывать большое количество неудобств и проблем.</p>
    <p>Основные неудобства заключались в том, что для нормальной работы веб-клиента на обычных компьютерах требовалась предварительная настройка браузера. А на мобильных устройствах браузеры вообще не поддерживают работу с модальными окнами.</p>
    <p>Поэтому в "1С:Предприятии" начиная с версии 8.3.3 сделан специальный режим работы интерфейса без использования модальных окон. Он определяется свойством конфигурации "РежимИспользованияМодальности", которое по умолчанию установлено в значение "Не использовать". Все новые конфигурации советуется разрабатывать именно в этом режиме. А если вы хотите, чтобы конфигурация работала на веб-клиенте, в модели сервиса (например, IcFresh) или на мобильных устройствах, то отказ от модальности - обязательное условие разработки.</p>
    <p>В этом режиме работы интерфейса для пользователя всё выглядит точно так же, как и раньше. Окно, которое раньше было бы модальным, рисуется в пределах родительского окна  и точно так же блокирует весь остальной интерфейс. Таким образом обеспечивается "модальность" для пользователя. Он не сможет выполнить никакие другие действия, пока не закроет блокирующее окно.</p>
    <p>Однако для разработчика в миг отображения блокирующего окна исполнение программного кода не останавливается. Это означает, что алгоритм, который обычно являлся одним целым, теперь придётся разделить на две части: одну, которая заканчивается открытием блокирующего окна, и вторую, которая будет выполнена тогда, когда пользователь закроет это окно.</p>
    <p>Чтобы система знала, с какого места продолжить исполнение программного кода, блокирующему окну передаётся имя процедуры, которая должна быть выполнена тогда, когда пользователь закроет это окно. Именно с этой процедурой и продолжиться выполнение программного кода.</p>
    <p>Для пояснения сказанного рассмотрим два примера.</p>
    <p>Блокирующая(подчинённая - это я так её называю, чтобы лучше понимать что за форма) форма может быть закрыта с помощью стандартных команд формы(таких как Да, Нет, ОК, Отмена) либо из встроенного языка методом Закрыть(). В первом случае мы можем проанализировать <i style="text-decoration: underline;">код возврата диалога</i>, соответствующий команде, с помощью которой блокирующая форма была закрыта.</p>
    <p>Если форма закрывается из встроенного языка методом Закрыть(), то в параметр этого метода разработчик может передать произвольное значение, которое будет возвращено в вызывающий код, т.е. в ту процедуру, которая будет вызвана при закрытии формы.</p>
    <p>Рассмотрим эти возможности на примере обработки "Заполнение данных", которая из своей основной формы "Форма" открывает две другие(подчинённые) формы для получения дополнительных данных.</p>
    <p>Сначала рассмотрим, как возвращать результаты выполнения стандартных интерактивных команд формы.</p>
    <p>Для этого кроме основной формы обработки ("Форма") создадим форму ("ПараметрыЗаполнения"). Эта форма будет открываться в блокирующем режиме из основной формы и возвращать коды стандартных команд.</p>
    <p>Затем в основной форме обработки создадим команду "ЗадатьПараметрыЗаполнения" и расположим её в группе "Дополнительно", которую создадим в командной панели формы с помощью добавления группы "Подменю".</p>
    <img src="../img/1С-1/2024-02-02_18-34-41.png" class="screen" alt="">
    <p>Чтобы открыть форму в блокирующем режиме, вместо метода ОткрытьФормуМодально() нужно использовать метод ОткрытьФорму(). И передать туда в качестве последних двух параметров объект ОписаниеОповещения, указывающий на процедуру модуля, которая будет выполнена после закрытия блокирующего(подчинённого) окна, и режим открытия окна, определяющий, будет ли заблокирован весь остальной интерфейс приложения или только окно, из которого открыта блокирующая форма.</p>
    <p><span class="vue-r">Если форма всегда будет открываться в блокирующем режиме, то в конфигураторе в её свойствах можно сразу установить её свойство "РежимОткрытияОкна" в значение "Блокировать весь интерфейс". Но если форму нужно открывать то в независимом, то в блокирующем режиме, то можно свойство "РежимОткрытияОкна" оставить в значении по умолчанию "Независимый". А при открытии формы в явном виде указывать нужный режим открытия окна последним параметром в методе ОткрытьФорму().</span></p>
    <p>Итак, в обработчике команды "ЗадатьПараметрыЗаполнения" напишем следующий код:</p>
    <div class="code-style">
        <pre>
            --модуль основной формы "Форма" обработки "ЗаполнениеДанных"

            <span class="vue-b">ОписаниеОповещения <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span>
                        <span class="vue-bl">"ЗадатьПараметрыЗаполненияЗавершение"</span><span class="vue-r">,</span> ЭтотОбъект<span class="vue-r">);</span>
            ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Обработка.ЗаполнениеДанных.Форма.ПараметрыЗаполнения"</span><span class="vue-r">,
                        ,,,,,</span>
                        ОписаниеОповещения<span class="vue-r">,</span>
                        <span class="vue-v">РежимОткрытияОкнаФормы</span><span class="vue-r">.</span>БлокироватьОкноВладельца<span class="vue-r">);</span></span>
        </pre>
    </div>
    <p>В этом обработчике сначала создаётся объект ОписаниеОповещения, в конструкторе которого первым параметром указывается имя процедуры обработки оповещения, которая будет выполнена после закрытия блокирующего окна. А во втором параметре указывается, в каком модуле расположена эта процедура.</p>
    <p>Процедура обработки оповещения может располагаться в модуле формы, в общем неглобальном клиентском модуле или в модуле команды. В данном случае эта процедура распологается в модуле нашей основной формы, на что указывает ссылка ЭтотОбъект.</p>
    <p>После этого методом ОткрытьФорму() форма "параметрыЗаполнения" открывается в режиме блокирующем весь интерфейс. Таким образом мы моделируем для пользователя старое, модальное поведение.</p>
    <p>Но в плане поддержки однотипного поведения с другими веб-приложениями лучше использовать режим открытия окна в значении "Блокировать окно владельца". Тогда окно владельца будет заблокировано, но остальной интерфейс прикладного решения для пользователя будет доступен.</p>
    <p>Такой режим открытия окна в зависимости от ситуации может иметь и свои плюсы, и свои минусы. Однако надо понимать, что открытие блокирующего окна в режиме блокирования окна владельца больше подходит к формату веб-приложений.</p>
    <p>Теперь в форме "ПараметрыЗаполнения" в командную панель формы перенесём три стандартные команды: ОК, Пропустить, Отмена:</p>
    <img src="../img/1С-1/2024-02-02_22-38-54.png" class="screen" alt="">
    <p>Вызовем подчинённую форму "ПараметрыЗаполнения" и при нажатии на одну из стандартных кнопок, которые мы вынесли в командную панель, форма закроется и в процедуру "ЗадатьПараметрыЗаполненияЗавершение" первым параметром "Результат" вернётся код возврата диалога, значения которого описаны в системном перечислении "КодВозвратаДиалога".</p>
    <img src="../img/1С-1/2024-02-03_19-03-13.png" class="screen" alt="">
    <p>Расположим процедуру обработки оповещения в модуле основной формы обработки и проверим возвращаемый результат, выведя в форму сообщение, соответствующее нажатой кнопке в форме "ПараметрыЗаполнения":</p>
    <div class="code-style">
        <pre>
            --модуль основной формы "Форма" обработки "ЗаполнениеДанных"

            <span class="vue-b"><span class="vue-r">&НаКлиенте</span>
            Процедура Заполнить<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                ОписаниеОповещения <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span>
                            <span class="vue-bl">"ЗадатьПараметрыЗаполненияЗавершение"</span><span class="vue-r">,</span> ЭтотОбъект<span class="vue-r">);</span>
                ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Обработка.ЗаполнениеДанных.Форма.ПараметрыЗаполнения"</span><span class="vue-r">,
                            ,,,,,</span>
                            ОписаниеОповещения<span class="vue-r">,</span>
                            <span class="vue-v">РежимОткрытияОкнаФормы</span><span class="vue-r">.</span>БлокироватьОкноВладельца<span class="vue-r">);
            КонецПроцедуры

            &НаКлиенте               
            Процедура</span> ЗадатьПараметрыЗаполненияЗавершение<span class="vue-r">(</span>Результат<span class="vue-r">,</span> ДопПараметры<span class="vue-r">) Экспорт</span>
                Сообщение <span class="vue-r">= Новый</span> СообщениеПользователю<span class="vue-r">;</span>

                <span class="vue-r">Если</span> Результат <span class="vue-r">=</span> <span class="vue-v">КодВозвратаДиалога</span><span class="vue-r">.</span>ОК <span class="vue-r">Тогда</span>
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"В форме нажата стандартная кнопка ОК"</span><span class="vue-r">;</span>
                <span class="vue-r">ИначеЕсли</span> Результат <span class="vue-r">=</span> <span class="vue-v">КодВозвратаДиалога</span><span class="vue-r">.</span>Отмена <span class="vue-r">Тогда</span>	
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"В форме нажата стандартная кнопка Отмена"</span><span class="vue-r">;</span>
                <span class="vue-r">ИначеЕсли</span> Результат <span class="vue-r">=</span> <span class="vue-v">КодВозвратаДиалога</span><span class="vue-r">.</span>Пропустить <span class="vue-r">Тогда</span>
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"В форме нажата стандартная кнопка Пропустить"</span><span class="vue-r">;</span>
                <span class="vue-r">Иначе</span>
                    Сообщение<span class="vue-r">.</span>Текст <span class="vue-r">=</span> <span class="vue-bl">"Обработка этой команды в форме не предусмотрена"</span><span class="vue-r">;
                КонецЕсли;</span>

                Сообщение<span class="vue-r">.</span>Сообщить<span class="vue-r">();
            КонецПроцедуры</span></span>
        </pre>
    </div>
    <p>Обратите внимание, что процедура обработки оповещения должна быть объявлена как экспортная.</p>
    <p>Теперь рассмотрим вторуювозможность - возврат произвольного значения из блокирующей формы.</p>
    <p>Для этого создадим ещё одну форму обработки - "ДобавлениеТекста". В ней создадим строковый реквизит(Текст), перенесём его в элементы формы. У нас получится поле ввода для ввода текста. Добавим команду "ЗакончитьВводТекста", по которой будем возвращать введёный пользователем текст.</p>
    <img src="../img/1С-1/2024-02-03_21-33-04.png" class="screen" alt="">
    <p>Обработчик команды "ЗакончитьВводТекста" будет очень простым:</p>
    <div class="code-style">
        <pre>
            --модуль формы "ДобавлениеТекста"

            <span class="vue-b"><span class="vue-r">&НаКлиенте
            Процедура</span> ЗакончитьВводТекста<span class="vue-r">(</span>Команда<span class="vue-r">)</span>
                Закрыть<span class="vue-r">(</span>Текст<span class="vue-r">);
            КонецПроцедуры</span></span>
        </pre>
    </div>
    <p>А в основной форме обработки добавим команду "ДобавитьТекст", которая будет открывать форму "ДобавлениеТекста" в блокирующем режиме.</p>
    <div class="code-style">
        <pre>
            --модуль формы "ДобавлениеТекста" обработки "ЗаполнениеДанных"

            <span class="vue-b">ОписаниеОповещения <span class="vue-r">= Новый</span> ОписаниеОповещения<span class="vue-r">(</span>
                        <span class="vue-bl">"ДобавитьТекстЗавершение"</span><span class="vue-r">,</span> ЭтотОбъект<span class="vue-r">);</span>
            ОткрытьФорму<span class="vue-r">(</span><span class="vue-bl">"Обработка.ЗаполнениеДанных.Форма.ДобавлениеТекста"</span><span class="vue-r">,
                        ,,,,,</span>
                        ОписаниеОповещения<span class="vue-r">,</span>
                        <span class="vue-v">РежимОткрытияОкнаФормы</span><span class="vue-r">.</span>БлокироватьОкноВладельца<span class="vue-r">);</span></span>
        </pre>
    </div>
    <p>После закрытия формы "ДобавлениеТекста" будет выполнена процедура обработки оповещения "ДобавитьТекстЗавершение". В параметре РезультатЗакрытия этой процедуры будет содержаться текст, введённый пользователем в блокирующей форме.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ДобавлениеТекстаЗавершение(РезультатЗакрытия, ДопПараметры) Экспорт
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "В поле введён текст " + РезультатЗакрытия;
                Сообщение.Сообщить();		
            КонецПроцедуры
        </pre>
    </div>
    <p>К примерам отказа от модальности мы ещё вернёмся.</p>

    <p class="title-size16"><b id="chapter3.3.13">Открытие и запуск отчёта</b></p>
    <p>Последняя задача, которую мы рассмотрим в этой главе, это открытие формы отчёта и выполнение этого отчёта без дополнительных действий со стороны пользователя.</p>
    <p>Например, есть отчёт "ЦеныТоваров". Он показывает последние цены, установленные на товары.</p>
    <p>Задача в том, чтобы по команде в форме списка товаров сразу запускать этот отчёт с отбором, установленным по тому товару, который выделен в списке.</p>
    <p>Выполнить эту задачу помогут два параметра, которые поставляются расширением отчёта: "Отбор" и "СформироватьПриОткрытии":</p>
    <img src="../img/1С-1/2024-02-04_11-32-32.png" class="screen-2" alt="">
    <p>Параметр "Отбор" позволяет установить отбор в отчёте, задав значения полей или параметров отчёта. А параметр "СформироватьПриОткрытии" позволяет сразу же выполнить отчёт, после того как его форма будет получена на сервере, т.е. самостоятельно как бы нажмётся кнопка "Сформировать" в форме отчёта.</p>
    <p>Итак, создадим форму списка справочника "Товары" и добавим в неё команду "ЦенаТовара". Текст обработчика этой команды будет выглядеть следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка справочника "Товары"

            УсловияОтбора = Новый Структура("Товар", Элементы.Список.ТекущаяСтрока);
            ПараметрыФормы = Новый Структура("Отбор, СформироватьПриОткрытии", УсловияОтбора, Истина);
            ОткрытьФорму("Отчет.ЦенаТоваров.ФормаОбъекта", ПараметрыФормы);
        </pre>
    </div>
    <p>Сначала создаём структуру УсловияОтбора, которая задаст единственное условие отбора - по тому товару, который выбран в списке.</p>
    <p>Затем сформируем структуру для параметров формы(ПараметрыФормы), описав в ней значения двух параметров: Отбор и СформироватьПриОткрытии.</p>
    <p>В заключение, как и раньше, открываем форму отчёта (ОткрытьФорму()), указав имя формы и параметры, предназначенные для открываемой формы.</p>
    <img src="../img/1С-1/2024-02-04_11-52-29.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter3.3.14">Переопределение открываемой формы</b></p>
    <p>Иногда бывает нужно открывать различные формы в зависимости от выполнения каких-либо условий. Например, для элемента справочника Товары нужно открывать разные формы для собственно товара и для услуги.</p>
    <p>Для решения этой задачи в модуле менеджера объекта следует создать обработчик события "ОбработкаПолученияФормы". В этом обработчике нужно выполнить все необходимые проверки и принять решение о том, какую форму следует открывать. И соотвествующим образом переопределить параметр обработчика "ВыбраннаяФорма":</p>
    <div class="code-style">
        <pre>
            --модуль менеджера справочника Товары

            Процедура ОбработкаПолученияФормы(ВидФормы, Параметры, ВыбраннаяФорма, ДополнительнаяИнформация, СтандартнаяОбработка)
                Если Параметры.Свойство("Ключ") Тогда
                    Если ВидФормы = "ФормаОбъекта" и Параметры.Ключ.Родитель.Наименование = "Услуги" Тогда
                        ВыбраннаяФорма = "Справочник.Товары.Форма.ПроизвольнаяФормаТовара";
                        СтандартнаяОбработка = Ложь;
                    КонецЕсли;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике (для существующих товаров) сначала проверяется, что открывается форма объекта (параметр ВидФорма = "ФормаОбъекта"). Ссылка на объект передаётся в структуре параметров открываемой формы (Параметры.Ключ).</p>
    <p>Поскольку у товара нет специального реквизита, определяющего его вид, будем считать, что все услуги собраны в отдельной папке справочника с наименованием "Услуги".</p>
    <p>Если элемент справочника находится в этой папке, то мы переопределяем параметр "ВыбраннаяФорма". Тем самым указываем форму, которая должна быть открыта. И параметр "СтандартнаяОбработка" устанавливаем в значение Ложь.</p>
    <p>В результате для услуг будет открыта произвольная форма товара, основная форма товара булет открываться только для товаров, не находящихся в папке "Услуги". Ну и, естественно, для вновь создаваемых товаров, у которых свойство "Ключ" в структуре параметров формы не определено, мы никаких проверок не делаем.</p>
    <p>Если требуется открывать не форму услуги, а какую-то связанную с ней информацию(например, счёт), то нужно также переопределить и параметр "Ключ", чтобы он содержал ссылку на этот связанный объект.</p>




    <h3 class="header-style2" id="chapter3.4">Глава 3.4 Преобразование прикладных данных в данные формы. Стр 471</h3>
    <p>Встроенный язык содержит целый ряд объектов, предназначенных для чтения и изменения объектных данных, хранящихся в базе данных. Это такие типы как СправочникОбъект.&lt;Имя>, ДокументОбъект.&lt;Имя> и т.д. Однако работа с этими типами данных возможна только в контексте сервера. Форма же и на клиенте, и на сервере для отображения таких объектных данных использует специальные универсальные типы.</p>
    <p>Поэтому при открытии форм объектов платформа выполняет самостоятельно преобразование данных из типов объектов в типы, поддерживаемы формой. При записи данных объектов из формы происходит обратное преобразование. Рассмотрим эти процессы подробнее.</p>
    <p>Когда открывается форма существующего объекта, платформа читатет его данные из базы данных и создаёт в памяти соответствующий этим данным объект встроенного языка. Например, СправочникОбъект.&lt;Имя>.</p>
    <p>После этого данные объекта преобразуются в данные основного реквизита формы. Как правило, основной реквизит формы имеет имя Объект.</p>
    <p>После того как форма полностью подготовлена, она передаётся с сервера на клиент.</p>
    <p>Обратное преобразование выполняется подобным образом. Сначала форма передаётся с клиента на сервер. После этого основной реквизит формы преобразуется в соотвествующий объект встроенного языка, позволяющий изменять данные в базе данных.</p>
    <p>Существует четыре типа универсальных данных формы, в которые преобразуются типы, доступные только на сервере:</p>
    <ul class="list">
        <li>ДанныеФормыСтруктура;</li>
        <li>ДанныеФормыКоллекция;</li>
        <li>ДанныеФормыДерево;</li>
        <li>ДанныеФормыСтруктураСКоллекцией;</li>
    </ul>
    <p>Это "простые" типы данных - в том смысле, что они по сути представляют собой определённым образом организованные структуры данных и не содержат никакого специфического поведения, зависящие от данных.</p>
    <p>В какой именно тип будут преобразованы серверные данные - зависит от самих этих данных. Преобразование выполняется в те универсальные типы, которые наиболее хорошо подходят для описания исходного типа данных.</p>
    <p>Например, данные типа СправочникОбъект.Товары будут преобразованы в тип "ДанныеФормыСтруктура".</p>
    <img src="../img/1С-1/2024-02-05_11-52-29.png" class="screen" alt="">
    <p>Элементы этой структуры будут содержать значения реквизитов справочника Товары. Реквизиты простых типов в форме будут иметь тот же тип, что и у серверного объекта. Например, КОд и Наименование будут иметь тип Строка.</p>
    <p>Никаких специфических методов "ДанныеФормыСтруктура" иметь не будет. Это каксается и стандартных методов объекта справочника (Например, Записать()), и методов, описанных разработчиком в модуле объекта (например, экспортируемая процедура ПересчитатьЦены()).</p>
    <p>Реквизиты ссылочного типа, например, СсылкаПоставщика типа СправочникаСсылка.Поставщики, будут иметь такой же тип, как и на сервере - СправочникСсылка.&lt;Имя>. Однако программный объект ссылки в форме в контексте клиента очень сильно ограничен в своих возможностях. Практически единственное, что можно сделать со ссылкой на клиенте, - это получить её значение. Ну, и ещё проверить, является ли эта ссылка пустой. Создание объектов от ссылки, получение значений через точку от ссылки на клиенте не доступны.</p>
    <p>Как уже говорилось выше, для системных процессов, таких как запись, проведение объекта из формы, подобное преобразование выполняется системой самостоятельно. Однако встроенный язык при необходимости позволяет разработчику выполнять такие преобразования. Для этого используются процедуры глобального котекста ДанныеФормыВЗначение() и ЗначениеВДанныеФормы().</p>
    <p>Подобные методы есть и у формы: РеквизитФормыВЗначение() и ЗначениеВРеквизитФормы(). Подробнее они будут рассмотрены в главе 3.7 и в главе 4.3.</p>





    <h3 class="header-style2" id="chapter3.5">Глава 3.5 Исполнение модуля формы на клиенте и на сервере. Стр 476</h3>
    <p>Как уже говорилось ранее, форма представляет собой особенный, специфический объект встроенного языка. ФОрма состит из двух взаимодействующих между собой частей, каждая из которых выполняется в разных контекстах. Одна часть на сервере, друга на клиенте.</p>
    <p>По этой причине все процедуры и функции, создаваемые в модуле формы, должны иметь явное указание на то, в каком контексте они будут исполняться.</p>
    <p>Для этого используются "директивы компиляции"(указания, где будет собираться и исполняться код), набор которых определён во встроенном языке. Одна из директив компиляции обязательно должна быть указана перед объявлением каждой процедуры или функции, находящейся в модуле формы.</p>
    <p>В модуле формы могут быть использованы четыре различные директивы компиляции:</p>
    <ul class="list">
        <li>&НаКлиенте</li>
        <li>&НаСервере</li>
        <li>&НаСервереБезКонтекста</li>
        <li>&НаКлиентеНаСервереБезКонтекста</li>
    </ul>
    <p>Директива &НаКлиенте указывает, что процедура или функция будет исполняться в контексте клиентского приложения. В этой процедуре будет доступен весь контекст формы: реквизиты, элементы и параметры формы. Эта директива используется для всех обработчиков клиентских событий формы, а также для процедур, описывающих локальные команды формы. В дальнейшем процедуры, которым предшествует эта директива, мы будем называть иногда "клиентскими процедурами формы".</p>
    <p>Директива &НаСервере подобна предыдущей - с той разницей, что исполнение кода происходит в контексте сервера. Эта директива используется для всех обработчиков серверных событий формы. Также эту директиву часто используют разработчики для собственных процедур, чтобы передать исполнение набора указаний на сервер. В дальнейшем процедуры, которым предшествует эта директива, мы будем называть иногда "серверными процедурами формы". А вызов такой процедуры из клиентской процедуры мы будем называть "контекстным серверным вызовом".</p>
    <p>Директива &НаСервереБезКонтекста также определяет, что код будет исполняться в контексте сервера, но при этом контекст формы(реквизиты, элементы, параметры) будет недоступен. Эту директиву тоже часто используют разработчики для собственных процедур, чтобы передать исполнение кода на сервер. Как и в предыдущем случае, такие процедуры мы будем называть иногда "серверными процедурами формы". А вот вызов такой процедуры из клиентской процедуры мы будем называть "внеконтекстным серверным вызовом".</p>
    <p>И последняя директива - &НаКлиентеНаСервереБезКонтекста, определяет, что процедура или функцияможет исполняться как в контексте клиента, так и в контексте сервера. Эта директива используется редко. Обычно она требуется в тех случаях, когда нужно выполнять одинаковые действия как при создании формы, так и в процессе её жизнедеятельности на клиенте. Тогда вместо двух одинаковых процедур, одна из которых исполняется на сервере, а другая на клиенте, создаётся одна процедура с этой директивой.</p>
    <p>Если по ошибке никая директива компиляции не указана, то платформа считает, что используется директива &НаСервере.</p>
    <p>Процесс исполнения кода на клиенте и сервере в формах соотвествует общему подходу, принятому в "1С:Предприятии". Из клиентски процедур можно вызвать серверные, после их выполнения исполнение кода возвращается на клиент. Принудительно передать исполнение кода в обратную сторону, с сервера на клиент, нельзя, т.е. из серверных процедур нельзя вызвавть клиентские.</p>

    <p class="title-size16"><b id="chapter3.5.1">Переменные модуля формы</b></p>
    <p>В модуле формы директивы компиляции должны быть указаны не только перед определением процедур и функций, но и перед определением переменных.</p>
    <p>Если перед описанием переменной используется директива компиляции &НаКлиенте, то такая переменная будет существовать с мига создания формы до мига её закрытия. Причём только в клиентской части формы. В серверных процедурах формы она доступна не будет.</p>
    <p>Если перед описанием переменной используется директива компиляции &НаСервере, то такая переменная будет существовать только между вызовом и исполнением какой-либо серверной процедуры или функции. После того как исполнение кода вернётся на клиент, модуль, исполнявшийся на сервере, будет уничтожен вместе с этой переменной.</p>
    <p>Получается однократная компиляция клиентской части модуля и многократная компиляция серверной части модуля.</p>
    <p>Почему важно понимать эту особенность? Потому что порой переменные модуля объявляются в явном виде, без указания директивы компиляции. В этом случае, как уже говорилось выше, платформа будет использовать директиву &НаСервере.</p>
    <p>Можно пытатьсяв одной серверной процедуре устанавливать значение этой переменной и читать её в другой. Но так получится только в том случае, если все эти процедуры выполняются в одном серверном вызове. Если серверные вызовы разные, переменная будет инициализироваться каждый раз заново.</p>
    <p>В то же время на клиенте можно использовать переменные модуля для хранения значений на всё время жизни формы, но для этого при объявлении таких переменных обязательно должна быть указана директива компиляции &НаКлиенте.</p>
    <p>Что касается процесса записи объекта из формы, тут есть одна удобная возможность, позволяющая использовать некоторый произвольный набор значений(структуру), доступный одновременно как в клиентских, так и в серверных процедурах. Речь идёт о <i style="text-decoration: underline;">параметрах записи</i> - это структура, указываемая в методе Записать() расширения формы. Подробнее об этом в разделе "Параметры записи" дальше по книге.</p>

    <p class="title-size16"><b id="chapter3.5.2">Экспортируемые процедуры формы</b></p>
    <p>Разработчик может создать в модуле формы экспортируемые процедуры и функции. Они будут доступны как методы программного объекта Форма во встроенном языке.</p>
    <p>Для таких процедур/функций также нужно указывать директивы компиляциию При этом практический смысл есть, наверное, в использовании лишь единственной директивы - &НаКлиенте.</p>
    <p>Поясним почему. Как мы уже знаем, объект формы создаётся методами ОткрытьФорму() или ПолучитьФорму(). Оба они доступны только в контексте клиента. Поэтому созданная форма также будет существовать в контексте клиента. Соответственно, в этом же контексте должны быть определены её экспортируемые процедуры/функции.</p>
    <p>В принципе программный объект формы может существовать как на клиенте, так и на сервере. Однако для чего, в каких случаях может потребоваться обращаться к нему "извне" на севере - сложно представить.</p>
    <p>Поэтому основное замечание этого раздела заклбчается в том,что при написании собственных экспортируемых процедур/функций формы нужно не забывать указывать для них директиву компиляции &НаКлиенте. Если никакая директивауказана не будет, платформа будет считать, что используется директива &НаСервере, и, значит, вызвать процедуру/функцию на клиенте вы не сможете.</p>
    <p>Однако без особой необходимости лучше не располагать экспортируемые процедуры и функции в модулях форм. Для этого лучше использовать модуле объектов,модули менеджеров объектов и общие модули. Исключения составляют экспортируемые процедуры обработки оповещений.</p>






    <h3 class="header-style2" id="chapter3.6">Глава 3.6 Контекстные и внеконтекстные серверные вызовы. Стр 482</h3>
    <p>Теперь рассмотрим подробнее, что происходит при контекстных и при внеконтекстных серверных вызовах в форме. Для упрощения рассказа мы опустим тонкости оптимизации и кеширования, которые выполняет при этом платформа, так как на суть описываемых действий это не влияет.</p>
    <p>Когда из клиентской процедуры/функции вызывается серверная процедура/функция, происходит передача всей формы на сервер.</p>
    <p>Сначала контекст формы (реквизиты формы, элементы формы, параметры формы) специальным образом упаковываются и подготавливаются к передаче на сервер.</p>
    <p>На сервере создаётся серверная часть формы, полученный контекст разворачивается в данные, элементы и реквизиты формы, после чего инициализируется модуль формы.</p>
    <p>После того как программный объект формы будет полностью подготовлен к работе, выполняется код той процедуры/функции, которая была вызвана на клиенте.</p>
    <p>Затем как исполнение кода на сервере будет закончено, происходит обратное действие. Контекст формы упаковывается и передаётся обратно на клиент, в клиентскую часть формы.</p>
    <p>На клиенте происходит синхронизация контекста формы: имеющийся контекст заменяется контекстом, полученным с севера. А на сервере происходит уничтожение серверной части формы(имеется ввиду уничтожение реквизитов, элементов, параметров формы).</p>
    <p>Таким образом, контекстный вызов формы - довольно затратный и не простой процесс. Использовать всё время только контекстные вызовы сервера было бы расточительно и непроизводительно. Поэтому контекстные вызовы сервера лучше использовать тогда, когда обойтись без них очень трудно или невозможно.</p>
    <p>В то же время есть масса случаев, когда нужно выполнять некоторые действия на сервере, но контекст формы при этом не нужен. Для этого используются внеконтекстные серверные вызовы, когда из клиентской процедуры вызывается серверная процедура с директивой &НаСервереБезКонтекста.</p>
    <p>В этом случае из модуля клиентской части формы выполнение кода сразу же передаётся на сервер, во внеконтекстную процедуру. После её выполнения осуществляется возврат на клиент.</p>
    <p>Внеконтекстный вызов проще, производительнее. Именно его лучше использовать в большинстве случаев.</p>
    <p>Однако не стоит увлекаться фанатичной погоней за производительностью.</p>
    <p>Во-первых всегда следует искать золотую середину между "читаемостью" программы и её производительностью. Можно так "заулучшать" прикладное решение, что разобраться в нём через некоторое время не сможет уже никто.</p>
    <p>Во-вторых, контекстные вызовы сервера мы рассматривали упрощённо. На самом деле платформа очень серьёзно оптимизирует объём данных, передаваемых между клиентом и сервером. Например, при открытии формы на клиент передаётся только часть данных, которые видит в данный миг пользователь. С клиента на сервер передаются не все данные, а только те, которые были изменены на клиенте. При изменении данных на сервере на клиент также передаются не все данные, а только те, которые были изменены.</p>
    <p>Поэтому если на сервере требуется обращаться к большому массиву данных, которые хранятся в данных формы, то выгоднее выполнить именно контекстный серверный вызов. Потому, что в этом случае платформа эффективно выполнит передачу данных формы на сторону сервера, там сконструирует соответсвующий контекст и обратно перешлёт данные на клиент.</p>






    <h3 class="header-style2" id="chapter3.7">Глава 3.7 Работа с данными объекта в форме. Стр 486</h3>
    <p>В этом разделе мы рассмотрим несколько простых примеров работы с данными объекта в форме. Они помогут понять общие подходы к основным действиям.</p>

    <p class="title-size16"><b id="chapter3.7.1">Пример 1</b></p>
    <p>Первым примером рассмотрим случай, когда мы находимся в форме документа и нам нужно получить какой-либо его реквизит. Например, номер документа или занчение реквизита Поставщик.</p>
    <p>Данные объекта, которые отображаются в форме (в нашем случае данные документа), находятся всегда в основном реквизите формы. В подавляющем большинстве случаев этотреквизит имеет имя Объект. По крайней мере именнотакое имя даёт ему платформа, когда с помощью конструктора создаёт форму объекта. В наше случае это именно так.</p>
    <p>Основной реквизит формы содержит набор подчинённых реквизитов, соответствующих реквизитам прикладного объекта. Поэтому для того, чтобы обратится, например, к номеру документа, нужно указать имя реквизита формы и через точку - имя подчинённого реквизита.</p>
    <p>В нашем случае, для того чтобы сообщить номер документа и поставщика, нужно будет выполнить код:</p>
    <div class="code-style">
        <pre>
            Сообщение = Новый СообщениеПользователю;
            Сообщение.Текст = Объект.Номер + Символы.ПС + Строка(Объект.Поставщик);
            Сообщение.Сообщить();
        </pre>
    </div>
    <p>Номер документа имеет тип Строка, поэтому мы выводим его просто как Объект.Номер, а значение реквизита Поставщик имеет тип ссылки. Поэтому для того, чтобы включить его в текстовую строку, мы получаем строковое представление этого ссылочного значения, преобразуя его к типу Строка.</p>

    <p class="title-size16"><b id="chapter3.7.2">Пример 2</b></p>
    <p>Второй пример, который мы рассмотрим будет заключаться в том, чтобы получить реквизит от ссылочного значения, хранящегося в реквизите формы. Как раз у документа Накладная есть реквизит ссылочного типа  - Поставщик. Мы будем получать ИНН этого поставщика.</p>
    <p>Мы, как и в предыдущем примере, по-прежнему находимся в модуле формы на клиенте. В контексте клиента, как мы уже упоминали выше, ссылочные типы очень сильно ограничены в своих возможностях. В частности, нельзя получить значение реквизита от ссылки через точку. Это можно сделать только в контексте сервера.</p>
    <p>Поэтому для решения нашей задачи мы создадим серверную внеконтекстную функцию, которую вызовем с клиента и передадим в неё ссылку на поставщика. В теле функции, на сервере, мы получим ИНН поставщика и вернём его на клиент.</p>
    <p>Локальная команда формы, вызывающая серверную функцию, будет выглядеть след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура РеквизитОтСсылки(Команда)
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = ПолучитьИННПоставщика(Объект.Поставщик);
                Сообщение.Сообщить();
            КонецПроцедуры

            &НаСервере
            Функция ПолучитьИННПоставщика(Поставщик)
                Возврат Поставщик.ИНН;
            КонецФункции
        </pre>
    </div>
    <p>Т.е. на сервере мы сразу же получаем значение реквизита через точку от полученной ссылки на поставщика.</p>


    <p class="title-size16"><b id="chapter3.7.3">Пример 3</b></p>
    <p>Третий пример, котрый мы рассмотрим, будет заключаться в вызове экспортируемой процедуры объекта. Наш документ как раз имеет одну такую процедуру, которая позволяет пересчитать все цены, содержащиеся в табличной части документа, и применить к ним скидку в 10%.</p>
    <p>Поскольку для вызова такой процедуры необходимо прежде всего иметь сам объект, мы поступим следующим образом.</p>
    <p>Выполним контекстный серверный вызов. На сервере преобразуем основной реквизит формы в прикладной объект, выполним экспортную функцию этого объекта и преобразуем объект обратно в основной реквизит формы.</p>
    <p>В результате выполненные на сервере изменения данных формы будут самостоятельно переданы системой на клиент, когда на него вернётся выполнение программного кода.</p>
    <p>Локальная команда формы, вызывающая серверную процедуру, будет выглядеть след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура МетодОбъекта(Команда)
                ПересчитатьЦеныНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ПересчитатьЦеныНаСервере()
                ОбъектДокумента = РеквизитФормыВЗначение("Объект", Тип("ДокументОбъект.Накладная"));
                ОбъектДокумента.НачислитьСкидку(10);
                ЗначениеВРеквизитФормы(ОбъектДокумента, "Объект");
            КонецПроцедуры
        </pre>
    </div>
    <p>В серверной процедуре мы преобразуем данные реквизита формы Объект в прикладной объект типа ДокументОбъект.Накладная.</p>
    <p>После этого мы вызываем экспортную процедуру этого прикладного объекта - НачислитьСкидку(). В результате её работы все цены, содержащиеся в табличной части объекта, будут уменьшены на 10%.</p>
    <p>Затем мы преобразуем данные прикладного объекта обратно в реквизит формы Объект. Т.е. новые цены в табличной части теперь будут и в форме, которая пока находится на сервере.</p>
    <p>Когда выполнение всех серверных процедур, которые мы вызвали, будет закончено, контекст формы на сервере будет собран, отправлен на клиент и там самостоятельно обновлён. В результате мы увидим в открытом документе на клиенте уже новые цены в табличной части документа.</p>








    <h3 class="header-style2" id="chapter3.8">Глава 3.8 Последовательность событий при открытии формы существующего объекта. Стр 491</h3>
    <p>Теперь, когда мы знакомы с тем, как открывать нужную нам форму, и понимаем, как в принципе форма функционирует, рассмотрим подробно последовательность событий, которые позникают при открытии формы существующего объекта. Этот пример мы рассмотрим как наиболее сложный и типичный(распространённый).</p>
    <p>Вот картинка как происходят события:</p>
    <img src="../img/1С-1/2024-02-06_10-17-17.png" class="screen" alt="">
    <p>Или вот картинка из книги:</p>
    <img src="../img/1С-1/2024-02-06_10-24-04.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter3.8.1">Чтение данных прикладного объекта</b></p>
    <p>Когда платформа получает команду от пользователя или программно на открытие формы объекта, прежде всего на сервере создаётся программный объект формы.</p>
    <p>После этого создаётся программный объект, соответствующий типу основного реквизита формы, и из базы данных читаются данные этого объекта. На картинке объект помечен тёмным цветом. Это означает, что он содержит данные, прочитанные из базы данных.</p>
    <p>Затем платформа выполняет преобразование данных объекта в данные формы.</p>

    <p class="title-size16"><b id="chapter3.8.2">Событие "При чтении на сервере"</b></p>
    <p>После этого вызывается первое событие формы - "ПриЧтенииНаСервере".</p>
    <p>В чём особенность этого события? Зачем именно в этот миг нам предлагается вмешаться в этот процесс?</p>
    <p>Посмотрим. Событие вызывается у формы. Причём поставляется это событие не самой формой, а её расширением, определяемым типом основного реквизита формы. Т.е. это какой-то особенный случай, связанный с тем, что открывается не просто формы, а именно форма этого объекта.</p>
    <p>Данные формы уже заполнены данными объекта, в то же время сам объект всё ещё существует в памяти сервера и доступен в обработчике этого события через параметр "ТекущийОбъект".</p>
    <p>Очевидно, что здась мы можем подготовить дополнительные данные формы, которые зависят от данных объекта.</p>
    <p>Существование самого объекта полезно тем, что мы можем воспользоваться всей его функциональностью, например, вызвать какую-либо его экспортируемую процедуру или получить значение через точку от его реквизита ссылочного типа. Это избавляет нас от необходимости преобразовывать данные формы в объект.</p>
    <p>Например, получили мы с помощью объекта через точку из ссылочного реквизита ещё како-то значение. Это значение мы можем добавить в какой-нибудь дополнительный реквизит формы. Это я уже от себя пишу, потому как книга не приводит конкретных примеров.</p>
    <p>Допустим, у нас в объекте данных есть ссылочный реквизит "Сотрудник", который проводит данный документ. Я хочу получить дату рождения этого сотрудника и записать в реквизит формы эту дату, чтобы пользователь видел.</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЧтенииНаСервере(ТекущийОбъект)
                ДатаСотрудника = ТекущийОбъект.Сотрудник.ДатаРождения;
            КонецПроцедуры
        </pre>
    </div>
    <p>"ДатаСотрудника" это реквизит формы. ПРимер может не жизненный, но это не важно, просто смотрим как можно такое делать.</p>
    <p>После обработки события "ПриЧтенииНаСервере" данные формы, вообще говоря, могут уже отличаться от тех данных, которые содержатся в прикладном объекте. Поэтому на картинке форма отмечена тёмным цветом. Это означает, что она содержит изменённые данные. Вот этот миг я не понял.</p>
    <p>Сам прикладной объект удаляется из памяти сервера, так как для дальнейших действий он уже не нужен. И вызывается второе и последнее событие формы на сервере - "ПриСозданииНаСервере".</p>

    <p class="title-size16"><b id="chapter3.8.3">Событие "При создании на сервере"</b></p>
    <p>Что изменилось по сравнению с предыдущим событием? Нет прикладного объекта. Это последние событие перед тем , как форма отправится на клиент. Это событие формы, т.е. оно не зависит от того, какие данные форма отображает, и существует у всех форм.</p>
    <p>Значит, в этом событии нужно полностью подготовить саму форму к открытию. Именно форму, её внешнее представление. Данные мы уже полностью подготовили в предыдущем обработчике события.</p>
    <p>Ранее мы уже использовали это событие, когда изучали различные способы открытия форм. Например, для того чтобы установить значения параметров произвольного запроса в динамическом списке.</p>
    <p>Также в этом событии можно отказаться от открытия формы, если по каким-либо причинам она не должна быть открыта. Для этого параметр "Отказ" нужно установить в значение Истина.</p>
    <p>Также здесь можно отказаться от стандартной обработки события, выполняемой платформой (СтандартнаяОбработка = Ложь). Стандартная обработка, выполняемая платформой, зависит от типа основного реквизита открываемой формы.</p>
    <p>Например, для формы списка это будет передача в динамический список параметров, указанных при открытии формы. Если в примере "Открыть список, чтобы курсор был на нужном элементе" в форме списка справочника Товары отменить стандартную обработку, то не будет выполняться позиционирование курсора на нужную строку в списке.</p>
    <p>Точно также, если в примере "Список подчинённого справочника по владельцу" в форме списка справочника "РасчетныеСчета" отменить стандартную обработку, то не будет выполняться отбор списка по владельцу.</p>
    <p>Для форм отчётов стандартная обработка заключается в загруске варианта и пользовательских настроек отчёта. Кроме того, стандартная обработка передаёт в отчёт параметры отбора и выполняет самостоятельный запуск отчёта. Например, если в примере "Открытие и запуск отчета" в форме отчёта "ЦеныТоваров" отменить стандартную обработку, то в отчёт не будет передаваться отбор и не будет выполняться самостоятельное формирование отчёта.</p>

    <p class="title-size16"><b id="chapter3.8.4">Событие "При открытии"</b></p>
    <p>После обработки события "ПриСозданииНаСервере" форма передаётся на клиент, и программный объект формы <span class="vur-r">(ВАЖНО!!! Как я понимаю полностью обект форма)</span> удаляется из памяти сервера. на клиенте вызывается последнее событие формы - "ПриОткрытии".</p>
    <p>Для чего может понадобится это событие?</p>
    <p>Во-первых, это последнее событие, в котором можно отказаться от открытия формы(Отказ = Истина).</p>
    <p>Если отказа не происходит, это значит, что форма точно будет открыта. И, значит, можно выполнить какие-то действия, которые должны выполняться только тогда, когда форма гарантированно открывается. Например, открыть связанную форму, которая сама по себе не существует, а существует только в том случае, если открыта основная форма.</p>
    <p>Во-вторых, в этом событии можно выполнить те действия, которые невозможно выполнить на сервере. Например, выдать предупреждение пользователю или настроить СОМ-объект HTML-документа, содержащийся в поле HTML-документа.</p>
    <p>После обработки события "ПриОткрытии" форма открывается на клиенте и становится видима пользователю.</p>






    <h3 class="header-style2" id="chapter3.9">Глава 3.9. Последовательность событий при записи объекта из формы. Стр 496</h3>
    <p>Последовательность событий, возникающих при записи объекта из формы, значительно больше и сложнее. Мы рассмотрим её на примере команды "Записатьи закрыть", когда данные объекта записываются и после этого форма закрывается.</p>
    <p></p>

    <p class="title-size16"><b id="chapter3.9.1">Событие "Перед записью"</b></p>
    <p>Когда в форме вызывается запись объекта, прежде всего в форме на клиенте вызывается событие "Перед записью".</p>
    <p>Синтаксис вызова этого обработчика выглядит следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПередЗаписью(Отказ, ПараметрыЗаписи)
        </pre>
    </div>
    <p>В этом обработчике можно проверить, все ли вспомогательные данные, необходимые для записи объекта, подготовлены. И если это не так - отказаться от записи, установив параметр Отказ в значение Истина. Дело в том, что на клиенте могут существовать объекты, недоступные на сервере, например СОМ-объект HTML-документа. Поэтому проверки, связанные с подобными объектами, нужно производить именно в клиентской процедуре.</p>
    <p>Также в этом обработчике доступны для анализа <i style="text-decoration: underline;">параметры записи</i>, созданные платформой или переданные разработчиком. Подробнее о параметрах записи написано в разделе "Параметры записи" далее.</p>
    <p><span class="vue-b">Пример из жизни. Например мы хотим записать документ, в котором дата должна быть не меньше текущей даты, а больше. Вот в этом обработчике на клиенте мы и можем проверить её на это соответствие и если они меньше, то Отказ = Истина и документ дальше даже не пойдёт записываться.</span></p>

    <p class="title-size16"><b id="chapter3.9.2">Проверка заполнения</b></p>
    <p>После обработки события "Перед записью" платформа выполняет контекстный серверный вызов. Контекст формы упаковывается и передаётся на сервер. На сервере создаётся программный объект формы. Из полученного контекста заполняются реквизиты, элементы, параметры формы, инициализируется модуль формы, и в дело вступает <i style="text-decoration: underline;">механизм проверки заполнения</i>.</p>
    <p>Его работа заключается в последовательном вызове двух событий: одного у формы, второго - у того объекта, который будет записан. Работа механизма проверки заполнения подробно рассматривается в главе <a href="#chapter3.11">3.11</a>, поэтому сейчас мы не будем подробно останавливаться на назначении каждого из событий. Опишем их лишь в общих чертах.</p>
    <p>Сначала вызывается событие формы "Обработка проверки заполнения на сервере".</p>
    <p>После этого выполняется преобразование данных формы в данные прикладного объекта: в памяти сервера создаётся прикладной объект, соответствуюзий типу основного реквизита формы, и его данные заполняются из данных формы.</p>
    <p>Затем вызывается событие прикладного объекта "Обработка проверки заполнения".</p>

    <p class="title-size16"><b id="chapter3.9.3">Событие "Перед записью на сервере"</b></p>
    <p>После того как механизм проверки заполнения закончил свою работу, на сервере вызывается событие формы "Перед записью на сервере".</p>
    <p>Чем интересен этот обработчик? Как мы говорили выше, в процессе проверки заполнения произошло "разделение" формы на форму и прикладной объект, данные которого будут записаны в БД. Это определяет ряд особенностей дальнейшей работы.</p>
    <p>Обработчик "ПередЗаписьюНаСервере" - первый, в котором появляется возможность доступа как к данным основного реквизита формы (через его имя, как правило - Объект), так и к самому объекту, который будет записан. Этот объект система передаёт в обработчик в параметре "ТекущийОбъект". Напомним описание вызова этого обработчика:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
        </pre>
    </div>
    <p>Что важно понимать, находясь в этом обработчике? Данные, доступные через основной реквизит формы Объект - "мертвы". Мертвы в том смысле, что их изменение не даст никакого результата. Их можно только изучить.</p>
    <p>При этом также нужно понимать, что эти данные - не то, что будет записано в инфобазу. Это то, что "приехало" с клиента и "пережило" проверку заполнения. Поэтому и изучать их можно только с точки зрения того, "а что же было".</p>
    <p>А записан  в инфобазу будет "ТекущийОбъект". Отсюда ещё два замечания:</p>
    <ul class="list">
        <li>Если нужно принять решение о том, можно записывать данные или нельзя, нужно изучать "ТекущийОбъект"</li>
        <li>Если нужно изменить записываемые данные (например, дописать служебную информацию в реквизиты), использовать нужно "ТекущийОбъект".</li>
    </ul>
    <p>Все попытки изменить данные через реквизит формы Объект ни к чему не приведут. В инфобазу эти данные записаны не будут, а перед тем как форма "поедет" обратно на клиент, её данные будут замещены данными записанного в инфобазу объекта. Таким образом, все изменения, внесённые в Объект, пропадут.</p>
    <p>Также нужно понимать, что все действия, выполняемые в этом обработчике (отказ от записи, изменения данных объекта), должны быть связаны именно с тем фактом, что данные записываются именно из формы. При программной записи объекта (методом объекта) форма будет отсутсвовать, следовательно, и это событие вызываться не будет.</p>
    <p>Поэтому если какие-либо алгоритмы должны выполняться при любом способе записи объект, а не только при записи из формы, их следует размещать в обработчике события объекта - "Перед записью", а не в обработчике события формы</p>

    <p class="title-size16"><b id="chapter3.9.4">Запись данных в базу данных</b></p>
    <p>После обработки события формы "Перед записью на сервере" в СУБД открывается транзакция записи и начинается процесс записи прикладного объекта в БД.</p>
    <p>Прежде всего вызывается событие объекта "Перед записью". В этом событии можно отказаться от записи данных. Причём эта проверка будет выполняться всегда, независимо от того, каким способом данные объекта записываются.</p>
    <p>После обработки события "Перед записью" данные записываются в БД, но транзакция не закрывается.</p>
    <p>После записи данных вызывается ещё одно событие объекта - "При записи". Это событие предназначено для того, чтобы выполнить действия над дополнительными данными, которые неразрывно связаны с основными данными объекта и не могут быть изменены независимо от основных данных. Поскольку это событие обрабатывается в транзакции записи основных данных, гарантируется синхронность изменения основных и вспомогательных данных. Либо и те и другие записаны, либо и те и другие изменения будут отменены при отмене транзакции.</p>
    <p><spa class="vue-r">Пример, что именно это за дополнительные записи, можно почитать в основном разделе шпоры в секции про регистры сведений в статье - "Записываем и изменяем данные в периодическом зависимом регистре сведений в обработчике "ПриЗаписи". Что такое Отбор. Отбор по регистратору."</spa></p>
    <p>После обработки события объекта "При записи", пока транзакция открыта, на сервере вызывается событие формы "При записи на сервере". Назначение этого обработчика подобно предыдущему - чтобы записать в базу данных дополнительную информацию, связанную с данными записываемого объекта, напрмер, сделать записи данных объекта в регистр. Совсем не обязательно, чтобы все исходные данные для записи дополнительной информации находились в самом объекте. Они могут находится и в форме. Как раз для таких случаев и предназначено это событие.</p>
    <p>Описание процедуры, обрабатывающей это событие, выглядит следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
        </pre>
    </div>
    <p>Находясь в этом обработчике, важно понимать, что имеет смысл работать только с теми данными объекта, которые доступны через "ТекущийОбъект". Здесь "ТекущийОбъект" - это именно то, что было записано в базу.</p>
    <p>Те данные, которые доступны через основной реквизит формы Объект, - это "старые" данные, то, что было в форме, когда она "приехала" на сервер. Изменять эти данные бесполезно, потому что после выхода из этого обработчика они будут заменены данными, содержащимися в "ТекущийОбъект".</p>
    <p>Иногда имеет смысл их изучать. Например, в случае записи нового объекта тут будет следующий случай. "Объект.Ссылка", скорее всего, будет содержать пустую ссылку(т.к. пока новый объект не записан, у него нет ссылки). В то же время "ТекущийОбъект.Ссылка" будет содержать уже конкретное значение ссылки на этот элемент в базе. Конечно, всё это справедливо тоько в том случае, если не выполнялось программное изменение ссылки до или после записи.</p>
    <p>Итак, по поводу обработчика можно сделать следующие замечания:</p>
    <ul class="list">
        <li>Если нужно выполнять какие-то действия, связанные с записанным объектом, и при этом, например, нужна ссылка на этот объект, необходимо использовать "ТекущийОбъект.Ссылка".</li>
        <li>Если нужно изменить записанные данные перед отправкой их на клиент, необходимо использовать "ТекущийОбъект".</li>
        <li>Основной реквизит формы "Объект" можно использовать только для сравнения того, что "было", с тем, что "записалось". Изменять его бессмысленно, т.к. он будет замещён данными из "ТекущийОбъект".</li>
    </ul>

    <p class="title-size16"><b id="chapter3.9.5">Событие "После записи на сервере"</b></p>
    <p>После того как обработано событие формы "При записи на сервере", транзакция записи в СУБД закрывается и начинается процесс передачи данных на клиент и закрытия формы.</p>
    <p>После завершения транзакции записи выполняется преобразование данных записанного объекта в данные формы. После этого вызывается событие формы "После записи на сервере". Это третий и последний обработчик, в котором по отдельности доступны данные форма и объект, который был записан. Вызов этого обработчика таже содержит "ТекущийОбъект" и похож на предыдущие:</p>
    <div class="code-style">
        <pre>
            Процедура ПослеЗаписиНаСервере(ТекущийОбъект, ПараметрыЗаписи)
        </pre>
    </div>
    <p>Однако здесь значение "ТекущийОбъект" - прямо противоположное тому, что было до этого. Объясним подробнее.</p>
    <p>В этом обработчике данные записанного объекта уже помещены в форму. Поэтому "живым" в этом обработчике является уже основной реквизит формы "Объект", а "ТекущийОбъект" существует лишь для того, чтобы дать возможность разработчику выполнить какие-то вспомогательные действия.</p>
    <p>Что обычно делают в этом обработчике? Обработчик - в модуле формы, значит, предполагаются действия над формой. Обработчик вызывается после окончания транзакции записи - значит, это действия, которые должны быть выполнены только в том члучае, когда объект 100% записан. Например, вывод в форме некоторой дополнительной информации, связанной с основными данными объекта. Или выполнение каки-либо действий, которые должны быть выполнены только в том случае, когда объект гарантированно записан.</p>
    <p>Отсюда последние замечания:</p>
    <ul class="list">
        <li>"ТекущийОбъект" изменять бессмысленно: он будет уничтожен при выходе из обработчика</li>
        <li>Если для выполнения связанных действия нужны какие-то данные или методы объекта, нужно использовать "ТекущийОбъект", а не пытаться получать их через основной реквизит формы.</li>
    </ul>

    <p class="title-size16"><b id="chapter3.9.6">Передача формы на клиент</b></p>
    <p>После обработки события "После записи на сервере" форма передаётся на клиент. В памяти сервера уничтожается прикладной объект. Изменённые реквизиты, элементы и параметры формы, требуемые для отображения, передаются на клиент. Уничтожается объект формы на сервере. После этого на клиенте вызывается событие формы "После записи".</p>

    <p class="title-size16"><b id="chapter3.9.7">Событие "После записи"</b></p>
    <p>В обработчике этого события также выполняются действия над формой, которые должны быть выполнены только в случае 100% записи данных объекта. Те действия, которые требуют взаимодействия с пользователем или которые невозможно выполнить на сервере.</p>

    <p class="title-size16"><b id="chapter3.9.8">Событие "Перед закрытием"</b></p>
    <p>Так как мы рассматриваем случай записи объекта и закрытия его формы, то после обработки на клиенте события "После записи" на клиенте же вызывается событие "Перед закрытием".</p>
    <p>Основное назначение этого события - изучить, можно ли закрывать форму или нельзя. И если нельзя, то отказаться от её закрытия. Описание процедуры обработчика этого события выглядит след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
        </pre>
    </div>
    <p>Установка параметрка "Отказ" в значение Истина позволяет отказаться от закрытия формы. А запрет стандартной обработки позволяет отказаться от стандартных действий, которые опять-таки определяются типом основного реквизита формы.</p>
    <p>Например, в случае с формой справочника стандартные действия платформы будут заключаться в следующем. Если форма изменена и окно формы закрывается клавишей Esc или нажатием кнопки закрытия окна, то платформа сообщит о том, что данные формы изменены, и предложит либо записать их, либо закрыть без сохранения изменений, либо отказаться от закрытия формы.</p>
    <p>Если в таком случае отказаться от стандартной обработки, то форма будет закрыта без вопросов в любом случае, независимо от того, изменены в ней данные или нет.</p>
    <p>С помощью параметра "ЗавершениеРаботы" разработчик может определить, закрывается форма "само по себе" или форма закрывается в процессе завершения работы приложения. Данный параметр устанавливается в значение Истина в том случае, если пользователь пытается закрыть основное окно приложения. При закрытии отдельной формы данный параметр будет установлен в значение Ложь.</p>
    <p>При закрытии всего приложения и при отказе от закрытия конкретной формы с помощью параметра "ТекстПредупреждения" разработчик может установить текстовое сообщение, которое будет показано пользователю, с возможностью отказаться от закрытия или подтвердить его (в ыеб-клиенте все сообщения будут объединены в один диалог).</p>
    <p>Если параметр "ТекстПредупреждения" не установлен, то в качестве текста предупреждения в диалоге будет показана строка "Работа в данном окне не завершена".</p>
    <p>Нужно помнить, что при обработке завершения работы приложения в обработчиках событий "Перед завершением работы системы", "При завершении работы системы", а также в обработчиках событий формы, находящейся в режиме закрытия("Перез закрытием", "При закрытии"), запрещено открывать окна и вызывать любые серверные вызовы. Поэтому советуется заранее сохранить в данных формы ту информацию, которая может потребоваться, чтобы определить, можно закрыть форму при завершении работы приложения или нет.</p>
    <p>Как уже говорилось, при закрытии форм прикладных объектов (по отдельности или в случае закрытия основного окна приложения), если данные были изменены, платформа предупредит об этом и не даст закрыть окно без подтверждения пользователя. Это поведение не требует вмешательства разработчика, в случае если стандартная обработка события "Пред закрытием" не отменена.</p>
    <p>В противном случае, или если форма произвольная (т.е. прикладной объект не является основным реквизиот формы), или это например, форма обработки, разработчик должен самостоятельно сделать принятый в платформе единый подход к закрытию форм и основного окна приложения.</p>
    <p>В обработчике события "Перед закрытием" по значению параметра "ЗавершениеРаботы" разработчик должен определить, закрывается ли форма в процессе завершения работы приложения. Если да, то разработчик, изучи данные формы, принимает решение, нужно ли выдавать пользователю како-либо сообщение, требующее реакции пользователя: завершить работу или всё таки продолжить работу, т.к. в форме есть существенная информация.</p>
    <ul class="list">
        <li>Если разработчик считает, что пользователю необходимо выдать сообщение, то он задаёт этот текст в значении параметра "ТекстПредупреждения" и устанавливает параметр Отказ в значение Истина</li>
        <li>В резуультате при завершении работы приложения текст предупреждения, который задал разработчик, будет показан пользователю с вариантами ответа: Завершить работу или Продолжить работу.</li>
    </ul>
    <p>Если параметр "ЗавершениеРаботы" имеет значение Ложь, то это означает, что закрывается отдельная форма, в Этом случае логика работы выглядит следующим образом:</p>
    <p>1) В начале задаётся вопрос о необходимости закрытия формы, а собственно закрытие формы отменяется.</p>
    <p>2) После того как пользователь ответил на вопрос, в специальной клиентской переменной отмечается, что сейчас будет выполнено "настоящее" закрытие формы, и форма закрывается повторно.</p>
    <p>Поясним вышестказанное на примере.</p>
    <p>В форме обработки "ЗакрытиеФормы"(смотрим в инфобазе "Открытие форм" форму обработку "ЗакрытиеФормы") содержится булевый реквизит "ПредупреждениеОЗакрытии", который отображается в форме в виде флажка. Для упрощения примера вместо "настоящего" изучения данных формы мы будем использовать состояние этого флажка в качестве признака того, надо ли показывать пользователю предупреждение с вопросом о возможности закрытия формы или закрывать её сразу, без вопросов.</p>
    <p>Рассмотрим обработчик события формы "ПередЗакрытием":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
                Если НЕ ПредупреждениеОЗакрытии Тогда
                    Возврат;
                КонецЕсли;

                Если НЕ ЗавершениеРаботы Тогда
                    Если ОтветПередЗакрытием &lt;> Истина Тогда
                        Отказ = Истина;
                        ОповещениеОЗакрытии = Новый ОписаниеОповещения("ПередЗакрытиемЗавершение", ЭтотОбъект);
                        ПоказатьВопрос(ОповещениеОЗакрытии, "Вы хотите закрыть форму?", РежимДиалогаВопрос.ДаНет);
                    КонецЕсли;
                Иначе
                    Отказ = Истина;
                    ТекстПредупреждения = "При закрытии формы все данные будут утеряны. Продолжить?");
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Прежде всего, если флажок "ПредупреждениеОЗакрытии" не установлен, то ничего не происходит и форма закрывается без вопросов.</p>
    <p>В противном случае, если параметр "ЗавершениеРаботы" имеет значение Истина, то форма закрывается в процессе завершения работы приложения.</p>
    <p>В этом случае параметр Отказ мы устанавливаем в значение Истина и задаём в параметре "ТекстПредупреждения" сообщение, которое будет показано пользователею перед закрытием формы обработки.</p>
    <p>Если параметр "ЗавершениеРаботы" имеет значение Ложь, значит, форма обработки закрывается, как обычно, кнопкой Закрыть.</p>
    <p>В этом случае мы проверяем значение клиентской переменной модуля формы "ОтветПередЗакрытием". Если это значение истинно, значит, ответ пользователя на вопрос о возможности закрытия формы уже был получен, и форма действительно закрывается. Если значение переменной "ОтветПередЗакрытием" не определено, значит, вопрос перед закрытием формы пользователю ещё не задавался.</p>
    <p>В этом случае параметр Отказ мы устанавливаем в значение Истина и создаём описание оповещения, определяющего процедуру, которая будет выполнена, после того как пользователь ответит на вопрос.</p>
    <p>Вопрос о возможности закрытия формы задаём пользователю с помощью немодального метода ПоказатьВопрос() и передаём туда первым параметром описание оповещения.</p>
    <p>Процедура обработки оповещения:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПередЗакрытиемЗавершение(Результат, ДополнительныеПараметры) Экспорт
                Если Результат = КодВозвратаДиалога.Да Тогда
                    ОтветПередЗакрытием = Истина;
                    Закрыть();
                Иначе
                    ОтветПередЗакрытием = Неопределено;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В процедуре обработки оповещения, в случае если пользователь согласился с закрытием формы, переменная ОтветПередЗакрытием устанавливается в значение Истина, и форма закрывается ещё раз методом Закрыть(). Если нет, то форма остаётся открытой и переменная ОтветПередЗакрытием устанавливается в значение Неопределено.</p>
    <p>Таким образом, мы задаём пользователю вопрос о возможности закрытия формы в обработчике события "Перед закрытием". Обработчик вызывается дважды. Первый раз - когда закрытие формы (отдельно или при завершении работы приложения) инициируется пользователем, а второй - из встроенного языка после подтверждения пользователя. Но вопрос задаётся пользователю только в первый раз, если переменная ОтветПередЗакрытием не определена.</p>
    <p>Остаётся только объявить эту клиентскую переменную в модуле формы:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Перем ОтветПередЗакрытием;
        </pre>
    </div>
    <p>В результате в режиме 1С:Предприятие при закрытии формы обработки кнопкой Закрыть и при установленном флажке "ПредупреждениеОЗакрытии" пользователю будет показан слудующий диалог, в котором он может подтвердить закрытие формы или отказаться от него:</p>
    <img src="../img/1С-1/2024-02-10_20-20-38.png" class="screen-2" alt="">
    <p>А при закрытии формы обработки в процессе завершения работы приложения пользователю будет показан следующий диалог:</p>
    <img src="../img/1С-1/2024-02-10_20-23-41.png" class="screen-2" alt="">

    <p class="title-size16"><b id="chapter3.9.9">Событие "При закрытии"</b></p>
    <p>После обработки события "Перед закрытием" форма закрывается, пользователь перестаёт её видеть. Однако программный объект формы всё ещё существует, и на клиенте вызывается событие формы "При закрытии".</p>
    <p>Назначение этого события в том, чтобы выполнить действия, которые должны быть выполнены в случае 100% закрытия формы.</p>
    <p>Например, закрыть вспомогательную форму, существующую только в том случае, если открыта основная форма.</p>
    <p>В обработчик события "При закрытии" в параметре "ЗавершениеРаботы" также передаётся признак того, при каких условиях закрывается форма. Но надо иметь ввиду, что отказаться от закрытия формы в данном обработчике нельзя.</p>
    <p>После обработки этого события программный объект формы удаляется из памяти клиента.</p>

    <p class="title-size16"><b id="chapter3.9.10">Параметры записи</b></p>
    <p>Запись данных объекта в форме может быть выполнена средствами встроенного языка. Для этого у многих расширений формы существует метод Записать(). У этого метода есть единственный параметр - "ПараметрыЗаписи". Он содержит структуру произвольных параметров записи.</p>
    <p>Некоторые расширения форм объектов добавляют собственные, предопрелённые параметры записи. Например, расширение документа добавляет параметры "РежимЗаписи" и "РежимПроведения", а расширение задачи - параметр "ВыполнитьЗадачу".</p>
    <p>Подробнее о предопределённых параметрах можно почитать в синтакс-помощнике, в описании события "Перех записью" для разных расширений формы или в описании других событий, перечисленных ниже.</p>
    <p>Наряду с предопределёнными параметрами разработчик может добавлять и собственные параметры. Эти параметры разработчик может использовать в различных обработчиках событий записи в зависимости от своих нужд.</p>
    <p>Таких событий, в которых будут доступны параметры записи - пять.</p>
    <p>В любом из этих обработчиков параметры записи можно изменять, добавлять, удалять - все выполненые изменения будут переданы в следующий обработчик.</p>
    <img src="../img/1С-1/2024-02-11_10-33-00.png" class="screen" alt="">
    <img src="../img/1С-1/2024-02-11_10-34-33.png" class="screen" alt="">






    <h3 class="header-style2" id="chapter3.10">Глава 3.10. Начальное заполнение. Стр 512</h3>
    <p>Механизм начального заполнения позволяет описать правила и алгоритмы, по которым новые объекты, создаваемые в инфобазе, будут заполнены некоторыми данными.</p>
    <p>Механизм начального заполнения предназначен исключительно при создании объекта пользователем. При создании новых объектов средствами встроенного языка он не вызывается. Но при необходимости разработчик может его задействовать, для того чтобы создать видимость создания нового объекта пользователем.</p>
    <p>Начальное заполнение вызывается в следующих случаях создания новых объектов пользователем:</p>
    <ul class="list">
        <li>командой Создать в панели функция текущего раздела или в списке;
        <img src="../img/1С-1/2024-02-11_10-59-04.png" class="screen" alt=""></li>
        <li>командой ввода на основании;</li>
        <li>при программном вызове методов глобального контекста ОткрытьФорму() или ПолучитьФорму();</li>
        <li>при программном вызове методов объектов Заполнить();</li>
    </ul>
    <p><span class="vue-r">Вроде выше было написано что средствами встроенного языка не вызывается этот механизм и тут же последними 2мя пунктами говорится, как программно вызвать этот механизм. Что-то немного не понимание у меня.</span></p>
    <p>Кроме перечисленных способов есть ещё один способ интерактивного создания объекта - копированием. Этот случай обрабатывается платформой отделно, и механизм начального заполнения при этом не задействуется.</p>
    <p>Механизм начального заполнения имеет несколько состовляющих, часть из них доступна в режиме Конфигуратор, часть во ствроенном языке в режиме 1С:Предприятие:</p>
    <ul class="list">
        <li>Во-первых, в конфигураторе можно задать конкретные значения, которыми самостоятельно будут заполнены реквизиты нового объекта. У реквизитов есть свойство <b>Значение заполнения</b>.</li>
        <li>Во-вторых, в конфигураторе можно разрешить платформе в некторых случаях самостоятельно заполнить реквизиты нового объекта подходящими данными. У реквизитов есть свойство <b>Заполнять из данных заполнения</b>.</li>
        <li>В-третьих, во встроенном языке разработчик может описать собственные алгоритмы заполнения рекизитов данными в обработке события <b>Обработка заполнения</b> в модуле объекта. Это событие вызывается в тех случаях, которые были перечислены выше у прикладных объектов(справочников, документов и т.д.) и у набора записей регистра сведений.</li>
    </ul>
    <p>Рассмотрим каждый из этих трёх элементов подробнее. В качестве примера мы будем использовать базу "Начальное заполнение".</p>

    <p class="title-size16"><b id="chapter3.10.1">Свойство "Значение заполнения"</b></p>
    <p>У реквизитов объектов конфигурации существует свойство <b>Значение заполнения</b>.</p>
    <p>Если реквизит простого типа(Строка, Число, Дата, Булево), то в свойстве можно задать любое значение этого типа, которым платформа самостоятельно заполнит этот реквизит у нового объекта:</p>
    <img src="../img/1С-1/2024-02-11_18-09-53.png" class="screen" alt="">
    <p>Если реквизит имеет тип ссылки, то в этом свойстве можно задать предоперелённый элемент(справочника) или конкретное значение перечисления:</p>
    <img src="../img/1С-1/2024-02-11_18-11-27.png" class="screen" alt="">
    <p>Выше картинки я делал из базы Камкова, далее примеры из базы этой книги  - "Начальное заполнение".</p>
    <p>Например, у документа "Накладная" может быть реквизит Склад с типом ссылки на справочник Склады. А в справочнике Склады может существовать предопределённый элемент "Главный склад".</p>
    <p>Тогда прямо в конфигураторе можно указать, что в новых документах реквизит Склад будет сразу же заполнен ссылкой на главный склад:</p>
    <img src="../img/1С-1/2024-02-11_18-45-18.png" class="screen" alt="">
    <p>В показательной базе можно создать новую накладную (командой в панели функция текущего раздела или командой в списке) и убедиться, что склад в новой накладной заполнен.</p>

    <p class="title-size16"><b id="chapter3.10.2">Свойство "Заполнять из данных заполнения"</b></p>
    <p>Другая возможность обеспечить начальное заполнение данных нового объекта - это разрешить платформе в некоторых случаях сделать это самостоятельно. Для этого используется другое свойство реквизитов объекта конфигурации - <b>Заполнять из данных заполнения</b>.</p>
    <p>Если это свойство установлено, платформа самостоятельно заполнит значение такого реквизита из <i style="text-decoration: underline;">данных заполнения</i> в том случае, если они представляют собой структуру, содержащую  отборы, и имя одного из условий отбора совпадает  с именем этого реквизита.</p>
    <p><span class="vue-r">От себя напишу. Тут речь идёт о отборе, который мы можем сделать в пользовательском режиме для динамического списка. Например, откроем список номенклатуры, в подменю "Ещё" откроем пункт "Настройка списка" и во вкладке "Отбор" сделаем отбор по какому-нибудь реквизиту. Пусть по "ВидНоменклатуры" равно "Товар" и применяем этот отбор:</span></p>
    <img src="../img/1С-1/2024-02-11_21-14-35.png" class="screen" alt="">
    <p><span class="vue-r">И теперь если создать новый объект номенклатуры через кнопку Создать в списке, то запустится обработчик события "Обработка заполнения" и в параметр "ДанныеЗаполнения" попадёт та самая структура вида: "ВидНоменклатуры" - "Товар". В принципе об этом будет дальше рассказано.</span></p>
    <p>Вообще в данные заполнения платформа может передавать различные типы значений.</p>
    <p>Например, если просто создаётся новый объект, то в данных заполнения будет значение Неопределно. Если новый объект создаётся вводом на основании, то в данных заполнения будет ссылка на объект, являющийся основанием или массив ссылок нескольких объектов являющихся основанием. Но во всех этих случаях платформа не будет самостоятельно заполнять реквизиты из данных заполнения.</p>
    <p>Самостоятельное заполнение будет только в том случае, когда данные заполнения содержат структуру, состоящей из условий отбора.</p>
    <p>Когда в данных заполнения может оказаться такая структура?</p>
    <ul class="list">
        <li>Во-первых, когда новый объект вводится командой Создать из списка, в котором установлены некоторые отборы. Тогда все эти отборы платформа самостоятельно поместит в данные заполнения.</li>
        <li>Во-вторых, когда новый объект вводится в результате программного вызова методов ОткрытьФорму(), ПолучитьФорму() или метода объекта Заполнить(). Во все эти методы разработчик самостоятельно может передать структуру, содержащую нужные отборы.</li>
    </ul>
    <p>Рассмотрим оба эти случая</p>
    <p><b>Создание объекта из отобранного списка</b></p>
    <p>Сначала рассмотрим случай, когда, например, в списке накладных установлен отбор и пользователь нажимает кнопку Создать в командной панели списка. При этом у накладной существует реквизит Поставщик, для которого установлено свойство <b>Заполнять из данных заполнения</b>:</p>
    <img src="../img/1С-1/2024-02-11_22-07-17.png" class="screen" alt="">
    <p>В пользовательском режиме в списке накладных установлены отборы по поставщику и по складу:</p>
    <img src="../img/1С-1/2024-02-11_22-29-43.png" class="screen" alt="">
    <p>Командой Создать списка можно создать новую накладную и убедиться, что поставщик будет заполнен тем значением, по которому был установлен отбор - Поставщик 3. Ещё одно замечание. Нужно в отборе поставить галочки, иначе они не будут применены и их не будет в структуре и значит ничего не заполнится при создании нового объекта. На картинке у меня галочки не стоят, нужно поставить.</p>
    <p>Если для реквизита Склад тоже установить свойство "Заполнять из данных заполнения", то тогда при создании из отобранного списка и поставщик и склад будут заполнены значениями отбора, несмотря на то что для склад установлено значение заполнения:</p>
    <img src="../img/1С-1/2024-02-11_22-38-33.png" class="screen" alt="">
    <p><b>Программная установка данных заполнения</b></p>
    <p>Теперь рассмотрим второй случай, когда данные заполнения устанавливаются программно.</p>
    <p>Например, выполняется метод встроенного языка ОткрытьФорму(). Как говорилось выше, при программном открытии формы есть возможность задать значения параметров формы. Для решения нашей задачи предназначен параметр расширения формы <b>ЗначенияЗаполнения</b>.</p>
    <p>Например, мы хотим открыть форму и сразу же указать, что реквизит Поставщик должен быть заполнен некоторой конкретной ссылкой.</p>
    <p>Для этого создадим серверную функцию, которая вернёт эту саму ссылку на поставщика:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Функция ПолучитьПоставщикаНаСервере()
                Возврат Справочники.Поставщики.НайтиПоКоду("000000001");
            КонецФункции
        </pre>
    </div>
    <p>А затем в клиентском обработчике команды "ОткрытьФорму" создадим структуру, содержащую отбор по поставщику и передадим её в параметр формы "ЗначенияЗаполнения":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОткрытьФормуСЗаполнениемДанных(Команда)
                СсылкаНаПоставщика = ПолучитьПоставщикаНаСервере();
                ЭлементыОтбора = Новый Структура("Поставщик", СсылкаНаПоставщика);
                ПараметрыФормы = Новый Структура("ЗначенияЗаполнения", ЭлементыОтбора);
                ОткрытьФорму("Документ.Накладная.ФормаОбъекта", ПараметрыФормы,,,,,, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
            КонецПроцедуры
        </pre>
    </div>
    <p>В итоге выполнения такой команды будет открыта форма новой накладной, в которой поставщик будет заполнен значением "Поставщик 1":</p>
    <img src="../img/1С-1/2024-02-12_08-46-37.png" class="screen" alt="">
    <p>Главное не забываем поставить галочку для реквизита Поставщик в свойстве "Заполнять из данных заполнения", иначе не заполнится он.</p>
    <p>В случае, когда новый объект полностью создаётся и записывается без участия пользователя, можно использовать метод объект Заполнить(), чтобы смоделировать создание объекта по тем правилам и алгоритмам, которые используются при его создании пользователем.</p>
    <p>Например, находясь на сервере, можно создать новый объект накладной и затем вызвать у него метод Заполнить(). В этот метод передать значения, необходимые для начального заполнения, например, поставщика.</p>
    <p>При создании новой накладной пользователем расширение формы "ЗначениеЗаполнения" самостоятельно устанавливает дату нового документа. В программном создании накладной форма не участвует, поэтому в структуру данных заполнения нужно ещё передать и значение для поля Дата, иначе записать такую накладную не удастся. А для того чтобы платформа обработала его самостоятельно, в конфигураторе у стандартного реквизита накладной Дата нужно установить свойство "Заполнять из данных заполнения":</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура СоздатьИЗаписатьОбъектНаСервере()
                СсылкаНаПоставщика = Справочники.Поставщики.НайтиПоКоду("000000002");
                ЭлементыОтбора = Новый Структура("Поставщик, Дата", СсылкаНаПоставщика, ТекущаяДата());

                ОбъектНакладной = Документы.Накладная.СоздатьДокумент();
                ОбъектНакладной.Заполнить(ЭлементыОтбора);
                ОбъектНакладной.Записать();
            КонецПроцедуры
        </pre>
    </div>
    <p>В результате выполнения команды Заполнить (из которой вызывается процедура СоздатьИЗаписатьОбъектНаСервере()) будет создана и записана новая накладная с текущей датой и поставщиком "Поставщик 2". Значение для реквизита Склад будет взято из его свойства "Значение заполнения".</p>
    <img src="../img/1С-1/2024-02-12_11-03-15.png" class="screen" alt="">
    <p>Следует заметить, что для стандартных реквизитов Родитель, Владелец и для ведущих измерений регистров сведений платформа самостоятельно в конфигураторе устанавливает свойство "Заполнять из данных заполнения".Для остальных стандартныхх реквизитов, как в нашем случае для Даты, нужно это свойство устанавливать самостоятельно, если планируется использовать возможность их автоматического заполнения.</p>


    <p class="title-size16"><b id="chapter3.10.3">Событие "Обработка заполнения"</b></p>
    <p>Если разработчика не устраивают значения заполнения, установленные в конфигураторе или значения, переданные в данные заполнения, он может написать собственный алгоритм заполнения нового объекта данными. Для этого у объекта есть событие "Обработка заполнения", которое может быть обработано в серверной процедуре.</p>
    <p>Чтобы лучше представлять себе возможности программной обработки заполнения, рассмотрим ещё раз последовательность, в которой платформа использует те или иные элементы механизма заполнения:</p>
    <img src="../img/1С-1/2024-02-12_14-27-39.png" class="screen" alt="">
    <p>Сначала будет вызван обработчик события "Обработка заполнения" и вызван её код.</p>
    <p>Если после выхода из этого обработчика его параметр "СтандартнаяОбработка" будет иметь значение Ложь, то платформа не будет пытаться самостоятельно заполнить реквизиты нового объекта, а сразу же вызовет событие формы "При создании на сервере".</p>
    <p>Если же будет Истина(по умолчанию), то сначала платформа попытается заполнить значения реквизитов из данных заполнения.</p>
    <p>Если после этого реквизит всё ещё будет иметь значение своего типа по умолчанию, то платформа попытается заполнить его значением заполнения(вставить то что указано в конфигураторе в свойстве "Значение заполнения"). Если же после данных заполнения реквизит будет иметь значение, отличное от значения по умолчанию, то значение заполнения использоваться не будет, даже если оно указано для этого реквизита.</p>
    <p>Таким образом, находясь в обработчике "ОбработкаЗаполнения", разработчик может, изучив данные заполнения, самостоятельно заполнить реквизиты нового объекта и затем использовать или не использовать возможности стандартной обработки заполнения.</p>
    <p>Какие возможны содержания переменной "ДанныеЗаполнения"? Мы уже говорили о них, перечислим ещё раз.</p>
    <ul class="list">
        <li>Если данные заполнения имеют значение Неопределено, это значит, что новый объект создаётся командой Создать в панели функций текущего раздела или командой Создать из списка, в котором отсутсвуют отборы</li>
        <li>Если данные заполнения являются ссылкой, то выполняется ввод на основании и разработчик должен самостоятельно обработать это значение: либо сохранить его в реквизите формы, либо на основе этих данных заполнить несколько реквизитов формы(имеется ввиду по ссылке объекта основания получить из базы данные и поместить их в реквизиты текущего объекта)</li>
        <li>Если данные заполнения - это структура, значит, новый объект создаётся командой Создать из отобранного списка, или в общем случае разработчик создаёт его программно, передавая эту структуру через методы ОткрытьФорму(), ПолучитьФорму() или Заполнить().</li>
    </ul>
    <p>В качестве примера рассмотрим процедуру "ОбработкаЗаполнения" документа Накладная:</p>
    <div class="code-style">
        <pre>
            Процедура ОбработкаЗаполнения(ДанныеЗаполнения, СтандартнаяОбработка)
                Сообщение = Новый СообщениеПользователю;
                Если ДанныеЗаполнения = Неопределено Тогда 
                    Сообщение.Текст = "Ввод новой накладной";
                    
                ИначеЕсли ТипЗнч(ДанныеЗаполнения) = Тип("СправочникСсылка.Поставщики") Тогда 
                    Сообщение.Текст = "Ввод накладной на основании поставщика";
                    Поставщик = ДанныеЗаполнения;
                    
                ИначеЕсли ТипЗнч(ДанныеЗаполнения) = Тип("Структура") Тогда
                    Сообщение.Текст = "Ввод накладной из отобранного списка";
                    
                    СтандартнаяОбработка = Ложь;
                    
                    ОтобранныйПоставщик = Неопределено;
                    Если ДанныеЗаполнения.Свойство("Поставщик", ОтобранныйПоставщик) Тогда
                        Поставщик = ОтобранныйПоставщик;
                    КонецЕсли;
                    
                КонецЕсли;
                Сообщение.Сообщить();			
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре для наглядности в каждом из возможных вариантов выводится информационное сообщение.</p>
    <p>При обычном вводе(Если ДанныеЗаполнения = Неопределено Тогда) не выполняется никаких действий, документ заполняется стандартным способом - реквизит Склад заполняется своим значением заполнения.</p>
    <p>При вводе на основании поставщика (ИначеЕсли ипЗнч(ДанныеЗаполнения) = Тип("СправочникСсылка.Поставщики") Тогда) реквизиту Поставщик устанавливается значение того поставщика, на основании которого введа эта накладная. И также используются возможности стандартного заполнения - реквизит Склад заполняется своим значением заполнения.</p>
    <p>При вводе из отобранного списка (ИначеЕсли ТипЗнч(ДанныеЗаполнения) = Тип("Структура") Тогда) стандартное заполнение не используется (склад не заполняется), а из переданного отбора берётся только значение для реквизита Поставщик (другие элементы отбора не берутся в расчёт).</p>





    <h3 class="header-style2" id="chapter3.11">Глава 3.11. Проверка заполнения. Стр 525</h3>
    <p>Механизм проверки заполнения позволяет самостоятельно проверить, заполнены ли указанные реквизиты объекта. Такая проверка выполняется при вводе объекта пользователем, перед его записью. Поля реквизитов, для которых должно проверяться заполнение, выделяются в форме красным подчёркиванием. Если перед записью объекта эти поля окажутся не заполнены, запись не будет выполнена, а в форме будут выданы сообщения об ошибках, привязанные к незаполненым реквизитам.</p>
    <p>Механизм проверки заполнения направлен(предназначен) исключительно при работе пользователя, при записи объектов средствами встроенного языка он не вызывается. Но при необходимости сделать видимость записи объекта пользователем разработчик может вызвать механизм проверки из встроенного языка.</p>
    <p>Суть проверки заполнения заключается в том, что у реквизитов объектов конфигурации, у табличныйх частей, у реквизитов табличных частей и у реквизитов форм есть свойство <b>"Проверка заполнения"</b>. По умолчанию значение стоит в "Не проверять". Оно означает, что реквизит не участвует в проверке заполнения. Однако если это свойство установить в значение "Выдавать ошибку", то перез записью платформа будет проверять, что значение реквизита отличается от значения его типа по умолчанию. А для табличных частей будет проверять, что в табличной части есть хотя бы одна строка:</p>
    <img src="../img/1С-1/2024-02-17_11-00-20.png" class="screen" alt="">
    <p>Например, в документе Накладная проверка заполнения может быть указана для его реквизитов, табличной части и реквизитов табличной части. Тогда при попытке провести незаполненный документ платформа выдаст сообщения с ошибкой.</p>
    <p>А при попытке провести документ с пустой строкой в табличной части сообщение будет следующим - "Не заполнена колонка "Товар" в строке 1 списка "Товары"".</p>
    <p>С помощью мыши или курсора можно перемещаться по сообщениям в окне Сообщения, при этом выделенное сообщение будет показано в форме в специальном окне, размещённым под тем элементом, в котором допущена ошибка. Нажимая кнопки "Предыдущее сообщение" и "Следующее сообщение", пользователь может перемещаться по форме и заполнять пропущенные данные.</p>
    <p>Естественно, во встроенном языке разработчик может описать собственные алгоритмы проверки заполнения реквизитов данными. Для этого предназначены два события. Событие формы <b>"Обработка проверки заполнения на сервере"</b> и событие прикладного объекта, редактируемого в форме - <b>"Обработка проверки заполнения"</b>.</p>

    <p class="title-size16"><b id="chapter3.11.1">Заполнение и проверка заполнения</b></p>
    <p>Прежде чем подробно рассматривать механизм проверки заполнения, хотелось бы обратить внимание на то, что в платформе есть два созвучных между собой механизма: механизм <i style="text-decoration: underline;">заполнения</i> и механизм <i style="text-decoration: underline;">проверки заполнения</i>.</p>
    <p>Не следует их путать.</p>
    <p><b>Заполнение</b> - это:</p>
    <ul class="list">
        <li>свойства реквизитов объектов конфигурации "Значение заполнения", "Заполнять из данных заполнения";</li>
        <li>обработчик объекта "ОбработкаЗаполнения";</li>
        <li>заполнение выполняется при создании нового объекта пользователем;</li>
    </ul>
    <p><b>Проверка заполнения</b> - это:</p>
    <ul class="list">
        <li>свойства реквизитов объектов конфигурации "Проверка зполнения";</li>
        <li>обработчик формы "Обработка проверки заполнения на сервере" и обработчик объекта "Обработка проверки заполнения";</li>
        <li>проверка заполнения выполняется при записи объекта пользователем;</li>
    </ul>
    <p>Для большей наглядности можно провести следующую схему:</p>
    <img src="../img/1С-1/2024-02-17_11-20-29.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter3.11.2">Свойство "Проверка заполнения"</b></p>
    <p>Относительно свойства "Проверка заполнения" хочется сделать следующее замечание. Хотя по умолчанию для новых реквизитов платформа устанавливает это свойство в значение "Не проверять", для некоторых стандартных реквизитов, наоборот, платформа сама включает это свойство при создании объектов конфигурации.</p>
    <p>Такими реквизитами являются, например, "Наименование" и "Владелец" для справочника, "Дата" для документа и так далее.</p>
    <p>Поэтому в тех случаях, когда требуется сделать нестандартное поведение системы, эти свойства для стандартных реквизитов нужно установить в значение "Не проверять" или программно исключить эти реквизиты из проверки заполнения:</p>
    <img src="../img/1С-1/2024-02-17_11-37-06.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter3.11.3">Программная обработка проверки заполнения</b></p>
    <p>Каким образом разработчик может повлиять на стандартную проверку заполнения, выполняемую платформой?</p>
    <p>Для этого у него есть два события. Одно событие формы - "Обработка проверки заполнения на сервере". Другое событие объекта - "Обработка проверки заполнения".</p>
    <p>Всё, что относится к проверкам реквизитов основного объекта формы, нужно выполнять в модуле объекта.</p>
    <p>Обработчик в форме нужен потому, что форма может имееть данные, не относящиеся к объекту, и свои причины для проверки.</p>
    <p>И тот и другой обработчик имееют два параметра: <b>Отказ</b> и <b>ПроверяемыеРеквизиты</b>.</p>
    <p>В параметр "ПроверяемыеРеквизиты" платформа передаёт массив имён тех реквизитов, заполненность которых должна быть проверена.</p>
    <p>Разработчик может поступить несколькими способами:</p>
    <ul class="list">
        <li>Проверить заполненность реквизитов самостоятельно и очистить массив "ПроверяемыеРеквизиты", чтобы платформа не выполняла их проверку:
        <div class="code-style">
            <pre>
                --самостоятельная проверка всех реквизитов
                --модуль объекта документа "Накладная"

                Процедура ОбработкаПроверкиЗаполнения(Отказ, ПроверяемыеРеквизиты)
                    Если Поставщик = Справочники.Поставщики.ПустаяСсылка() Тогда
                        Сообщение = Новый СообщениеПользователю;
                        Сообщение.Текст = "Необходимо заполнить поставщика!";
                        Сообщение.Поле = "Поставщик";
                        Сообщение.УстановитьДанные(ЭтотОбъект);
                        Сообщение.Сообщить();

                        Отказ = Истина;
                    КонецЕсли;

                    //Проверка остальных реквизитов
                    //...

                    //Очистить массив проверяемых реквизитов, чтобы платформа
                    //не выполняла их проверку самостоятельно
                    ПроверяемыеРеквизиты.Очистить();
                КонецПроцедуры
            </pre>
        </div>    
        </li>
        <li>Проверить часть реквизитов самостоятельно, удалить их из массива ПроверяемыеРеквизиты, а оставшиеся реквизиты оставить в массиве на проверку платформе:
        <div class="code-style">
            <pre>
                --самостоятельная проверка всех реквизитов
                --модуль объекта документа "Накладная"

                Процедура ОбработкаПроверкиЗаполнения(Отказ, ПроверяемыеРеквизиты)
                    Если Поставщик = Справочники.Поставщики.ПустаяСсылка() Тогда
                        Сообщение = Новый СообщениеПользователю;
                        Сообщение.Текст = "Необходимо заполнить поставщика!";
                        Сообщение.Поле = "Поставщик";
                        Сообщение.УстановитьДанные(ЭтотОбъект);
                        Сообщение.Сообщить();

                        Отказ = Истина;

                        //удалить поставщика из массива проверяемых реквизитов
                        ИндексПоляПоставщик = ПроверяемыеРеквизиты.Найти("Поставщик");

                        Если ИндексПоляПоставщик &lt;> Неопределено Тогда
                            ПроверяемыеРеквизиты.Удалить(ИндексПоляПоставщик);
                        КонецЕсли;
                    КонецЕсли;
                КонецПроцедуры
            </pre>
        </div>    
        </li>
        <li>Добавить в массив ПроверяемыеРеквизиты какие-то реквизиты, чтобы платформа проверила и их тоже:
        <div class="code-style">
            <pre>
                --добавление новых реквизитов в массив для того, 
                --чтобы система проверила и их тоже

                ...
                ПроверяемыеРеквизиты.Добавить("Коментарий");
                ...
            </pre>
        </div>    
        </li>
        <li>Очистить массив ПроверяемыеРеквизиты, чтобы ничего не проверять ни самому, ни платформе:
        <div class="code-style">
            <pre>
                --отказ от самостоятельной проверки реквизитов платформой

                ...
                ПроверяемыеРеквизиты.Очистить();
                ...
            </pre>
        </div>
        </li>
    </ul>
    <p>Нужно заметить, что состав массива ПроверяемыеРеквизиты <b>различен</b> в обработчике формы и в обработчике объекта.</p>
    <p>В обработчике объекта в этом массиве содержаться имена реквизитов <i style="text-decoration: underline;">объекта</i>, которые требуют проверки:</p>
    <img src="../img/1С-1/2024-02-17_18-07-30.png" class="screen-2" alt="">
    <p>В обработчике формы в этом массиве содержатся имена реквизитов <i style="text-decoration: underline;">формы</i>, которые требуют проверки. И если есть реквизиты объекта, которые нужно проверять, то содержится имя основного реквизита формы, содержащего данные объекта:</p>
    <img src="../img/1С-1/2024-02-17_18-19-24.png" class="screen" alt="">
    <p>Параметр Отказ нужен для того, чтобы отказаться от записи объекта. Не от проверки заполненности, а именно от записи. Чтобы отказаться от проверки реквизитов, нужно очистить массив ПроверяемыеРеквизиты.</p>
    <p>Если установить параметр Отказ при обработке события в объекте, то после выполнения обработчика "Обработка проверки заполнения" процесс записи будет прекращён.</p>
    <p>Если параметр Отказ установить в форме, то дальнейшее поведение системы будет зависить от того, есть ли в списке проверяемых реквизитов основной реквизит формы. Если есть, то отработает проверка заполнения в объекте, и на этом всё закончится:</p>
    <img src="../img/1С-1/2024-02-17_19-32-00.png" class="screen-2" alt="">
    <p>Если нет (например, разработчик очистил этот список), то обработчик в модуле объекта вызываться не будет:</p>
    <img src="../img/1С-1/2024-02-17_19-32-12.png" class="screen-2" alt="">

    <p class="title-size16"><b id="chapter3.11.4">Вывод сообщений с привязкой к элементам формы</b></p>
    <p>При самостоятельной проверке заполненности реквизитов, естественно, возникает желание вывести такие же сообщения об ошибках, которые выводит система, чтобы они были привязаны к тем элементам формы, в которых значения не заполнены.</p>
    <p>Для этого используется специальный механизм платформы - механизм <i style="text-decoration: underline;">сообщений пользователю</i>. Подробнее об этом механизме можно прочитать в главе 3.12. Здесь мы рассмотрим только некоторые примеры его использования.</p>
    <p>Примечние. Пример можно посмотреть в базе "Проверка заполнения", в модуле объекта документа Накладная в процедуре "ОбработкаПроверкиЗаполнения" в закоментированном примере 5.</p>
    <p>Чтобы вывести такое сообщение из модуля объекта (в обработчике "ОбработкаПроверкиЗаполнения"), нужно создать новый объект "СообщениеПользователю", задать текст этого сообщения</p>
    <p>Также нужно указать, с каким реквизитом формы будет связано это сообщение. Для этого используется свойство "Поле" (Сообщение.Поле = "Поставщик";). Таким образом мы указываем, что сообщение должно быть привязано к тому элементу форму, который отображает значение реквизита Поставщик.</p>
    <p>Мы указали, к какому реквизиту привязали сообщение. Но неизвестно, в какой форме находится этот реквизит. Ведь наш код выполняется в модуле объекта, и у нас нет информации о каких-либо открытых формах.</p>
    <p>Сейчас мы не будем углубляться в этот впорос, скажем лишь, что для того, чтобы сообщение было правильно привязано к форме нашего объекта, нужно задать значения ещё двух свойств: <b>ПутьКДанным</b> и <b>КлючДанных</b>.</p>
    <p>Эти свойства платформа может заполнить самостоятельно, если выполнить метод УстановитьДанные() и передать в него тот программный объект, в модуле которого мы находимся.</p>
    <p>Ну и собственно для показа сообщения используется метод Сообщить().</p>
    <p>Допустим, нужно проверить заполненность реквизита Поставщик:</p>
    <img src="../img/1С-1/2024-02-18_08-09-35.png" class="screen" alt="">
    <p>Это можно выполнить следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль объекта документа Накладная

            Если Поставщик = Справочники.Поставщики.ПустаяСсылка() Тогда
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Необходимо заполнить поставщика!";
                Сообщение.Поле = "Поставщик";
                Сообщение.УстановитьДанные(ЭтотОбъект);
                Сообщение.Сообщить();

                Отказ = Истина;
            КонецЕсли;
        </pre>
    </div>
    <p>В итоге, если поставщик не заполнен, мы будем иметь возле реквизита это сообщение - "Нужно заполнить поставщика!".</p>
    <p>Обратим внимание, что после выдачи сообщения пользователю мы отменяем дальнейшую запись объекта(Отказ = Истина). Если этого не сделать, объект будет записан, несмотря на все наши сообщения, а если выполнилась команда "Записать и закрыть", то форма тоже будет закрыта, несмотря на то что в неё были выведены сообщения.</p>
    <p>Теперь рассмотрим случай, когда нужно сообщить об отсутствии строк в табличной части Товары:</p>
    <img src="../img/1С-1/2024-02-18_08-19-26.png" class="screen" alt="">
    <p>Это можно выполнить следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль объекта документа Накладная

            Если Товары.Количество() = 0 Тогда
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Нужно заполнить список полученных товаров!";
                Сообщение.Поле = "Товары";
                Сообщение.УстановитьДанные(ЭтотОбъект);
                Сообщение.Сообщить();

                Отказ = Истина;
            КонецЕсли;
        </pre>
    </div>
    <p>здесь в свойстве "Поле" указывается имя табличной части.</p>
    <p>В результате, если табличная часть пуста, мы будем видет это сообщение около таблицы.</p>
    <p>Теперь, допустим, нужно сообщить о том, что в некоторой строке табличной части не заполнено какое-то поле - например, во второй строке пустое поле Цена:</p>
    <img src="../img/1С-1/2024-02-18_08-24-40.png" class="screen" alt="">
    <p>Это можно выполнить следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль объекта документа Накладная

            Если Товары[1].Цена = 0 Тогда
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Нужно написать цену товара!";
                Сообщение.Поле = "Товары[1].Цена";
                Сообщение.УстановитьДанные(ЭтотОбъект);
                Сообщение.Сообщить();

                Отказ = Истина;
            КонецЕсли;
        </pre>
    </div>
    <p>Здесь в свойстве Поле указывается путь к нужному полю табличной части.</p>
    <p>В случае, когда нужно самостоятельно проверять заполненность каких-либо реквизитов формы(а не реквизитов объектов), всё обстоит несколько проще. Такие проверки нужно делать в обработчике события <b>формы</b> "Обработка проверки заполнения на сервере".</p>
    <p>Поскольку код данного обработчика выполняется в контексте формы, нет необходимости устанавливать для сообщения данные (Сообщение.УстановитьДанные(...)). Достаточно лишь указать имя реквизита формы, к данным которого будет привязано сообщение.</p>
    <p>Например, нужно проверить реквизит формы "Ответственный":</p>
    <img src="../img/1С-1/2024-02-18_08-35-16.png" class="screen" alt="">
    <p>Это можно сделать так:</p>
    <div class="code-style">
        <pre>
            --модуль формы документа Накладная

            Если СокрЛП(Ответственный) = "" Тогда
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Нужно написать фамилию отвественного!";
                Сообщение.Поле = "Ответственный";
                Сообщение.Сообщить();

                Отказ = Истина;  // не выполнять запись

                //удалить ответсвенного из массива проверяемых реквизитов
                ИндексПоляОтветсвенный = ПроверяемыеРеквизиты.Найти("Ответсвенный");

                Если ИндексПоляОтветсвенный &lt;> Неопределено Тогда
                    ПроверяемыеРеквизиты.Удалить(ИндексПоляОтветсвенный);
                КонецЕсли;
            КонецЕсли;
        </pre>
    </div>

    <p class="title-size16"><b id="chapter3.11.5">Проверка заполнения и функциональные опции</b></p>
    <p>Использование функциональных опций определяет некоторые особенности проверки заполнения.</p>
    <p>Функциональные опции позволяют самостоятельно скрыть/отобразить элементы интерфейса, которые связаны с функциональностью, не использующейся в данном прикладном решении (или, наоборот, использующейся).</p>
    <p>Функциональные опции бывают <i style="text-decoration: underline;">независимыми</i> и <i style="text-decoration: underline;">параметризуемые</i>.</p>
    <p>Если функциональная опция независимая, то её значение неизменно для всей конфигурации в целом.</p>
    <p>Оно может храниться, например, в константе типа Булево. Истина - функциональная опция включена, Ложь - выключена:</p>
    <img src="../img/1С-1/2024-02-18_09-55-32.png" class="screen" alt="">
    <p>В этом случае всё просто и понятно. Если, например, реквзит Склад связан с такой функциональной опцией, то, когда опция выключена, реквизит не отображается в форме и платформа не проверяет его заполненость, не включает его в массив проверяемых реквизитов.</p>
    <p>Если функциональная опция включена, реквизит отображается в форме и его заполненость проверяется.</p>
    <p>С параметризуемыми функциональными опциями дело обстоит сложнее. Их значение не постоянно для всей конфигурации. Параметризуемая опция в одном документе может иметь значение Истина(быть включённой), а в другом - иметь значение Ложь(быть выключенной). Всё зависит от её параметра. Поясним на примере.</p>
    <p>Допустим, есть параметризуемая функциональная опция "ВалютныйУчет". Она определяет, нужно ли использовать различные валюты при расчётах с поставщиком. Особенность заключается в том, что всё зависит от конкретного поставщика. С одним поставщиком расчёты ведутся только в рублях. А с другим поставщиком расчёты могут производится как в рублях, так и в деньгах других стран.</p>
    <p>Пусть значение такой функциональной опции хранится в реквизите "РасчетыВВалюте" справочника Поставщики. Реквизит имеет тип Булево.</p>
    <p><span class="vue-r">Как я понял функциональные опции могут хранить своё значение не только в константах, но и в любом реквизите объекта конфигурации. Наверно, главное чтобы реквизит имел тип булево.</span></p>
    <p>А вот что мы будем показывать или скрывать по значению "РасчетыВВалюте" мы указываем во вкладке "Состав" этой функциональной опции, а именно реквизит табличной части Товары документа Накладная - "Валюта".</p>
    <img src="../img/1С-1/2024-02-18_18-11-26.png" class="screen" alt="">
    <p>Поставщиков в базе может быть много. У одних этот реквизит имеет значение Истина, у других - Ложь. Какого именно поставщика взять для опеределния значения функциональной опции?</p>
    <p>Для этого как раз и служит параметр функциональной опции (в нашем примере - Поставщик). В каждом конкретном случае он определяет, реквизит какого именно поставщика нужно брать для выяснения значения функциональной опции.</p>
    <p>Например, в форме накладной при изменении значения поля поставщик может выполняться следующий код:</p>
    <div class="code-style">
        <pre>
            ПараметрыОпций = Новый Структура("Поставщик", Объект.Поставщик);
            УстановитьПараметрыФункциональныхОпцийФормы(ПараметрыОпций);
        </pre>
    </div>
    <p>Таким образом платформе сообщается, что в данный миг параметр функциональной опции должен быть равен тому поставщику, которого выбрал пользователь в поле Поставщик. Имея эту информацию, дальше платформа самостоятельно выясняет значение функциональной опции(т.е. в нашем случае она находит занчение того реквизита у поставщика, куда мы определили хранится её, а именно в реквизите "РасчетыВВалюте") и скрывает или, наоборот, отображает реквизит табличной части "Валюта".</p>
    <p>Когда мы в документе Накладная меняем поставщика меняется и отображение этого реквизита табличной части. При выборе поставщика с рублёвыми расчётами этот реквизит пропадает.</p>
    <p>Теперь вернёмся к проверке заполнения. Поскольку от разработчика зависит, как и в какой миг в конкретной форме будут установлены параметры функциональных опций, проверяемые реквизиты, связанные с параметризуемыми функциональными опциями, всегда присутствуют в массиве "ПроверяемыеРеквизиты". Если в конкретном случае заполненность этого реквизита проверять не нужно, разработчик сам должен удалить его из массива проверяемых реквизитов.</p>
    <p><span class="vue-b">Рассмотрим это на примере. Пример можно посмотреть в базе "Проверка заполнения" в модуле документа Накладная, поцедура "ОбработкаПроверкиЗаполнения" - пример 6.</span></p>
    <p>Выполним команду "Настройки" в панели функций из группы команд "Сервис":</p>
    <img src="../img/1С-1/2024-02-18_20-57-01.png" class="screen" alt="">
    <p>Сейчас учёт по складам включён, в списке накладных есть колонка Склад, а в самой накладной есть поле Склад. Выключим учёт по складам и закроем форму настроек. Создадим новую накладную. В ней уже нет поля Склад. Заполним все требуемые поля, запишем и закроем накладную.</p>
    <p>Никаких сообщений о незаполненности реквизита Склад мы не получим, т.к. платформа сама исключила его из числа проверяемых реквизитов, потому что независимая функциональная опция "УчетПоСкладам" выключена.</p>
    <p>Включим учёт по складам и снова откроем эту же накладную. В ней появилось поле Склад, и оно не заполнено. Таким его и оставим.</p>
    <p>Реквизит "Ответственный" требует заполнения, но не сохраняется в базе данных. Такова логика нашей показательной формы. Поэтому сейчас для чистоты опыта заполним его ещё раз. После этого попробуем записать документ. Мы получим сообщение о том, что реквизит Склад не заполнен.</p>
    <p>В данном случае независимая функциональная опция включена, и поэтому платформа сама включила связанный с ней реквизит Склад в проверку.</p>
    <p>Теперь рассмотрим работу параметризуемой функциональной опции "ВалютныйУчет". С этой опцией связан реквизит табличной части "Валюта".</p>
    <p>Создадим новую накладную и выберем поставщика "Поставщик валютный". В табличной части появится колонка "Валюта".</p>
    <p>Заполним все требуемые поля, кроме валюты, и попробуем записать документ. Мы получим сообщение о том, что поле "Валюта" не заполнено.</p>
    <p>Теперь, так и не заполнив поле "Валюта", выберем другого поставщика - "Поставщик рублёвый 2". Колонка "Валюта" исчезнет.</p>
    <p>Попробуем записать документ. Документ запишется без сообщений об ошибках.</p>
    <p>Таким образом, в одном случае рекизит "Валюта" проверяется, а в другом - нет. Хотя и в одном, и в другом случае он присутствует в массиве проверяемых реквизитов. Как это достигается?</p>
    <p>Откроем модуль документа, процедуру "ОбработкаПроверкиЗаполнения", пример 6.</p>
    <p>В ней присутствует код, который в зависимости от значения функциональной опции перед записью исключает реквизит "Валюта" из массива проверяемых реквизитов:</p>
    <div class="code-style">
        <pre>
            --модуль объекта документа Накладная

            Процедура ОбработкаПроверкиЗаполнения(Отказ, ПроверяемыеРеквизиты)
                СтруктураПараметров = Новый Структура("Поставщик", Поставщик);
                
                // Если функциональная опиция "Валютный учет" выключена...
                Если НЕ ПолучитьФункциональнуюОпцию("ВалютныйУчет", СтруктураПараметров) Тогда
                    // ... не проверять заполненность поля Валюта табличной части.
                    ИндексПоляВалюта = ПроверяемыеРеквизиты.Найти("Товары.Валюта");	
                    Если ИндексПоляВалюта &lt;> Неопределено Тогда
                        ПроверяемыеРеквизиты.Удалить(ИндексПоляВалюта);
                    КонецЕсли;	                   
                КонецЕсли;	              
            КонецПроцедуры
        </pre>
    </div>
    <p>Во встроенном языке есть метод глобального контекста <b>ПолучитьФункциональнуюОпцию()</b>. Он позволяет узнать значение параметризуемой функциональной опции. Кроме имени опции ему можно передать и значение её параметра. Значение параметра передаётся в виде структуры, которая содержит имя параметра и значение параметра.</p>
    <p>Таким образом, если метод вернёт Ложь(в реквизите "РасчетыВВалюте" не будет стоять галочка), выполняется условие Если..., и из массива проверяемых реквизитов удаляется реквизит табличной части "Валюта".</p>
    <p>Если ФО включена, ничего не происходит, и платформа проверяет значение реквизита "Валюта".</p>

    <p class="title-size16"><b id="chapter3.11.6">Проверка заполнения и проверка при записи</b></p>
    <p>Ещё раз хочется обратить внимание на то, что проверка заполнения - это механизм, предназначенный исключительно при вводе данных пользователем. Он самостоятельно вызывается расширениями форм.</p>
    <p>Но могут быть случаи, когда программно выполняется некоторый алгоритм, который должен делать вид "ввода данных пользователем". В этом случае проверку заполнения можно вызвать с помощью методов <b>ПроверитьЗаполнение()</b>, написанных у объектов, наборов записей регистров и формы.</p>
    <p>Важно понимать, что проверка заполнения не является частью записи объекта. Она специально выделена отдельно:</p>
    <img src="../img/1С-1/2024-02-19_10-22-41.png" class="screen" alt="">
    <p>Запись объекта может происходить в самых разных случаях: обмен данными, создание данных обработкой. Это может быть программный код, который "очень хорошо знает", что с объектом нужно сделать и что в нём нужно записать. Поэтому если просто записывать объект из встроенного языка, автопроверка заполнения не вызывается.</p>
    <p>Если же запись объекта вызывается из формы, использующее стандартное расширение форм, то это расширение вызовет самостоятельную проверку заполнения.</p>
    <p>Естественно, в какой-то миг может возникнуть вопрос: что проверять перед записью, а что в проверке заполнения?</p>
    <p>Чтобы решить, нужно, по сути, ответить на вопрос: что является неотъемлемой частью технической логики объекта, не зависящей от способа ввода данных? Такой частью, без которой он существовать не может?</p>
    <p>Наверняка какие-то проверки нужно выполнять перед записью. Но они во-первых, должны быть очень быстрыми(потому что у нас может происходит массовое создание объектов), во-вторых, должны быть очень "жестокими". Т.е. вообще в базу данных никогда не должен попасть объект "без такого вот значения".</p>
    <p>А проверка заполнения может содержать большой объём проверок, направленных именно на то, что не хочется пользователю дать ввести "вот такое" вручную.</p>
    <p>Пару слов следует сказать о свойстве <b>"Запрет неиспользованных значений"</b>, которое существует у измерений регистров. Если это свойствоустановлено у измерения, то платформа сама будет проверять при записи наборов записей, что измерение заполнено:</p>
    <img src="../img/1С-1/2024-02-19_10-42-52.png" class="screen" alt="">
    <p>На первый взгляд может показаться, что и там, и там проверяется заполненность, что это одно и то же.</p>
    <p>Тут нужно понимать, что проверка заполнения - это исключительно проверка при взаимодействии пользователя с формой.</p>
    <p>В отличии от этого запрет незаполненых значений - это неотъемлемая часть бизнес-логики регистра. Она означает, что записи с незаполненным измерением не имеют смысла в базе. каким бы образом они в неё не попали: в результат ввода пользователем или в результате выполнения программного кода.</p>





    <h3 class="header-style2" id="chapter3.12">Глава 3.12. Сообщения пользователю. Стр 553</h3>
    <p>Сообщения пользователю - удобный инструмент для оповещения пользователя об ошибках в заполнении тех или иных данных. Можно выделить три ключевые возможности сообщений пользователю:</p>
    <ul class="list">
        <li>Во-первых, сообщения выводятся в окно сообщений окна клиентского приложения, в котором открыта форма, и накапливаются в нём. Таким образом, пользователь может последовательно или выборочно выполнять советы, содержащиеся в этих сообщениях.</li>
        <li>Во-вторых, сообщения могут привязываться к элементам формы. В итоге пользователь не только быстро находит поле, которое требует исправления, но и быстро выполняет это исправление. Как только сообщение отображается рядом с нужным полем формы, это поле сразу же переходит в режим редактирования.</li>
        <li>В-третьих, сообщения могут относится не только к той форме, в которой они выведены, но и к другим формам. В этом случае при двойном щелчке на таком сообщении будет открыта форма, к которой относится это сообщение, и в этой форме сообщение будет спозиционировано рядом с нужным элементом формы.</li>
    </ul>
    <p>Рассмотрим подробнее, каким образом сообщение определяет тот элемент формы, около которого оно должно быть отображено.</p>
    <p>Сообщение имеет три свойства, которые позволяют ему точно позиционироваться возле нужного элемента формы: <b>КлючДанных</b>, <b>ПутьКДанным</b> и <b>Поле.</b></p>
    <img src="../img/1С-1/2024-02-19_15-52-47.png" class="screen" alt="">
    <p>Выполнение любого программного кода всегда начинается на клиенте - из какой-нибудь активной формы или из основного окна.</p>
    <p>Все сообщения пользователю платформа выводит в окно формы, идентификатор которой задан в свойстве <b>ИдентификаторНазначения</b> класса "СообщениеПользователю". Если идентификатор не указан, то сообщения выводятся в активное окно.</p>
    <p>Когда сообщение отказывается в окне какой-либо формы, то первым делом изучается ссылка, содержащаяся в свойстве "КлючДанных":</p>
    <ul class="list">
        <li>Если эта ссылка совпадает с данными, содержащимися в основном реквизите формы(Объект.Ссылка), значит сообщение предназначено этой форме. Затем ищется реквизит формы, имя которого указано в свойстве "ПутьКДанным". После этого ищется подчинённый реквизит, имя которого указано в свойстве "Поле". В итоге после двойного щелчка на сообщении оно отображается рядом с нужным элементом формы.</li>
        <li>Другой сценарий - когда ссылка, содержащаяся в свойстве "КлючДанных", не совпадает с данными, содержащимися в основном реквизите формы.<br> 
        Это означает, что сообщение предназначено другой форме - основной форме того объекта, ссылка на который содержится в ключе данных.<br>
        В этом случае после двойного щелчка на сообщении будет открыта основная форма объекта, ссылка на который содержится в ключе данных, а далее сообщение будет спозиционировано рядом с нужным элементом формы по принципу, описанному выше.<br>
        Кроме того, выполняется перенос всех сообщений со свойством "КлючДанных", равным значению этого свойтсва текущего сообщения, из окна текущей формы в открытую форму.</li>
    </ul>
    <p>Оба рассмотренных случая, когда заполнены все три свойства сообщения, являются наиболее общими и универсальными. Они позволяют правильно воспользоваться сообщением независимо от того, в какой форме оно оказалось.</p>
    <p>Но могут быть и другие разновидности вывода сообщений.</p>
    <p>Например, если точно известно, что сообщение может оказаться только в одной-единственной форме (например, когда оно формируется в этой самой форме), можно не указывать "КлючДанных". В этом случае будет считаться, что сообщение относится именно к той форме, в которой оно оказалось. При этом если сообщение должно быть привязано не к реквизиту основного объекта, а к реквизиту формы, то также не нужно указывать "ПутьКДанным", достаточно указать только "Поле".</p>
    <p>Есть и ещё один случай, который может возникнуть при работе с сообщениями. Может оказаться так, что для сообщения будут указаны "КлючДанных" и "Поле". А свойство "ПутьКДанным" не будет заполнено. В этом случае сообщение само заполнит свойство "ПутьКДанным" именем основного реквизита формы. Той, в которой оно оказалось(если ключ данных совпадает), или той, которая будет открыта при двойном щелчке на сообщении.</p>
    <p>Сообщения формируемые при помощи объекта "СообщениеПользователю", рекомендуется использовать только для информирования об ошибочных действиях. Если требуется проинформировать пользователя о каком-либо событии, то советуется использовать для этого метод <b>ПоказатьОповещениеПользователя()</b>, о котором рассказывается в следующей главе.</p>
    <p>Теперь рассмотрим все эти случаи на небольшом примере. <span class="vue-b">Пример можно посмотреть в базе "Сообщение пользователю"</span>.</p>
    <p>Допустим, у нас есть обработка "ПроведениеДокументов". Задача этой обработки - провести(перепровести) выбранный документ некоторым специальным образом, который не требуется для обычного ежедневного учёта. Т.е. при таком проведении помимо обычных данных формируются дополнительные данные, требуемые для расчётов с отдельными поставщиками. Алгоритм расчёта этих данных сложен, таких поставщиков не много, данные требуются эпизодически. Поэтому существует отдельная обработка для получения этих данных.</p>
    <p>Наша задача будет заключаться:</p>
    <ul class="list">
        <li>в том, чтобы проверить правильность заполнения всех полей в обработке и выдать сообщения, если какие-то поля не заполнены;</li>
        <li>выполнить проведение документа сложным образом, из обработки, и выдать сообщение, если что то не так;</li>
        <li>обеспечить "обычное", ежедневное проведение документа и выдачу сообщений о недостатке списываемых товаров на складе.</li>
    </ul>
    <p>Обработка имеет реквизит "Документ" с типом "ДокументСсылка.Накладная", в котором мы будем выбирать обрабатываемый документ Накладная. Кроме того, форма обработки имеет реквизит "Комментарий", в который должно быть записано произвольное пояснение.</p>
    <img src="../img/1С-1/2024-02-20_23-15-35.png" class="screen" alt="">
    <p>"Документ" является реквизитом обработки, а не формы, для того чтобы была возможность программного запуска обработки без использования её формы.</p>
    <p>Для выполнения нашего алгоритма в форме обработки существует локальная команда "ПровестиДокументы", которая вызывает процедуру "ПровестиДокументы" в модуле формы:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПровестиДокументы(Команда)
                // Использовать стандартный механизм проверки заполнения, 
                // реализуемый платформой для обработки.
                Если ПроверитьЗаполнение() Тогда
                    // Выполнить собственный алгоритм обработки данных вызвав процедуру НаСервере()
                    НаСервере();
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре сначала вызывается стандартная проверка заполнения. Метод формы ПроверитьЗаполнение() вызывает сначала проверку заполнения в форме, а затем в объекте заполнения. Подобно тому, как выполняется проверка заполнения пользователем при записи объектов из формы. Эта тема подробно рассматривалась в главе 3.11. Сначала будет вызвано событие "Обработка проверки заполнения на сервере у формы". В обработчике этого события нам нужно проверить заполненность реквизита формы "Комментарий" и вывести сообщение:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ОбработкаПроверкиЗаполненияНаСервере(Отказ, ПроверяемыеРеквизиты)
                //удалим этот реквизит из массива провереямых реквизитов
                //чтобы система его не проверяла, мы сами его проверим
                ИндексКомментария = ПроверяемыеРеквизиты.Найти("Комментарий");
                
                Если ИндексКомментария &lt;> Неопределено Тогда
                    ПроверяемыеРеквизиты.Удалить(ИндексКомментария);
                КонецЕсли;
                
                Если СокрЛП(Комментарий) = "" Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Поле = "Комментарий";
                    Сообщение.Текст = "Нужно написать комментарий.";
                    Сообщение.Сообщить();
                    
                    Отказ = Истина;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Набор указаний написанный выше можно было бы и не писать, потому что в свойстве "Проверка заполнения" реквизита формы "Комментарий" установлено значение "Выдавать ошибку". Система сама бы проверила этот реквизит и выдала бы сообщение "Поле "Комментарий" не установлено". Но мы тут на примере показываем как и в каких случаях можно выводить свои сообщения, поэтому и такой набор указаний написали.</span></p>
    <p>Сначала исключаем комментарий из массива проверяемых реквизитов. Затем, если комментарий "пустой", формируем и выводим сообщение.</p>
    <p>В сообщении мы заполнеям только свойство Поле. В данном случае активной формой будет только форма обработки, и сообщение попадёт в неё. Поэтому достаточно указать лишь поле, остальные свойства сообщения не понадобятся:</p>
    <img src="../img/1С-1/2024-02-21_10-32-51.png" class="screen" alt="">
    <p>После того как будет обработано событие в форме, платформа вызовет подобное событие у объекта обработки - "Обработка проверки заполнения". В обработчике этого события нам нужно проверить заполненность реквизита обработки "Документ" и вывести соббщение:</p>
    <div class="code-style">
        <pre>
            --модуль объекта обработки

            Процедура ОбработкаПроверкиЗаполнения(Отказ, ПроверяемыеРеквизиты)
                //Очищаем полностью массив
                ПроверяемыеРеквизиты.Очистить();
                
                Если Документ = Документы.Накладная.ПустаяСсылка() Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Нужно выбрать какую-нибудь накладную.";
                    Сообщение.Поле = "Документ";
                    Сообщение.УстановитьДанные(ЭтотОбъект);
                    Сообщение.Сообщить();
                    
                    Отказ = Истина;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Сначала мы очищаем массив проверяемых реквизитов, т.к. все проверки будут выполняться самостоятельно.</p>
    <p>Затем проверяем заполненность реквизита "Документ" и, если он не заполнен, формируем и выводим сообщение.</p>
    <p>Тут всё уже несколько сложнее, чем в форме. Проверка заполнения в модуле обработки может быть вызвана и из формы обработки, и программно, без использования формы обработки. А это значит, что формируемое сообщение может попасть не только в форму обработки, для которой оно предназначено, но и в какую-нибудь другую форму.</p>
    <p>Поэтому нужно заполнить все свойства сообщения, чтобы попав в другую форму, сообщение "знало", что нужно открыть форму обработки и именно в ней спозиционироваться возле поля "Документ".</p>
    <p>Свойство "Поле" мы заполняем сами: "Сообщение.Поле = "Документ"". А для того чтобы заполнить два других свойства - "КлючДанных" и "ПутьКДанным", мы воспользуемся возможностями предоставляемыми платформой.</p>
    <p>Дело в том, что при выполнении некоторых определённых действий платформа запоминает соответствие объекта, который отображается в форме, и имени основного реквизита этой формы. Например, когда в форме объекта выполняется стандартная команда записи или когда в форме вызывается метод ПроверитьЗаполнение().</p>
    <p>"Запоминанием" этого соответсивя занимается расширение формы, определяемое основным реквизитом. Соответствие запоминается для того, чтобы в модуле объекта можно было бы им воспользоваться для правильного формирования сообщения. Ведь в общем случае, попав в модуль объекта, мы не знаем, из какой формы мы в него попали, не знаем, как в этой форме называется основной реквизит формы. Поэтому, прежде чем перейти в модуль объекта, платформа запоминает, какие данные (ссылку) содержит основной реквизит формы и как он называется.</p>
    <p>В случае с обработкой платформа запомнит только имя основного реквизита формы обработки (в нашем случае "Объект", не знаю существуют ли другие имена основного реквизита у обработок). В платформе не существует типа ссылки на обработку, поэтому запоминать просто нечего.</p>
    <p>Затем в модуле объекта обработки мы просто пишем - "Сообщение.УстановитьДанные(ЭтотОбъект);". После такого указания у сообщения будет установлено свойство "ПутьКДанным" - "Объект". "КлючДанных" останется незаполненным, так как заполнить его просто нечем.</p>
    <p>В результате сообщение окажется в форме обработки с незаполненным свойством "КлючДанных". Поэтому платформа будет пытаться (и это ей удастся) привязать его к форме обработки, используя значения свойств "ПутьКДанным" и "Поле":</p>
    <img src="../img/1С-1/2024-02-21_22-10-29.png" class="screen" alt="">
    <p>Поскольку оба раза при проверке мы устанавливали параметр Отказ в значение Истина, после обработки события "Обработка проверки заполнения" дальнейшее выполнение действий останавливается. Метод ПроверитьЗаполнение() возвращает Ложь, и наша проведура НаСервере() не выполняется.</p>
    <p>Пока на этом остановимся и обратим внмание на документ Накладная.</p>
    <p><span class="vue-b">Пример смотреть в базе "Сообщение пользователю". Не буду тут расписывать набор указаний из модуля Накладной.</span></p>
    <p>В модуле документа в процедуре "ОбработкаПроведения" находится набор указаний, который формирует движения документа. А после него для примера формируется и выводятся два сообщения.</p>
    <p>Предпологается, что наша накладная имеет "два повода" для проведения: обычное повседневное проведение и "специальное" проведение, выполняемое только в этой обработки.</p>
    <p>Чтобы различать, каким образом в данный миг проводится накладная, в модуле накладной существует экспортируемая переменная "ПроведениеИзОбработки".</p>
    <p>При любом проведении значение этой переменной сначала устанавливается в Ложь последней строкой в модуле.</p>
    <p>Это значение будет говорить нам о том, что проведение документа выполняется не из обработки. И в этом случае мы контролируем остатки и выводим сообщение, если товара на складе недостаточно.</p>
    <p>Здесь, как и в модуле обработки, мы используем возможность платформы самостоятельно устанавливать данные для сообщения(Сообщение.УстановитьДанные(ЭтотОбъект);).</p>
    <p>Если проведение документа будет выполняться стандартной командой из формы документа, то расширение формы документа самостоятельно установит соответствме объекта и реквизита формы. Таким образом "КлючДанных" и "ПутьКДанным" будут заполнены, и сообщение будет привязано к нужному полю.</p>
    <p>Если проведение будет выполняться, например, стандарной командой из формы списка("Еще" - "Провести"), то такого соответствия самостоятельно установлено не будет. Выполнение метода "Сообщение.УстановитьДанные(ЭтотОбъект);" приведёт лишь к тому, что будет установлено свойство "КлючДанных" - ссылка на объект документа. Свойство "ПутьКДанным" останется незаполненным. При этом основное сообщение попадёт в основное окно приложения.</p>
    <img src="../img/1С-1/2024-02-22_10-55-09.png" class="screen" alt="">
    <p>При двойном щелчке на этом сообщении будет открыта форма накладной, т.к. у сообщения установлен "КлючДанных". Платформа сама заполнит свойство "ПутьКДанным" именем основного реквизита формы и правильно привяжет его к полю "Количество".</p>
    <p>Таким образом, если при формировании сообщения мы используем метод УстановитьДанные() при любом способе проведения документа, сообщение отработает правильно, в какой бы форме оно ни оказалось.</p>
    <p>Теперь вернёмся в обработке, заполним поля документа и комментарий и нажмём кнопку "Провести документы".</p>
    <p>В модуле формы будет вызвана процедура НаСервере():</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура НаСервере()
                // Получить объект документа.
                ОбъектДокумента = Объект.Документ.ПолучитьОбъект();
                
                // Провести документ.
                ОбъектДокумента.ПроведениеИзОбработки = Истина;
                ОбъектДокумента.Записать(РежимЗаписиДокумента.Проведение);
            КонецПроцедуры
        </pre>
    </div>
    <p>В ней мы получаем объект документа от ссылки, хранящейся в реквизите Документ.</p>
    <p>Затем устанавливаем значение экспортируемой переменной "ПроведениеИзОбработки" модуля документа в Истина. В процедуре обработки проведения документа это будет означать для нас, что проведение выполняется "сложным" способом, из обработки.</p>
    <p>И после этого вызываем проведение документа в неоперативном режиме:</p>
    <div class="code-style">
        <pre>
            ОбъектДокумента.Записать(РежимЗаписиДокумента.Проведение);
        </pre>
    </div>    
    <p>В модуле документа, в обработке проведения, изучив значение переменной "ПроведениеИзОбработки", выполняем уже другие проверки и выводим другое сообщение, не такое как при обычном проведении.</p>
    <p>Мы хотим, чтобы сообщение отображалось не в форме документа, а в форме обработки и было привязано к полю Документ.</p>
    <p>Поэтому в свойстве Поле мы указываем "Документ", а в свойстве "ПутьКДанным" - Объект, так как Документ - это подчинённый реквизит объекта обработки. "КлючДанных" мы не указываем.</p>
    <p>Во-первых, у нас его нет. Ключом данных должна быть ссылка на объект обработки, а такой тип в платформе отсутствует. Вообще говоря, это не очень хорошо, т.к. снижает универсальность нашего сообщения. Если оно попадёт не в форму обработки, то не сможет правильно отработать.</p>
    <p>С другой стороны, вероятность того, что оно попадёт не в форму обработки очень мала. Если предполагается, что обработка будет использоваться только пользователем, тогда можно допустить, что в другую форму это сообщение не попадёт никогда.</p>
    <p>А раз так, то свойств Поле и ПутьКДанным будет достаточно для того, чтобы правильно привязать сообщение в форме обработки.</p>
    <p>При использовании сообщений всегда следует помнить о том, что присутствие сообщений в форме не препятствует её закрытию.</p>
    <p>Поэтому, если вывод сообщений используется в стандартных процедурах проверки заполнения, то всегда следует отказаться от продолжения работы. Для этого параметр Отказ этих обработчиков нужно устанавливать в Истина.</p>
    <p>В других случаях следует самостоятельно заботится о том, чтобы форма не была закрыта при появлении в ней сообщений - например, изучив какой-нибудь служебный реквизит объекта в процедуре формы "ПередЗакрытием()".</p>






    <h3 class="header-style2" id="chapter3.13">Глава 3.13. Способы информирования пользователя. Стр 568</h3>
    <p>Начав говорить о сообщениях пользователю, меет смысл взглянуть более широко на то, какие существуют способы информирования пользователей вообще и в каких случаях следует применять тот или иной способ.</p>
    <p>Все сообщения, предназначенные пользователю, можно разделить на несколько основных категорий.</p>
    <ul class="list">
        <li>Сообщения о неудачном окончании некоторого процесса. Такие сообщения возникают тогда, когда возникло некоторое исключение. Они информируют пользователя о причинах неудачи. Для таких случаев советуется использовать объект <b>"СообщениеПользователю"</b>. Он был рассмотрен подробно в предыдущей главе.
        <img src="../img/1С-1/2024-02-22_12-26-52.png" class="screen-2" alt=""></li>
        <li>Сообщения, которые отражают ход работы. Такие сообщения нужны для информирования пользователя о текущем этапе работе. Для этого хорошо подходит метод глобального контекста <b>Состояние()</b>. Он выводит на экран панель состояния, снабжённую индикатором. 
        <img src="../img/1С-1/2024-02-22_13-09-09.png" class="screen-2" alt=""><br>
        Пример использования этого объекта будет рассмотрен далее.</li>
        <li>Сообщения, с которыми нужно ознакомится после окончания некоторого процесса, сообщения о проделанной работе. Такие сообщения могут включать информацию о том, что сделано, её можно посмотреть, но можно и не смотреть. В случае если факт выполнения команды неочивиден для пользователя, система должна выдавать ту или иную реакцию на любою команду. Неправильно молча "проглатывать" нажатие на кнопку формы. Для таких сообщений следует использовать метод глобального контекста <b>ПоказатьОповещениеПользователя()</b>. Оповещение выводится в специальном постпенно затухающем окне в правом нижнем углу экрана:
        <img src="../img/1С-1/2024-02-22_15-24-52.png" class="screen-2" alt=""><br>
        Важные для пользователя оповещения (со статусом Важное) запоминаются в центре оповещений, который можно открыть в любое время из панели инструментов.
        <img src="../img/1С-1/2024-02-22_15-30-20.png" class="screen" alt=""></li>
        <li>Сообщения, с которыми обязательно нужно ознакомится до начала или после окончания некоторого процесса. Для вывода таких сообщений хорошо подходит метод <b>ПоказатьПредупреждение()</b>, выводящий на экран блокирующее окно:
        <img src="../img/1С-1/2024-02-22_18-37-13.png" class="screen-2" alt=""><br>
        Если указан параметр "Таймаут", то окно будет закрыто по истечении заданного времени.</li>
    </ul>
    <p><span class="vue-b">Пример можно посмотреть в базе "Способы информирования пользователя".</span></p>
    <p>Рассмотрим все перечисленные способы на небольшом примере.</p>
    <p>Пусть в конфигурации существует справочник Товары, у которого перед записью проверяется заполненность реквизита "Наименование". Для этого в модуле объекта, в процедуре "ОбработкаПроверкиЗаполнения", используется сообщение пользователю:</p>
    <div class="code-style">
        <pre>
            --модуль объекта справочника Товары

            Процедура ОбработкаПроверкиЗаполнения(Отказ, ПроверяемыеРеквизиты)
                ПроверяемыеРеквизиты.Очистить();
                
                Если СокрЛП(Наименование) = "" Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Поле = "Наименование";
                    Сообщение.УстановитьДанные(ЭтотОбъект);
                    Сообщение.Текст = "Не заполнено наименование товара!";
                    Сообщение.Сообщить();
                    
                    Отказ = Истина;	      
                КонецЕсли;	               
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2024-02-22_18-46-55.png" class="screen-2" alt="">
    <p>Кроме того, в конфгурации существует глобальная команда "ГенерацияТоваров", которая заполняет справочник Товары элементами в проверочных целях.</p>
    <p>После нажатия на эту кнопку пользователю выдаётся сообщение о предполагаемых действиях и о том, что он может прервать выполнение этих действий:</p>
    <div class="code-style">
        <pre>
            --модуль общей команды "ГенерацияТоваров"

            &НаКлиенте
            Процедура ОбработкаКоманды(ПараметрКоманды, ПараметрыВыполненияКоманды)
                ПоказатьПредупреждение(Новый ОписаниеОповещения("ОбработкаКомандыЗавершение", ЭтотОбъект), 
                                "Будет добавлено 1000 товаров. 
                                |Выполнение можно прервать, нажав сочетание клавиш Ctrl + Break",
                                ,
                                "Добавление товаров"); 
            КонецПроцедуры
        </pre>
    </div>
    <p>Для этого используется предупреждение, которое показывается в блокирующем окне. Это окно не останавливает исполнение программного кода, но блокирует весь интерфейс до тех пор, пока пользователь не ознакомится с этим сообщением и не нажмёт кнопку ОК.</p>
    <img src="../img/1С-1/2024-02-22_21-28-56.png" class="screen" alt="">
    <p><span class="vue-b">Команда "ГенерацияТоваров" и правда добавит 1000 товаров. Чтобы удалить все эти товары, я добавил кнопку в форму списка справочника Товары. Кнопка называется "Выделить все товары". По кнопке выделяются все объекты в списке и можно через меню "Ещё" удалить их все сразу. Вот набор указаний для кнопки:</span></p>
    <div class="code-style">
        <pre>
            --модуль формы списка справочника Товары

            &НаКлиенте
            Процедура ВыделитьВсеТовары(Команда)
                МаасивСсылок = ПолучитьВсеТоварыИзБазы();

                Для каждого Ссылка Из МаасивСсылок Цикл
                    Элементы.Список.ВыделенныеСтроки.Добавить(Ссылка);
                КонецЦикла;		
            КонецПроцедуры 

            &НаСервереБезКонтекста
            Функция ПолучитьВсеТоварыИзБазы() 
                МассивСсылок = Новый Массив;
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	Товары.Ссылка КАК Ссылка
                    |ИЗ
                    |	Справочник.Товары КАК Товары";
                
                РезультатЗапроса = Запрос.Выполнить();
                ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
                
                Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
                    МассивСсылок.Добавить(ВыборкаДетальныеЗаписи.Ссылка);	
                КонецЦикла;	

                Возврат МассивСсылок;
            КонецФункции
        </pre>
    </div>
    <p><span class="vue-b">Я искал в инете, сам динамический список не перебирается в цикле, как и ТаблицаФормы в элементах формы.</span></p>
    <p>Далее. Предупреждение показывается с помощью немодального метода ПоказатьПредупреждение(). Первым параметром в него передаётся описание оповещения, указывающее на экспортную процедуру обработку оповещения "ОбработкаКомандыЗавершение()", которая будет выполнена после закрытия окна предупреждения.</p>
    <p>Таким образом, только после того, как пользователь закроет окно предупреждения кнопкой ОК, происходит добавление элементов в справочник Товары:</p>
    <div class="code-style">
        <pre>
            --модуль общей команды "ГенерацияТоваров"

            <span class="vue-g">//эта процедура вызывается после закрытии окна предупреждения</span>
            &НаКлиенте
            Процедура ОбработкаКомандыЗавершение(ДополнительныеПараметры) Экспорт
                <span class="vue-g">//этот счётчик добавляет проценты в поле состояния для видимости хода добавления товаров в справочник</span>
                Для Счетчик = 0 по 9 Цикл
                    ПоследняяДобавленнаяСсылка = НаСервере(Счетчик);

                    Состояние("Добавление товаров",
                    10 + Счетчик * 10,
                    "Выполнятеся автоматическое заполнение справочника Товары",
                    БиблиотекаКартинок.СоздатьЭлементСписка);
                    
                    <span class="vue-g">//Предназначен для прерывания работы встроенного
                    //языка при нажатии пользователем клавиши Ctrl+Break.</span>
                    ОбработкаПрерыванияПользователя();
                КонецЦикла;
                
                
                <span class="vue-g">// Обновить список товаров на начальной странице</span>
                ОповеститьОбИзменении(ПоследняяДобавленнаяСсылка);
                
                <span class="vue-g">//по окончании добавления элементов справочника мы показываем
                //оповещение пользователю о окончании этого процесса</span>
                ПоказатьОповещениеПользователя(
                            "Данные заполнены",
                            ПолучитьНавигационнуюСсылку(ПоследняяДобавленнаяСсылка),
                            "Открыть последний добавленный товар",
                            БиблиотекаКартинок.Справочник, 
                            СтатусОповещенияПользователя.Важное);
            КонецПроцедуры
        </pre>
    </div>
    <p>Обратим внимание, что если бы код по добавлению товаров располагался сразу после показа предупреждения, а не в отдельном обработчике оповещения, то товары добавились бы соазу, не ожидая закрытия окна предупреждения. Потому что это окно немодальное и оно не останавливает исполнение программного кода.</p>
    <p>Добавление элементов в сравочник может быть выполнено только на сервере, и для этого используется серверная функция НаСервере(). Она добавляет в справочник 100 элементов:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Функция НаСервере(НомерВызова)
                Для Счетчик = 1 по 100 Цикл
                    ОбъектТовара = Справочники.Товары.СоздатьЭлемент();
                    ОбъектТовара.Наименование = "Товар_" + Строка(НомерВызова * 100 + Счетчик);
                    ОбъектТовара.Записать();
                КонецЦикла;
                
                Возврат ОбъектТовара.Ссылка;
            КонецФункции
        </pre>
    </div>
    <p>Для того, чтобы пользователь имел возможность прервать процесс добавления товаров в справочник, серверная функция вызывается в цикле несколько раз, т.е. добавление элементов выполняется порциями по 100 штук.</p>
    <p>Каждый раз после выполнения функции проверяется, не нажал ли пользователь сочетание клавиш Ctrl + Break. Для этого вызывается метод глобального контекста <b>ОбработкаПрерыванияПользователя()</b>.</p>
    <p>Кроме того, каждый раз после вызова серверной функции в нижнем правом углу экрана выводится окно состояния, отображающее ход процесса.</p>
    <p>В данном случае состояние используется, во-первых, чтобы информировать пользователя о том, что система выполняет какие то действия, а во-вторых, чтобы пользователь мог примерно оценить время, оставшееся до окончания действий.</p>
    <p>Серверная функция возвращает ссылку на последний элемент, добавленный в справочник Товары.</p>
    <p>Эта ссылка используется для того, чтобы после добавления всех элементов обновить список товаров, расположенный на начальной странице:</p>
    <div class="code-style">
        <pre>
            ОповеститьОбИзменении(ПоследняяДобавленнаяСсылка);   
        </pre>
    </div>
    <p>Также эта ссылка используется в оповещении, которое выдаётся по окончании процесса.</p>
    <p>Оповещение показывается на несколько секунд в правом нижнем углу экрана. Но, чтобы пользователь позднее мог ознакомиться с ним через центр оповещений, последним параметром в метод ПоказатьОповещениеПользователя() передаётся статус "Важное" системного перечисления "СтатусОповещенияПользователя". Ссылка на последний добавленный товар позволяет открыть его форму сразу же из оповещения, или позже, из центра оповещений.</p>
    <img src="../img/1С-1/2024-02-24_10-30-09.png" class="screen" alt="">
    <p>Сообщение о том, что система закончила выполнение действий, является чисто информационным. В общем случае оно не требует от пользователя никаких действий. Поэтому по умолчанию используются оповещения со статусом "Информация", исчезающие с экрана в случае отсутствия внимания к нему со стороны пользователя.</p>






    <h3 class="header-style2" id="chapter3.14">Глава 3.14. Обновление данных в динамических списках. Стр 576</h3>
    <p>Зачастую запись тех или иных объектов в БД выполняется программно, из встроенного языка. Запись в БД возможна только на сервере, и в этом случае, естественно, открытые в клиентском приложении формы ничего не знают о том, что данные в БД изменились. А ведь эти формы могут содержать списки тех объектов, которые мы изменяли или добавляли в БД.</p>
    <p>Сама по себе информация в этих списках не обновится. Разработчик должен предпринять действия, для того чтобы динамические списки, существующие в открытых формах, перечитали данные и начали отображать новую, изменённую информацию.</p>
    <p>Для этого существует несколько способов, которые можно применять в зависимости от конкретного случая. Рассмотрим их по порядку, от наиболее универсального к наименее универсальному.</p>
    <p><span class="vue-b">Примеры можно посмотреть в базе "Обновление динамических списков".</span></p>

    <p class="title-size16"><b id="chapter3.14.1">Метод "ОповеститьОбИзменениях()"</b></p>
    <p>Наиболее простым и наиболее частым является метод глобального контекста <b>ОповеститьОбИзменении()</b>. В этот метод передаётся единственный параметр - ссылка на объект (или ключ записи), об изменении которого нужно оповестить формы.</p>
    <p>Этот метод уведомит все динамические списки, расположенные в созданных на клиенте формах, об изменении этого объекта, и они обновят свои данные. Но есть особенность: этот метод не обновит те динамические списки, у которых не задана основная таблица.</p>
    <p>Преимущество этого способа заключается в том, что нам не нужно знать об открытых формах, не нужно "влезать" внутрь этих форм - платформа сама всё сделает.</p>
    <p>Чтобы посмотреть, как будут обновляться различные формы (включая формы, размещённые на начальной странице), в конфигурации созданы "обычная" основная форма списка и специальная форма списка справочника Товары, в которой для динамического списка не назначена основная таблица.</p>
    <p>Для удобства эти формы, а также форма обработки "ВариантыОбновления" помещены на начальную страницу приложения:</p>
    <img src="../img/1С-1/2024-02-24_16-30-26.png" class="screen" alt="">
    <p>Кроме того, обе формы списка программно открыты в окнах клиентского приложения из модуля управляемого приложения при начале работы системы:</p>
    <div class="code-style">
        <pre>
            --модуль приложения

            Процедура ПриНачалеРаботыСистемы()
                <span class="vue-g">//ОткрытьФорму("Обработка.ВариантыОбновления.Форма",,,,,,,РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);</span>
                ОткрытьФорму("Справочник.Товары.ФормаСписка");
                ОткрытьФорму("Справочник.Товары.Форма.СпециальнаяФормаСписка");   
            КонецПроцедуры
        </pre>
    </div>
    <p>Предположим, в модуле формы обработки "ВариантыОбновления" существует серверная функция, добавляющая новый элемент в справочник Товары:</p>
    <div class="code-style">
        <pre>
            --модуль формы обработки

            &НаСервереБезКонтекста
            Функция ДобавитьЭлементНаСервере()
                ОбъектТовара = Справочники.Товары.СоздатьЭлемент();
                ОбъектТовара.Наименование = "Новый товар " + Строка(ТекущаяДата());
                ОбъектТовара.Записать();
                
                Возврат ОбъектТовара.Ссылка;
            КонецФункции
        </pre>
    </div>
    <p>Эта функция возвращает ссылку на тот товар, который был добавлен. А в процессе выполнения некоторого алгоритма на клиенте выполняется следующий набор указаний:</p>
    <div class="code-style">
        <pre>
            СсылкаНаНовыйЭлемент = ДобавитьЭлементНаСервере();
	        ОповеститьОбИзменении(СсылкаНаНовыйЭлемент);
        </pre>
    </div>
    <p>Сначала вызывается серверная фукнция и добавляется новый товар, а затем полученная ссылка передаётся в метод ОповеститьОбИзменении().</p>
    <p>В итоге во всех открытых формах, отображающих список товаров, появится новый товар. Исключением будет лишь специальная форма списка, в которой для динамического списка не назначена основная форма:</p>
    <img src="../img/1С-1/2024-02-24_16-47-31.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter3.14.2">Метод "Оповестить()"</b></p>
    <p>Второй метод связан с тем, что мы заранее должны прописать некоторый код в тех формах, в которых нужно что-то обновлять. Но зато тут уже мы можем полностью управлять этими формами так, как хочется.</p>
    <p>Суть этого способа заключается в том, что существует метод глобального контекста <b>Оповестить()</b>. Он отсылает оповещение всем созданным (не обязательно открытым) формам. Если в форме описан обработчик события <b>ОбработкаОповещения()</b>, то в этом обработчике можно обработать это оповещение и выполнить нужное изменение формы.</p>
    <p>Например, как и раньше, в серверной процедуре добавляется новый товар. После этого вызывается метод Оповестить(), в котором первым параметром мы передаём придуманное разработчиком имя события, по которой в форме можно будет понять, какой алгоритм следует выполнить:</p>
    <div class="code-style">
        <pre>
            СсылкаНаНовыйЭлемент = ДобавитьЭлементНаСервере();
	        Оповестить("ОбновитьСписокТоваров");
        </pre>
    </div>
    <p>Во всех формах, в которых может понадобиться обновление списка товаров, описывается обработчик события ОбработкаОповещения(). Например, он может выглядеть след. образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка

            &НаКлиенте
            Процедура ОбработкаОповещения(ИмяСобытия, Параметр, Источник)
                Если ИмяСобытия = "ОбновитьСписокТоваров" Тогда
                    Элементы.Список.Обновить();		
                КонецЕсли;		
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Т.е. Оповещение() раздаёт всем созданным формам оповещение в виде произвольной строки(имя события), а обработчики события формы ОбработкаОповещения() получив это имя, запускаются в каждой форме, реагируя на полученное оповещение и выполняют написанный в них набор указаний. </span></p>
    <p>В итоге во всех открытых формах, в которых существует обработчик события ОбработкаОповещения(), появится новый товар. В том числе и в тех формах, которые расположены на начальной странице</p>

    <p class="title-size16"><b id="chapter3.14.3">Обновление формы извне</b></p>
    <p>Способ описанный далее, можно использовать тогда, когда нам точно известна форма, в которой нужно что-то обновить, и известно, что эта форма открыта.</p>
    <p>Смысл заключается в том, чтобы получить саму открытую форму, получить список, расположенный в этой форме, и обновить его.</p>
    <p>Для получения формы используется метод глобального контекста ПолучитьФорму().</p>
    <div class="code-style">
        <pre>
            СсылкаНаНовыйЭлемент = ДобавитьЭлементНаСервере();
	        Форма = ПолучитьФорму("Справочник.Товары.ФормаСписка");
	        Форма.Элементы.Список.Обновить();
        </pre>
    </div>
    <p>Т.к. четвёртый параметр в этом методе не указывается, то будет получена уже открытая форма. Затем обновляется список полученный в этой форме.</p>
    <p>В итоге в форме списка товаров появится новый товар. Остальные формы останутся без изменений.</p>
    <p>Этот способ имеет существенный недостаток - нужно точно знать устройство формы, как называется её таблица, отображающая данные динамического списка. Если по каким то причинам её имя изменится, форма перестанет обновляться.</p>

    <p class="title-size16"><b id="chapter3.14.4">Коллекция окон</b></p>
    <p>Последний, четвёртый, способ удобен тогда, когда нужно выполнить одинаковые действия со всеми открытыми формами.</p>
    <p>Можно получить коллекцию открытых окон приложения, обойти её и от каждого окна попробовать получить содержащуюся в нём форму. Затем, как и в предыдущем способе, обновить список, расположенный в этой форме.</p>
    <p>Коллекцию открытых окон приложения  можно получить с помощью метода глобального контекста <b>ПолучитьОкна()</b>.</p>
    <div class="code-style">
        <pre>
            СсылкаНаНовыйЭлемент = ДобавитьЭлементНаСервере();
	
            Окна = ПолучитьОкна();
            Для Каждого ТекущееОкно Из Окна Цикл
                
                //Сообщить("Заголовок: " + ТекущееОкно.Заголовок);
                //Сообщить("Основное окно приложения: " + ТекущееОкно.Основное);
                //Сообщить("Начальная страница: " + ТекущееОкно.НачальнаяСтраница);
                //Сообщить("Форм в окне: " + ТекущееОкно.Содержимое.Количество());
                    
                Если ТекущееОкно.Содержимое.Количество() Тогда
                    Для каждого Форма Из ТекущееОкно.Содержимое Цикл
                        //Сообщить("    Форма : " + Форма.ИмяФормы);
                        СписокТоваров = Форма.Элементы.Найти("Список");
                        Если СписокТоваров &lt;> Неопределено Тогда   // если есть элемент Список - обновить его
                            СписокТоваров.Обновить();
                        КонецЕсли;	
                    КонецЦикла;
                КонецЕсли;
            КонецЦикла
        </pre>
    </div>
    <p>В этом примере коллекция открытых окон обходится в цикле. У каждого окна изучается свойство "Содержимое", в котором содержится фиксированный массив форм, размещённых на начальной странице, а также открытых в окнах клиентского приложения. Элементы этого массива имееют тип "ФормаКлиентскогоПриложения". Свойство "Содержимое" для основного окна приложения (с установленным свойством Основное) всегда содержит пустой массив.</p>
    <p>Если массив не пустой, элементы этого массива обходятся в цикле. В каждой текущей форме ищется элемент с именем Список, и если он есть, то он обновляется.</p>
    <p>На самом деле алгоритм поиска того, что нужно обновлять, может быть долее сложным. Ведь совсем не обязательно таблица будет иметь стандартное имя Список, да и хорошо бы проверить тип объектов, которые отображаются в этом списке... Поэтому здесь просто приведён один из возможных способов тех действий, которые требуются выполнить в открытых формах.</p>
    <p>В итоге список товаров будет обновлён во всех открытых формах, включая формы, расположенные на начальной странице.</p>





    <h3 class="header-style2" id="chapter3.15">Глава 3.15. Оформление списков. Стр 584</h3>
    <p>"1С:Предприятие" позволяет различным образом оформлять данные, представленные в списках</p>
    <p>Самые большие возможности оформления предоставляют динамические списки. Для них можно задавать отбор, сортировку, группировать данные по значению и применять условное оформление. Эти возможности доступны разработчику и пользователю в режиме взаимодействия вручную с настройками.</p>
    <p>Возможности по оформлению статических списков (табличных частей, таблиц знаячений, деревьев значений и пр.) значительно меньше. К ним может быть применено только условное оформление формы, которое разработчик задаёт в настройках конфигуратора.</p>
    <p>Важно понимать, что, хотя динамические списки также можно оформить с помощью условного оформления формы, в которой они находятся, делать этого не нужно, т.к. это не эффективно.</p>
    <p>Однако все упомянутые возможности оформления списков доступны из встроенного  языка. Таким образом, разработчик может не только сделать собственный алгоритм оформления динамического списка, но и предоставить, например, пользователю возможность задать условное оформление для табличной части документа.</p>
    <p>Рассмотрим на двух примерах, каким образом можно программно оформить "обычные" и динамические списки.</p>

    <p class="title-size16"><b id="chapter3.15.1">Динамические списки</b></p>
    <p>Для того чтобы познакомиться с возможностями оформления динамического списка, создадим четыре команды, которые в режиме "1С:Предприятия" позволяет нам задать отбор, порядок, группировку и условное оформление списка документов.</p>
    <p><span class="vue-b">Примеры можно посмотреть в базе "Оформление списков".</span></p>
    <p><b id="chapter3.15.1.1">Отбор</b></p>
    <p>Любое оформление динамических списков возможно на клиенте. Поэтому для программной установки отбора в списке накладных мы будем использовать локальную команду формы списка. Обработчик этой команды выглядит следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка документа Накладная

            &НаКлиенте
            Процедура Отбор(Команда)
                Отбор = Список.КомпоновщикНастроек.Настройки.Отбор.Элементы;
                
                Если Отбор.Количество() > 0 Тогда 
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Отбор уже задан. Команда не выполнена.";
                    Сообщение.Сообщить();
                    Возврат;
                КонецЕсли;
                
                УсловиеОтбора = Отбор.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
                УсловиеОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("НаКонтроле");
                УсловиеОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
                УсловиеОтбора.ПравоеЗначение = Истина;
                
                Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Моя заметка!!! Не совсем понятно что такое Компановщик настроек у списка, но могу предположить что это те настройки, которые в пользовательском режиме открываются в форме списка по кнопке "Еще - Настроить список...". Вот нарисовал картинку, какие свойства во встроенном языке соотвествуют настройкам в пользовательской части:</span></p>
    <img src="../img/1С-1/2024-02-25_09-25-20.png" class="screen" alt="">
    <p>"Список" это реквизит формы, содержащий динамический список. Его свойство Отбор может содержать произвольное количество элементов, описывающих условия отбора в этом списке. Эти условия могут быть заданы разработчиком в конфигураторе, либо пользователем или программно из встроенного языка.</p>
    <p>Мы будем получать доступ к настройкам списка, заданным в конфигураторе. Они содержатся в коллекции настроек компоновки данных, к которой мы получаем доступ с помощью свойства динамического списка "КомпановщикНастроек" (Список.КомпановщикНастроек.Настройки):</p>
    <img src="../img/1С-1/2024-02-25_09-43-04.png" class="screen" alt="">
    <p>Прежде чем ставить собственные условия отбора в списке, мы должны каким то образом обработать случай, когда в списке уже имеются условия отбора.</p>
    <p>В жизни возможны различные алгоритмы, но, поскольку у нас всего лишь показательный пример, мы поступим просто. Если для динамического списка уже заданы какие-то условия отбора, мы не будем предпринимать никаких действий и предложим пользователю самостоятельно удалить имеющиеся условия отбора:</p>
    <div class="code-style">
        <pre>
            Отбор = Список.КомпоновщикНастроек.Настройки.Отбор.Элементы;
            
            Если Отбор.Количество() > 0 Тогда 
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Отбор уже задан. Команда не выполнена.";
                Сообщение.Сообщить();
                Возврат;
            КонецЕсли;
        </pre>
    </div>
    <p>Если же никаких условий отбора ещё не задано, мы зададим одно условие. Для этого в коллекцию элементов отбора добавим новый элемент:</p>
    <div class="code-style">
        <pre>
            УсловиеОтбора = Отбор.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
        </pre>
    </div>
    <p>В простом случае отбора может быть перечислено несколько элементов, которые объединяются по условию <b>И</b>. В более сложных случаях отборов несколько элементов могут объединяться в группы, и для каждой группы можно задать собственные условия объединения элементов: И, ИЛИ, НЕ.</p>
    <p>Таким образом, в коллекции условий отбора могут находится как элементы, так и группы. В нашем простом примере мы добавляем один элемент, но если мы захотим формировать сложные условия, то нужно будет добавлять группы (Тип("ГруппаЭлементовОтбораКомпоновкиДанных")), устанавливать их свойство "ТипГруппы" и уже в эти группы добавлять отдельные элементы.</p>
    <p>Итак, после того как элемент добавлен, нужно задать условие отбора.</p>
    <p>У нашей накладной есть булев реквизит "НаКонтроле", который проставляется для накладных, требующих "особого внимания".</p>
    <p>Мы хотим, чтобы в итоге наших действий в списке отображались только те накладные, которые на котроле.</p>
    <p>Условие отбора задаётся с помощью свойств "ЛевоеЗначение", "ВидСравнения" и "ПравоеЗначение".</p>
    <p>В нашем случае левое значение - это поле "НаКонтроле":</p>
    <div class="code-style">
        <pre>
            УсловиеОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("НаКонтроле");
        </pre>
    </div>
    <p>Это поле мы создаём конструктором Новый, указывая имя поля.</p>
    <p>Условие сравнения - равеноство. Оно задаётся с помощью системного перечисления "ВидСравненияКомпоновкиДанных".</p>
    <p>Правое значение Истина.</p>
    <p>Таким образом должны быть отобраны только те накладные, у которых поле "НаКонтроле" содержит значение Истина.</p>
    <p>И в заключение мы должны загрузить изменённые настройки обратно в компановщик настроек динамического списка:</p>
    <div class="code-style">
        <pre>
            Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
        </pre>
    </div>
    <p>В пользовательском режиме при нажатии на кнопку "Отбор" мы увидим в списке отобранные накладные по полю "НаКонтроле". Если открыть найтройку списка - "Еще - Настроить список", то увидим, что появилось наше условие отбора.</p>
    <p>Это то самое условие, которое мы добавили из встроенного языка. Пользователь может его изменить, отключить, удалить. Кроме того, у элемента отбора (и у других настроек) есть свойство "РежимОтображения", с помощью которого он может сделать настройку невидимой и недоступной для изменения в пользовательском режиме:</p>
    <div class="code-style">
        <pre>
            УсловиеОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
        </pre>
    </div>
    <p><b id="chapter3.15.1.2">Сортировка</b></p>
    <p>Для сортировки динамического списка будем использовать локальную команду формы "Сортировка" со следующим текстом:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка документа Накладная

            &НаКлиенте
            Процедура Сортировка(Команда)
                Сортировка = Список.КомпоновщикНастроек.Настройки.Порядок.Элементы;
                
                Если Сортировка.Количество() = 1 Тогда                  
                    Сортировка[0].Использование = Ложь;                  
                ИначеЕсли Сортировка.Количество() > 1 Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Уже задано несколько условий сортировки. Команда не выполнена.";
                    Сообщение.Сообщить();
                    Возврат;                   
                КонецЕсли;
                
                УсловиеСортировки = Сортировка.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
                УсловиеСортировки.Поле = Новый ПолеКомпоновкиДанных("Склад");
                УсловиеСортировки.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных.Убыв;
                
                Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2024-02-25_13-00-08.png" class="screen" alt="">
    <p>Как правило, динамический список всегда содержит некоторое условие сортировки. Например, список документов платформа по умолчанию сортирует по дате документа:</p>
    <img src="../img/1С-1/2024-02-25_13-17-46.png" class="screen" alt="">
    <p>Поэтому изучать имеющиеся условия сортировки мы будем следующим образом. Если условие одно, будем считать, что это условие задано платформой. Мы будем отклбчать его использование и добавлять собственное условие. Если условий несколько, сообщим об этом пользователю и не будем выполнять никаких действий:</p>
    <div class="code-style">
        <pre>
            Сортировка = Список.КомпоновщикНастроек.Настройки.Порядок.Элементы;
            
            Если Сортировка.Количество() = 1 Тогда
                Сортировка[0].Использование = Ложь;
            ИначеЕсли Сортировка.Количество() > 1 Тогда
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Уже задано несколько условий сортировки. Команда не выполнена.";
                Сообщение.Сообщить();
                Возврат;    
            КонецЕсли;
        </pre>
    </div>
    <p>После этого добавляем своё новое условие упорядочивания:</p>
    <div class="code-style">
        <pre>
             УсловиеСортировки = Сортировка.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
        </pre>
    </div>
    <p>Поскольку мы собираемся сами указать, по какому полю упорядочивать список, мы добавляем "обычный" элемент порядка. Но существует возможность добавить и автоэлемент порядка(Тип("АвтоЭлементПорядкаКомпоновкиДанных")). Тогда платформа сама, на основе имеющегося описания запроса динамического списка, определит, по каким полям нужно выполнять сортировку.</p>
    <p>Итак, после того как новый элемент порядка добавлен, нужно указать поле, по которому будет выполняться сортировка, и направление сортировки.</p>
    <p>В нашем случае сортировать будем по полю Склад:</p>
    <div class="code-style">
        <pre>
            УсловиеСортировки.Поле = Новый ПолеКомпоновкиДанных("Склад");
        </pre>
    </div>
    <p>А направление сортировки будет по убыванию значения этого поля:</p>
    <div class="code-style">
        <pre>
            УсловиеСортировки.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных.Убыв;
        </pre>
    </div>
    <p>В заключение загружаем изменённые настройки обратно в помпоновщик настроек динамического списка:</p>
    <div class="code-style">
        <pre>
            Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
        </pre>
    </div>
    <p>Поскольку поле Склад - это ссылочное поле, то сортировка фактически будет выполняться не по самим значениям ссылок, а по их представлениям, т.е. по наименованиям складов, которые являются строками.</p>
    <p>Запустим конфигурацию в режиме "1С:Предприятие". Откроется список накладных, который по умолчанию упорядочен платформой по возрастанию даты:</p>
    <img src="../img/1С-1/2024-02-25_14-19-06.png" class="screen" alt="">
    <p>После того как мы выполним команду "Сортировка", список будет опорядочен по убыванию наименования склада.</p>
    <img src="../img/1С-1/2024-02-25_14-23-13.png" class="screen" alt="">
    <p>Если мы откроем настройку списка, то увидим, что существует два условия упорядочивания:</p>
    <img src="../img/1С-1/2024-02-25_14-21-40.png" class="screen" alt="">
    <p>Первое - эта упорядочивание по дате по умолчанию платформой, которую мы отключили, но не удалили. А второе - это то самое условие, котрое мы добавили из встроенного языка. Пользователь может его отключить или удалить.</p>
    <p><b id="chapter3.15.1.3">Группировка</b></p>
    <p>Для группировки динамического списка мы также будем использовать локальную комнду формы:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка документа Накладная

            &НаКлиенте
            Процедура Группировка(Команда)
                
                СтруктураСписка = Список.КомпоновщикНастроек.Настройки.Структура;
                
                //Если ГруппировкаСписка.Количество() > 0 Тогда
                Если СтруктураСписка.Количество() > 0 Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Группировка уже задана. Команда не выполнена.";
                    Сообщение.Сообщить();
                    Возврат;
                КонецЕсли;
                
                ГруппировкаСписка = СтруктураСписка.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
                //ЭлементГруппировки = ГруппировкаСписка.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
                ЭлементГруппировки = ГруппировкаСписка.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
                ЭлементГруппировки.Поле = Новый ПолеКомпоновкиДанных("Поставщик");
                Элементы.Список.НачальноеОтображениеДерева = НачальноеОтображениеДерева.НеРаскрывать;
                
                Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2024-02-26_10-56-04.png" class="screen" alt="">
    <p>Здесь, также как и в случае с отбором, для простоты примера не будем выполнять никаких действияй, если условия группировки уже заданы.</p>
    <p>С помощью свойств компоновщика настроек динамического списка (Список.КомпоновщикНастроек.Настройки.Структура) мы получаем доступ к коллекции элементов структуры настроек компоновки данных. И проверяем, есть ли элементы в этой коллекции.</p>
    <p>Если условия группировки не заданы, добавим новый элемент группировки:</p>
    <div class="code-style">
        <pre>
            ГруппировкаСписка = СтруктураСписка.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
            ЭлементГруппировки = ГруппировкаСписка.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
        </pre>
    </div>
    <p>Сначала мы добавляем в коллекцию элементов структуры настроек компоновки данных элемент типа "ГруппировкаКомпоновкиДанных".</p>
    <p>Как и в случае с упорядочиванием, можно использовать автополя группировки, но мы добавим обычное поле, чтобы самостоятельно задать его значение.</p>
    <p>В набор полей группировки добавляем элемент типа "ПолеГруппировкиКомпоновкиДанных". Группировать список будем по значению поля Поставщик.</p>
    <div class="code-style">
        <pre>
            ЭлементГруппировки.Поле = Новый ПолеКомпоновкиДанных("Поставщик");
        </pre>
    </div>
    <p>Дополнительно, для "красоты", укажем, что все группы списка должны быть свёрнуты.. Для этого мы обратимся не к динамическому списку (реквизиту), а к таблице формы, которая этот динамический список отображает. Воспользуемся её свойством "НачальноеОтображениеДерева":</p>
    <div class="code-style">
        <pre>
            Элементы.Список.НачальноеОтображениеДерева = НачальноеОтображениеДерева.НеРаскрывать;
        </pre>
    </div>
    <p>У системного перечисления, которое мы использовали, есть ещё и два дрцгих значения: "РаскрыватьВерхнийУровень" и "РаскрыватьВсеУровни". При необходимости можно использовать их.</p>
    <p>Платформа не предоставляет возможности как-либо скрывать/раскрывать отдельные группы сгруппированного динамического списка из встроенного языка. Это можно сделать только в пользовательском режиме.</p>
    <p>В заключение загружаем изменённые настройки обратно в компоновщик настроек динамического списка.</p>
    <p>В пользовательском режиме при нажатии на кнопку "Группировка" мы получим сгруппированный список по поставщику.</p>
    <p>Все группы будут свёрнуты, за исключением той, в которой находится текущая строка списка.</p>
    <p><b id="chapter3.15.1.4">Условное оформление</b></p>
    <p>Для условного оформления динамического списка будем использовать локальную команду формы со следующим списком:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка документа Накладная

            &НаКлиенте
            Процедура УсловноеОформление(Команда)
                УО = Список.КомпоновщикНастроек.Настройки.УсловноеОформление.Элементы;
                
                Если УО.Количество() > 0 Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Условное оформление уже задано. Команда не выполнена.";
                    Сообщение.Сообщить();
                    Возврат;
                КонецЕсли;
                
                ЭлементУО = УО.Добавить();
                
                <span class="vue-g">// Оформление: цвет фона светлый лосось</span>
                ЭлементУО.Оформление.УстановитьЗначениеПараметра("ЦветФона", WebЦвета.ЛососьСветлый);
                
                <span class="vue-g">// Условие: поле НаКонтроле равно Истина</span>
                ЭлементУсловия = ЭлементУО.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
                ЭлементУсловия.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("НаКонтроле");
                ЭлементУсловия.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
                ЭлементУсловия.ПравоеЗначение = Истина;
                
                <span class="vue-g">// Оформляемое поле: Номер </span>
                ОформляемоеПоле = ЭлементУО.Поля.Элементы.Добавить();
                ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных("Номер");
                
                Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2024-02-26_11-20-35.png" class="screen" alt="">
    <img src="../img/1С-1/2024-02-26_17-09-00.png" class="screen" alt="">
    <p>Здесь для простоты примера не будем выполнять никаких действий, если условное оформление уже задано.</p>
    <p>Если же условное оформление не задано, добавим новый элемент, описывающий условное оформление:</p>
    <div class="code-style">
        <pre>
            ЭлементУО = УО.Добавить();
        </pre>
    </div>
    <p>Теперь для этого элемента нужно зададть:</p>
    <ul class="list">
        <li>само оформлениеЮ которое будет применяться (цвет, жирность начертания(шрифта) и пр.);</li>
        <li>условие, при выполнении которого это оформление будет применяться;</li>
        <li>поля, которые таким образом будут оформлены;</li>
    </ul>
    <p>Оформление задаётся путём установки значений имеющихся предопределённых параметров оформления. В нашем примере мы указываем, что поля будут выделяться другим цветом фона - "светлый лосось".</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Оформление: цвет фона светлый лосось</span>
            ЭлементУО.Оформление.УстановитьЗначениеПараметра("ЦветФона", WebЦвета.ЛососьСветлый);
        </pre>
    </div>
    <p>Для задания условия, при котором будет применяться оформление, мы используем уже знакомый нам по первому примеру отбор компоновки данных. В коллекцию условий отбора добавим новый элемент и зададим для него левое значение, вид сравнения и правое значение:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Условие: поле НаКонтроле равно Истина</span>
            ЭлементУсловия = ЭлементУО.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
            ЭлементУсловия.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("НаКонтроле");
            ЭлементУсловия.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
            ЭлементУсловия.ПравоеЗначение = Истина;
        </pre>
    </div>
    <p>В итоге оформление будет применяться в тех строках, где поле "НаКонтроле" имеет значение Истина. Т.е мы "подсветим" документы, требующие "особого внимания".</p>
    <p>В заключение укажем, какие поля будут "подсвечиваться". Если не указывать ничего, то будет "подсвечена" вся строка. Но мы добавим новое поле в коллекцию оформляемых полей и укажем, что оформляться будет только одно поле - Номер:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Оформляемое поле: Номер </span>
            ОформляемоеПоле = ЭлементУО.Поля.Элементы.Добавить();
            ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных("Номер");
        </pre>
    </div>
    <p>Загружаем изменённые настройки обратно в компоновщик настроек динамического списка:</p>
    <div class="code-style">
        <pre>
            Список.КомпоновщикНастроек.ЗагрузитьНастройки(Список.КомпоновщикНастроек.Настройки);
        </pre>
    </div>
    <p>Запустим конфигурацию в режиме "1С:Предприятие". Откроется список накладных, который по умолчанию не содержит никакого условного оформления.</p>
    <img src="../img/1С-1/2024-02-26_17-34-57.png" class="screen" alt="">
    <p>После того как мы выполним команду "Условное оформление", номера документов "0000000002" "000000005" будут выделены цветом фона. Именно эти документы находятся на контроле:</p>
    <img src="../img/1С-1/2024-02-26_17-38-08.png" class="screen" alt="">
    <p>Если мы откроем настройку, то увидим, что появилось условное оформление.</p>
    <p>Это то самое условие, которое мы добавили из встроенного языка. Пользователь может его изменить, отключить, удалить.</p>

    <p class="title-size16"><b id="chapter3.15.2">Табличная часть</b></p>
    <p>Возможность условного оформления нединамических списков мы рассмотрим на примере табличной части документа. Будем выделять те строки в табличной части, в которых количество товара больше 10.</p>
    <p>При оформлении нединамических списков есть несколько особенностей.</p>
    <p>Во-первых, для динамических списков условное оформление является свойством самого реквизита формы.</p> 
    <img src="../img/1С-1/2024-02-27_10-23-34.png" class="screen" alt="">
    <p>Чтобы оформить нединамические списки, нужно использовать условное оформление самой формы.</p>
    <img src="../img/1С-1/2024-02-27_10-28-10.png" class="screen" alt="">
    <p>Во-вторых, задать оформление динамического списка можно прямо на клиенте. Условное же оформление формы можно задать только на сервере.</p>
    <p>В остальном программная работа с условным оформлением нединамических списков ничем не отличается от рассмотренного выше примера.</p>
    <p>Для того чтобы оформить табличную часть накладаной, создадим локальную команду формы "Условное формление", в которой вызовем контекстную серверную процедуру:</p>
    <div class="code-style">
        <pre>
            --модуль формы документа Накладная

            &НаКлиенте
            Процедура УсловноеОформление(Команда)
                ОформитьНаСервере();
            КонецПроцедуры
        </pre>
    </div>
    <p>А в серверной процедуре выполним условное оформление:</p>
    <div class="code-style">
        <pre>
            --модуль формы документа Накладная

            &НаСервере
            Процедура ОформитьНаСервере()
                
                Если УсловноеОформление.Элементы.Количество() > 0 Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.Текст = "Условное оформление уже задано. Команда не выполнена";
                    Сообщение.Сообщить();
                    Возврат;
                КонецЕсли;	
                
                ЭлементУО = УсловноеОформление.Элементы.Добавить();
                
                // Оформление: цвет фона зеленая лужайка
                ЭлементУО.Оформление.УстановитьЗначениеПараметра("ЦветФона", WebЦвета.ЗеленаяЛужайка);
                
                // Условие: количество в табличной части больше 10
                ЭлементУсловия = ЭлементУО.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
                ЭлементУсловия.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Объект.Товары.Количество");
                ЭлементУсловия.ВидСравнения = ВидСравненияКомпоновкиДанных.Больше;
                ЭлементУсловия.ПравоеЗначение = 10;
                
                // Оформляемое поле: товар в табличной части 
                ОформляемоеПоле = ЭлементУО.Поля.Элементы.Добавить();
                ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных("ТоварыТовар");
                
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2024-02-27_10-35-10.png" class="screen" alt="">
    <p>Из особенностей здесь можно упомянуть об именах полей, которые используются в условии офрмления и в коллекции оформляемых полей. В динамических списках не вызывает затруднений указать правильное имя поля. Как правило, имена полей в реквизите(динамическом списке)  и в таблице совпадают. Так было в предыдущем примере:</p>
    <img src="../img/1С-1/2024-02-27_19-28-40.png" class="screen" alt="">
    <p>Мы накладывали условие на поле реквизита "НаКонтроле", в оформляли(подкрашивали) поле таблицы "Номер". При этом можно было не задумываться, в каком случае чьё поле указывается.</p>
    <p>В случае же с табличной частью имена по большей части не совпадают. Поэтому когда описывается условие оформления, нужно помнить, что указывается поле реквизита формы - "Объект.Товары.Количество":</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//откуда берём значение для условия</span>
            ЭлементУсловия.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Объект.Товары.Количество");
        </pre>
    </div>
    <img src="../img/1С-1/2024-02-27_19-49-44.png" class="screen-2" alt="">
    <p>А в коллекции оформляемых полей нужно указывать имя поля таблицы - "ТоварыТовар":</p>
    <img src="../img/1С-1/2024-02-27_19-54-54.png" class="screen-2" alt="">
    <div class="code-style">
        <pre>
            <span class="vue-g">//какое поле красим</span>
            ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных("ТоварыТовар");
        </pre>
    </div>
    <p>Теперь запустим конфигурацию в пользовательском режиме и откроем накладную №6. Её табличная часть не содержит никакого условного оформления:</p>
    <img src="../img/1С-1/2024-02-27_19-57-12.png" class="screen" alt="">
    <p>После того как мы выполним команду "Условное оформление", товар "Товар 2" будет выделен цветом фона, потому что количество товара больше 10:</p>
    <img src="../img/1С-1/2024-02-27_19-59-28.png" class="screen" alt="">
    <p>Пользователь не имеет возможности изменять условное оформление формы, поэтому в данном случае он не сможет отключить или удалить условное оформление, добавленное нами.</p>
    <p>Напоследок хочется сделать ещё одно небольшое замечание. В отличии от динамического списка, в условном оформлении формы обязательно нужно указывать оформляемые поля. Если хрчется выделить всю строку табличной части, нужно указывать все поля, которые в ней содержатся.</p>
    





    <h3 class="header-style2" id="chapter3.16">Глава 3.16. Дополнительные колонки в списках. Стр 607</h3>
    <p>Одной из часто встречающихся задач - добавить собственные колонки с дополнительными данными в динамический список или в табличную часть документа.</p>
    <p>Обе эти задачи решаются относительно просто. В случае с динамическим списком нужно использовать произвольный запрос, который выведет требуемые поля данных. В случае с табличной частью решение может быть более сложным, и оно зависит от того, какие именно данные хочется показать в дополнительных колонках.</p>

    <p class="title-size16"><b id="chapter3.16.1">Динамический список</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Дополнительные колонки в списках"</span></p>
    <p>Для примера возьмём стандартную форму списка справочника товаров, созданную конструктором. В этой форме находится динамический список, отображающий товары и некоторые их реквизиты("Наименование" и "Код"). Хотя на самом деле справочник содержит также реквизиты "Артикул" и "Сорт".</p>
    <img src="../img/1С-1/2024-02-28_19-46-38.png" class="screen-2" alt="">
    <p>Это поведение контсруктора по умолчанию. Он включает в список только необходимые реквизиты справочника. Другие реквизиты разработчик может добавить сам, если в этом есть нужда.</p>
    <p>У нас как раз есть такая необходимость. Мы хотим дополнительно отображать в этом списке колонки "Артикул" и "Сорт". Поскольку эти поля являются реквизитами справочника, отобразить их в списке будет очень просто.</p>
    <p>Если мы раскроем реквизит формы "Список", то увидим что нужные нам поля уже есть в составе этого реквизита:</p>
    <img src="../img/1С-1/2024-02-28_19-52-52.png" class="screen-2" alt="">
    <p>Платформа, создавая динамический список, всключила в него все поля, связанные со справочником "Товары", но только два поля поместила в таблицу формы: "Наименование" и "Код".</p>
    <p>Поэтому наша задача решается очень просто. Нужно перетащить мышью поля "Артикул" и "Сорт" в дерево элементов, в таблицу формы "Список".</p>
    <p>Если теперь запустить пользовательский режим, мы увидим, что в списке товаров отображаются две дополнительные колонки "Артикул" и "Сорт".</p>
    <p>Итак, мы рассмотрели простой случай, когда в динамический список нужно добавить доп. колонки, отображающие данные реквизитов.</p>
    <p>Теперь рассмотрим более сложный случай, когда доп. данные не являются реквизитами объекта, содержащегося в основной таблице динамического списка.</p>
    <p>В показной базе есть периодический регистр сведений "Цены". В нём храняяться цены на товары:</p>
    <img src="../img/1С-1/2024-02-28_20-02-01.png" class="screen-2" alt="">
    <p>Теперь наша задача будет заключаться в том, чтобы в списке товаров показать в отдельной колонке последнюю цену товара.</p>
    <p>Для этого нам понадобится изменить текст запроса, который содержится в динамическом списке. В свойствах реквизита формы "Список", содержащего динамический список, установим галочку "Произвольный запрос":</p>
    <img src="../img/1С-1/2024-02-28_20-47-19.png" class="screen" alt="">
    <p>После этого состав свойств этого реквизита изменится. Нажав на гиперссылку "Открыть" свойства "Настройка списка", мы увидим текст запроса заданный платфорой по умолчанию и сможем его изменить:</p>
    <div class="code-style">
        <pre>
            ВЫБРАТЬ
                СправочникТовары.Ссылка,
                СправочникТовары.ПометкаУдаления,
                СправочникТовары.Код,
                СправочникТовары.Наименование,
                СправочникТовары.Артикул,
                СправочникТовары.Сорт,
                СправочникТовары.Предопределенный,
                СправочникТовары.ИмяПредопределенныхДанных
            ИЗ
                Справочник.Товары КАК СправочникТовары
        </pre>
    </div>
    <p>Заменим существующий текст запроса следующим:</p>
    <div class="code-style">
        <pre>
            ВЫБРАТЬ
                СправочникТовары.Ссылка,
                СправочникТовары.ПометкаУдаления,
                СправочникТовары.Код,
                СправочникТовары.Наименование,
                СправочникТовары.Артикул,
                СправочникТовары.Сорт,
                СправочникТовары.Предопределенный,
                СправочникТовары.ИмяПредопределенныхДанных,
                ЦеныСрезПоследних.Цена
            ИЗ
                Справочник.Товары КАК СправочникТовары
                ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.Цены.СрезПоследних КАК ЦеныСрезПоследних
                ПО СправочникТовары.Ссылка = ЦеныСрезПоследних.Товар
        </pre>
    </div>
    <p>Этим запросом мы дополнительно выводим поле "Цена", соединяясь с виртуальной таблицей среза последних этого регистра.</p>
    <p>Нажмём ОК в дилоге "Динамический список", вернёмся к форме и развернём реквизит формы Список. Теперь среди его полей появилось поле "Цена". Как и раньше, просто перетащим его в таблицу формы:</p>
    <img src="../img/1С-1/2024-02-28_21-14-11.png" class="screen" alt="">
    <p>Теперь при запуске конфигурации в пользовательском режиме мы увидем в списке товаров доп. колонку "Цена".</p>

    <p class="title-size16"><b id="chapter3.16.2">Дополнительная обработка данных, получаемых динамическим списком</b></p>
    <p>Иногда в динамическом списке требуется отобразить некоторую вспомогательную информацию, которую затруднительно, непроизводительно или невозможно получить в рамках запроса динамического списка.</p>
    <p>Например, мы хотим по выбору какого-то промежутка времени отобразить сумарное количество поступившего товара:</p>
    <img src="../img/1С-1/2024-02-29_20-54-24.png" class="screen" alt="">
    <p>В этом случае можно воспользоваться обработчиком <b>ПриПолученииДанныхНаСервере</b> таблицы формы, отображающей данные динамического списка. Это внеконтекстный серверный обработчик, который позволяет выполнить дополнительную обработку данных, которые получает динамический список для отображения.</p>
    <p>Данное событие вызывается после получения данных динамическим списком в том случае, если динамическим списком получена хотя бы одна строка. В обработчик события ПриПолученииДанныхНаСервере() первым параметром передаётся имя таблицы формы, из которой вызван этот обработчик.</p>
    <p>Во втором параметре передаётся копия полных настроек динамического списка типа <b>НастройкиКомпоновкиДанных</b>. С помощью свойства настроек <b>ДополнительныеСвойства</b> предоставляется возможность передавать необходимые данные из формы во внеконтекстный обработчик.</p>
    <p>Третий параметр содержит коллекцию строк, которые будет отображать динамический список. В коллекции содержатся собственно данные (кроме строк группировок) и оформление этих данных.</p>
    <p>Необходимо учитывать, что настройка списка: отбор(в том числе поиск), сортировка, группировка, условное оформление - будут применяться к значениям, полученным до изменения их обработчиком.</p>
    <p>Для пояснения сказанного рассмотрим пример. Допустим, в списке товаров в отдельной колонке нам нужно выводить сумарное количество поступлений товаров за период, указанный в реквизите формы "Период".</p>
    <p>В жизни для этого, конечно, может использоваться регистр накопления остатков, но в нашей конфигурации его нет. Поэтому, в качестве примера, "оторванного от жизни", нам эта задача вполне подхидит.</p>
    <p>Откроем форму списка справочника Товары, добавим реквизит формы "Период" типа "СтандартныйПериод" и перетащим его в форму. Создадим у получившегося поля обработчик события "ПриИзменении" и заполним его следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы справочника Товары

            &НаКлиенте
            Процедура ПериодПриИзменении(Элемент)
                Список.КомпоновщикНастроек.Настройки.ДополнительныеСвойства.Вставить("ДатаНачала", Период.ДатаНачала);
                Список.КомпоновщикНастроек.Настройки.ДополнительныеСвойства.Вставить("ДатаОкончания", Период.ДатаОкончания);
                Элементы.Список.Обновить();
            КонецПроцедуры
        </pre>
    </div>
    <p>При изменении периода, за который нужно получить данные, мы сохраняем даты начала и окончания стандартного периода в структуре дополнительных свойств настроек динамического списка. И затем обновляем таблицу формы, отображающую данные списка.</p>
    <p>При этом сначала выполняется запрос, указанный в свойствах динамического списка. Добавим туда заготовку для поля "Поступило", в котором будет отображаться количество поступлений товара за заданный период:</p>
    <div class="code-style">
        <pre>
            ВЫБРАТЬ
                СправочникТовары.Ссылка,
                СправочникТовары.ПометкаУдаления,
                СправочникТовары.Код,
                СправочникТовары.Наименование,
                СправочникТовары.Артикул,
                СправочникТовары.Сорт,
                СправочникТовары.Предопределенный,
                СправочникТовары.ИмяПредопределенныхДанных,
                ЦеныСрезПоследних.Цена,
                <b>ВЫРАЗИТЬ (NULL КАК Число) КАК Поступило</b>
            ИЗ
                РегистрСведений.Цены.СрезПоследних КАК ЦеныСрезПоследних
                    ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Товары КАК СправочникТовары
                    ПО ЦеныСрезПоследних.Товар = СправочникТовары.Ссылка
        </pre>
    </div>
    <p>После получения данных запросом динамического списка вызывается событие "ПриПолученииДанныхНаСервере" таблицы формы, отображающей данные списка. В обработчике этого события мы и будем получать дополнительные данные и заполнять ими колонку списка "Поступило".</p>
    <p>Создадим обработчик события "ПриПолученииДанныхНаСервере" (обработчик должен быть внеконтекстным серверным) у таблицы формы список и заполним его следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы списка српавочника Товары

            &НаСервереБезКонтекста
            Процедура СписокПриПолученииДанныхНаСервере(ИмяЭлемента, Настройки, Строки)
                
                <span class="vue-g">//проверем, есть ли в структуре "ДополнительныеСвойства" даты
                //промежутка времени выбранные пользователем. Если есть, то
                //заполним переменные этими значениями</span>
                Если Настройки.ДополнительныеСвойства.Свойство("ДатаНачала") И
                        Настройки.ДополнительныеСвойства.Свойство("ДатаОкончания") Тогда
                    ДатаНачала = Настройки.ДополнительныеСвойства.ДатаНачала;
                    ДатаОкончания = Настройки.ДополнительныеСвойства.ДатаОкончания;
                Иначе
                    Возврат;
                КонецЕсли;
                
                <span class="vue-g">//переменные дат заполнились, значит можно выполнить запрос</span>
                Запрос = Новый Запрос;
                Запрос.Текст =
                    "ВЫБРАТЬ
                    |	МАКСИМУМ(НакладнаяТовары.Ссылка) КАК Ссылка,
                    |	СУММА(НакладнаяТовары.Количество) КАК ИтогКоличество,
                    |	НакладнаяТовары.Товар КАК Товар
                    |ИЗ
                    |	Документ.Накладная.Товары КАК НакладнаяТовары
                    |ГДЕ
                    |	НакладнаяТовары.Ссылка.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания
                    |	И	 НакладнаяТовары.Товар В(&Товары)
                    |	И	 НакладнаяТовары.Ссылка.Проведен = ИСТИНА
                    |
                    |СГРУППИРОВАТЬ ПО
                    |	НакладнаяТовары.Товар";
                    
                Запрос.УстановитьПараметр("Товары", Строки.ПолучитьКлючи());
                Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
                Запрос.УстановитьПараметр("ДатаОкончания", ДатаОкончания);
                
                Выборка = Запрос.Выполнить().Выбрать();

                <span class="vue-g">//данными из запроса теперь можно заполнить поле "Поступило" в 
                //строках динамического списка</span>
                Пока Выборка.Следующий() Цикл
                    СтрокаСписка = Строки[Выборка.Товар];
                    СтрокаСписка.Данные["Поступило"] = Выборка.ИтогКоличество;
                    СтрокаСписка.Оформление["Поступило"].УстановитьЗначениеПараметра("ЦветТекста", WebЦвета.Малиновый);
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>Сначала мы получаем из структуры дополнительных свойств настроек динамического списка, переданных в параметре Настройки, даты начала и окончания промежутка, заданного в реквизите формы "Период". Эти даты будут использоваться в качестве значений параметров "ДатаНачала" и "ДатаОкончания" запроса для получения данных.</p>
    <p>С помощью этого запроса выбираются данные из табличных частей накладных за период, группируются по товарам, а значение поля "Количество" суммируется по каждому товару.</p>
    <p>Массив выбираемых товаров ограничивается с помощью параметра Товары. Значение этого параметра получается с помощью метода ПолучитьКлючи() коллекции строк динамического списка, переданной в параметре Строки. Этот метод возвращает массив значений ключей для всех записей, которые будут отображаться динамическим списком.</p>
    <p>В цикле обхода результата выполнения запроса из коллекции Строки по ключу товара мы получаем соответствующую ему строку динамического списка. И устанавливаем у этой строки в колонке "Поступило" (с помощью свойств "Данные" и "Оформление") итоговое количество поступлений товара, а также выделяем это количество особым цветом текста.</p>
    <p>Надо заметить, что работа с оформлением ячеек динамического списка(Строки.Оформление) ничем не отличается от работы с оформлением ячеек системы компоновки данных. Мы изменили цвет текста колонки "Поступило" просто в целях показа.</p>
    <p>После завершения обработчика изменённый набор данных (коллекция Строки) будет передан клиентскому приложению для отображения таблицей формы, которая связана с динамическим списком.</p>
    <p>Проверим, как это работает.</p>
    <p>Раскроем реквизит Список и перетащим новое поле "Поступило", которое появилось благадаря запросу, в таблицу формы:</p>
    <img src="../img/1С-1/2024-03-01_08-33-57.png" class="screen-2" alt="">
    <p>запустим конфигурацию в режиме пользователя. Сначала колонка "Поступило" в списке товаров пуста, так как поле "Период" ещё незаполненно. Укажем период, и колонка "Поступило" сразу же заполнится итоговым количеством поступивших товаров по накладным за указанный промежуток времени. Причём данные в этой колонке будут выделены малиновым цветом текста:</p>
    <img src="../img/1С-1/2024-03-01_08-38-57.png" class="screen" alt="">
    <p>Если настроить список программно или в пользовательском режиме (например, задать отбор, условное оформление и т.д.), то настройки списка будут применены, но только к данным, полученным до изменения их обработчиком "ПриПолученииДанныхНаСервере".</p>
    <p>Необходимо заметить, что данные, передаваемые в этот обработчик события, уже обработаны условным оформлением динамического списка. Поэтому если требуется изменять оформление данных списка в зависимости от результата работы обработчика "ПриПолученииДанныхНаСервере", то следует менять условное оформление непосредственно в самом обработчике.</p>
    <p>Вот примерно схема, как устроен этот механизм:</p>
    <img src="../img/1С-1/2024-03-01_09-07-26.png" class="screen" alt="">
    
    <p class="title-size16"><b id="chapter3.16.3">Табличная часть</b></p>
    <p>Добавление колонок в табличную часть также рассмотрим на двух примерах. Опыты будем проводить со стандартной формой документа "Накладная". Его табличная часть содержит колонки - "Номер строки", "Товар", "Количество", "Цена" и "Сумма".</p>
    <p>Как мы помним из предыдущего примера, у товара есть реквизит "Артикул", который нам тоже хотелось бы видеть в табличной части этого документа.</p>
    <p>Чтобы добавить "Артикул", развернём реквизит формы Объект, развернём его табличную часть Товары, развернём реквизит Товар и увидим поле "Артикул". Перетащим его в таблицу формы Товары:</p>
    <img src="../img/1С-1/2024-03-01_09-22-04.png" class="screen-2" alt="">
    <p>Теперь останется только запустить йонфигурацию в режиме пользователя и убедиться, что в табличной части накладной отображается колонка с артикулом товара</p>
    <p>Всё просто, потому что добавляемые данные являются реквизитом товара, который сам по себе уже отображается в табличной части документа.</p>
    <p>Но как быть в том случае, когда добавляемые данные не являются реквизитом, а должны быть получены в результате некотрых вычислений?</p>
    <p>В этом случае всё будет несколько сложнее. В реквизит формы, описывающий табличную часть документаЮ нужно будет добавить собственное поле и заполнить его данными в определённых обработчиках формы документа.</p>
    <p>Чтобы не усложнять пример алгоритмами, не относящимися к сути, мы добавим в документ ещё один реквизит товара - "Сорт". Это позволит нам в обработчиках событий при заполнении собственной колонки данными просто писать Товар.Сорт. В жизни же здесь будет некоторый алгоритм, который по имеющейся ссылке на товар будет получать данные, необходимые для отображения.</p>
    <p>Итак, сначала в реквизит формы Объект, в табличную часть Товары, добавим собственное поле "СортТовара", имеющее тип ссылки на значение перечисления "Сорт". И затем перетащим это поле в таблицу формы Товары.</p>
    <img src="../img/1С-1/2024-03-01_16-22-02.png" class="screen-2" alt="">
    <p>Теперь начнём создавать обработчики событий, в которых колонка "СортТовара" будет заполняться данными.</p>
    <p>Для того чтобы доп. колонка была заполнена данными при чтении существующей накладной из БД, создадим обработчик события формы "При чтении на сервере":</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Заполнение дополнительной колонки при чтении существующего объекта</span>
            &НаСервере
            Процедура ПриЧтенииНаСервере(ТекущийОбъект)
                <span class="vue-g">// Алгоритм, по которому дополнительная колонка заполняется данными</span>
                Для Каждого СтрокаДанных Из Объект.Товары Цикл
                    СтрокаДанных.СортТовара = СтрокаДанных.Товар.Сорт;
                КонецЦикла
            КонецПроцедуры
        </pre>
    </div>
    <p>Для того чтобы поле доп. колонки было заполнено данными при изменении строки табличной части или при добавлении новой строки, создадим обработчик события "ПриИзменении" поля таблицы ТоварыТовар. Поскольку это клиентский обработчик формы, для получения данных из базы данных будем вызывать серверную процедуру:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Заполнение поля дополнительной колонки при изменении товара в табличной части</span>
            &НаКлиенте
            Процедура ТоварыТоварПриИзменении(Элемент)
                <span class="vue-g">// Алгоритм, по которому поле дополнительной колонки заполняется данными</span>
                ДанныеСтроки = Элементы.Товары.ТекущиеДанные;
                ДанныеСтроки.СортТовара = ПолучитьСортТовара(ДанныеСтроки.Товар);
            КонецПроцедуры

            &НаСервереБезКонтекста
            Функция ПолучитьСортТовара(Товар)
                Возврат Товар.Сорт;	
            КонецФункции
        </pre>
    </div>
    <p>Для того чтобы доп. колонка была заполнена данными при копировании или при вводе накладной на основании другого объекта, создадим обработчик события формы "При создании на сервере":</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Заполнение дополнительной колонки при копировании или вводе на основании</span>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
                <span class="vue-g">// Алгоритм, по которому дополнительная колонка заполняется данными</span>
                Для Каждого СтрокаДанных Из Объект.Товары Цикл
                    Если НЕ ЗначениеЗаполнено(СтрокаДанных.СортТовара) Тогда
                        СтрокаДанных.СортТовара = СтрокаДанных.Товар.Сорт;
                    КонецЕсли;
                КонецЦикла
            КонецПроцедуры
        </pre>
    </div>
    <p>И, наконец, предусмотрим случай, когда данные накладной могут быть изменены в процессе её записи. На этот случай создадим обработчик события формы "После записи на сервере":</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Заполнение дополнительной колонки если данные были изменены при записи</span>
            &НаСервере
            Процедура ПослеЗаписиНаСервере(ТекущийОбъект, ПараметрыЗаписи)
                <span class="vue-g">// Алгоритм, по которому дополнительная колонка заполняется данными</span>
                Для Каждого СтрокаДанных Из Объект.Товары Цикл
                    Если НЕ ЗначениеЗаполнено(СтрокаДанных.СортТовара) Тогда
                        СтрокаДанных.СортТовара = СтрокаДанных.Товар.Сорт;
                    КонецЕсли;
                КонецЦикла
            КонецПроцедуры
        </pre>
    </div>
    <p>Теперь осталось запустить конфигурацию в пользовательском режиме и убедиться, что при любых раскладах управления накладной данные колонки "Сорт" заполняются правильно.</p>






    <h3 class="header-style2" id="chapter3.17">Глава 3.17. Работа с таблицей в форме. Стр 624</h3>
    <p>При работе с табличной частью документа или просто произвольной таблицей значений, расположенной в форме, зачастую возникает необходимость выборочной или групповой обработки данных, содержащихся в таблице.</p>
    <p>Особенность заключается в том, что для выполнения простейших действий с текущей строкой можно не обращаться к данным(реквизиту формы), а получить нужные значения прямо из элемента формы "ТаблицаФормы". Для этого используется свойство таблицы <b>ТекущиеДанные</b>.</p>
    <p>Однако для выполнения более сложных или массовых операций требуется доступ непосредственно к данным формы, т.е. к её реквизиту. Реквизит формы может иметь разный тип - например, в случае табличной части это будет <b>ДанныеФормыКоллекция</b>, а в случае дерева значений - <b>ДанныеФормыДерево</b>. Сути дела это не меняет.</p>
    <p>В любом случае реквизит формы является некоторой коллекцией. И когда мы "переходим" от элемента формы, в котором какая-то строка является текущей, к реквизиту, нужно уметь однозначно определить, какой элемент этой коллекции соответствует текущей строке таблицы. И наоборот, зная некоторый элемент коллекции, содержащийся в реквизите, нужно уметь сделать текущей строкой таблицу ту, которая соответствует этому элементу коллекции.</p>
    <p>Для решения этой задачи используется <i style="text-decoration: underline;">идентификатор</i>. Идентификатор это номер строки начиная с 0.</p>
    <img src="../img/1С-1/2024-03-01_16-22-03.png" class="screen" alt="">
    <p>Находясь в таблице формы, узнать идентификатор текущей строки просто. Его возвращает свойство таблицы <b>ТекущаяСтрока</b>.</p>
    <p>Имея этот идентификатор, найти соответствующий ему элемент коллекции, содержащийся в реквизите, тоже просто. У коллекции есть метод <b>НайтиПоИдентификатору()</b>, который вернёт нужный элемент коллекции.</p>
    <p>В "обратную сторону" всё работает похожим образом:</p>
    <img src="../img/1С-1/2024-03-01_16-22-04.png" class="screen" alt="">
    <p>Имея некоторый элемент колекции, содержащийся в реквизите, мы можем получить его идентификатор с помощью его метода <b>ПолучитьИдентификатор()</b>. Останется только присвоить этот идентификатор текущей строке таблицы, чтобы спозиционироваться на нужной строке.</p>
    <p>Рассмотрим работу с таблицей на двух примерах. Первый будет заключаться в том, чтобы обойти поля таблицы в нужной последовательности, а в торой - в том, чтобы сохранить текущую строку таблицы после массированного изменения данных.</p>
    <p><span class="vue-r">Кстати можно указать программно ту строку таблицы, которая будет выделена при открытии формы. Это можно сделать указав свойству "ТекущаяСтрока" идентификатор:</span></p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПриОткрытии()
                Элементы.Товары.ТекущаяСтрока = 1;
            КонецПроцедуры
        </pre>
    </div>
    <p>Как правильно добавлять/удалять строки таблицы формы, а также выедлять новую добавленную строку показано в обработке "КопированиеДокумента" в базе Камков - "Основные объекты".</p>
    <p><span class="vue-r">Почему я так выделяю эту тему, потому что там не так всё сразу понятно. Когда происходит добавление нового элемента, то к нему присвается идентификатор и этот идентификатор не обязательно будет равен позиции этого в элемента в коллекции. Когда мы добавили элемент в коллекцию и он отобразился в таблице формы, то у этой новой строки таблице свойство "ТекущаяСтрока" будет возвращать не порядковый номер строки в таблице, а номер этого идентификатора. Допусим в таблице формы, отображающая таблицу значений, есть 2 строки. Удаляю 2 строку и добавляю тут же через кнопку новую строку. По идеи новая строка должна иметь индекс 1, первая это 0, а новая добавленная 1, но нифига, она будет иметь индекс 2, это так присвоился идентификатор нового элемента. И теперь чтобы удалить без проблем, нужно получить этот идентификатор через "ТекущаяСтрока" и удалить из коллекции по позиции в коллекции, но для начала нужно найти индекс этого элемента по идентификатору. В общем делаем как выше написано в книге.</span></p>
    <p>При открытии формы увидим выделенную вторую строку таблицы:</p>
    <img src="../img/1С-1/2024-03-01_21-47-19.png" class="screen" alt="">


    <p class="title-size16"><b id="chapter3.17.1">Ввод данных по колонкам</b></p>
    <p><span class="vue-b">Пример можно найти в базе "Таблица в форме"</span>.</p>
    <p>Сразу оговоримся, что этот пример не совсем хорош. Мы будем использовать сообщение пользователю, но не по назначению.</p>
    <p>Сообщения пользователю предназначены для того, чтобы прервать действие и указать на элемент формы, содержащий неправильные данные.</p>
    <p>Мы же будем использовать их для того, чтобы "подсказывать" пользователю, в какой элемент формы необходимо ввести данные. Полезное свойство сообщений заключается в том, что если сообщение выводится с привязкой к элементу формы, то этот элемент сразу же переходит в режим редактирования. Таким образом, пользователю остаётся всего лишь ввести в него неправильные данные.</p>
    <p>Сценарий, который мы будем воплощать, имеет под собой вполне настоящую основу. Зачастую оператору, вводящему накладную, удобно вводить её не по строкам, а по столбцам.</p>
    <p>Сначала вводится вся номенклатура - первая колонка. Затем вводится всё количество - вторая колонка. После этого вводится вся цена - третья колонка. В конце проверяется итоговая сумма, и если есть расхождения, то они исправляются путём построчной проверки сумм.</p>
    <p>Такой сценарий удобен тем, что на каждом этапе выполняются однотипные действия, которые легко сверять с бумажным документом. Сначала подбор номенклатуры. Затем - ввод чисел.</p>
    <p>Для того, чтобы воплотить этот сценарий, напишем обработчик события "ПриИзменении" для того реквизита таблицы, который предполпгпется заполнять по колонке.</p>
    <p>В нашем случае таким реквизитом будет "ТоварКоличество":</p>
    <img src="../img/1С-1/2024-03-01_20-20-37.png" class="screen" alt="">
    <p>обработчик будет выглядеть следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыКоличествоПриИзменении(Элемент)
                <span class="vue-g">//вернёт объект типа "ДанныеФормыЭлементКоллекции"</span>
                СтрокаКоллекции = Объект.Товары.НайтиПоИдентификатору(Элементы.Товары.ТекущаяСтрока);

                <span class="vue-g">//вернёт номер позиции этого объекта в коллекции</span>
                ИндексСтрокиКоллекции = Объект.Товары.Индекс(СтрокаКоллекции);
                <span class="vue-g">//ИЛИ то же индекс можно получить так
                //ИндексСтрокиКоллекции = СтрокаКоллекции.ПолучитьИдентификатор();</span>
                
                Если Объект.Товары.Количество() > ИндексСтрокиКоллекции + 1 Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.КлючДанных  = Объект.Ссылка;
                    Сообщение.ПутьКДанным = "Объект";
                    Сообщение.Поле        = "Товары[" + Строка(ИндексСтрокиКоллекции + 1) + "].Количество";
                    Сообщение.Текст       = "Введите количество товара";
                    Сообщение.Сообщить();
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">А можно и по другому немного написать код:</span></p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыКоличествоПриИзменении(Элемент)
                ИндексСтроки = Элементы.Товары.ТекущаяСтрока;
                
                Если Объект.Товары.Количество() > ИндексСтроки + 1 Тогда
                    Сообщение = Новый СообщениеПользователю;
                    Сообщение.КлючДанных  = Объект.Ссылка;
                    Сообщение.ПутьКДанным = "Объект";
                    Сообщение.Поле        = "Товары[" + Строка(ИндексСтроки + 1) + "].Количество";
                    Сообщение.Текст       = "Введите количество товара";
                    Сообщение.Сообщить();
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Работать будет также. Не знаю для чего в книге так накручено, наверно чтобы показать эти методы. Единственное от реквизита формы Объект нам нужно получить количесвто элементов в коллекции Товары, потому что у таблицы формы нет метода Количество().</span></p>
    <p>Сначала мы находим строку коллекции, которая соотвествует текущей строке таблицы. Затем получаем индекс этой строки в коллекции, т.к. нам нужно будет привязать сообщение к следующей строке таблицы. Следующая строка будем иметь индекс на единицу больше, чем текущая.</p>
    <p>После этого мы формируем сообщение пользователю и привязываем его к полю "Количество", находящемуся в следующей строке таблицы.</p>
    <p>Условие Если... нужно для того, чтобы не формировать сообщение в том случае, когда редактируется последняя строка таблицы.</p>
    <p>В итоге если запустить систему и заполнить номенклатуру в документе Накладная, мы сможем затем последовательно ввести количество номенклатуры, просто набирая его на клавиатуре и нажимая клавишу Ввод. Позиционирование на нужном элементе управления и вход в режим редактирования будут выполняться самостоятельно. Кроме этого, сообщение в форме всегда будет подсказывать текущую позицию ввода, что удобно для сверки с документом.</p>

    <p class="title-size16"><b id="chapter3.17.2">Сохранение текущей строки после загрузки данных</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Таблица в форме", форма документа Накладная, команды "Сортировать без выгрузки", "Сортировать с выгрузкой"(неправильно), "Сортировать с выгрузкой"(правильно).</span></p>
    <p>Второй пример поможет понять некоторые особенности работы с коллекцией, которая хранит данные таблицы в реквизите формы. Мы будем рассматривать случай, когда эти данные обрабатываются по некоторому непростому алгоритму. В примере мы будем всего лишь сортировать данные, но в жизни это может быть гораздо более сложный алгоритм обработки.</p>
    <p>Итак, наша задача - отсортировать табличную часть документа по возрастанию значений в колонке "Цена".</p>
    <p>Самый простой способ - обратится непосредственно к реквизиту формы и выполнить метод Сортировать():</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СортироватьБезВыгрузки()
                Объект.Товары.Сортировать("Цена");
            КонецПроцедуры
        </pre>
    </div>
    <p>Допустим, перед выполнением этого действия текущей была, например, третья строка табличной части:</p>
    <img src="../img/1С-1/2024-03-02_09-07-49.png" class="screen" alt="">
    <p>Тогда после выполнения сортировки "Сортировать без выгрузки" эта же строка останется текущей. Она уже не будет третьей, но это будет та же самая строка.</p>
    <p>Теперь рассмотрим другой случай. Допустим, для выполнения нашего алгоритма нужно выгрузить данные из реквизита в таблицу значений, обработать их и затем загрузить обратно(команда "Сортировать с выгрузкой(неправильно)"):</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СортироватьСВыгрузкойНеправильно(Команда)
                НаСервереНеправильно();
            КонецПроцедуры

            &НаСервере
            Процедура НаСервереНеправильно()
                <span class="vue-g">//т.к. таблица значений тяжела для обработки на клиенте, то
                //она доступна только на сервере</span>
                ТЗ = Объект.Товары.Выгрузить();
                ТЗ.Сортировать("Цена");
                Объект.Товары.Загрузить(ТЗ);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом случае результат окажется другим. Строки, как и раньше, будут отсортированы, однако текущей станет первая строка таблицы:</p>
    <img src="../img/1С-1/2024-03-02_09-44-08.png" class="screen" alt="">
    <p>Так происходит потому, что после загрузки в реквизит формы в нём фактически оказывается новая коллекция данных. Они могут не совпадать с теми данными, которые были выгружены из реквизита. Поэтому текущей становится первая строка таблицы, что соотвествует поведению платформы по умолчанию.</p>
    <p>Однако мы знаем, что данные, которые загружены, те же самые, поменялся лишь порядок строк. Как в этом случае сохранить правильную текущую строку?</p>
    <p>Рассмотрим третий способ(команда "Сортировать с выгрузкой(правильно)"):</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СортироватьСВыгрузкойПравильно(Команда)
                НаСервереПравильно();
            КонецПроцедуры

            &НаСервере
            Процедура НаСервереПравильно()
                СтрокаКоллекции = Объект.Товары.НайтиПоИдентификатору(Элементы.Товары.ТекущаяСтрока);
                ИндексСтрокиКоллекции = Объект.Товары.Индекс(СтрокаКоллекции);
                
                ТЗ = Объект.Товары.Выгрузить();
                СтрокаВыгруженнойТаблицы = ТЗ.Получить(ИндексСтрокиКоллекции);
                
                ТЗ.Сортировать("Цена");
                
                ИндексСтрокиПослеСортировки = ТЗ.Индекс(СтрокаВыгруженнойТаблицы);
                
                Объект.Товары.Загрузить(ТЗ);
                
                СтрокаКоллекции = Объект.Товары.Получить(ИндексСтрокиПослеСортировки);
                <span class="vue-g">//не могу понять почему перестал работать метод НайтиПоИдентификатору()
                //после того как загрузили в Товары значения из ТЗ, то и перестал работать этот
                //метод, а вместо него мы используем метод Получить()
                //СтрокаКоллекции = Объект.Товары.НайтиПоИдентификатору(ИндексСтрокиПослеСортировки);</span>
                Элементы.Товары.ТекущаяСтрока = СтрокаКоллекции.ПолучитьИдентификатор();                                
            КонецПроцедуры
        </pre>
    </div>






    <h3 class="header-style2" id="chapter3.18">Глава 3.18. Работа с файлами и картинками. Стр 636</h3>
    <p>Тонкий клиент и веб-клиент имеют разные возможности по работе с файлами и картинками.</p>
    <p>Поскольку веб-клиент является типичным веб-приложением, он ничего не знает о локальной файловой системой компьютера, на котором он работает. Его собственные стандартные возможности заключаются лишь в том, чтобы поместить один файл на сервер или получить один файл из базы данных.</p>
    <p>Причём и в том и в другом случае передаётся только один файл, и эта операция выполняется пользователем, потому что отсутствуют какие-либо средства программной работы с локальной файловой системой клиентского компьютера.</p>
    <p>Исходный файл для помещения на сервер должен быть выбран пользователем, или путь к нему должен быть указан в явном виде. Подобно и при получении файла из БД - его конечное местоположение должно быть выбрано пользователем или в явном виде указано в программном коде.</p>
    <p>Тонкий клиент является Виндовс-приложением и имеет более широкие возможности работы с файлами. В частности, он поддерживает множественный экспорт и импорт файлов и предоставляет программные средства для работы с локальной файловой системой клиентского компьютера.</p>
    <p>Для того чтобы веб-клиент смог выполнять такие же действия, на клиентском компьютере надо установить и подключить <i style="text-decoration: underline;">расширение работы с файлами</i>. Это отдельный компонент платформы, его установка и подключение выполняется самостоятельно средствами встроенного языка.Но установка этого расширения должна быть произведена пользователем. Пользователь должен сам принять решение об установке.</p>
    <p>Однако использование расширений работы с файлами снижает общую безопасность системы: в браузере Microsoft Internet Explorer требуется разрешение на установку и использование ActiveX, а в браузере Mozila Firefox надо предоставление расширенных прав. Пользователь веб-клиента попросту может не иметь подобных прав, если работа выполняется на общественном компьютере или в организации, использующей определенное соглашение по безопасности.</p>
    <p>Поэтому при работе с файлами и картинками следует в обязательном порядке воплощать алгоритмы, использующие стандартные, общие для тонкого и веб-клиента возможности работы с файлами. Кроме того, можно воплотить и другую ветку алгоритма, использующую расширенные возможности работы с файлами. Но эта ветка должна быть опциональной, дополнительной. Нельзя обязательно заставлять пользователя использовать расширение работы с файлам, ведь у него может не быть прав на его установку.</p>

    <p class="title-size16"><b id="chapter3.18.1">Стандартные возможности</b></p>
    <p><span class="vue-r">Вообщем поузнавал тут и оказалось, что методы ПолучитьФайл(), НачатьПомещениеФайла() устарели. Вместо них теперь <b>НачатьПомещениеФайлаНаСервер(), НачатьПомещениеФайловНаСервер(), НачатьПолучениеФайлаССервера(), НачатьПолучениеФайловССервера()</b> </span></p>
    <p><span class="vue-r">Так что ниже описанные методы из книги надо менять на эти.</span></p>
    <p>Стандартные возможности работы с файлами представляются двумя методами встроенного языка: <b>НачатьПомещениеФайлаНаСервер()</b>, <b>НачатьПомещениеФайловНаСервер()</b>, <b>НачатьПолучениеФайлаССервера()</b> и <b>НачатьПолучениеФайловССервера()</b>.</p>
    <p>НачатьПомещениеФайлаНаСервер() - помещает файл из локальной файловой системы во временное хранилище.</p>
    <p>НачатьПолучениеФайлаССервера() - получает файл из информационной базы и помещает его на клиентский комп.</p>
    <p>Помещение файла в информационную базу выполняется в два этапа.</p>
    <p>Сначала с помощью метода НачатьПомещениеФайлаНаСервер() файл с клиентского компьютера помещается во <i style="text-decoration: underline;">временное хранилище</i>:</p>
    <img src="../img/1С-1/2024-03-02_09-44-09.png" class="screen" alt="">
    <p>Временное хранилище - это набор служебных файлов кластера, в которых в течении ограниченного времени могут хранится произвольные данные до помещения их в базу данных.</p>
    <p>На втором этапе, когда пользователь принимает решение сохранить данные в БД, файл из временного хранилища помещается в како-либо реквизит, имеющий тип <b>ХранилищеЗначения</b> и эти данные записываются в БД:</p>
    <img src="../img/1С-1/2024-03-02_09-44-10.png" class="screen" alt="">
    <p>Если же пользователь отказывается от сохранения данных, то файл удаляется из временного хранилища либо сам, когда будет закрыта форма, с помощью которой он туда был помещён, либо "вречную" из встроенного языка.</p>
    <p>Процесс получения файла из инфобазы проще. Он выполняется в один этап, с помощью метода НачатьПолучениеФайлаССервера().</p>
    <img src="../img/1С-1/2024-03-02_09-44-11.png" class="screen" alt="">
    <p>Файл извлекается из реквизита типа "ХранилищеЗначения" и помещается на компьютер пользователя.</p>
    <p>С помощью метода можно получить на клиентский комп данные не только из БД. но и из временного хранилища. При работе с файлами эта возможность имеет малое практическое значение. Зато она востребована, например, в тех случаях, когда временное хранилище используется для передачи больших массивов данных между двумя формами на клиенте. Такой пример рассмотрен в разделе "Использование временного хранилища для передачи данных между формами" далее по книге.</p>

    <p class="title-size16"><b id="chapter3.18.2">Расширенные возможности</b></p>
    <p>Как уже говорилось раньше, в тонком клиенте расширенные возможности работы с файлами доступны всегда. В веб-клиенте для их использования нужно установить и подключить расширение работы с файлами.</p>
    <p>Здесь мы лишь перечислим эти возможности, т.к. их практическое использование, как правило не вызывает трудностей.</p>
    <p>Установка и подключение расширения работы с файлами выполняется с помощью двух методов встроенного языка:</p>
    <ul class="list">
        <li>НачатьУстановкуРасширенияРаботыСФайлами(),</li>
        <li>НачатьПодключениеРасширенияРаботыСФайлами().</li>
    </ul>
    <p>После этого в веб-клиенте становятся доступны методы экспорта/импорта файлов:</p>
    <ul class="list">
        <li>НачатьПомещениеФайлов(),</li>
        <li>НачатьПолучениеФайлов().</li>
    </ul>
    <p>Они подобны упоминавшимся ранее методам, но позволяют выполнять операции сразу на группой файлов</p>
    <p>Также становятся доступны методы прямого доступа к локальной файловой системе клиентского компьютера:</p>
    <ul class="list">
        <li>НачатьКопированиеФайла(),</li>
        <li>НачатьПоискФалов(),</li>
        <li>НачатьПеремещениеФайла(),</li>
        <li>НачатьСозданиеКаталога(),</li>
        <li>НачатьУдалениеФайла().</li>
    </ul>
    <p>Чтобы не запутаться в различных методах работы с файлами, все их можно представить в виде следующей иерархии:</p>
    <img src="../img/1С-1/2024-03-03_09-22-39.png" class="screen-2" alt="">

    <p class="title-size16"><b id="chapter3.18.3">Получение файла и сохранение его в базе данных</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Файлы и картинки" справочника Поставщики.</span></p>
    <p>В качестве примера рассмотрим задачу получения файла с клиентского компьютера и сохранения его в реквизите справочника.</p>
    <p>Пусть в конфигурации существует справочник "Поставщики". Для каждого поставщика в базе данных должен храниться произвольный файл, содержащий договор с этим поставщиком.</p>
    <p>Сразу оговоримся, что рассматриваемый пример упрощён и произвольный файл мы будем хранить в одном из реквизитов самого справочника "Поставщики". В жизни, как правило, так не поступают.</p>
    <p>Для хранения больших объёмов двоичных данных(бинарных данных)(файлы, картинки) создаются отдельные объекты конфигурации (справочники или регистры сведений), связанные с данным объектом. Такой подход позволяет исключить обязательное считывание больших объёмов данных при считывании самого объекта.</p>
    <p>Итак, справочник "Поставщики" будет содержать два реквизита: "ФайлДоговора"(тип ХранилищеЗначения для хранения двоичных данных) и "ИмяФайлаДоговора"(тип Строка для хранения имени загружаемого файла):</p>
    <img src="../img/1С-1/2024-03-03_09-37-32.png" class="screen-2" alt="">
    <p>Имя загруженного файла нам понадобится для того, чтобы иметь возможность в дальнейшем этот файл поместить обратно на компьютер пользователя.</p>
    <p>Форма элемента справочника "Поставщики" помимо данных самого объекта(реквизиты объекта) будет содержать два дополнительных строковых реквизита: "ИмяФайлаДоговора" и "СсылкаНаФайлВоВременномХранилище":</p>
    <img src="../img/1С-1/2024-03-03_09-44-01.png" class="screen" alt="">
    <p>Ссылка на временное хранилище запоминается в форме потому, что она необходима лишь на миг от загрузки файла до записи объекта в базу данных и не является частью прикладных данных объекта.</p>
    <p>"ИмяФайлаДоговора" запоминается в форме для того, чтобы не изменять данные объекта до тех пор, пока не начнётся запись объекта в БД. В принципе можно обойтись и без него - сохранять имя файла прямо в реквизит объекта, но тогда несколько сложнее станет проверка, выполняемая при сохранении файла на компьютер пользователя.</p>
    <p>Для загрузки файла с диска в инфобазу и для сохранения его на диск нами в форме созданы две локальные команды: "ЗагрузитьСДиска" и "СохранитьНаДиск":</p>
    <img src="../img/1С-1/2024-03-03_09-57-18.png" class="screen" alt="">
    <p>Загрузка файла выполняется с помощью немодального метода глобального контекста НачатьПомещениеФайлаНаСервер(). Первым параметром в этот метод передаётся описание оповещения, описывающее экспортную процедуру(расположенную в том же модуле - модуле формы) ЗагрузитьСДискаЗавершение(), которая будет вызвана, когда пользователь выберет файл:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьСДиска(Команда)
                Оповещение = Новый ОписаниеОповещения("ЗагрузитьСДискаЗавершение", ЭтотОбъект);
                
                НачатьПомещениеФайлаНаСервер(Оповещение,,,,, УникальныйИдентификатор);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре обработки оповещения в случае выбора файла пользователем и будут выполняться действия по загрузке файла с диска:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//как только файл успешно поместится во временное хранилище
            //запустится эта процедура </span>
            &НаКлиенте
            Процедура ЗагрузитьСДискаЗавершение(ОписаниеФайла, ДопПараметры) Экспорт
                Если ОписаниеФайла &lt;> Неопределено Тогда
                    ИмяФайлаДоговора = ОписаниеФайла.СсылкаНаФайл.Файл.Имя;
                    
                    СсылкаНаФайлВоВременномХранилище = ОписаниеФайла.Адрес;
                    
                    Модифицированность = Истина;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Помимо описания оповещения в метод НачатьПомещениеФайлаНаСервер() шестым параметром передаётся уникальный идентификатор открытой формы, о котором речь пойдёт ниже.</p>
    <p>В процедуру, вызывающуюся после выбора файла, в параметр "ОписаниеФайла" передаётся описание помещённого во временное хранилище файла. В свойстве этого параметра (ОписаниеФайла.Адрес) находится адрес файла во временном хранилище. А в свойстве "ОписаниеФайла.СсылкаНаФайл.Файл.ПолноеИмя" находится полное имя файла:</p>
    <img src="../img/1С-1/2024-03-03_19-14-51.png" class="screen" alt="">
    <p><span class="vue-r">Вот так было описано в книге со старым методом:</span></p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьСДиска(Команда)
                Оповещение = Новый ОписаниеОповещения("ЗагрузитьСДискаЗавершение", ЭтотОбъект);
                
                НачатьПомещениеФайла(Оповещение,,, Истина, УникальныйИдентификатор);
            КонецПроцедуры


            &НаКлиенте
            Процедура ЗагрузитьСДискаЗавершение(Результат, АдресВХранилище, ВыбранноеИмяФайла, ДопПараметры) Экспорт 
                Если Результат Тогда
                    Файл = Новый Файл(ВыбранноеИмяФайла);
                    ИмяФайлаДоговора = Файл.Имя;  

                    СсылкаНаФайлВоВременномХранилище = АдресВХранилище;
                    
                    Модифицированность = Истина;
                КонецЕсли;
            КонецПроцедуры 
        </pre>
    </div>
    <p>Немного отступим от нашего примера, чтобы дать полезный совет. Быстро и без ошибок создать заготовку процедуры обработки оповещения и сконструировать объект ОписаниеОповещения при вызове немодального метода можно с помощью механизма рефакторинга. Для этого достаточно написать имя метода, поставить открывающуюся скобку и установить курсор на имя метода и вызвать из контекстного меню команду "Рефакторинг - Создать обработку оповещения". Затем в отдельном окне можно задать имя процедуры обработки оповещения или согласиться с именем, котрое предлагает платформа:</p>
    <img src="../img/1С-1/2024-03-03_21-08-04.png" class="screen" alt="">
    <p><span class="vue-r">Это срабатывает почему то только на устаревшем методе НачатьПомещениеФайла(), на новом методе НачатьПомещениеФайлаНаСервер() это не работает.</span></p>
    <p>Вернёмся к нашему примеру. Итак, после помещения файл окажется во временном хранилище, а в реквизитах формы будет ссылка на него и его имя:</p>
    <img src="../img/1С-1/2024-03-03_21-08-05.png" class="screen" alt="">
    <p>Примечательным здесь является то, что при помещении файла мы указали последний параметр метода НачатьПомещениеФайлаНаСервер():</p>
    <div class="code-style">
        <pre>
            НачатьПомещениеФайлаНаСервер(Оповещение,,,,, <b>УникальныйИдентификатор</b>);  
        </pre>
    </div>
    <p>В качестве этого параметра мы передали уникальный идентификатор нашей открытой формы. Это значит, что файл во временном хранилище будет существовать до тех пор, пока мы не закроем форму. Тогда платформа сама удалить его из хранилища. Значит, если пользователь откажется от сохранения изменений, сделанных в форме, нам не нужно заботится об удалении файла из временного хранилища - платформа сделает это сама.</p>
    <p>А вот если пользователь решит сохранить сделанные изменения, тогда будут выполнены следующие действия.</p>
    <p>Сначала на сервере будет вызван обработчик события формы "Перед записью на сервере":</p>
    <div class="code-style">
        <pre>
            --модуль формы справочника Поставщики

            &НаСервере
            Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
                <span class="vue-g">//получаем файл из хранилища и помещаем его в объект</span>
                Если ЭтоАдресВременногоХранилища(СсылкаНаФайлВоВременномХранилище) Тогда
                    ДвоичныеДанные = ПолучитьИзВременногоХранилища(СсылкаНаФайлВоВременномХранилище);	
                    
                    ТекущийОбъект.ФайлДоговора =  Новый ХранилищеЗначения(ДвоичныеДанные, Новый СжатиеДанных(9));
                    ТекущийОбъект.ИмяФайлаДоговора = ИмяФайлаДоговора;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы поместим файл из временного хранилища в реквизит записываемого объекта, и в другой реквизит объекта поместим имя этого файла. Делать это мы будем не всегда (ведь пользователь может записать оюъект и не указывая файл договора), а только в том случае, когда реквизит формы действительно хранит ссылку на файл во временном хранилище:</p>
    <div class="code-style">
        <pre>
            Если ЭтоАдресВременногоХранилища(СсылкаНаФайлВоВременномХранилище) Тогда
        </pre>
    </div>
    <p>В этом случае мы получим из временного хранилища двоичные данные и преобразуем их в объект ХранилищеЗначения, который и поместим в реквизит записываемого объекта.</p>
    <p>Таким образом, после выполнения этого обработчика мы будем иметь следующую картину:</p>
    <img src="../img/1С-1/2024-03-03_21-08-06.png" class="screen-2" alt="">
    <p>Затем платформа начнёт запись объекта, и его данные будут помещены в БД:</p>
    <img src="../img/1С-1/2024-03-03_21-08-07.png" class="screen" alt="">
    <p>После этого, ещё до окончания транзакции записи, на сервере будет вызван обработчик события формы "При записи на сервере":</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
                <span class="vue-g">//удалим файл из временного хранилища</span>
                Если ЭтоАдресВременногоХранилища(СсылкаНаФайлВоВременномХранилище) Тогда
                    УдалитьИзВременногоХранилища(СсылкаНаФайлВоВременномХранилище);
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы "наведём красоту". Т.к. данные объекта уже записаны в БД, полученный файл успешно сохранён, можно удалять из временного хранилища находящийся там файл. Для этого мы используем ссылку, сохранённую в реквизите формы.</p>
    <p>Вообще говоря можно этого и не делать, платформа всё равно удалит сама этот файл, когда мы закроем форму. Но в общем случае при нагруженной многопользовательской работе лучше освобождать ресурсы сервера сразу же после того, как необходимость в них исчезнет.</p>
    <p>Процесс получения файла из базы выглядит гораздо проще. Он целиком описан в обработчике локальной команды формы "Сохранить на диск":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СохранитНаДиск(Команда)
                <span class="vue-g">//вот для чего нужен был реквизит формы ИмяФайлаДоговора. Он выступил в 
                //поли переменной посредника, которая сохранила из описания файла в себе имя
                //и потом на сервере мы взяли это имя из этого реквизита и записали его в 
                //реквизит объекта "ИмяФайлаДоговора". И теперь тут мы проверяем пустое оно или нет</span>
                Если Объект.ИмяФайлаДоговора = "" Тогда
                    ПоказатьПредупреждение(, "У поставщика нет сохранённого в базе договора");
                Иначе
                    СсылкаНаФайлВИБ = ПолучитьНавигационнуюСсылку(Объект.Ссылка, "ФайлДоговора");	
                    НачатьПолучениеФайлаССервера(СсылкаНаФайлВИБ, Объект.ИмяФайлаДоговора); 
                КонецЕсли;
            КонецПроцедуры

        </pre>
    </div>
    <p>Поскольку имя файла жоговора мы записываем в реквизит объекта только в миг записи, можно использовать его для определения того, есть ли в объекте сохранённый файл или нет.</p>
    <p>Если нет, то показываем пользователю сообщение с помощью немодального метода ПоказатьПредупреждение(). Первый параметр - описание оповещения - в этом вызове опущен, т.к. после вывода предупреждения никаких действий выполнять не требуется.</p>
    <p>Чтобы получить файла из инфобазы, нужно иметь навигационную ссылку на этот файл.</p>
    <p>Навигационную ссылку мы получаем, указывая ссылку на объект и указывая имя реквизита объекта, в котором хранится файл:</p>
    <div class="code-style">
        <pre>
             СсылкаНаФайлВИБ = ПолучитьНавигационнуюСсылку(Объект.Ссылка, "ФайлДоговора"); 
        </pre>
    </div>
    <p>Затем просто получаем файл по ссылке "СсылкаНаФайлВИБ" и сохраняем его на компьютер пользователя с именем, заданным в реквизите "ИмяФайлаДоговора".</p>

    <p class="title-size16"><b id="chapter3.18.4">Картинка товара в форме</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Файлы и картинки", справосник Товары.</span></p>
    <p>При работе с картинками используется тот же самый подход, который был описан выше. Отличие заключается только в том, что в предыдущем примере нам не нужно было никак отображать файл в форме элемента справочника "Поставщики".А картинка, как правило, загружается в инфобазу именно для того, чтобы отображать её в какой-нибудь форме.</p>
    <p>Работу с картинками рассмотрим на примере справочника Товары и картинки товара. Её нужно загрузить, отобразить в форме, сохранить в базе данных и иметь возможность получить из базы данных на клиентский компьютер.</p>
    <p>Снова сделаем оговорку. Рассматриваемый пример упрощён, и картинку мы будем хранить в одном из реквизитов самого справочника Товары. В жизни, как правило, так не делают, а хранят картинки в отдельных объектах конфигурации, в справочниках или в регистрах сведений.</p>
    <p>Как и в предыдущем примере, спраовник Товары будет содержать два реквизита: "ФайлКартинки", чтобы хранить саму картинку, и "ИмяФайлаКартинки", чтобы знать её имя при выгрузке на клиентский компьютер:</p>
    <img src="../img/1С-1/2024-03-04_17-48-10.png" class="screen-2" alt="">
    <p>Форма элемента справочника Товары также будет содержать два дополнительных реквизита: "ИмяФайлаКартинки" и "СсылкаНаКртинку".</p>
    <p>"ИмяФайлаКартинки" в форме нужно, чтобы не изменять данные объекта до того, как начнётся запись в БД, а "СсылкаНаКртинку" будет содержать навигационную ссылку на картинку, находящуюся во временном хранилище или в базе данных. Этот реквизит связан с элементом формы, имеющим вид "Поле картинки". Таким образом, платформа будет самостоятельно отображать в форме ту картинку, которая находится по ссылке, содержащейся в этом реквизите.</p>
    <p>Для загрузки картинки с диска в базу и для сохранения её на диск в форме созданы две локадьные команды: "ЗагрузитьСДиска" и "СохранитьНаДиск".</p>
    <p>Загрузка картинки выполняется также с помощью немодального метода НачатьПомещениеФайлаНаСервер():</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьСДиска(Команда)
                Оповещение = Новый ОписаниеОповещения("ЗагрузитьСДискаЗавершение", ЭтотОбъект);
                
                НачатьПомещениеФайлаНаСервер(Оповещение,,,,, УникальныйИдентификатор);
            КонецПроцедуры


            &НаКлиенте
            Процедура ЗагрузитьСДискаЗавершение(ОписаниеФайла, ДопПараметры) Экспорт
                Если ОписаниеФайла &lt;> Неопределено Тогда
                    ИмяФайлаДоговора = ОписаниеФайла.СсылкаНаФайл.Файл.Имя;
                    
                    СсылкаНаКртинку = ОписаниеФайла.Адрес;
                    
                    Модифицированность = Истина;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Как только в реквизит формы мы поместим ссылку на картинку во временном хранилище(СсылкаНаКртинку = ОписаниеФайла.Адрес), она отобразится в форме.</p>
    <p>Таким образом, после помещения картинки она окажется во временном хранилище, а в реквизите формы будет ссылка на неё. Связанное с реквизитом поле картинки отобразит её в форме.</p>
    <p>Когда пользователь решит сохранить сделанные изменения, на сервере будет вызван обработчик события "Перед записью на сервере":</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
                //получаем файл из хранилища и помещаем его в объект
                Если ЭтоАдресВременногоХранилища(СсылкаНаКртинку) Тогда
                    ДвоичныеДанные = ПолучитьИзВременногоХранилища(СсылкаНаКртинку);	
                    
                    ТекущийОбъект.ФайлКартинки =  Новый ХранилищеЗначения(ДвоичныеДанные, Новый СжатиеДанных(9));
                    ТекущийОбъект.ИмяФайлаКартинки = ИмяФайлаКартинки;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Этот обработчик подобен тому, что рассматривался в примере выше. Картинка из временного хранилища помещается в объект справочника, туда же помещается имя картинки из реквизита формы.</p>
    <p>Затем платформа начнёт запись объекта, и его данные будут помещены в БД.</p>
    <p>После этого, ещё до окончания транзакции записи, на сервере будет вызван обработчик события формы "При записи на сервере":</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
                //удалим файл из временного хранилища
                Если ЭтоАдресВременногоХранилища(СсылкаНаКртинку) Тогда
                    УдалитьИзВременногоХранилища(СсылкаНаКртинку);
                    СсылкаНаКртинку = ПолучитьНавигационнуюСсылку(ТекущийОбъект.Ссылка, "ФайлКартинки");
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Здесь есть небольшое отличие от того, что мы делали при работе с файлами</p>
    <p>Как и раньше, мы удаляем картинку из временного хранилища, т.к. она нам больше не нужна, она уже сохранена в БД. Но так как форма, как и раньше, должна отображать картинку, в реквизит формы мы помещаем навигационную ссылку на картинку, которая теперь находится в БД. Для получения навигационной ссылки указываем ссылку на сам объект и имя его реквизита, в котором хранится картинка:</p>
    <div class="code-style">
        <pre>
            СсылкаНаКртинку = ПолучитьНавигационнуюСсылку(ТекущийОбъект.Ссылка, "ФайлКартинки");
        </pre>
    </div>
    <p>Теперь осталось сделать последнюю небольшую доработку. Если сейчас закрыть форму и снова открыть сохранённый элемент, мы не увидим картинки в форме, т.к. в реквизите формы нет ссылки на сохранённую в БД картинку. Поэтому создадим обработчик события формы "При создании на сервере" и в нём поместим в реквизит формы ссылку на картинку:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
                Если Объект.ИмяФайлаКартинки &lt;> "" Тогда
                    СсылкаНаКртинку = ПолучитьНавигационнуюСсылку(ТекущийОбъект.Ссылка, "ФайлКартинки");
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>Процес получения картинки из инфобазы выглядит точно также как и в случае работы с файлами:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СохранитНаДиск(Команда)
                <span class="vue-g">//вот для чего нужен был реквизит формы ИмяФайлаДоговора. Он выступил в 
                //поли переменной посредника, которая сохранила из описания файла в себе имя
                //и потом на сервере мы взяли это имя из этого реквизита и записали его в 
                //реквизит объекта "ИмяФайлаДоговора". И теперь тут мы проверяем пустое оно или нет</span>
                Если Объект.ИмяФайлаДоговора = "" Тогда
                    ПоказатьПредупреждение(, "У поставщика нет сохранённого в базе договора");
                Иначе
                    СсылкаНаФайлВИБ = ПолучитьНавигационнуюСсылку(Объект.Ссылка, "ФайлДоговора");	
                    НачатьПолучениеФайлаССервера(СсылкаНаФайлВИБ, Объект.ИмяФайлаДоговора); 
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>

    <p class="title-size16"><b id="chapter3.18.5">Картинки, используемые для оформления</b></p>
    <p>Кроме картинок, яляющимися данными и существующих в виде файлов, в формах могут использоваться картинки, являющиеся элементами оформления. Такие картинки хранятся либо в конфигурации, либо в библиотеке картинок, либо как общие картинки.</p>
    <p>Существует три способаиспользования таких картинок:</p>
    <ul class="lidt">
        <li>Во-первых такую картинку можно поместить непосредственно в реквизит формы</li>
        <li>Во-вторых, картинку, являющуюся коллекцией, можно поместить в свойство элемента формы "Поле", и тогда платформа будет отображать одну из имеющихся картинок коллекции. Здесь возможны две разновидности:
            <ul class="list2">
                <li>Когда поле связано с реквизитом типа Булево, в коллекции должно быть две картинки: одна из них будет отображаться, когда реквизит имеет значение Истина, другая - когда Ложь.</li>
                <li>Вторая возможность - связать поле с реквизитом типа Число. Тогда будет отображаться та картинка из коллекции, индекс которой содержится в реквизите.</li>
            </ul>
        </li>
    </ul>
    <p>Рассмотрим перечисленные способы на примере.</p>
    <p><span class="vue-b">Пример в базе "Файлы и картинки", обработка "ФормированиеМаршрутныхЛистов".</span></p>
    <p>В качестве "подопытного" будем использовать форму воображаемой обработки "ФормированиеМаршрутныхЛистов".</p>
    <p>В ней пользователь должен выбрать сначала тип автомобилей, для которых будут формироваться маршрутные листы: "Грузовики" или "Газели". Чтобы тип выбранных автомобилей был хорошо заметен на глаз, в левом углу формы мы выведем картинку, показывающую тот или иной тип автомобиля.</p>
    <p>Чтобы выполнить эту задачу, создадим в конфигурации две общие картинки: "Грузовик" и "Газель":</p>
    <img src="../img/1С-1/2024-03-04_21-26-31.png" class="screen-2" alt="">
    <p>Затем создадим реквизит формы обработки "ТипАвтомобилей" типа Число и свяжем его с элементом формы "Поле" вида "Поле переключателя". Также для элемента в свойстве "Список выбора" зададим "Значение" - 0, "Представление" - "Грузовики" и "Значение" - 1, "Представление" - "Газели". Вот что получится:</p>
    <img src="../img/1С-1/2024-03-04_21-42-27.png" class="screen" alt="">
    <p>Кроме этого создадим реквизит формы "Картинка" типа Картинка и свяжем его с полем, имеющим вид "Поле картинки":</p>
    <img src="../img/1С-1/2024-03-04_21-57-59.png" class="screen" alt="">
    <p>Теперь для поля "ТипАвтомобилей" создадим обработчик события "ПриИзменении", в котором напишем след. текст:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТипАвтомобилейПриИзменении(Элемент)
                Если ТипАвтомобилей = 0 Тогда
                    Картинка = БиблиотекаКартинок.Грузовики;
                ИначеЕсли ТипАвтомобилей = 1 Тогда	
                    Картинка = БиблиотекаКартинок.Газели;
                КонецЕсли;
            КонецПроцедуры   
        </pre>
    </div>
    <p>В зависимости от выбранного значения переключателя мы подставляем в реквизит формы ту или иную картинку.</p>
    <p>Чтобы при открытии формы были выбраны значения переключателя и картинки, в обработчике события формы "При создании на сервере" напишем такой код:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
                ТипАвтомобилей = 0;
                Картинка = БиблиотекаКартинок.Грузовики;
            КонецПроцедуры
        </pre>
    </div>
    <p>Если изменить значение переключателя, то изменится и отображаемая в форме картинка:</p>
    <img src="../img/1С-1/2024-03-04_22-13-39.png" class="screen-2" alt="">
    <p>Теперь займёмся списком автомобилей.</p>
    <p>Кроме обозначения автомобиля в этом списке указывается, нужен на данный автомобиль доставщик или нет. Чтобы наглядно выделять автомобили, на которые нужен доставщик, мы будем использовать пиктограмму, выводимую в первой колонке списка.</p>
    <p>Сначла добавим в общие картинки картинку "Внимание". Она является коллекцией, состоящей из двух картинок: восклицательного знака и пустой картинки.</p>
    <img src="../img/1С-1/2024-03-05_20-03-21.png" class="screen" alt="">
    <p><span class="vue-r">Сделать такую картинку коллекцию можно в любом графическом редакторе. Это как в вебе делается строка и в неё в строку помещаются иконки. Желательно делать размер картинок 16х16.</span></p>
    <p>Если доставщик требуется, будем показывать восклицательный знак, если нет, будем показывать пустую картинку.</p>
    <p>Далее создадим реквизит формы "СписокАвтомобилей"(ТаблицаЗначений) и её колонки: "Автомобиль"(строка) и "НуженДоставщик"(Булево):</p>
    <img src="../img/1С-1/2024-03-06_09-10-55.png" class="screen" alt="">
    <p>Реквизит "НуженДоставщик" свяжем сразу с двумя полями таблицы формы.</p>
    <p><span class="vue-r">Когда мы перенесли таблицу значений в элементы формы, с соглашением создать эти колонки, и в элементах образовалась таблица формы, то поле этой таблицы "СписокАвтомобилейНуженДоставщик" само связялось с данными таблицы значений, а именно с колонкой "НуженДоставщик" и приобрело вид "Поле фалжка":</span></p>
    <img src="../img/1С-1/2024-03-06_09-21-56.png" class="screen" alt="">
    <p><span class="vue-r">А вот про поле "СписокАвтомобилейКартинка" в книге ничего не сказано, когда и как мы его добавили. Короче как я понял нужно в контекстном меню таблицы формы нажать на пункт "Добавить колонки". Добавятся повторно все колонки, удалим лишние, оставим первую, переименуем её в "СписокАвтомобилейКартинка", сделаем её вид "Поле картинки" и свяжем её с данными "СписокАвтомобилей.НуженДоставщик":</span></p>
    <img src="../img/1С-1/2024-03-06_09-29-29.png" class="screen" alt="">
    <p>Продолжение из книги. Во-первых, с полем "СписокАвтомобилейНуженДоставщик", имеющим вид "Поле флажка". В этом поле мы будем устанавливать желаемое значение.</p>
    <p>Во-вторых, с полем "СписокАвтомобилейКартинка", имеющим вид "Поле картинки". В этом поле будет отображаться одна из двух пиктограмм.</p>
    <p>Чтобы поле "СписокАвтомобилейКартинка" "знало", где взять пиктограммы, в его свойстве "КартинкаЗначений" укажем созданную нами общую картинку "Внимание":</p>
    <img src="../img/1С-1/2024-03-06_09-34-44.png" class="screen" alt="">
    <p>В итоге, если в реквизите "НуженДоставщик" будет значение Истина, отобразится первая картинка из коллекции. Если Ложь - вторая, пустая:</p>
    <img src="../img/1С-1/2024-03-06_09-52-28.png" class="screen" alt="">
    <p><span class="vue-r">Я пока не понимаю как система понимает, что нужно двигать картинку влево-вправо в зависимости от булево значения. Как она понимает, что это не одна какая то картинка, а что в ней их две. Там в редакторе есть какой то пункт "Установить режим коллекции", но я не знаю как он работает и он не установлен. Так что пока не понятно как система распознаёт, что это не одна картинка, а несколько, может по размеру в 16 пикселей на каждую картинку.</span></p>
    <p>Теперь рассмотрим последний способ работы с картинками.</p>
    <p>В списке автомобилей желательно также указывать, есть ли необходимость оповещать клиента о предстоящей доставке груза, и если есть - указывать конкретный способ оповещения: по телефону, по электронной почте и т.д. При этом хочется видеть наглядно отметки о том или ином виде оповещения.</p>
    <p>Для этого добавим в конфигурацию ещё одну общую картинку "Оповещение". Она также является коллекцией картинок:</p>
    <img src="../img/1С-1/2024-03-06_10-11-40.png" class="screen" alt="">
    <p><span class="vue-r">Эту картинку я также сделал в пейнте, просто выложил иконки в ряд по 16 пикселей в ширину и высоту.</span></p>
    <p>Первая картинка пустая, остальные показывают определённый вид оповещения.</p>
    <p>Также добавим в конфигурацию перечисление "ВидыОповещений":</p>
    <img src="../img/1С-1/2024-03-06_10-18-18.png" class="screen-2" alt="">
    <p>После этого в таблицу значений в форме добавим два реквзита.</p>
    <p>Первый реквизит "ОповеститьКлиента"(с типом ссылки на перечисление "ВидыОповещений"). Свяжем его с полем таблицы "СписокАвтомобилейОповеститьКлиента"(при переносе колонки в таблицу формы система сама свяжет их).В этом поле будем устанавливать нужное значение перечисления.</p>
    <p>Второй реквизит - "НомерОповещения" типа Число. Его свяжем с реквизитом таблицы "СписокАвтомобилейКартинкаОповещения", имеющий вид "Поле картинки". В этом поле будет отображаться одна из выбранных пиктограмм. В его свойстве "КартинкаЗначений" выберем общую картинку "Оповещение":</p>
    <img src="../img/1С-1/2024-03-06_16-18-10.png" class="screen" alt="">
    <p>Для поля таблицы "СписокАвтомобилейОповеститьКлиента" создадим обработчик события "ПриИзменении", в котором, в зависимости от выбранного значения перечисления, будем заполнять реквизит "НомерОповещения":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СписокАвтомобилейОповеститьКлиентаПриИзменении(Элемент)
                ДанныеСтроки = Элементы.СписокАвтомобилей.ТекущиеДанные;
                Если ДанныеСтроки.ОповеститьКлиента = ПредопределенноеЗначение("Перечисление.ВидыОповещений.Почта") Тогда
                    ДанныеСтроки.НомерОповещения = 1;
                ИначеЕсли ДанныеСтроки.ОповеститьКлиента = ПредопределенноеЗначение("Перечисление.ВидыОповещений.Телефон") Тогда	
                    ДанныеСтроки.НомерОповещения = 2;
                ИначеЕсли ДанныеСтроки.ОповеститьКлиента = ПредопределенноеЗначение("Перечисление.ВидыОповещений.ЭлектроннаяПочта") Тогда	
                    ДанныеСтроки.НомерОповещения = 3;
                ИначеЕсли ДанныеСтроки.ОповеститьКлиента = ПредопределенноеЗначение("Перечисление.ВидыОповещений.Интернет") Тогда	
                    ДанныеСтроки.НомерОповещения = 4;
                ИначеЕсли ДанныеСтроки.ОповеститьКлиента = ПредопределенноеЗначение("Перечисление.ВидыОповещений.НеОповещать") Тогда	
                    ДанныеСтроки.НомерОповещения = 5;
                ИначеЕсли ДанныеСтроки.ОповеститьКлиента.Пустая() Тогда
                    ДанныеСтроки.НомерОповещения = 0;
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>
    <p>В итоге, если значение перечисления не выбрано, будет отображаться пустая пиктограмма. Если выбрано - пиктограмма, соответствующая этому способу оповещения:</p>
    <img src="../img/1С-1/2024-03-06_16-30-17.png" class="screen" alt="">
    <p>Следует сделать небольшое замечание относительно пустых картинок (и картинок вообще), отображаемых в табличной части. Текущая строка списка подсвечивается жёлтым фоном. Кроме того, к таблице может применяться условное оформление. Поэтому, чтобы пиктограммы хорошо выглядели на любом (не только белом) фонеЮ нужно делать их фон прозрачным. Особенно это важно для пустых пиктограмм.</p>
    <p>В противном случае в текущей строке они будут отображаться в виде белых прямоугольников, что некрасиво и вызывает у пользователя желание нажать на них мышью.</p>
    <p>Чтобы сделать пустую картинку прозрачной, нужно отредактировать её цвет и установить для него свойство "Прозрачность" в значение 0.</p>
    <p><span class="vue-r">Короче у меня не получилось убрать в редакторе 1с задний фон, чтобы он был прозрачным. Поэтому сделал это в Paint.NET. Как это сделать, я сохранил видео с интернета в закладках папки "Картинки с прозрачностью - Как сделать прозрачный фон". Сделал прозрачность, теперь выглядят пиктограммы хорошо:</span></p>
    <img src="../img/1С-1/2024-03-06_19-23-41.png" class="screen" alt="">
    




    <h3 class="header-style2" id="chapter3.19">Глава 3.19. Поле ввода. Стр 667</h3>
    <p>Для работы с полем ввода ссылочных значений в "1С:Предприятии" есть несколько удобных возможностей:</p>
    <ul class="list">
        <li>ввод значений в поле ввода путём набора текста прямо в этом поле;</li>
        <li>выбор значений из истории выбора в поле ввода;</li>
        <li>создание новых значений при вводе в ссылочное поле.</li>
    </ul>
    <p>Ссылочные поля - это поля, значения которых являются ссылками на другие объекты базы данных. Например, в поле "Поставщик" может содержаться ссылка на какого-либо поставщика, который является одним из элементов справочника "Поставщики":</p>
    <img src="../img/1С-1/2024-03-07_10-27-22.png" class="screen" alt="">

    <p class="title-size16"><b id="chapter3.19.1">Ввод по строке</b></p>
    <p>Один из возможных способов ввода такого значения в поле показан на рисунке:</p>
    <p>Нужно нажать кнопку выпадающего списка в поле ввода, затем в выпадающем списке, появившемся под полем ввода, нажать ссылку "Показать все". После этого платформа откроет форму выбора справочника "Поставщики", и в этой форме необходимо выделить нужного поставщика и нажать кнопку "Выбрать". Ссылка на выбранного поставщика будет помещена в поле ввода.</p>
    <p>Однако можно использовать другой, более удобный способ - <i style="text-decoration: underline;">ввод по строке</i>. Не нажимая кнопку выпадающего списка, просто начать вводить в поле наименование поставщика. В миг паузы или по окончанию ввода платформа сама выдаст список подходящих поставщиков, из которых можно будет выбрать нужного:</p>
    <img src="../img/1С-1/2024-03-07_10-30-13.png" class="screen" alt="">
    <p>Если такой поставщик окажется один, платформа самостоятельно подставит ссылку на этого поставщика в редактируемое поле при переходе к другому элементу формы.</p>
    <p>Ввод по строке возможен благодаря тому, что для каждого объекта конфигурации, имеющего ссылочные значения, по умолчанию указаны поля, по которым осуществляется ввод по строке:</p>
    <img src="../img/1С-1/2024-03-07_10-41-42.png" class="screen" alt="">
    <p>Обычно для справочников в качестве таких полей используется "Наименование" и "Код", т.е. можно вводить в поле наименование элемента справочника или можно вводить его код.</p>
    <p>Для других объектов конфигурации по умолчанию могут использоваться другие поля. Разработчик может изменить состав и порядок полей, по которым выполняется ввод по строке.</p>
    <p><b id="chapter3.19.1.1">Последовательность событий при вводе по строке.</b></p>
    <p>Рассмотрим какие события вызываются платформой при вводе по строке:</p>
    <img src="../img/1С-1/2024-03-07_13-31-33.png" class="screen" alt="">
    <p>Это события у поля ввода.</p>
    <p>Пользователь начинает вводить текст в поле.</p>
    <p>Дальше возможны две разновидности развития событий:</p>
    <ul class="list">
        <li>В процессе ввода он делает паузу. В этом случае будет вызвано событие "Автоподбор".</li>
        <li>Находясь в поле ввода, в которое уже введена часть наименования, он нажимает стрелку вниз. Например, после паузы платформа показала список выбора, но пользователь случайно закрыл его(нажал, например, Esc). При нажатии стрелки вниз также будет вызвано событие "Автоподбор".</li>
        <li>В процессе ввода он не делает пауз и, введя часть наименования, переходит к следуюущему элементу формы, нажав Tab или Enter. В этом случае будет вызвано событие "Окончание ввода текста":
        <img src="../img/1С-1/2024-03-07_13-47-35.png" class="screen" alt="">
        </li>
    </ul>
    <p>События "Автоподбор" и "Окончание ввода текста" - это клиентские события поля формы, вернее её расширения - расширения поля ввода.</p>
    <p>После обработки одного из этих событий платформа вызывает событие "Обработка получения данных выбора". Это  событие вызывается в модуле менеджера того объекта конфигурации, значение которого хранится в этом поле. В нашем случае это будет событие, обрабатываемое в модуле менеджера справочника "Поставщики".</p>
    <p>После обработки этого события платформа показывает рядом с полем ввода <i style="text-decoration: underline;">список выбора</i> - список возможных значений, которые могут быть помещены в это поле.</p>
    <p>Пользователь выбирает одно из значений, после чего возникает событие поля - "Обработка выбора".</p>
    <p>После обработки этого события платформа помещает выбранное значение в поле ввода и вызывает последнее событие поля - "При изменении".</p>
    <p>Чаще всего при работе с вводом по строке разработчик решает две задачи:</p>
    <ul class="list">
        <li>сформировать список выбора по своим правилам;</li>
        <li>отказаться от выбора, сделанного пользователем, или подставить в поле собственное значение.</li>
    </ul>
    <p>Вторая задача довольно простая и решается в обработчике "Обработка выбора". Подробнее этот вопрос рассматривается в разделе "Событие 'Обработка выбора'" далее по книге.</p>
    <p>А вот для решения первой задачи существует большое количество возможностей, которые мы сейчас и рассмотрим.</p>
    <p><b id="chapter3.19.1.2">Формирование собственного списка выбора</b></p>
    <p>Как видно из приведённой выше схемы, в любом случае при вводе по строке вызываются два события:</p>
    <ul class="list">
        <li>"Автоподбор" или "Окончание ввода текста";</li>
        <li>"Обработка получения данных выбора".</li>
    </ul>
    <p>Примечательным здесь является то, что первые события вызываются в форме, в то время как последнее событие вызывается в модуле менеджера прикладного объекта.</p>
    <p>Из этого следует важное замечание: переопределять формирование списка выбора нужно прежде всего в обработчике "ОбработкаПолученияДанныхВыбора". Потому что это будет работать во всех случаях, когда в каком-либо поле, в какой-либо форме будет формироваться список выбора значений этого типа. Даже в тех формах, которые создаются платформой самостоятельно и которые разработчик изменить не может.</p>
    <p>Более сложный случай - когда в одной или нескольких формах нужно иметь особенное формирование списка выбора, не такое, как в остальных местах. В этом случае можно использовать обработчики событий этой(этих) формы: "Автоподбор" и "Окончание ввода текста". В простейшем варианте в этих обработчиках должен быть написан одинаковый алгоритм.</p>
    <p>Самым сложным и специфическим является случай, когда в некоторой форме список выбора при паузе и при переходе к следующему элементу должен формироваться по разным алгоритмам. Тогда в каждом из обработчиков "Автоподбор" и "Окончание ввода текста" будет собственный алгоритм формирования списка выбора.</p>
    <p><b id="chapter3.19.1.3">Событие "Обработка получения данных выбора" менеджера объекта</b></p>
    <p><span class="vue-r">Как я понимаю, список выбора это тот динамический список, которой отображается в форме выбора. А то я поначалу думал что это тот список, который платформа подбирает при вводе текста в поле ввода, внизу под полем который вылетает.</span></p>
    <p><span class="vue-r">ОШИБКА!!! Всё правильно я подумал, спиок выбора это именно то что вылетает вниз под полем ввода:</span></p>
    <img src="../img/1С-1/2024-03-09_11-37-50.png" class="screen-2" alt="">
    <p>Итак, рассмотрим возможности, которые есть в обработчике события "Обработка получения данных выбора".</p>
    <p>Синтаксис описания этого обработчика выглядит следующим образом:</p>
    <div class="code-style">
        <pre>
            ОбработкаПолученияДанныхВыбора(ДанныеВыбора, Параметры, СтандартнаяОбработка)
        </pre>
    </div>
    <p><i style="text-decoration: underline;">ДанныеВыбора</i> - это переменная, в которую разработчик должен поместить собственный список выбора. При входе в обработчик этот параметр не содержит никаких значений, т.е. через него нельзя получить доступ к списку выбора, который сформирует платформа. Просто потому, что этот список формируется уже после выхода из этого обработчика. Однако может возникнуть желание в этом обработчике получить список, формируемый платформой, и добавить в него (удалить) несколько элементов. Как это сделать - рассказано в разделе "Метод 'ПолучитьДанныеВыбора()'" чуть далее по книге.</p>
    <p>Переменная <i style="text-decoration: underline;">Параметры</i> содержит набор параметров, которые платформа будет использовать для формирования списка выбора. Особенность заключается в том, что при формировании списка выбора платформа будет учитывать свойства "Параметры выбора" и "Связи параметров выбора", заданные для соответствующего реквизита объекта конфигурации. Поэтому в параметрах могут содержаться какие то отборы.</p>
    <p><i style="text-decoration: underline;">СтандартнаяОбработка</i> - это булева переменная, на основе которой платформа определяет, что делать после выхода из обработчика.</p>
    <p>Если СтандартнаяОбработка равна Истина, то платформа сама сформирует список выбора исходя из того, что указано в Параметрах</p>
    <p>Если СтандартнаяОбработка равна Ложь, платформа не будет формировать список выбора сама, а покажет то, что находится в параметре "ДанныеВыбора".</p>
    <p>Таким образом, у нас есть следующие возможности:</p>
    <ul class="list">
        <li>изменить Параметры и сказать платформе, чтобы она сформировала список выбора;</li>
        <li>отказаться от стандартной обработки и самостоятельно сформировать список выбора.</li>
    </ul>
    <p>Сначала рассмотрим, каким образом можно изменить параметры.</p>
    <p>Допустим, есть документ Накладная, в табличной части которого надо подбирать товары. Причём для выбора должны предлагаться не все возможные товары, а только те, которые поставляет поставщик, указанный в этом документе, и те, которые не помечены на удаление.</p>
    <p>Для этого у реквизита табличной части Товар заданы свойства "Параметры выбора" и "Связи параметров выбора":</p>
    <img src="../img/1С-1/2024-03-09_10-22-48.png" class="screen" alt="">
    <p>В связях параметров выбора указывается, что для выбора будут предлагаться только товары поставщика, указанного в документе. А в параметрах выбора указывается, что кроме этого для выбора будут предлагаться только товары, не помеченные на удаление.</p>
    <p>В результате при наборе наименования товара будет предложен следующий список товаров:</p>
    <img src="../img/1С-1/2024-03-09_11-53-12.jpg" class="screen" alt="">
    <p>Если мы посмотрим на все имеющиеся товары, то заметим, что подбор товаров произведён правильно.</p>
    <p><span class="vue-r">Ещё раз отмечу, что список выбора учитывает значения свойств "Связи параметров выбора" и "Параметры выбора". Отсюда следует, что форма выбора будет иметь список такой же как и сам список выбора, вот что выдаст форма выбора, если нажать "Посмотреть все":</span></p>
    <img src="../img/1С-1/2024-03-09_12-55-49.png" class="screen-2" alt="">
    <p>Допустим, нас не устраивает, что для выбора предлагаются те элементы справочника, которые являются услугами.</p>
    <p>Мы можем легко исправить это сразу двумя способами. Можно просто, ничего не программируя, добавить этот отбор в свойство "Параметры выбора" реквизита табличной части Товар:</p>
    <img src="../img/1С-1/2024-03-09_13-02-56.jpg" class="screen" alt="">
    <p>Но, если нужно, можно сделать это программно в обработчике события "Обработка получения данных выбора" в модуле менеджера справочника Товары.</p>
    <p>Благодаря свойствам "Параметры выбора" и "Связи параметров выбора" в этом обработчике структура параметров содержит следующее:</p>
    <img src="../img/1С-1/2024-03-09_14-41-18.png" class="screen" alt="">
    <p><span class="vue-r">Как видно, чтобы добраться до этих параметров нужно открыть целую "матрёшку".</span></p>
    <p>Добавим к ним ещё одно условие - что товар не должен быть услугой, а стандартную обработку оставим в значении Истина, чтобы платформа сформировала список выбора самостоятельно:</p>
    <img src="../img/1С-1/2024-03-09_14-48-12.png" class="screen" alt="">
    <p><span class="vue-r">Как видно в структуру добавился ещё один параметр.</span></p>
    <p>Если теперь выполнить те же операции, мы увидим, что для выбора предлагаются только элементы, являющиеся товарами.</p>
    <p>Рассмотрим второй случай, когда полностью самостоятельно формируем список выбора, не используя стандартных возможностей платформы.</p>
    <p>Здесь есть два случая. Список выбора может быть простым и сложным:</p>
    <ul class="list">
        <li>В простом случае это должен быть список значений, содержащий выбираемые значения(ссылки).</li>
        <li>В сложном случае это будет список значений, содержащий в качестве своих элементов структуры. Каждая такая структура содержит само выбираемое значение и некоторую дополнительную информацию об этом значении.</li>
    </ul>
    <p><b>Сначала посмотрим, как можно сформировать простой список.</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Поле ввода", документ Накладная, реквизит Склад.</span></p>
    <p>Допустим, в документе Накладная есть реквизит Склад. Тогда в модуле менеджера справочника Склады мы можем написать следующий обработчик:</p>
    <div class="code-style">
        <pre>
            Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора, Параметры, СтандартнаяОбработка)
                СтандартнаяОбработка = Ложь;
                
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	Склады.Ссылка
                    |ИЗ
                    |	Справочник.Склады КАК Склады
                    |ГДЕ
                    |	Склады.Розничный = ЛОЖЬ
                    |	И Склады.Наименование ПОДОБНО &СтрокаПоиска";

                Запрос.УстановитьПараметр("СтрокаПоиска", "%" + Параметры.СтрокаПоиска + "%");	
                Результат = Запрос.Выполнить();

                ВыборкаДетальныеЗаписи = Результат.Выбрать();
                
                Список = Новый СписокЗначений;
                Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
                    Список.Добавить(ВыборкаДетальныеЗаписи.Ссылка);
                КонецЦикла;

                ДанныеВыбора = Список;
            КонецПроцедуры
        </pre>
    </div>
    <p>В нём мы прежде всего отказываемся от стандартной обработки.</p>
    <p>Затем формируем запрос, который выберет нам все склады, не являющиеся розничными и наименование которых содержат строку, введённую пользователем в поле ввода.</p>
    <p>Строку, введённую пользователем мы получаем из структуры параметров, в ней она содержится отдельным элементом с ключом "СтрокаПоиска". На картинке выше этот элемент структуры видно.</p>
    <p>Затем создаём пустой список значений и, обходя результат запроса, заполняем список ссылками. В конце помещаем этот список в переменную "ДанныеВыбора".</p>
    <p>Если в пользовательской части посмотреть на список складов, мы увидим, что выбор произведён правильно, а фрагмент наименования склада может быть произвольным, не обязательно находящимся в начале наименования. Это всё благодаря сравнению "ПОДОБНО" в запросе. По умолчанию платформа сама так не делает, нужно писать наименование с самомго начала, иначе ничего не найдёт.</p>
    <p><b>Теперь рассмотрим, как формировать сложный список выбора.</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Поле ввода", документ Накладная, реквизит Поставщик. В модуле менеджера справочника Поставщики пример 1.</span></p>
    <p>Допустим в документе Накладная есть реквизит Поставщик. Тогда в модуле менеджера справочника Поставщики мы можем написать следующий обработчик:</p>
    <div class="code-style">
        <pre>
            Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора, Параметры, СтандартнаяОбработка)
                СтандартнаяОбработка = Ложь;
                
                Запрос = Новый Запрос;
                Запрос.Текст = 
                    "ВЫБРАТЬ
                    |	Поставщики.Ссылка,
                    |	Поставщики.ПометкаУдаления,
                    |	Поставщики.Ненадежный
                    |ИЗ
                    |	Справочник.Поставщики КАК Поставщики
                    |ГДЕ
                    |	Поставщики.Наименование ПОДОБНО &СтрокаПоиска";

                Запрос.УстановитьПараметр("СтрокаПоиска", "%" + Параметры.СтрокаПоиска + "%");	
                Результат = Запрос.Выполнить();

                ВыборкаДетальныеЗаписи = Результат.Выбрать();
                
                Список = Новый СписокЗначений;
                Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
                    Структура = Новый Структура;
                    Структура.Вставить("Значение", ВыборкаДетальныеЗаписи.Ссылка);
                    Структура.Вставить("ПометкаУдаления", ВыборкаДетальныеЗаписи.ПометкаУдаления);
                    Если ВыборкаДетальныеЗаписи.Ненадежный Тогда
                        Структура.Вставить("Предупреждение", "Это ненадежный поставщик, его лучше не выбирать!");
                    КонецЕсли;

                    Список.Добавить(Структура); 
                КонецЦикла;
                
                ДанныеВыбора = Список;
            КонецПроцедуры
        </pre>
    </div>
    <p>Здесь как и раньше, отказываемся от стандартной обработки и запросом получаем нужные ссылки.</p>
    <p>Затем создаём пустой список значений, а при каждом обходе результата запроса создаём структуру, в которую помещаем:</p>
    <ul class="list">
        <li>Само значение - в элемент с ключом "Значение".</li>
        <li>Признак пометки удаления - в элемент с ключом "ПометкаУдаления". Если пользователь выберет поставщика, помеченного на удаление, платформа выдаст стандартное предупреждение.</li>
        <li>Для тех поставщиков, которые являются ненадёжными, мы добавляем в структуру элемент с ключом "Предупреждение". Если пользователь выберет ненадёжного поставщика, ему будет выдано добавленное нами предупреждение.</li>
    </ul>
    <p>После заполнения структуры добавляем её в список значений, а после обхода всего результата запроса список помещаем в переменную "ДанныеВыбора".</p>
    <p>В итоге при вводе наименования поставщика список выбора будет таким:</p>
    <img src="../img/1С-1/2024-03-10_17-05-45.png" class="screen-2" alt="">
    <p>На примере имеющихся поставщиков мы сможем посмотреть все возможные разновидности работы "сложного" списка выбора:</p>
    <img src="../img/1С-1/2024-03-10_17-08-19.png" class="screen-2" alt="">
    <p>Если выбрать Поставщик 1, мы не получим никаких предупреждений.</p>
    <p>Если выбрать поставщика, помеченного на удаление (Поставщик11), мы получим стандартное предупрждение платформы:</p>
    <img src="../img/1С-1/2024-03-10_17-27-37.png" class="screen-2" alt="">
    <p>Если выбрать ненадёжного поставщика, да ещё и помеченного на удаление (Поставщик367), мы получим "своё" предупреждеие:</p>
    <img src="../img/1С-1/2024-03-10_17-29-58.png" class="screen-2" alt="">
    <p>Несколько слов о производительности. Событие "Обработка получения данных выбора", обрабатываемое в модуле менеджера объекта, вызывается довольно часто. Перечислим эти случаи ещё раз:</p>
    <ul class="list">
        <li>Во-первых, при автоподборе, т.е. когда возникает пауза при наборе текста в поле ввода.</li>
        <li>Во-вторых, при вводе по строке, т.е. когда в поле ввода уже введена какая-то строка и фокус ввода переходит на другой элемент формы.</li>
        <li>И в-третьих (о чём не упоминалось в этом разделе), при быстром выборе, когда для выбора объекта используется не его основная форма выбора, а небольшой список, формируемый системой.</li>
    </ul>
    <p>Поэтому при написании этого обработчика нужно особенно тщательно подходить к вопросу производительности создаваемого кода.</p>
    <p><b id="chapter 3.19.1.4">Метод "ПолучитьДанныеВыбора()"</b></p>
    <p>В процессе работы с полем ввода могут возникнуть разные случаи, связанные с обработкой ввода по строке или автоподбора.</p>
    <p>Как мы уже говорили, ввод по строке возможен только для ссылочных значений. Однако автоподбор и окончание текста отрабатываются для любых типов в поле ввода.</p>
    <p>Поэтому, например, поле ввода может иметь строковый тип, но в обработчике события "Автоподбор" может использовать один или несколько справочников, из которых будет получаться список элементов, соответствующих введённой подстроке.</p>
    <p>Другой случай, когда поле ввода имеет ссылочный тип и при обработке события "Обработка получения данных выбора" в модуле менеджера объекта ещё до того, как платформа сформирует список выбора, нужно получить этот список для изменения.</p>
    <p>Для таких особенных случаев у менеджера прикладных объектов конфигурации существуют методы ПолучитьДанныеВыбора().</p>
    <p>Эти методы полностью имитируют формирование списка выбора платформой, вплоть до вызова события "Обработка получения данных выбора".</p>
    <p>Такой метод есть и в глобальном контексте. В его параметре нужно указывать тип объекта, для которого он должен быть вызван.</p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Поле ввода", документ Накладная, реквизит Поставщик. В модуле менеджера справочника Поставщики пример 2.</span></p>
    <p>В использовании этих методов нет ничего сложного, за исклбчением того случая, когда этот метод вызывается в обработчике "Обработка получения данных выбора". Если не предпринять специальных действий, это приведёт к бесконечной рекурсии. Но от неё можно избавиться довольно простым способом. Рассмотрим это на примере.</p>
    <p>Рассмотрим следующий обработчик в модуле менеджера справочника Поставщики:</p>
    <div class="code-style">
        <pre>
            Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора, Параметры, СтандартнаяОбработка)
                // Если это рекурсивный вызов - ничего не делать
                Если НЕ Параметры.Свойство("Рекурсия") Тогда
                    СтандартнаяОбработка = Ложь;
                    
                    // Получить стандартный список выбора
                    Параметры.Вставить("Рекурсия");
                    СтандартныйСписок = ПолучитьДанныеВыбора(Параметры);
                    
                    // Добавить к стандартному списку собственный элемент
                    ДополнительныйЭлемент = Справочники.Поставщики.НайтиПоКоду("000000003");
                    СтандартныйСписок.Добавить(ДополнительныйЭлемент);
                    
                    ДанныеВыбора = СтандартныйСписок;
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>
    <p>Для защиты от рекурсии перед вызовом метода ПолучитьДанныеВыбора() в структуру параметров будем добавлять служебный параметр с ключом Рекурсия.</p>
    <p>Весь код, написанный в обработчике, будем выполнять только в том случае, если в параметрах отсутсвует элемент Рекурсия, т.е. при первом "заходе" в этот обработчик:</p>
    <div class="code-style">
        <pre>
            Если НЕ Параметры.Свойство("Рекурсия") Тогда
        </pre>
    </div>
    <p>При втором заходе в этот обработчик (когда платформа будет формировать стандартный список выбора) в параметрах уже будет присутсвовать элемент Рекурсия. Таким образом, никакой код выполняться не будет:</p>
    <div class="code-style">
        <pre>
            Параметры.Вставить("Рекурсия");
            СтандартныйСписок = ПолучитьДанныеВыбора(Параметры);
        </pre>
    </div>
    <p>После получения стандартного списка мы добавляем в него ещё одного поставщика, который нам очень нравится и, возможно, пригодится пользователю для выбора:</p>
    <div class="code-style">
        <pre>
            ДополнительныйЭлемент = Справочники.Поставщики.НайтиПоКоду("000000003");
            СтандартныйСписок.Добавить(ДополнительныйЭлемент);
        </pre>
    </div>
    <p>И в конце полученный список помещаем в переменную ДанныеВыбора. Так как в начале мы отказались от стандартной обработки, именно этот список и будет показан пользователю</p>
    <p><b id="chapter3.19.1.5">Событие "Обработка выбора"</b></p>
    <p>Это событие хорошо тем, что оно вызывается после того, как пользователь выбрал какое то значение из предложенного списка, но ещё до того, как это значение будет помещено  в поле ввода.</p>
    <p>Поэтому в этом событии можно:</p>
    <ul class="list">
        <li>отказаться от того выбора, который сделал пользователь (СтандартнаяОбработка = Ложь);</li>
        <li>поместить в поле ввода другое значение, не то, которое выбрал пользователь (ВыбранноеЗначение).</li>
    </ul>
    <p>Первый случай может показаться на первый взгляд странным. Если пользователь может выбрать "что-то не то", то зачем тогда ему предлагать это выбирать? Нужно с самомго начала предложить ему выбирать только из того, что "можно".</p>
    <p>Такой подход имеет право на жизнь и, наверное, может применяться в целом ряде случаев. Однако он имеет два недостатка.</p>
    <p>Первый недостаток, если можно так выразиться, "юзабельный". Например, пользователь начинает вводить в документ поставщика "Стройтрест". Он точно знает, что такой поставщик существует в базе данных. Но программа не предлагает ему выбрать этого поставщика. Первое, о чём подумает пользователь, - что программа "сломалась" или что он неправильно пишет наименование. О том, что именно этого поставщика нельзя выбрать именно в этом документе, пользователь может не подумать совсем или догадаться об этом только после долгово времени.</p>
    <p>Поэтому логичнее поступать следующим образом: если пользователь хочет выбрать поставщика с таким наименованием, предоставить ему такую возможность. Но если по каким-то причинам этого поставщика недбзя использовать в этом документе, после выбора пользователя сообщить ему об этом и отказаться от выбора, сделанного пользователем.</p>
    <p>Такой сценарий, конечно, не является догмой, но в целом ряде случаев, когда для пользователя не очивиден тот факт, что выбирать можно среди ограниченного мнежества элементов, этот сценарий вполне имеет право на жизнь.</p>
    <p>Другой недостаток изначального ограницения списка выбора может быть чисто технологическим. Например, для того чтобы выяснить, можно использовать этого поставщика или нет, требуется выполнить целый ряд сложных рачётов.</p>
    <p>Допустим, список выбора, формируемый для пользователя, будет содержать 49 элементов. Для всех них необходимо будет выполнить этот расчёт. Это может занять значительное время. А в результате пользователь выберет один-единственный элемент из этих 49.</p>
    <p>В таком случае гораздо производительнее будет, ничего не расчитывая, предоставить ему для выбора 49 элементов. А после того как он выберет единственный элемент, только для него одного провести расчёты. И либо согласиться с выбором пользователя, либо отказаться от него.</p>
    <p>Что касается помещения в поле ввода значения другого типа, такой случай может возникнуть при имитации ввода по строке, выполняемого платформой. Например, когда поле ввода имеет строковый тип, список выбора формируется из элементов справочника, на основании выбора пользователя заполняется какая-то служебная информация, а вполе ввода помещается не ссылка, выбранная пользователем, а её представление.</p>
    <p>Выполнить все эти действия как раз и можно в обработчике события "Обработка выбора".</p>
    <p><b id="chapter3.19.1.6">Событие "Начало выбора"</b></p>
    <p>Для того, чтобы картина с формированием списка выбора для поля ввода была полной, следует упомянуть ещё об одном событии - "Начало выбора".</p>
    <p>Это событие возникает в поле ввода в миг нажатия кнопки выбора или клавиши F4 либо вызывается при нажатии "Показать все" или по клавише F4 в выпадающем списке поля ввода.</p>
    <p>Стандартным действием платформы в этом случае является либо открытие формы выбора, либо открытие списка выбора (если для реквизита указан режим быстрого выбора).</p>
    <p>Если разработчик переопределяет формирование списка выбора при автоподборе и при окончании ввода текста, вполне возможно, что ему захочется формировать подобный список и при начале выбора.</p>
    <p>Такая возможность существует. Обработчик события "Начало выбора" имеет параметры "ДанныеВыбора" и СтандартнаяОбработка. Они используются таким же образом, как и в других рассмотренных обработчиках.</p>
    <p>Можно отменить стандартную обработку, а в данные выбора поместить список значений, из которых будет выбирать пользователь. Тогда, даже если для реквизита не используется быстрый выбор, при наступлении события будет открыта не форма выбора, а список выбора, расположенный под полем ввода.</p>

    <p class="title-size16"><b id="chapter3.19.2">История выбора при вводе</b></p>
    <p>При вводе значений в ссылочное поле также очень удобно пользоваться выпадающим списком, открывающимся под этим полем, содержащим наиболее часто используемые и последние выбранные значения данного ссылочного поля.</p>
    <p>Использование истории при выборе задаётся с помощью свойства "ИсторияВыбораПриВводе" у прикладных объектов конфигурации, ссылочных реквизитов объектов конфигурации, измерений, ресурсов и др. и элементов формы, отображающих данные этих реквизитов.</p>
    <p>Если на всех "уровнях" иерархии (начиная от поля ввода до прикладного объекта) свойство "ИсторияВыбораПриВводе" установлено в значение Авто, то история выбора при вводе в ссылочное поле будет сохраняться и отображаться в том случае, если это поле на находится в режиме выбора из списка или в режиме быстрого выбора.</p>
    <p>Выпадающий список с историей выбора открывается самостоятельно при любом попадании фокуса в пустое ссылочное поле ввода, или если список подбора значений при вводе по строке пустой.</p>
    <p>Однако в некоторых случаях пользователю может быть совершенно не нужно (и даже вредно) видеть значения, которые он выбирал в поле ввода до этого. Например, когда надо выбирать и закрывать заказы покупателей. Естественно, в этом случае он должен видеть только те заказы, которые он не обрабатывал ранее.</p>
    <p>В этом случае нужно запретить показ истории выбора при вводе либо на уровне реквизита объекта конфигурации, либо для отдельного поля ввода. Для этого нужно установить свойство "ИсторияВыбораПриВводе" в значение "Не использовать".</p>
    <p>Это можно сделать как в пользовательском режиме, так и программно. Например, при выполнении определённых условий показ и формирование истории выбора у поля ввода модно включать или выключать с помощью встроенного языка:</p>
    <div class="code-style">
        <pre>
            Если ... Тогда
                Элементы.Склад.ИсторияВыбораПриВводе = ИсторияВыбораПриВводе.НеИспользовать;
            Иначе
                Элементы.Склад.ИсторияВыбораПриВводе = ИсторияВыбораПриВводе.Авто;
            КонецЕсли;
        </pre>
    </div>
    <p>Кроме того, отключать историю выбора следует для объектов, в модуле менеджера которых переопределена обработка получения данных выбора(есть обработчик "ОбработкаПолученияДанныхВыбора"), т.к. прописанные там условия не учитываются механизмом составления списка истории выбора. Поэтому, используя историю выбора в этом случае, пользователь может получить возможность выбрать значение, которое он не мог бы выбрать другими способами.</p>

    <p class="title-size16"><b id="chapter3.19.3">Создание при вводе</b></p>
    <p>Ещё одной удобной возможностью при вводе данных в ссылочное поле, несомненно, является возможность создания нового элемента ссылочного типа непосредственно из выпадающего списка, открывающегося под этим полем.</p>
    <p>Эта возможность задаётся с помощью свойства "СозданиеПриВводе" у прикладных объектов конфигурации, ссылочных реквизитов объектов конфигурации, измерений, ресурсов и др. У элементов формы, отображающих данные ссылочных реквизитов, это свойство называется "КнопкаСоздания".</p>
    <p>Если на всех уровнях иерархии (начиная от поля ввода до прикладного объекта) создание новых элементов данных при вводе в ссылочное поле разрешено, то в выпадающем списке у поля будет присутствовать кнопка создания - с пиктограммой "+". С её помощью пользователь может создавать новые элементы данных в форме прикладного объекта и сразу же подставлять их в поле ввода, не открывая при этом форму выбора:</p>
    <img src="../img/1С-1/2024-03-11_13-19-25.jpg" class="screen" alt="">
    <p>Напрмер, пользователь может сразу начинать ввод наименования нового поставщика в ссылочном поле Поставщик. Убедившись, что соответствия с новым значением не найдено, он может нажать кнопку создания в выпадающем списке, открывшемся под этим полем. Появится форма нового элемента справочника Поставщики, при этом введённые в поле ввода буквы уже будут подставлены в наименование нового элемента. Пользователю остаётся только нажать кнопку "Записать и закрыть", и ссылка на нового поставщика будет подставлена в поле ввода.</p>
    <p>Таким образом существенно повышаются удобство и скорость работы пользователей с прикладным решением.</p>
    <p>Однако надо учитывать, что пользователь может создать такой элемент данных, который, вообще говоря, не должен оказаться в ссылочном поле. Например, если он не соответсвует условиям отбора, которые заданы в свойствах "Связи параметров выбора" и "Параметры выбора" этого поля.</p>
    <p>Поэтому перед подставновкой нового элемента в ссылочное поле он самастоятельно проверяется на соответсвие параметрам выбора и связям параметров выбора, установленным для поля. И если элемент не соответствует условиям отбора, то будет выдано сообщение об этом и созданный элемент не будет помещён в поле ввода.</p>
    <p>Разработчик может программно вмешаться в процесс проверки, отменить её или изменить условия проверки и т.д. Для этого в платформе воплощён следующий механизм.</p>
    <p>При нажатии кнопки создания в выпадающем списке у ссылочного поля возникает событие "Создание". В обработчике этого события разработчик может изменить или дополнить условия выбора, заданые в свойствах "Связи параметров выбора" и "Параметры выбора" этого поля. Причём он может описать и дополнительные условия выбора, имена которых начинается с префикса "Дополнительно."</p>
    <p>По умолчанию параметр "СтандартнаяОбработка" события "Создание" установлен в значение Истина. В этом случае платформа выполнит открытие основной формы объекта в режиме выбора, при этом для осуществления проверки в форму будут переданы параметры:</p>
    <ul class="list">
        <li><b>ПараметрыВыбора</b>. Это структура содержит параметры выбора, ограничивающие список элементов, которые могут быть выбраны в поле ввода. Заполняется из параметров выбора и связей параметров выбора. В структуру попадают только те значения, имена которых начинаются с префикса "Отбор."</li>
        <li><b>Дополнительные параметры</b>. Это структура содержит дополнительные параметры, которые разработчик считает нужным передать в форму объекта. Заполняется из параметров выбора и связей параметров выбора. В структуру попадают только те значения, имена которых начинаются с перфикса "Дополнительно."</li>
    </ul>
    <p>Владельцем открываемой формы нового объекта будет выступать поле ввода, откуда вызвано создание объекта.</p>
    <p>При открытии формы нового объекта значение параметра формы "ПараметрыВыбора" копируется в одноимённое свойство формы. Таким образом, условия отбора выбираемых элементов будут нам доступны через свойство "ПараметрыВыбора" в течении всей жизни формы.</p>
    <p>А вот условия, содержащиеся в параметре "ДополнительныеПараметры", будут доступны только в обработчике события "ПриСозданииНаСервере()", как и все остальные неключевые параметры. Поэтому, если требуется использовать их где-то ещё (например, изучить их на предмет подстановки созданного значения в поле ввода), нужно сохранять эти условия в специальном реквизите формы.</p>
    <p>В миг закрытия формы (после вызова события "ПередЗакрытием" и перед вызовом события "ПриЗакрытии") у формы вызывается событие "ВыборЗначения". В обработчике этого события разработчик может выполнить дополнительные проверки или повлиять на результат самостоятельной проверки с помощью значения свойства "ВыборДоступен":</p>
    <ul class="list">
        <li>Если свойство "ВыборДоступен" установлено в значение Истина, то проверка успешно пройдена и выполняется выбор созданного элемента.</li>
        <li>Если свойство "ВыборДоступен" установлено в значение Ложь, то формируется сообщение о том, что созданный элемент не соответствует условиям выбора, и выбор созданного элемента не выполняется.</li>
    </ul>
    <p>В случае если разработчик хочет самостятельно выполнить проверку, выдать собственное сообщение, поместить значение в поле ввода и т.д., нужно установить параметр СтандартнаяОбработка события "ВыборЗначения" в значение Ложь.</p>
    <p>Поясним сказаное на примерах.</p>
    <p><b id="chapter3.19.3.1">Стандартная проверка при выборе значения</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Поле ввода", форма документа Накладная, формы элементов справочника Поставщики и Товары.</span></p>
    <p>В этом примере мы просто программно установим свойство "Параметр выбора" у ссылочного поля Склад в форме документа Накладная и посмотрим, как будет происходить самостоятельная проверка при подстановке в это поле нового склада, созданного с помощью кнопки создания из выпадающего списка.</p>
    <p>Перед этим убедимся, что свойство "Параметры выбора" у реквизита Склад документа Накладная и одноимённое свойство у поля Склад, отображающего данные этого реквизита, пусты. Зададим параметры выбора в миг нажатия на кнопку создания в выпадающем списке. Для этого создадим обработчик события "Создание" для поля Склад в форме документа Накладная и заполним его следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СкладСоздание(Элемент, СтандартнаяОбработка)
                НовыйПараметр = Новый ПараметрВыбора("Отбор.Розничный", Ложь);
                НовыйМассив = Новый Массив();
                НовыйМассив.Добавить(НовыйПараметр);
                НовыеПараметры = Новый ФиксированныйМассив(НовыйМассив);
                Элементы.Склад.ПараметрыВыбора = НовыеПараметры;
            КонецПроцедуры
        </pre>
    </div>
    <p>Согласно этим параметрам выбора при создании новых элементов из выпадающего списка в поле Склад не должны выбираться розничные склады.</p>
    <p>Запустим "1С:Предприятие" и создадим новую накладную. Щёлкнем мышью в поле Склад и в открывшемся выпадающем списке нажмём кнопку создания. В появившейся форме нового элемента справочника Склады укажем наименование элемента, установим признак "Розничный" и нажмём кнопку "Записать и закрыть":</p>
    <img src="../img/1С-1/2024-03-11_13-19-26.jpg" class="screen" alt="">
    <p>В итоге новый элемент справочника будет создан, форма справочника закроется, но созданный элемент не будет помещён в поле ввода. Пользователю будет показано сообщение о том, что созданный элемент не соответствует условиям выбора.</p>
    <p>Так произошло потому, что перед подстановкой нового элемента в поле ввода вызывается событие "ВыборЗначения" и платформа выполняет самостоятельную проверку созданного значения на соответсвие параметрам выбора, содержащимся в свойстве формы "Параметры выбора".</p>
    <p>Так как мы создали новый склад с установленным признаком "Розничный", этот элемент не прошёл проверку. В результате при выходе из обработчика события "ВыборЗначения" свойство "ВыборДоступен" платформа установила в значение Ложь.</p>
    <p>Обратите внимание, что здесь мы никак не вмешивались в процесс проверки, т.к. обработчик события, да и сама форма элемента справочника Склады, в конфигурации отсутствуют.</p>
    <p>Подобного результата можно было бы достигнуть путём интерактивной установки свойства "Параметры выбора" реквизита Склад или связанного с ним поля формы накладной.</p>
    <p><b id="chapter3.19.3.2">Передача дополнительных параметров выбора в форму нового элемента</b></p>
    <p>В этом примере мы рассмотрим, как при создании нового элемента справочника из выпадающего списка поля ввода передавать дополнительные параметры выбора в форму нового элемента и обрабатывать их в этой форме.</p>
    <p>У реквизита Товар табличной части Товары документа Накладная заданы свойства "Связи параметров выбора" и "Параметры выбора":</p>
    <img src="../img/1С-1/2024-03-20_10-12-42.png" class="screen" alt="">
    <p>В связях параметров выбора указывается, что в поле таблицы формы Товар могут выбираться только товары поставщика, указанного в документе. В параметрах выбора указывается, что эти товары не должны быть помечены на удаление.</p>
    <p>Предположим, мы не хотим, чтобы в этом поле выбирались услуги. Зададим это условие в дополнительных параметрах выбора товаров (с префиксом "Дополнительно.") в миг нажатия на кнопку создания в выпадающем списке.</p>
    <p>Для этого создадим обработчик события "Создание" для поля ТоварыТовар в таблице формы Товары и заполним его следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыТоварСоздание(Элемент, СтандартнаяОбработка)
                НовыйПараметр = Новый ПараметрВыбора("Дополнительно.Услуга", Ложь);
                НовыйМассив = Новый Массив();
                НовыйМассив.Добавить(НовыйПараметр);
                НовыеПараметры = Новый ФиксированныйМассив(НовыйМассив);
                Элементы.ТоварыТовар.ПараметрыВыбора = НовыеПараметры;
            КонецПроцедуры
        </pre>
    </div>
    <p>В дополнительных параметрах выбора мы указываем, что у новых товаров, подставляемых в поле выбора Товар, признак Услуга должен быть выключен. Конечно, мы могли бы задать это условие выбора в качестве отбора в свойстве поля "ПараметрыВыбора", причём интерактивно в конфигураторе. Но наш пример показывает работу с дополнительными параметрами выбора, поэтому мы поступаем таким образом.</p>
    <p>После этого откроем форму элемента справочника Товары, создадим обработчик события "ПриСозданииНаСервере" и заполним его следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
                ВыборУслуг = Истина;
                Параметры.ДополнительныеПараметры.Свойство("Услуга",ВыборУслуг);
                    
                Если ВыборУслуг = Ложь Тогда
                    Объект.ВидТовара = Перечисления.ВидыТоваров.Товар;
                    Элементы.ВидТовара.Подсказка = "Услуги недоступны для выбора при создании из формы накладной";
                    Элементы.ВидТовара.ОтображениеПодсказки = ОтображениеПодсказки.Кнопка;
                    Элементы.ВидТовара.Доступность = Ложь;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике в переменной "ВыборУслуг" мы получаем значение поля Услуга из структуры "ДополнительныеПараметры". Если выбор услуг запрщён, то значение реквизита "ВидТовара" мы устанавливаем в значение Товар перечисления "ВидыТоваров". Кроме того, делаем соотвествующее поле формы недоступным. И чтобы у пользователей не возникло лишних вопросов, выводим для поля поясняющую подсказку.</p>
    <p>Запустим 1с предприятие и созадим новую накладную. Заполним поле Поставщик, добавим строку в таблицу товаров и в открывшемся выпадающем списке под полем Товар нажмём кнопку создания:</p>
    <img src="../img/1С-1/2024-03-20_10-44-56.png" class="screen" alt="">
    <p>Новый товар создан, самостоятельная проверка также будет выполнена и успешно пройдена, а ссылка на созданный товар будет подставлена в поле Товар в первую строку таблицы формы накладной.</p>
    <p>А вот если в форме создания нового товара указать другого поставщика (отличного от поставщика в накладной), то созданный товар не будет соответствовать связям параметров выбора, установленном в конфигураторе для реквизита накладной Товар. В итоге после самостотельной проверки платформа выдаст сообщение о том, что новый товар не соответствует условиям выбора, и не подставит его в накладную.</p>
    <p>Что касается услуг, то пользователь просто не сможет выбрать этот вид товара при создании из формы накладной. В то время как при создании нового товара из других мест прикладного решения поле "Вид товара" по-прежнему доступно для изменения и выбор услуг возможен.</p>
    <p>Так произошло потому, что дополнительные параметры мы устанавливаем только при нажатии кнопки создания в выпадающем списке у поля таблицы накладной ТОвар. В остальных случаях в обработчике "ПриСозданииНаСервере" формы нового товара значение параметра "ДополнительныеПараметры" не определено и выбор услуг разрешён.</p>
    <p><b id="chapter3.19.3.3">Собственная проверка при выборе значения</b></p>
    <p>В этом примере мы выполним собственную проверку перед подстановкой созданного элемента справочника Поставщики в поле ввода накладной Поставщик. Если у нового поставщика установлен признак Ненадёжный, то мы отменим стандартную проверку и зададим вопрос, нужно ли подставлять в поле ввода ненадёжного поставщика. Если да, то ссылка на ненадёжного поставщика, тем не менее, должна попасть в поле ввода.</p>
    <p>При нажатии кнопки создания в выпадающем списке у поля накладной Поставщик открывается форма создания нового элемента справочника Поставщики. При этом значения параметрв формы справочника "ПараметрВыбора" и "ДополнительныеПараметры" не определены, так как ни программно, ни интерактивно мы их не задавали.</p>
    <p>Поэтому, в принципе, любой созданный поставщик может быть подставлен в поле ввода. Но перед этим мы хотим, чтобы пользователь подтвердил свой выбор в случае, если поставщик ненадёжный.</p>
    <p>Эти действия нужно выполнять в обработчике события "ВыборЗначения" формы элемента справочника Поставщики. Создадим этот обработчик и заполним его следующим образом.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ВыборЗначения(СтандартнаяОбработка)
                Если Объект.Ненадежный Тогда
                    СтандартнаяОбработка = Ложь;
                    ВыборДоступен = Ложь;
                    ПоказатьВопрос(Новый ОписаниеОповещения("ВопросЗавершение", ЭтотОбъект),
                            "Вы выбрали ненадежного поставщика! Продолжить тем не менее?", РежимДиалогаВопрос.ДаНет);
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике события происходит проверка соответствия созданного значения параметрам выбора и связям параметров выбора, установленным для поля ввода, инициировавшего создание нового элемента. В миг обработки чобытия эти условия выбора содержаться в свойстве формы справочника "ПараметрВыбора". И по результатам этой проверки свойтсво формы "ВыборДоступен" устанавливается в Истина или Ложь.</p>
    <p>Поскольку "ПараметрВыбора" не определены, то проверять нечего и свойство "ВыборДоступен" при выходе из обработчика всегда будет истинно. Мы вмешиваемся в процесс проверки только в том случае, если у созданного поставщика установлен признак Ненадёжный.</p>
    <p>В этом случае мы отменяем стандартную обработку события (СтандартнаяОбработка = Ложь;), а также устанавливаем результат проверки (свойство "ВыборДоступен") в значение Ложь. Если больше ничего не делать, то ненадёжный поставщик никогда не попадёт в поле накладной.</p>
    <p>Но мы хотим, чтобы пользователь сам выбирал, нужно ли подставлять в поле ввода ненадёжного поставщика или нет. Поэтому с помощью немодального метода ПоказатьВопрос() мы задаём ему этот вопрос с разновидностями ответа Да или Нет.</p>
    <p>Первым параметром в этот метод передаётся описание оповещения, описывающее экспортную процедуру, расположенную в модуле формы, ВопросЗавершение(), которая будет вызвана, когда пользователь ответит на вопрос.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ВопросЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт
                Если РезультатВопроса = КодВозвратаДиалога.Да Тогда
                    ОповеститьОВыборе(Объект.Ссылка);
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В параметре "РезультатВопроса" процедуры обработки оповещения содержится результат ответа пользователя. Если ответ положительный, значит, пользователь хочет подставить в поле ввода накладной поставщика, несмотря на то, что он ненадёжный.</p>
    <p>В этом случае вызывается метод формы <b>ОповеститьОВыборе()</b> и владельцу формы создания нового элемента справочника - полю ввода накладной Поставщик передаётся выбранное значение (Объект.Ссылка). В итоге у поля ввода будет вызвано событие "ОбработкаВызова" и ссылка на поставщика попадёт в поле накладной.</p>
    <p>Если же пользователь ответит Нет, то больше ничего не произойдёт и ссылка на поставщика подставлена не будет, так как стандартная обработка события отменена.</p>
    <p>Запустим 1с предприятие и создадим новую накладную. Щелкнем мышью в поле Поставщик и в открывшемся выпадающем списке нажмём кнопку создания. В появившейся форме новго элемента справочника Поставщики укажем наименование элемента, установим признак Ненадёжный и нажмём кнопку "Записать и закрыть".</p>
    <p>После этого пользователю будет показано сообщение о том, что он выбрал ненадёжного поставщика, с возможностью продолжения выбора. Если пользователь хочет продолжить, то ссылка на созданного поставщика будет подставлена в поле накладной Поставщик.</p>
    <p>Если же пользователь отказался от выбора, то ссылка на поставщика подставлена не будет.</p>
    <p>Ну а если созданный поставщик надёжный, всё работает "с шататном режиме", так как в этом случае стандартную обработку события "ВыборЗначения" мы не отменяли.</p>






    <h3 class="header-style2" id="chapter3.20">Глава 3.20. Программное изменение формы. Стр 702</h3>
    <p>В 1С:Предприятии воплощён в жизнь довольно богатый механизм программного изменения формы, однако он не полностью позволяет воплотить те возможности, которые предоставляются средствами конфигурирования (см. часть 2, "Конструирование форм"). Это обусловлено тем, что сама модель прикладного решения направлена на работу с неподвижным (статическим), а не с подвижным (динамическим) описанием форм.</p>
    <p>Форма не рождается на клиенте. Форма рождается на сервере, она проходит несколько важных стадий предварительной обработки, прежде чем достичь глаз пользователей. Платформа содержит достаточно сложные механизмы многоуровнего кеширования различных частей формы как на сервере, так и на клиенте.</p>
    <p>По этой причине возможность программного изменения формы является скорее дополнительной. Она расчитана на отдельные конкретные сценарии работы и не предполагает массового использования в большом количестве форм конфигурации или в часто используемых формах. Основным подходом при разработке прикладных решений должно являться конструирование руками форм в конфигураторе. А программное изменение форм советуется использовать лишь в отдельных узконапрвленных сценариях работы.</p>
    <p>Такими сценариями могут быть, например, отображение в форме имеющихся типовых операций или описание объектов. То есть тех данных, которые содержатся в базе данных и структура которых неизвестна на этапе конфигурирования. Их можно узнать только уже в процессе работы прикладного решения, в пользовательском режиме. Поэтому для отображения этих данных в форме и потребуется её программное изменение.</p>

    <p class="title-size16"><b id="chapter3.20.1">Общие подходы</b></p>
    <p>Встроенный язык позволяет добавлять, изменять и удалять реквизиты, команды и элементы формы. Особенность заключается в том, что программно удалить можно только то, что программно же нами и добавленно. Нельзя программно удалить элементы, реквизиты или команды, созданные в конфигураторе.</p>
    <p>При программном изменении формы нужно управлять всей "троицей": реквизиты, команды и элементы. Например, чтобы разместить какие-то данные в форме, нужно создать реквизит, создать элемент, связать элемент с реквизитом. Для команды - создать команду, связать её с имеющимся в модуле формы обработчиком, создать элемент, связать элемент с командой.</p>
    <p>Добавление и удаление реквизитов, команд и элементов формы возможно только на сервере. Поэтому алгоритмы изменения формы нужно размещать в серверных процедурах формы - в обработчиках событий формы на сервере или в контекстных серверных процедурах модуля формы.</p>
    <p>Программное изменение формы возможно только "изнутри" формы, т.е. при нахождении в её модуле. Нет возможности получить какую-либо форму, программно изменить её и затем открыть эту форму. Потому что изменение формы возможно только на сервере, а открытие формы только на клиенте. А встроенный язык не содержит методов, позволяющих разработчику принудительно передать форму с сервера на клиент.</p>
    <p>Механика добавления/удаления реквизитов формы принципиально отличается от механики работы с её элементами и командами.</p>
    <p>Элементы и команды можно добавлять и удалять поодиночке, просто обращаясь к коллекциям этих элементов, используя методы <b>Добавить()</b> и <b>Удалить()</b>. Это относительно "безболезненные" действия для формы.</p>
    <p>Изменение состава реквизитов, напротив, является сложным и затратным действием. Поэтому здесь используется следующий подход. Сначала разработчик создаёт два массива программных объектов, которые описывают реквизиты формы. Один массив - это те реквизиты, которые должны быть добавлены, а другой массив - это те реквизиты, которые нужно удалить. После этого "за один подход" выполняется изменение формы с помощью её метода <b>ИзменитьРеквизиты()</b>, в который передаются оба этих массива. Снчала выполняется удаление реквизитов, затем  - добавление.</p>
    <p>С добавлением реквизитов связана ещё одна важная особенность. Можно добавить реквизит и установить его свойства. Но из встроенного языка нельзя назначить реквизит основным. Поэтому, например, польностью программно невозможно моздать "настоящую" форму списка или объекта.</p>
    <p>Теперь в качестве примеров рассмотрим четыре случая программного изменения формы:</p>
    <ul class="list">
        <li>добавление поля;</li>
        <li>добавление динамического списка;</li>
        <li>добавление колонки в таблицу;</li>
        <li>добавление команды.</li>
    </ul>

    <p class="title-size16"><b id="chapter3.20.2">Добавление поля</b></p>
    <p>Разберём пример с добавлением поля, как мы делали бы его в конфигураторе, - средствами конструирования руками.</p>
    <p>Сначала мы добавим реквизит формы "РеквизитСтроковый" типа Строка:</p>
    <img src="../img/1С-1/2024-03-21_09-47-57.png" class="screen-2" alt="">
    <p>После этого добавим элемент формы Поле, который в дальнейшем будет отображать значение нашего реквизита:</p>
    <img src="../img/1С-1/2024-03-21_09-54-03.png" class="screen" alt="">
    <p>Затем свяжем между собой элемент формы и реквизит формы:</p>
    <img src="../img/1С-1/2024-03-21_09-58-53.png" class="screen" alt="">
    <p>И в заключении для элемента формы назначим обработчик события "ПриИзменении", который заранее заготовлен в модуле нашей формы:</p>
    <img src="../img/1С-1/2024-03-21_10-09-30.png" class="screen" alt="">
    <p>Теперь все те же самые действия выполним программно, из встроенного языка.</p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Программное изменение формы", общая форма Форма, команда "Добавить поле", это локальная команды формы.</span></p>
    <p><span class="vue-r">Кстати, я из инета скопировал шпору по созданию программно элементов, реквизитов, команд формы. Найти можно в разделе "Основы программирования 1С -> Работа с формами -> Работа в форме -> и там 2й пункт".</span></p>
    <p>Для изменения формы сразу же выполним контекстый вызов сервера, в котором и будем изменять форму:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ДобавитьПоле(Команда)
                ДобавитьПолеНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ДобавитьПолеНаСервере()
                ...
        </pre>
    </div>
    <p>В серверной процедуре сначала добавим реквизит формы "РеквизитСтроковый":</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//добавляем реквизит</span>
            ТипыРеквизита = Новый Массив;
            ТипыРеквизита.Добавить(Тип("Строка"));

            ОписаниеТиповДляРеквизита = Новый ОписаниеТипов(ТипыРеквизита);
            
            НовыйРеквизит = Новый РеквизитФормы(
                "РеквизитСтроковый",       <span class="vue-g">//имя реквизита</span>
                ОписаниеТиповДляРеквизита, <span class="vue-g">//тип</span> реквизита
                ,                          <span class="vue-g">//путь</span>
                "Реквизит строковый",      <span class="vue-g">//заголовок реквизита</span>
                Истина                     <span class="vue-g">//сохраняемые данные</span>   
            );

            ДобавляемыеРеквизиты = Новый Массив;
            ДобавляемыеРеквизиты.Добавить(НовыйРеквизит);

            ИзменитьРеквизиты(ДобавляемыеРеквизиты);
        </pre>
    </div>
    <p>В этом участке кода мы сначала создаём объект, описывающий тип добавляемого реквизита. Поскольку в общем случае реквизит может иметь составной тип, т.е. включать в себя сразу несколько типов, то для описания его типа используется класс "ОписаниеТипов". Конструктор класса принимает первым параметром либо массив типов, либо строку типов через запятую.</p>
    <p>Наш реквизит будет иметь тип Строка, поэтому мы создаём массив "ТипыРеквизита", содержащий единственный элемент. Затем на основании этого массива создаём объект - "ОписаниеТиповДляРеквизита", который будем использовать в конструкторе создания нового реквизита формы - "РеквизитФормы". В параметрах конструктора мы также указываем:</p>
    <ul class="list">
        <li>Имя реквизита - "РеквизитСтрококвый".</li>
        <li>Тип этого реквизита - созданное нами описание типов "ОписаниеТиповДляРеквизита".</li>
        <li>Путь к реквизиту не указываем, поскольку добавляем реквизит первого уровня.</li>
        <li>Заголовок реквизита - "Реквизи строковый", этот заголовок будет использоваться платформой для отображения в форме.</li>
        <li>Последним параметром указываем, что реквизит содержит сохраняемые данные, т.е. при изменении этого реквизита будет самостоятельно устанавливаться изменяемость формы (появляться около заголовка формы "звёздочки"). В данном случае этот параметр мы используем исключительно в показательных целях, чтобы видить, что такая возможность имеется. Благодаря этому в дальнейшем перед закрытием формы мы сможем изучать её изменённость и предотвращать закрытие формы без сохранения изменённых данных.</li>
    </ul>
    <p>После того как реквизит создан, мы добавляем его в массив и этот массив передаём в метод формы ИзменитьРеквизиты() первым параметром. То есть как те реквизиты, которые нужно добавить в форму.</p>
    <p>Теперь мы имеем то состояние, подобное тому, которое было на первой картинке. Когда мы просто создали реквизит формы.</p>
    <p>На втором этапе, как мы говорили выше, нужно создать элемент формы. Для этого мы используем следующий код:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//Добавляем элемент формы и связываем его с реквизитом</span>
            НовыйЭлемент = Элементы.Добавить("ПолеСтроковое", Тип("ПолеФормы"));
        </pre>
    </div>
    <p>В итоге мы имеем состояние, которое было показано на картинке второй.</p>
    <p>Теперь мы связываем элемент формы и реквизит. Для этого в свойстве элемента ПутьКДанным мы указываем имя нашего реквизита:</p>
    <div class="code-style">
        <pre>
            НовыйЭлемент.ПутьКДанным = "РеквизитСтроковый";
        </pre>
    </div>
    <p>Теперь мы имеем состояние, которое было показано на третьей картинке.</p>
    <p>После того как элемент добавлен и связан с реквизитом, установим некоторые его свойства. Во-первых укажем, что это не просто поле, а поле ввода (отметим, что указать какого вида будет поле можно после того, как укажем путь к данным реквизита, это я от себя добавил), а во-вторых - отобразим в нём кнопку очистки:</p>
    <div class="code-style">
        <pre>
            НовыйЭлемент.Вид           = ВидПоляФормы.ПолеВвода;
            НовыйЭлемент.КнопкаОчистки = Истина;
        </pre>
    </div>
    <p>Теперь нам осталось выполнить последний шаг - назначить обработчик события для только что добавленного элемента формы:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">//Установим обработчик события</span>
            НовыйЭлемент.УстановитьДействие("ПриИзменении", "ОбработчикПриИзмененииПоляКомментарий");
        </pre>
    </div>
    <p>Здесь мы указываем имя события и имя процедуры, которая будет обрабатывать это событие. Эта процедура должна быть создана в модуле формы заранее, на этапе конфигурирования:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОбработчикПриИзмененииПолеСтроковое(Элемент)
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = ЭтотОбъект["РеквизитСтроковый"];
                Сообщение.Сообщить();
            КонецПроцедуры
        </pre>
    </div>
    <p>После этого можно запустить систему в режиме 1С:Предприятие и посмотреть, как работает наша команда "Добавить поле". В результате её выполнения внизу формы появится поле ввода "Реквизит строковый". При изменении значения этого поля будет обрабатываться событие, и новое значение поля будет выводится в окно сообщений.</p>

    <p class="title-size16"><b id="chapter3.20.3">Добавление динамического списка</b></p>
    <p>Пример с добавлением динамического списка, если бы мы выполняели его ручками в конфигураторе, выглядел бы следующим образом.</p>
    <p>Сначала мы добавим реквизит формы типа "ДинамическийСписок":</p>
    <img src="../img/1С-1/2024-03-22_20-37-02.png" class="screen" alt="">
    <p>После для этого динамического списка установим флажок "Произвольный запрос" и зададим текст запроса и основную таблицу:</p>
    <img src="../img/1С-1/2024-03-22_21-16-31.png" class="screen" alt="">
    <p>Затем добавим элемент формы Таблица:</p>
    <img src="../img/1С-1/2024-03-22_21-31-03.png" class="screen" alt="">
    <p>После этого свяжем между собой элемент формы и реквизит формы:</p>
    <img src="../img/1С-1/2024-03-22_21-41-24.png" class="screen" alt="">
    <p>Но соглашаться на добавление колонок таких же как в динамическом списке не будем, сами добавим эти колонки и свяжем.</p>
    <p>Создадим колонку для таблицы - "Наименование" и свяжем её с колонкой динамического списка "Наименование"</p>
    <p>Чтобы добавить колонку для таблицы формы, нужно выделить элемент таблицы, вызвать контекстное меню и нажать "Добавить", либо сверху нахать на плюсик. В окне выбрать "Поле":</p>
    <img src="../img/1С-1/2024-03-22_23-20-34.png" class="screen" alt="">
    <p>И затем связываем эту колонку с колонкой динамического списка, указав для свойства "ПутьКДанным" путь к колонке дин. списка "Наименование".  Вид поля, как я понял, нужно установить в "Поле надписи":</p>
    <img src="../img/1С-1/2024-03-22_23-27-42.png" class="screen" alt="">
    <p>Также создадим ещё одну колонку "Код" и свяжем её с колонкой динамического списка "Код".</p>
    <p>Теперь эти же самые действия выполним программно.</p>
    <p>Как и в предыдущем примере, изменение формы будем выполнять в серверной контекстной процедуре.</p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Программное изменение формы", общая форма Форма, команда "Добавить динамический список", это локальная команды формы.</span></p>
    <p>Сначала добавим реквизит формы "РеквизитСписокТоваров":</p>
    <div class="code-style">
        <pre>
            // Добавить реквизит динамический список.
            ТипыРеквизита = Новый Массив;
            ТипыРеквизита.Добавить(Тип("ДинамическийСписок"));
            
            ОписаниеТиповДляРеквизита = Новый ОписаниеТипов(ТипыРеквизита);
            
            НовыйРеквизит = Новый РеквизитФормы(
                "РеквизитСписокТоваров",     // имя
                ОписаниеТиповДляРеквизита,   // тип
                ,                            // путь
                "СписокТоваров",             // заголовок
                Истина);                     // сохраняемые данные

            ДобавляемыеРеквизиты = Новый Массив;
            ДобавляемыеРеквизиты.Добавить(НовыйРеквизит);
            
            ИзменитьРеквизиты(ДобавляемыеРеквизиты);
        </pre>
    </div>
    <p>Здесь всё также как и в предыдущем примере, за исключением типа добавляемого реквизита - ТипРеквизита.Добавить(Тип("ДинамическийСписок")).</p>
    <p>В итоге мы имеем состояние показанное на первой картинке. Теперь, после добавления реквизита можно задать текст запроса и основную таблицу динамического списка:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Задаём текст запроса и другие свойства динамического списка.
            //Для начала получим созданный выше реквизит</span>
            РеквизитСписок = ЭтотОбъект["РеквизитСписокТоваров"];
            РеквизитСписок.ТекстЗапроса    = "ВЫБРАТЬ Наименование, Код ИЗ Справочник.Товары";
            РеквизитСписок.ОсновнаяТаблица = "Справочник.Товары";
        </pre>
    </div>
    <p>В результате имеем состояние как на второй картинке.</p>
    <p>Теперь добавим элемент формы "Таблица" и свяжем его с данными. Снова всё как и в предыдущем примере. Отличается лишь тип добавляемого элемента:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Добавить элемент формы и связать его с реквизитом.</span>
            НовыйЭлемент = Элементы.Добавить("ЭлементСписокТоваров", Тип("ТаблицаФормы"));
            НовыйЭлемент.ПутьКДанным   = "РеквизитСписокТоваров";
        </pre>
    </div>
    <p>В результате мы имеем состояние, показанное на третьей картинке.</p>
    <p>Особенность работы с таблицей заключается в том, что при видимом конструировании платформа предлагает самостоятельно создать колонки таблицы, если мышью перетаскиваем реквизит в дерево элементов формы</p>
    <p>В нашем же случае это нужно сделать самим. И не только создать колонки, но и связать их с данными:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Создать колонки и связать их с данными.</span>
            НоваяКолонкаТаблицы = Элементы.Добавить("КолонкаНаименование", Тип("ПолеФормы"), НовыйЭлемент);
            НоваяКолонкаТаблицы.ПутьКДанным = "РеквизитСписокТоваров.Наименование";
            
            НоваяКолонкаТаблицы = Элементы.Добавить("КолонкаКод", Тип("ПолеФормы"), НовыйЭлемент);
            НоваяКолонкаТаблицы.ПутьКДанным = "РеквизитСписокТоваров.Код";
        </pre>
    </div>
    <p>Тут особенность заключается в том, что, во-первых, при добавлении колонки (поля формы) мы указываем его родителя третьим параметров метода Добавить(). НовыйЭлемент - это как раз та самая таблица, которую мы только что добавили в форму.</p>
    <p>Во-вторых, указывая путь к данным, мы указываем его полностью, от корня реквизитов. Сначала имя реквизита, являющегося динамическим списком, а потом через точку - имя одного из полей запроса, содержащегося в этом динамическом списке - "РеквизитСписокТоваров.Наименование".</p>
    <p>В итоге мы имеем состояние показанное на трёх последующих картинках.</p>
    <p>После этого можно запустить систему в режиме 1с:Предприятие и посмотреть, как работает наша команда "Добавить динамический список".</p>
    <p>В итоге её выполнения в форме появится полноценный список товаров, позволяющий добавлять, изменять и удалять товары. Имеется ввиду добавлять, изменять товары в этой таблице, в базе данных эти изменения не произойдут.</p>

    <p class="title-size16"><b id="chapter3.20.4">Добавление колонки в таблицу</b></p>
    <p>Пример с добавлением колонки в существующую таблицу, если бы мы выполняли его средствами конструирования руками, выглядел бы следующим образом.</p>
    <p>Допустим у нас уже есть реквизит формы "РеквизитТаблицаЗначений" с типом "ТаблицаЗначений". У этого реквизита уже есть пара подчинённых реквизитов(колонок):</p>
    <img src="../img/1С-1/2024-03-24_08-34-45.png" class="screen" alt="">
    <p>Добавим третий подчинённый реквизит формы типа Строка - "РеквизитКолонкаЗанятость":</p>
    <img src="../img/1С-1/2024-03-24_08-42-24.png" class="screen" alt="">
    <p>После этого добавим элемент формы с типом "Поле" как подчинённый элемент существующей в форме таблицы:</p>
    <img src="../img/1С-1/2024-03-24_08-47-04.jpg" class="screen" alt="">
    <p>Затем свяжем между собой элемент формы и реквизит формы, указав для свойства "ПутьКДанным" элемента "КолонкаЗанятость" в значение:</p>
    <img src="../img/1С-1/2024-03-24_08-53-03.png" class="screen" alt="">
    <p>В заключение для элемента формы назначим обработчик события "ПриИзменении", который заранее заготовлен в модуле нашей формы.</p>
    <img src="../img/1С-1/2024-03-24_08-57-52.jpg" class="screen" alt="">
    <p>Теперь все те же самые действия выполним программно.</p>
    <p>Как и раньше, изменение формы будем выполнять в серверной контекстной процедуре. Сначала добавим подчинённый реквизит формы:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Добавим реквизит.</span>
            ТипыРеквизита = Новый Массив;
            ТипыРеквизита.Добавить(Тип("Строка"));
            
            ОписаниеТиповДляРеквизита = Новый ОписаниеТипов(ТипыРеквизита);
            
            НовыйРеквизит = Новый РеквизитФормы(
                "РеквизитКолонкаЗанятость",   // имя
                ОписаниеТиповДляРеквизита,    // тип
                "РеквизитТаблицаЗначений",    // путь
                "Занятость",                  // заголовок
                Истина);                      // сохраняемые данные

            ДобавляемыеРеквизиты = Новый Массив;
            ДобавляемыеРеквизиты.Добавить(НовыйРеквизит);
            
            ИзменитьРеквизиты(ДобавляемыеРеквизиты);
        </pre>
    </div>
    <p>Здесь особенность в том, что при добавлении реквизита мы указываем параметр "Путь" как "РеквизитТаблицаЗначений". Поскольку добавляемый реквизит подчинён существующему в форме реквизиту, в этом параметре нужно указать полный путь от корня реквизитов до добавляемого нами реквизита, не включая имя самого добавляемого реквизита.</p>
    <p>В итоге мы имеем состояние, показанное на первой картинке.</p>
    <p>После этого добавим элемент формы:</p>
    <div class="code-style">
        <pre>
            <span class="vue-g">// Добавим элемент формы и свяжем его с реквизитом.</span>
	        НовыйЭлемент = Элементы.Добавить("КолонкаЗанятость", Тип("ПолеФормы"), Элементы.ЭлементТаблицаЗначений);
        </pre>
    </div>
    <p>Здесь та же особенность. При добавлении элемента мы указываем его родителя - элемент Таблица, существующий в форме Элементы.ЭлементТаблицаЗначений.</p>
    <p>В итоге мы имеем состояние, показанное на второй картинке:</p>
    <img src="../img/1С-1/2024-03-24_08-57-52.jpg" class="screen" alt="">
    <p>Теперь свяжем элемент формы с реквизитом формы и установим некоторые свойства элемента формы:</p>
    <div class="code-style">
        <pre>
            НовыйЭлемент.ПутьКДанным   = "РеквизитТаблицаЗначений.РеквизитКолонкаЗанятость";									 
            НовыйЭлемент.Вид           = ВидПоляФормы.ПолеВвода;
            НовыйЭлемент.КнопкаОчистки = Истина;
        </pre>
    </div>
    <p><span class="vue-r">Кстати тут уже вид поля имеет значение "Поле ввода" для колонок элемента таблицы. А в предыдущем примере при создании колонок для таблицы, отображающей динамический список вид полей был "Поле надписи". Это можно проверить, если просто перенести реквизит в дерево элементов и посмотреть, какие система сама присвоила виды колонкам таблицы.</span></p>
    <p>В итоге мы имеем состояние, показанное на третьей картинке/</p>
    <p>После этого можно запустить систему и посмотреть, как работает наша команда "Добавить колонку в таблицу".</p>

    <p class="title-size16"><b id="chapter3.20.5">Добавление команды</b></p>
    <p>Последний пример, который мы рассмотрим, - это добавление команды. Если бы мы выполняли его в конфигураторе, то это выглядело бы следующим образом.</p>
    <p>Сначала мы добавим команду формы "НоваяКоманда":</p>
    <img src="../img/1С-1/2024-03-24_09-43-40.png" class="screen" alt="">
    <p>Затем мы свяжем эту команду с обработчиком, который будет вызываться при исполнении этой команды:</p>
    <img src="../img/1С-1/2024-03-24_10-48-20.jpg" class="screen" alt="">
    <p>После этого добавим в командную панель формы кнопку:</p>
    <img src="../img/1С-1/2024-03-24_10-51-59.jpg" class="screen" alt="">
    <p>Затем свяжем кнопку командной панели с той командой, которую мы добавили. Связывается элемент с командой через свойство "ИмяКоманды" вместо "ПутьКДанным" у полей:</p>
    <img src="../img/1С-1/2024-03-24_10-57-46.png" class="screen" alt="">
    <p>Теперь все те же действия выполним программно. Как и раньше, изменение формы будем выполнять в серверной контекстной процедуре.</p>
    <p>Не буду расписывать по строке кода, вроде и так понятно:</p>
    <div class="code-style">
        <pre>
            <span class="screen">// Добавить команду.</span>
            НоваяКоманда = Команды.Добавить("НоваяКоманда");
            НоваяКоманда.Действие = "КомандаФормыДобавленнаяПрограммно";
            
            <span class="screen">// Добавить кнопку и связать ее с командой.</span>
            НовыйЭлемент = Элементы.Добавить("КнопкаНоваяКоманда", Тип("КнопкаФормы"), Элементы.ФормаКоманднаяПанель);
            НовыйЭлемент.ИмяКоманды = "НоваяКоманда";
            
            НовыйЭлемент.Заголовок = "Новая команда";
            НовыйЭлемент.КнопкаПоУмолчанию = Истина;
        </pre>
    </div>
    





    <h3 class="header-style2" id="chapter3.21">Глава 3.21. Программная настройка интерфейса. Стр 723</h3>
    <p>Как уже говорилось раньше, состав и расположение панелей интерфейса в основном окне приложения, а также состав и расположение форм на начальной странице могут быть настроены вручную. Сначала разработчиком в конфигураторе для всех пользователей прикладного решения, а затем отдельным пользователем для себя в режиме 1С:Предприятие.</p>
    <p><span class="vue-b">Пример можно посмотреть в базе "Открытие форм", модуль приложения и общий модуль "РаботаСИнтерфейсом".</span></p>
    <p>Кроме того, эти же настройки можно выполнить из встроенного языка при начале работы прикладного решения. Например, если в зависимости от роли пользователя нужно программным образом настраивать его рабочее пространство.</p>

    <p class="title-size16"><b id="chapter3.21.1">Настройка состава панелей интерфейса</b></p>
    <p>Основной объект, с помощью которого выполняется настройка панелей интерфейса, - <b>НастройкиИнтерфейсаКлиентскогоПриложения</b>. Он позволяет работать как с настройками, заданными в конфигураторе разработчиком, так и с настройками, которые пользователь установил для себя в пользовательском режиме.</p>
    <p>Процедуру настройки интерфейса нужно вызывать в модуле управляемого приложения, в обработчике "ПриНачалеРаботыСистемы":</p>
    <div class="code-style">
        <pre>
            Процедура ПриНачалеРаботыСистемы()
                //вызов процедуры из общего модуля
                РаботаСИнтерфейсом.НастройкиИнтерфейса();

                //обновление интерфейса прикладного решения
                ОбновитьИнтерфейс();
            КонецПроцедуры
        </pre>
    </div>
    <p>После выполнения настройки нужно выполнить перестроение интерфейса клиентского приложения с помощью метода глобального контекста <b>ОбновитьИнтерфейс()</b>.</p>
    <p>Саму процедуру настройки интерфейса поместим в общий неголобальный модуль "РаботаСИнтерфейсом" с установленными свойствами "Сервер" и "Вызов сервера":</p>
    <div class="code-style">
        <pre>
            Процедура НастройкаИнтерфейса() Экспорт 
                ПользовательИБ = ПользователиИнформационнойБазы.ТекущийПользователь();	
                Для Каждого РольПользователя Из ПользовательИБ.Роли Цикл
                    Если РольПользователя.Имя = "Администратор" Тогда
                        РасширенныйИнтерфейс();
                        СложнаяНачальнаяСтраница();
                    КонецЕсли;
                    Если РольПользователя.Имя = "Менеджер" Тогда
                        МинимальныйИнтерфейс();
                        ПростаяНачальнаяСтраница();
                    КонецЕсли;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре для пользователя с ролью "Менеджер"(в базе это пользователь с именем Петров) мы вызываем процедуру для формирования минималистического интерфейса, а для пользователя с ролью "Администратор" вызываем процедуру формирования расширенного интерфейса. Для простоты будем считать, что каждому пользователю присвоена только одна роль.</p>
    <p>Для менеджера мы будем отображать в основном окне приложения только панель интсрументов и панель открытых, причём независимо от его личных настроек и настроек, сделанных в конфигураторе.</p>
    <p>Поместии в общем модуле процедуру "МинимальныйИнтерфейс()" и заполним её следующим образом:</p>
    <div class="code-style">
        <pre>
            Процедура МинимальныйИнтерфейс() Экспорт 
                НастройкиИнтерфейса = Новый НастройкиИнтерфейсаКлиентскогоПриложения;
                
                <span class="vue-g">// С помощью пустого объекта настроек получить настройки состава, установленные в конфигураторе.</span>
                НастройкиСостава = НастройкиИнтерфейса.ПолучитьСостав();
                
                <span class="vue-g">// Очистить настройки состава.</span>
                НастройкиСостава.Верх.Очистить();
                НастройкиСостава.Лево.Очистить();
                НастройкиСостава.Низ.Очистить();
                НастройкиСостава.Право.Очистить();
                
                <span class="vue-g">// Заполнить своими панелями.</span>
                ПанельРазделов = Новый ЭлементНастройкиСоставаИнтерфейсаКлиентскогоПриложения("ПанельРазделов");
                ПанельОткрытых = Новый ЭлементНастройкиСоставаИнтерфейсаКлиентскогоПриложения("ПанельОткрытых");
                
                НастройкиСостава.Лево.Добавить(ПанельРазделов);
                НастройкиСостава.Низ.Добавить(ПанельОткрытых);
                
                <span class="vue-g">// Загрузить настройки состава в пустой объект настроек.</span>
                НастройкиИнтерфейса.УстановитьСостав(НастройкиСостава);
                
                <span class="vue-g">// Положить объект настроек текущему пользователю в хранилище.</span>
                ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиИнтерфейсаКлиентскогоПриложения", , НастройкиИнтерфейса);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре мы конструктором создаём пустой объект "НастройкиИнтерфейсаКлиентскогоПриложения". Затем с помощью метода этого объекта <b>ПолучитьСостав()</b> мы получаем настройки состава интерфейса, установленные в конфигураторе. После этого очищаем список панелей интерфейса и групп панелей, размещённых в верхней, левой, правой и нижних частях основного окна клиентского приложения.</p>
    <p>Это необходимо сделать, так как, даже если разработчик ничего не настраивал в конфигураторе, стандартно в интерфейсе клиентского приложения уже отображаются панель разделов, панель функций текущего раздела:</p>
    <img src="../img/1С-1/2024-03-25_10-20-32.png" class="screen-2" alt="">
    <p>Затем создаём конструктором новые элементы настройки состава интерфейса на основании стандартных имён панелей - "ПанельИнструментов" и "ПанельОткрытых". И добавляем их соотвественно в верхнюю и нижнюю часть основного окна приложения.</p>
    <p>После этого с помощью метода <b>УстановитьСостав()</b> мы загружаем изменённые настройки состава интерфейса в пустой объект "НастройкиИнтерфейсаКлиентскогоПриложения".</p>
    <p>И в заключении сохраняем эти настройки для текущего пользователя в хранилище системных настроек с ключом "Общее/НастройкиИнтерфейсаКлиентскогоПриложения". Это необходимо сделать, так как пользовательские настройки применяются поверх всех остальных и затирают их.</p>
    <p>Запустим 1С:Предприятие от имени пользователя с ролью Менеджер. Независимо от настроек, сделанных в конфигураторе, и от личных настроек менеджера, сделанных в прошлом сеансе работы, при начале работы прикладного решения для него всегда будет отображаться минималистический интерфейс, состоящий из рабочей области, панели разделов слева и панели открытых снизу:</p>
    <img src="../img/1С-1/2024-03-25_14-24-19.png" class="screen" alt="">
    <p>Теперь рассмотрим формирование состава панелей интерфейса для пользователя с ролью "Администратор" на основе настроек, сделанных им в режиме 1С:Предприятие.</p>
    <p>Предположим, администратор в пользовательском режиме изменил стандартное расположение панелей интерфейса. Он скрыл панель разделов и установил отображение панели открытых в нижней части основного окна приложения.</p>
    <p>После изменения эти настройки были сохранены в системном хранилище для пользователя с ролью "Администратор". И теперь при начале работы прикладного решения для админа в основном окне прилодения вместо стандарного состава и расположения панелей интерфейса показывается тот вид, который он настроил для себя в режиме 1С:Предприятие.</p>
    <p>Теперь мы хотим немного изменить и расширить эти настройки из встроенного языка. А именно - мы хотим отображать для админа в левой части панель избранного, а сверху, несмотря на его личные настройки, панель открытых и панель функций текущего раздела, причём не друг под другом, а в одной строке.</p>
    <p>Для этого настройки пользователя нужно прочитать из системного хранилища, изменить и записать обратно.</p>
    <p>Напомним, что процедура НастройкиИнтерфейса() расположена в общем модуле "РаботаСИнтерфейсом" и вызывается из модуля управляемого приложения в обработчике ПриНачалеРаботыСистемы(). В процедуре настройки изучаются роли пользователей, и для пользователя с ролью "Администатор" вызывается процедура формирования расширенного интерфейса.</p>
    <p>Поместим процедуру РасширенныйИнтерфейс() в том же общем модуле и заполним её следующим образом:</p>
    <div class="code-style">
        <pre>
            Процедура РасширенныйИнтерфейс() Экспорт 
                НастройкиИнтерфейса = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиИнтерфейсаКлиентскогоПриложения");
                
                <span class="screen">// Получить состав настроек текущего пользователя</span>
                НастройкиСостава = НастройкиИнтерфейса.ПолучитьСостав();
                
                Лево = НастройкиСостава.Лево;
                Верх = НастройкиСостава.Верх;
                Низ = НастройкиСостава.Низ;
                Право = НастройкиСостава.Право;
                
                <span class="screen">// Добавить свои панели</span>
                ПанельОткрытых = Новый ЭлементНастройкиСоставаИнтерфейсаКлиентскогоПриложения("ПанельОткрытых");
                ПанельФункцийТекущегоРаздела = Новый ЭлементНастройкиСоставаИнтерфейсаКлиентскогоПриложения("ПанельФункцийТекущегоРаздела");
                ПанельИзбранного = Новый ЭлементНастройкиСоставаИнтерфейсаКлиентскогоПриложения("ПанельИзбранного");
                
                Если Верх.Количество() > 0 Тогда 
                    Верх.Очистить();
                КонецЕсли;
                
                ГруппаВерх = Новый НастройкиСоставаИнтерфейсаКлиентскогоПриложения();
                ГруппаВерх.Верх.Добавить(ПанельОткрытых);
                ГруппаВерх.Верх.Добавить(ПанельФункцийТекущегоРаздела);
                Верх.Добавить(ГруппаВерх.Верх);
                
                Для Каждого Панель Из Лево Цикл
                    Если Панель.Имя = "ПанельФункцийТекущегоРаздела" Тогда
                        Лево.Удалить(Лево.Индекс(Панель));
                    КонецЕсли;
                    Если Панель.Имя = "ПанельИзбранного" Тогда
                        Лево.Удалить(Лево.Индекс(Панель));
                    КонецЕсли;
                КонецЦикла;
                
                Лево.Добавить(ПанельИзбранного);
                
                <span class="screen">// Загрузить настройки состава в настройки пользователя</span>
                НастройкиИнтерфейса.УстановитьСостав(НастройкиСостава);
                
                <span class="screen">// Положить объект настроек текущему пользователю в хранилище.</span>
                ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиИнтерфейсаКлиентскогоПриложения", , НастройкиИнтерфейса);
            КонецПроцедуры
        </pre>
    </div>  
    <p>В этой процедуре сначала мы загружаем из системного хранилища настройки текущего пользователя в переменную НастройкиИнтерфейса. Затем с помощью метода ПолучитьСостав() мы получаем настройки состава интерфейса, заданные пользователем. После этого с помощью свойств "Верх", "Лево", "Право", "Низ" получаем список панелей и групп панелей, размещённых в верхней, левой, правой и нижних частях основного окна клиентского приложения.</p>  
    <p>Затем создаём конструктором новые элементы настройки состава интерфейса на основании стандартных имён панелей: "ПанельОткрытых", "ПанельФункцийТекущегоРаздела" и "ПанельИзбранного".</p>  
    <p>Нужно обратить внимание на один миг. Здесь, в отличии от настройки панелей для менеджера, мы не очищаем списки панелей, так как нам нужно добавить свои панели к списку панелей пользователя.</p>  
    <p>Поэтому в общем случае, перед тем как добавлять панели, надо проверить, не содержится ли в каждой из четырёх групп (Верх, Лево, Право, Низ) настроек состава интерфейса, заданных пользователем. Это нкжно сделать потому, что панель интерфейса не может быть дважды включена ни в одну и ту же , ни в разные группы настроек состава интрфейса.</p>  
    <p>Для упрощения примера мы будем проверять наличие трёх панелей (которые мы собираемся добавлять) только в левой группе настроек состава пользовательского интерфейса. И если наши панели там уже содержатся, будем их просто удалять. А верхнюю группу будем очищать, несмотря на настройки пользователя.</p>  
    <p>После выполнения этих проверок мы конструктором создаём пустой объект НастройкиСоставаИнтерфейсаКлиентскогоПриложения. И добавляем в верхнюю часть этих настроек (ГруппаВерх.Верх) созданные ранее элементы настройки состава интерфейса - ПанельОткрытых и ПанельФункцийТекущегоРаздела. И затем уже эту новую группу настроек (ГруппаВерх.Верх) добавляем в верхнюю группу пользовательских настроек состава. Таким образом, мы расположили эту группу вверху основного окна приложения пользователя.</p>  
    <p>ПанельИзбранного просто добавляем в левую группу пользовательских настроек состава, так как перед этим мы удаляем её из списка панелей (если они там содержатся).</p>  
    <p>После этого с помощью метода УстановитьСостав() мы загружаем изменённые настройки состава в пользовательские настройки состава интерфейса.</p>  
    <p>В заключении сохраняем эти настройки для текущего пользователя в хранилище системных настроек с ключом "Общее/НастройкиИнтерфейсаКлиентскогоПриложения".</p>  
    <p>Запустим 1С:Предприятие от имени пользователя с ролью Администратор. Мы видим, что в левой части основного окна клиентского приложения появилась панель избранного, а сверху, несмотря на личные настройки пользователя, в одной строке располагаются панель открытых и панель функций текущего раздела. При этом панель открытых отображается в нижней части основного окна приложения - в соотвествии с пользовательскими настройками, сделанными ранее:</p>
    <img src="../img/1С-1/2024-03-26_10-14-58.png" class="screen" alt="">  
    <p><span class="vue-r">Замечу от себя. Если запускать решение без предварительного сохранения ранее сделанных настроек, то видимо метод Загрузить по указанному пути не найдёт никаких настроек. Поэтому надо зайти в пользовательский режим, как то подвигать панели и выйти, настройки сохранятся. А потом снова запускать решение, но уже код раскоментировать и тогда настройки найдутся, изменятся и применятся.</span></p>  

    <p class="title-size16"><b id="chapter3.21.2">Настройка состава форм на начальной странице</b></p>
    <p>По подобию с предыдущим примером можно при начале работы прикладного решения в зависимости от роли пользователя программно формировать его начальную страницу.</p>  
    <p>Основной объект, с помощью которого выполняется настройка начальной страницы, - <b>НастройкаНачальнойСтраницы</b>. Он позволяет работать как с настройками, заданными в конфигураторе, так и с настройками, которые пользователь установил для себя.</p>  
    <p>Продолжим наш пример. В процедуру НастройкаИнтерфейса() общего модуля РаботаСИнтерфейсом добавим вызов процедур для формирования начальной страницы для пользователя с ролью Администратор(Иванов) и для пользователя с ролью Менеджер(Петров).</p>  
    <div class="code-style">
        <pre>
            Процедура НастройкаИнтерфейса() Экспорт 
                ПользовательИБ = ПользователиИнформационнойБазы.ТекущийПользователь();	
                Для Каждого РольПользователя Из ПользовательИБ.Роли Цикл
                    Если РольПользователя.Имя = "Администратор" Тогда
                        РасширенныйИнтерфейс();
                        <b>СложнаяНачальнаяСтраница();</b>
                    КонецЕсли;
                    Если РольПользователя.Имя = "Менеджер" Тогда
                        МинимальныйИнтерфейс();
                        <b>ПростаяНачальнаяСтраница();</b>
                    КонецЕсли;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>На начальной странице менеджера будем отображать слева форму списка справочника Товары, а справа - форму отчёта ЦенаТоваров. Причём независимо от его личных настроек и настроек, сделанных в конфигураторе.</p>  
    <p>Поместим в общем модуле РаботаСИнтерфейсом процедуру ПростаяНачальнаяСтраница() и заполним её след. образом:</p>
    <div class="code-style">
        <pre>
            Процедура ПростаяНачальнаяСтраница() Экспорт 
                НачальнаяСтраница = Новый НастройкиНачальнойСтраницы;
                <span class="vue-g">//СоставФорм = Новый СоставФормНачальнойСтраницы;</span>
                СоставФорм = НачальнаяСтраница.ПолучитьСоставФорм();
                
                СоставФорм.ЛеваяКолонка.Очистить();
                СоставФорм.ПраваяКолонка.Очистить();
                
                СоставФорм.ЛеваяКолонка.Добавить("Справочник.Товары.ФормаСписка");
                СоставФорм.ПраваяКолонка.Добавить("Отчет.ЦеныТоваров.Форма.ФормаОтчета");
                
                НачальнаяСтраница.УстановитьСоставФорм(СоставФорм);
                ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиНачальнойСтраницы", "", НачальнаяСтраница);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре мы конструктором создаём пустой объект НастройкиНачальнойСтраницы. Затем с помощью метода этого объекта ПолучитьСоставФорм() мы получаем состав форм начальной страницы, заданный в конфигураторе.</p>
    <p>В нашем случае в конфигураторе начальная страница настроена следующим образом:</p>
    <img src="../img/1С-1/2024-03-26_16-51-10.png" class="screen" alt="">
    <p>очищаем список форм, размещённых в левой и правой колонке начальной страницы. И добавляем в левую колонку форму списка справочника Товары, а в правую - форму отчёта ЦенаТоваров.</p>
    <p>При указании имени формы можно использовать как полные имена форм объектов конфигурации (например, Справочник.Товары.Форма.ИмяФормы), так и стандартные имена форм (например, Справочник.Товары.ФормаСписка).</p>
    <p>Также нужно учитывать, что при программной настройке начальной страницы нельзя изменить шаблон начальной страницы. Будет использоваться тот шаблон, который задан в конфигураторе.</p>
    <p>После этого с помощью метода УстановитьСоставФорм() мы загружаем изменённые настройки начальной страницы в пустой объект НастройкиНачальнойСтраницы.</p>
    <p>И в заключении сохраняем эти настройки для текущего пользователя в хранилище системных настроек с ключом "Общее/НастройкиНачальнойСтраницы".</p>
    <p>Запустим 1С:Пердприятие от имени пользователя с ролью Менеджер(Петров). Независимо от настроек, сделанных в конфигураторе, и от личных настроек менеджера, сделанных в прошлом сеансе работы, при начале работы прикладного решения на его начальной странице всегда слева будет отображаться список товаров, а справа - отчёт, показывающий цены товаров.</p>
    <p>Теперь рассмотрим формирование начальной страницы для пользователя с ролью Администратор на основе настроек, сделанных им в режиме 1С:Предприятие.</p>
    <p>Предположим, админ в пользовательском режиме изменил состав форм на начальной странице, заданный в конфигураторе. Он скрыл форму списка товаров, перенёс из правой колонки начальной страницы в левую колонку форму списка справочника Организации и форму обработки "Заполнение данных". А также админ перетащил форму списка справочника "Расчетные счета" из списка доступных форм в правую колонку начальной страницы:</p>
    <img src="../img/1С-1/2024-03-26_22-03-45.png" class="screen" alt="">
    <p>После изменения эти настройки были сохранены в системном хранилище для пользователя с ролью Администратор. И теперь при начале работы прикладного решения на начальной странице администратора показывается тот вид, который он настроил для себя в режиме 1С:Предприятие:</p>
    <img src="../img/1С-1/2024-03-26_22-07-29.png" class="screen" alt="">
    <p>Теперь мы хотим немного изменить и расширить эти настройки из встроенного языка. А именно - мы хотим отображать для админа в левой колонке форму списка справочника Организации, а в правой - форму обработки "Заполнение данных". Остальные настройки, которые админ сделал, должны остаться без изменения.</p>
    <p>Для этого настройки пользователя надо прочитать из системного хранилища, изменить и записать обратно.</p>
    <p>Поместим в общем модуле процедуру СложнаяНачальнаяСтраница() и заполним её след. образом:</p>
    <div class="code-style">
        <pre>
            Процедура СложнаяНачальнаяСтраница() Экспорт 
                НастройкиНачальнойСтраницы = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиНачальнойСтраницы");
                СоставФорм = НастройкиНачальнойСтраницы.ПолучитьСоставФорм();
                
                Левая = СоставФорм.ЛеваяКолонка;
                Правая = СоставФорм.ПраваяКолонка;
                
                ИмяФормы = "Справочник.Организации.Форма.ФормаСписка";
                ИндексФормы = Правая.Найти(ИмяФормы);
                Если ИндексФормы &lt;> Неопределено Тогда
                    Правая.Удалить(ИндексФормы);
                КонецЕсли;
                ИндексФормы = Левая.Найти(ИмяФормы);
                Если ИндексФормы = Неопределено Тогда
                    Левая.Добавить("Справочник.Организации.Форма.ФормаСписка");
                КонецЕсли;
                
                ИмяФормы = "Обработка.ЗаполнениеДанных.Форма.Форма";
                ИндексФормы = Левая.Найти(ИмяФормы);
                Если ИндексФормы &lt;> Неопределено Тогда
                    Левая.Удалить(ИндексФормы);
                КонецЕсли;
                ИндексФормы = Правая.Найти(ИмяФормы);
                Если ИндексФормы = Неопределено Тогда
                    Правая.Добавить("Обработка.ЗаполнениеДанных.Форма.Форма");
                КонецЕсли;
                
                НастройкиНачальнойСтраницы.УстановитьСоставФорм(СоставФорм);
                ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиНачальнойСтраницы", "", НастройкиНачальнойСтраницы);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре сначала мы загружаем из системного хранилища настройки текущего пользователя в переменную НастройкиНачальнойСтраницы. Затем с помощью метода ПолучитьСоставФорм() мы получаем состав форм начальной страницы, заданный пользователем. После этого с помощью свойств ЛеваяКолонка и ПраваяКолонка получаем список форм, размещённых в левой и правой колонках начальной страницы.</p>
    <p>Здесь, в отличие от настройки начальной страницы для менеджера, мы не очищаем список форм, так как нам нужно добавить свои формы к списку форм пользователя.</p>
    <p>Надо заметить, что форма может несколько раз содержаться и в одной и той же, и в разных колонках начальной страницы. Но это будет по меньшей мере "некрасиво" и совершенно не нужно.</p>
    <p>Поэтому перед добавлением форм на начальную страницу мы будем проверять их наличие в настройках пользователя. И будем добавлять форму в случае её отсутствия той колонке, в которую мы хотим её добавить, и удалять форму, если она уже присутствует в другой колонке.</p>
    <p>Надо учитывать, что для поиска в списках форм левой и правой колонки нужно использовать полные имена форм, соответственно, и при добавлении форм на начальную страницу нужно также использовать эти имена.</p>
    <p>После этого с помощью метода УстановитьСоставФорм() мы загружаем изменённые настройки в пользовательские настройки начальной страницы.</p>
    <p>В заключение сохраняем системные настройки для тек. пользователя в хранилище системных настроек с ключом "Общее/НастройкиНачальнойСтраницы".</p>
    








    

    <h2 class="header-style">Часть 4. Наладка клиент-серверного взаимодействия в формах.</h2>




    <p class="title-size16"><b id="chapter4.1">Глава 4.1. Общие советы по наладке клиент-серверного взаимодействия. Стр 741</b></p>
    <p>Форма должна быть "лёгкой", доступной в веб-клиенте и работать как можно быстро даже при использовании низкоскоростных каналов связи. Данные формы присутствуют как на клиенте, так и на сервере и самостоятельно синхронизируются при клиент-серверном взаимодействии.</p>
    <p>Передача данных между сервером и клиентом происходит во многих случаях - например, при открытии формы и записи данных платформа сама преобразовывает прикладные объекты в данные формы и обратно. При контекстных вызовах процедур модуля формы все изменеия данных формы и её элементов платформа передаёт на сервер и обратно, и т.д.</p>
    <p>Однако нужно понимать, что любое обращение на сервер - это непростой процесс. Платформа формирует обращение к серверу, передаёт его по каналу связи, выполняет какие то действия на сервере, возвращает ответ по каналу связи. При работе тонкого клиента через GPRS каждый вызов сервера занимает примерно 1,5 секунды. Это, естественно, сказывается на быстродействии прикладного решения.</p>
    <p>Поэтому <i style="text-decoration: underline;">разработку прикладного решения нужно вести с контролем количества вызовов серверных процедур и функций из клиентского кода, а также объёма передаваемых данных между клиентом и сервером(трафика)</i>.</p>
    <p>Общее количество серверных вызовов складывается:</p>
    <ul class="list">
        <li>из обращений на сервер, которые выполняет платформа в пользовательском режиме</li>
        <li>вызвово, которые выполняются из клиентского кода конфигурации разработчиком.</li>
    </ul>
    <p>Если рассматривать источник этих вызовов, то существует несколько разделов серверных вызовов:</p>
    <ul class="list">
        <li>вызовы, которые платформа делает в результате того, что пользователь совершает какие то интерактивные действия. На это разработчик повлиять не может.</li>
        <li>вызовы, которые платформа также делает самостоятельно, но при выполнении определённых методов или свойств программного кода. На это разработчик может повлиять, если попробует использовать другие методы, свойства или изменить алгоритм.</li>
        <li>серверные вызовы, которые разработчик делает в явном виде в коде.</li>
    </ul>
    <p>Таким образом, разработчику при создании клиент-серверного взаимодействия в конфигурации нужно стремиться как можно меньше совершать количество вызовов сервера, которые он порождает своим кодом.</p>
    <p>Также разработчику нужно наладить не только количество вызовов, но и объём передаваемых данных между клиентом и сервером (трафик). Неотлаженность решения особенно будет заметна при работе через низскоскоростные каналы связи. Чтобы наглядно оценить скорость работы на плохом канале связи, советуется запускать клиентское приложение в режиме низкой скорости соединения, а в параметрах системы включать режим подражания(подделки, имитации) задержек при вызове сервера.</p>
    <p>С другой стороны, нужно уменьшать объём кода, выполняющегося на клиенте. Это требование продиктовано:</p>
    <ul class="list">
        <li>тем, что, как правило, клиентский компьютер менее производительный, чем серверный;</li>
        <li>необходимостью приемлемого качества работы в веб-клиенте. Клиентский код выполняется интерпритатором встроенного языка, который в веб-клиенте работает медленнее, чем в тонком или толстом клиенте.</li>
    </ul>
    <p>В связи с этим методака наладки клиент-серверного взаимодействия основывается на следующих общих советах:</p>
    <ul class="list">
        <li>Клиент и сервер рассматриваются как два взаимодействующих приложения.</li>
        <li>Разработчик программирует в явном виде серверную и клиентскую части конфигурации.</li>
        <li>Построение кода определяется логикой клиент-серверного взаимодействия, а не логикой того прикладного алгоритма, который воплощает разработчик.</li>
        <li>Клиентский код продумавается не как последовательность действий, которую нужно выполнить, а как сценарий передачи управления между клиентои и сервером.</li>
        <li>Разработчик должен уменьшить частоту вызовов сервера. В совершенстве одному действию пользователя должен соответсвовать один вызов сервера. Например, "хорошим тоном" разработки считается открытие формы за один серверный вызов. Конечно этот совет нельзя считать строго обязательным, но желательно к этому стремиться.</li>
        <li>Разработчик должен пытаться сократить объём передаваемых данных.</li>
        <li>Нужно писать алгоритмы так, чтобы было меньше кода на клиенте, но и меньше вызовов сервера.</li>
    </ul>
    <p>Важно понимать, что стремление наладить код конфигурации должно иметь разумные пределы. Не нужно слепо следовать инструкциям и впадать в крайности. В погоне за наладкой можно сделать код совершенно нечитаемым.</p>
    <p>В этом случае поддержка такого кода станет очень сложным делом. Человек, который не принимал участия в написании этого кода, скорее всего, просто не станет раскапывать этот кладезь наладки. А сам разработчик через полгода - год тоже с большим трудом сможет разобраться в том, что же он написал.</p>
    <p>Таким образом, нужно искать золотую середину между стройным читаемым кодом и его наладкой. Не нужно всегда бездумно стремиться только к одной лишь наладке.</p>



    <p class="title-size16"><b id="chapter4.2">Глава 4.2. Инструменты, используемые при наладке клиент-серверного взаимеодействия. Стр 744</b></p>
    <p>В процессе отладки и работы конфигурации разработчику доступны следующие интременты, которые он может использовать при наладке клиент-серверного взаимодействия:</p>
    <ul class="list">
        <li>показатели производительности;</li>
        <li>режим низкой скорости соединения;</li>
        <li>режим подражания задержек при вызове сервера;</li>
        <li>отображение серверных вызовов в замерах производительности;</li>
        <li>проверка серверных вызовов в обработчиках событий.</li>
    </ul>
    <p>Рассмотрим каждый из них подробнее:</p>

    <p><b id="chapter4.2.1">Показатели производительности</b></p>
    <p>Показатели производительности прикладного решения позволяют рабработчику оценить, насколько отлажено работает прикладное решение. Они дают данные о количестве текущих и накопленных вызовов сервера, длительности вызовов сервера, объёме принятых и отправленных данных. Их можно увидеть в информационной панели окна 1С:Предприятия:</p>
    <img src="../img/1С-1/2024-03-27_09-57-49.jpg" class="screen" alt="">
    <p><i style="text-decoration: underline;">Текущие вызовы</i> - это вызовы сервера с мига последнего действия пользователя. <i style="text-decoration: underline;">Накопленные вызовы</i> - это те вызовы сервера, которые накопились с запуска приложения или с обнуления накопленных показателей.</p>
    <p><i style="text-decoration: underline;">Принято</i> - это объём данных, принятых клиентом от сервера. <i style="text-decoration: underline;">Отправленно</i> - это объём данных, отправленных с клиента на сервер.</p>
    <p>Запустив 1С:Предприятие при включённом отображении показателей производительности, разработчик в текущем времени может увидеть и оценить количество и длительность серверных вызовов, а также объём переданных данных между клиентом и сервером. Изучение этих показателей позволит разработчику отладить клиент-серверное взаимодействие в целях повышения производительности работы прикладного решения.</p>
    <p>Показатели производительности системы отображаются в информационной панели, расположенной в нижней части основного окна приложения. А также там отображается иконка, показывающая включён ли режим подражания задержек при вызове сервера.</p>
    <p>Значок <img src="../img/1С-1/2024-03-27_10-02-00.png" alt=""> в информационной панели означает, что отображение показателей производительности включено. Включить/Выключить его можно как в настройках конфигуратора, так и в пользовательском режиме.</p>
    <p>При запуске сеанса 1С:Предприятия из конфигуратора отображение показателей производительности по умолчанию включено. В этом можно убедиться, выполнив команду главного меню конфигуратора Сервис - Параметры - Запуск 1С:Предприятия - Дополнительные:</p>
    <img src="../img/1С-1/2024-03-27_10-43-28.png" class="screen" alt="">
    <p>В пользовательском режиме можно включить отображение показателей производительности, выполнив команду главного меню Настройки - Параметры:</p>
    <img src="../img/1С-1/2024-03-27_10-47-19.jpg" class="screen" alt="">
    <p>Отображение показателей производительности также можно включить, запустив 1С:Предприятие из командной строки с параметром "/DisplayPerformance".</p>
    <p>По умолчанию в информационной панели будет показано только количество вызовов сервера (накопленное и текущее), но отображение других показателей производительности можно настроить в специальном окне.</p>
    <p>Нажав на значок  <img src="../img/1С-1/2024-03-27_10-02-00.png" alt="">, можно выполнить различные команды контекстного меню:</p>
    <img src="../img/1С-1/2024-03-27_10-55-47.jpg" class="screen" alt="">
    <p>Таким образом, чтобы отладить разрабатываемое приложение, разработчику нужно запустить 1С:Предпритие в режиме отладки из конфигуратора и изучить показатели проиводительности, отражающие клиент-серверное взаимодействие.</p>

    <p><b id="chapter4.2.2">Режим низкой скорости соединения</b></p>
    <p>При отладке клиент-серверного взаимодействия бывает важно и интересно посмотреть, насколько действенно прикладное решение будет работать при использовании низкоскоростных каналов связи.</p>
    <p>Дело в том, что клиентский компьютер может быть подключён к серверу как по локальной сети, так и через Интернет. Связь с сервером через международную сеть может устанавливаться не только через быстрые оптоволоконные каналы, но и через модемы, использующие такие протоколы доступа к данным, как GPRS и т.п.</p>
    <p>В этом случае админу или пользователю 1С:Предприятия нужно указать клиентскому приложению, что оно должно запуститься в режиме низкой скорости соединения.</p>
    <p><i style="text-decoration: underline;">Режим низкой скорости соединения</i> - это способ работы клиентского приложения, позволяющий ему функционировать на медленных каналах связи как можно успешнее.</p>
    <p>При запуске в этом режиме платформа самостоятельно придпринимает шаги по отладки взаимодействия с сервером. Она отключает некоторую функциональность прикладного решения - например, не показывает начальную страницу, и картинки разделов, объединяет и уменьшает вызовы сервера, дополнительно сжимает данные и т.д.</p>
    <p>Таким образом, даже на плохом канале связи в режиме низкой скорости соединения 1С:Предприятие будет обеспечивать приемлемую скорость работы пользователей.</p>
    <p>Заметим, что установка низкой скорости соединения имеет смысл только для тонкого клиента и веб-клиента, т.к. толстый клиент не умеет работать через международную сеть.</p>
    <p>Задать низкую скорость соединения можно для всей инфобазе при её создании или редактировании в списке инфобазв начальном окне 1С:Предприятия:</p>
    <img src="../img/1С-1/2024-03-27_18-41-55.png" class="screen-2" alt="">
    <p>Также если в свойстве "Скорость соединения" установлено "Выбирать при запуске", то режим низкой скорости соединения может задать сам пользователь в диалоге выбора инфобазы:</p>
    <img src="../img/1С-1/2024-03-27_18-46-00.png" class="screen" alt="">
    <p>Кроме того, при любых настройках инфобазы низкую скорость соединения можно указать с помощью параметра командной строки. Для запуска тонкого клиента используется параметр "/0 Low".</p>
    <p>Для веб-клиента и тонкого клиента, подключаемого по протоколу HTTP, используется параметр "/0=Low":</p>
    <div class="code-style">
        <pre>
            https://demo-ma.1c.ru/demo_ma?N=Administrator&0=Low
        </pre>
    </div>
    <p>Для сеансов 1С:Предприятие, запускаемых из конфигуратора, тоже можно задать режим низкой скорости соединения. Для этого нужно выполнить команду главного меню "Сервис - Параметры - Запуск 1С:Предприятия - Основные" и установить флажок "Низкая скорость соединения":</p>
    <img src="../img/1С-1/2024-03-27_19-00-33.png" class="screen" alt="">
    <p>Режим низкой скорости соединения, как уже говорилось выше, сказывается на внешнем функционировании тонкого клиента и веб-клиента. Например, не отображается начальная страница при начале работы приложения, не отображаются картинки разделов, самостоятельно не формируется список выбора при вводе по строке и т.д.</p>
    <p>Если в режиме 1С:Предпритие вызвать окно информации о программе ("Сервис и настройки - О программе"), то можно увидеть, в какой скорости соединения запущено приложение:</p>
    <img src="../img/1С-1/2024-03-27_20-00-44.png" class="screen-2" alt="">
    <p>Заметим, что режим низкой скорости соединения задаёься один раз при запуске клиентского приложения и не может быть изменён в процессе его работы.</p>
    <p>Таким образом, чтобы наглядно оценить, с какой скоростью будет работать решение у клиента на низкоскоростном канале связи, разработчику нужно подключиться к Интернету, например, через мобильный телефон, и запустить тонкий клиент в режиме низкой скорости соединения.</p>

    <p><b id="chapter4.2.3">Имитация задержек при вызове сервера</b></p>
    <p>Однако разработчик может и не использовать специальные медленные соединения через сеть, но при этом оценить настоящую скорость работы его прикладного решения у клиента. Для этого предназначен "режим имитации задержек при вызове сервера". При подключении этого режима платформа (даже в файловом способе на локальном компе) будет работать с теми временными задержками, с которыми работает настоящий канал связи.</p>
    <p>Этот режим не нужно путать с режимом низкой скорости соединения.</p>
    <p><i style="text-decoration: underline;">Режим низкой скорости соединения</i> - это скорее, интсрумент пользователя. Пользователь устанавливает этот режим, чтобы приложение на медленных каналах связи работало как можно быстрее. Данный режим задаётся при запуске клиентского приложения и не может быть изменён в процессе его работы.</p>
    <p><i style="text-decoration: underline;">Режим имитации задержек при вызове сервера</i> - это интсрумент разработчика, позволяющий ему превратить быстрый канал связи в медленный. Причём сделать это можно как при запуске приложения, так и процессе его работы. При этом режим, в котором было запущено клиентское приложение, не изменится.</p>
    <p>Заметим, что включать режим имитации задержек при вызове сервера можно только для тонкого и толстого клиента, запущенного в режиме управляемого приложения.</p>
    <p>Этот режим можно задать в параметрах конфигуратора, чтобы при запуске в режиме отладки приложение сразу работало в "плохих условиях". Для этого нужно выполнить команду главного меню: "Сервис - Параметры - Запуск 1С:Предприятие - Основные" и установить флажок "Имитировать задержку при вызовах сервера":</p>
    <img src="../img/1С-1/2024-03-27_19-00-34.png" class="screen" alt="">
    <p>При этом можно установить нужные временные задержки при вызове сервера и при передаче/получении данных с сервера. Платформа использует стандартные задержки, соответсвующие мобильному интернет соединению. Но разработчик может подобрать другие значения временных задержек, соответствующие характеристикам канала связи, используемого заказчиком.</p>
    <p>При запуске 1С:Предпрития в режиме имитациив информационной панели приложения появится значок <img src="../img/1С-1/2024-03-27_22-53-56.png" alt=""></p>
    <p>В текущем рабочем сеансе также можно включить/выключить режим имитации задержек при вызове сервера. Для этого нужно выполнить команду главного меню "Сервис и настройки - Настройки - Параметры" и установить флажок "Имитировать задержку при вызовах сервера":</p>
    <img src="../img/1С-1/2024-03-27_23-00-13.png" class="screen-2" alt="">
    <p>Режим имитации задержек при вызове сервера также можно включить, запустив 1С:Предприятие из командной строки с параметром: <b>/SimulateServerCallDelay [-CallXXXX] [-SendYYYY] [-ReceiveZZZZ]</b></p>
    <p>Таким образом, чтобы нагладно оценить, с какой скоростью будет работать прикладное решение у клиента на низкоскоростном канале связи, разработчику нужно запустить тонкий клиент в режиме низкой скорости соединения и установить режим имитации задержек при вызове сервера (при этом не нужно использовать специальные медленные каналы связи, можно это сделать даже в файловом варианте на локальном компе).</p>

    <p><b id="chapter4.2.4">Отображение серверных вызовов в замерах производительности</b></p>
    <p><i style="text-decoration: underline;">Замер производительности</i> позволяет оценить скорость работы всей конфигурации или любой её части в процессе отладки. При этом измеряются частота и скорость выполнения отдельных участков кода, указывается где выполняется код (на сервере или на клиенте), помечаются строки кода, приведшие к вызову сервера.</p>
    <p>Для того чтобы выполнить замер производительности какого-либо участка конфигурации, нужно запустить 1С:Предприятие из конфигуратора в режиме отладки, дойти в ходе выполнения до интересующего участка, перейти в режим Конфигуратор и выполнить команду главного меню "Отладка - Замер производительности". Затем вернутся в режим 1С:Предприятие, продолжить выполнение приложения, а когда замер производительности больше не нужен - повторно выполнить команду "Отладка - Замер производительности" из конфигуратора. После этого в конфигураторе откроется окно с результатами замера, выполненного между двумя этими нажатиями.<</p>
    <img src="../img/1С-1/2024-03-28_08-35-40.png" class="screen" alt="">
    <p>Эти результаты можно сохранить в файл для дальнейшего изучения с помощью команд "Файл - Сохранить" и "Файл - Сохранить как". Файл будет иметь расширение *.pff.</p>
    <p>В окне результатов замера в колонке "Обр. сервером"(Обработка сервером) показываются серверные вызовы, которые выполняются платформой и/или производятся из клиентского кода:</p>
    <ul class="list">
        <li>вызовы сервера методами объектов встроенного языка, вызовы процедур и функций, исполнение которых происходит на сервере, отображаются с помощью значка <img src="../img/1С-1/2024-03-28_08-41-10.png" alt=""></li>
        <li>вызовы клиентских процедур и функций, в которых тем или иным способом происходил вызов сервера, отображаются с помощью значка <img src="../img/1С-1/2024-03-28_08-43-35.png" alt=""></li>
    </ul>
    <p>В окне результатов замера показывается, где исполнялся код на встроенном языке: на клиенте или на сервере:</p>
    <ul class="list">
        <li>строки кода на встроенном языке, исполнение которых происходило на клиенте, отображаются в колонке "Клиент" с помощью значка <img src="../img/1С-1/2024-03-28_08-46-33.png" alt=""></li>
        <li>строки кода на встроенном языке, исполнение которых происходило на сервере, отображаются в колонке "Сервер" с помощью значка <img src="../img/1С-1/2024-03-28_08-47-02.png" alt=""></li>
    </ul>
    <p>По любой колонке окна результатов замера возможна сортировка. Для этого достаточно щёлкнуть мышью в соответсвующей колонке.</p>
    <p>В окне результатов замера существует возможность фильтрации данных. такая возможность воплощена в виде двух флажков (Клиент и Сервер) в правой нижней части окна результатов замера. По умолчанию установлены оба флажка, т.е. в результатах замера присутсвуют данные о ходе исполнения кода как на клиенте, так и на сервере.</p>
    <p>Изучение замеров производительности в процессе разработки может дать дополнительную информацию, детализирующую данные показателей производительности.</p>
    <p>Совместное использование этих двух интсрументов позволит выявить узкие места в приложении даже без наличия большой тестовой основы и без выполнения нагрузочной проверки.</p>

    <p><b id="chapter4.2.5">Проверка серверных вызовов в обработчиках событий</b></p>
    <p>При отладке клиент-серверного взаимодействия разработчик должен учитывать, что в некоторых клиентских обработчиках событий формы (ПередЗаписью(), ПослеЗаписи(), ПередЗакрытием(), ПриЗакрытии() и др.) запрещается вызывать контекстные серверные процедуры.</p>
    <p>При описании таких событий в синтакс-помощнике содержится специальное указание на запрещённое действие или описание действия, которое может привести в недопустимому вызову:</p>
    <ul class="list">
        <li>В обработчике данного события нельзя использовать серверные методы формы с директивой компиляции &НаСервере.</li>
        <li>Изменение свойства на клиенте может потребовать обращения к серверу.</li>
        <li>Вызов метода выполняет обращение к серверу.</li>
    </ul>
    <p>Последние два предупреждения означают, что использование указанных клиентских методов или изменение некоторых свойтв на клиенте могут приводит к неявным серверным вызовам. Поэтому разработчик не может применять их в обработчике события, для которого запрещены контекстные серверные вызовы.</p>
    <p>Дело в том, что подобные вызыво потенциально могут нарушить алгоритмы функционирования форм. Поэтому они запрещены на уровне платформы, в процессе исполнения прикладного кода в режиме 1С:Предприятия. Но в процессе написания кода разработчик может допустить такую ошибку. И для того, чтобы обнаружить такую ошибку заранее (а не в режиме исполнения), существует эта проверка.</p>
    <p>Тут немного далее не дописал, не интересно, если будет нужно , то допишу.</p>





    <p class="title-size16"><b id="chapter4.3">Глава 4.3. Примеры наладки клиент-серверного взаимодействия. Стр 760</b></p>

    <p><b id="chapter4.3.1">Объединение нескольких вызовов сервера в один</b></p>
    <p>В процессе работы формы часто бывает нужно получить дополнительные данные об объекте, на который ссылается поле реквизита, и отразить её в форме. Как это сделать наиболее правильно? Рассмотрим пример.</p>
    <p>Предположим в конфигурации есть справочник Товары. В нём для каждого товара хранятся его артикул, единица измерения и цена. Для приходования товаров существует документ "ПриходнаяНакладная", в табличную часть которого подбираются товары.</p>
    <p>Хочется, чтобы пользователь, выбрав товар, видел в документе не только ссылку, но сразу же и артикул, и единицу измерения, и цену выбранного товара:</p>
    <img src="../img/1С-1/2024-03-28_09-19-08.png" class="screen" alt="">
    <p>Выбор товара происходит на клиенте, но на клиенте, имея ссылку на товар, нельзя получить значения реквизитов от этой ссылки, например, "Артикул".</p>
    <p>Чтобы его получить, нужно "пойти" с этой ссылкой на сервер, там прочитать из базы значение артикула и передать его обратно на клиент.</p>
    <p>Рассмотрим разновидности решения этой задачи.</p>
    <p><b>Первый способ решения</b></p>
    <p><span class="vue-b">Пример можно посмотреть в базе "01(вар. 1) Объединение нескольких вызовов сервера в один".</span></p>
    <p>Как уже говорилось выше, возможности ссылки на клиенте сильно ограничены. Чтобы воспользоваться полными возможностями ссылки. можно, например, создать универсальную функцию ПолучитьРеквизитИзБазыДанных(Ссылка, ИмяРеквизита), поместить её в общем модуле, исполняющемся на сервере, и использовать её всякий раз, когда требуется получить реквизит какого-нибудь объекта.</p>
    <p>Поскольку функция универсальная, мы будем использовать её в разных формах, поэтому поместим её не в какой-то одной форме, а в общем модуле, чтобы все формы могли ею пользоваться.</p>
    <p>Итак, создадим общий модуль конфигурации "РаботаСОбъектами". По умолчанию у него установлен флажок Сервер, значит, объекты этого модуля будут скомпилированны на стороне сервера. Установим к него флажок "Вызов сервера", чтобы экспортируемые процедуры и функции этого модуля можно было вызывать с клиента.</p>
    <p>Поместим в этом модуле функцию для получения реквизита объекта по его ссылке:</p>
    <div class="code-style">
        <pre>
            Функция ПолучитьРеквизитИзБазыДанных(Ссылка, ИмяРеквизита) Экспорт
                Возврат Ссылка[ИмяРеквизита]; 
            КонецФункции
        </pre>
    </div>
    <p>Чтобы обеспечить заполнение колонок табличной части приходной накладной при выборе товара, создадим форму документа и обработчик события ПриИзменении() для поля формы Товар, содержащегося в таблице формы Товары:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыТоварПриИзменении(Элемент)
                ДанныеТекущейСтроки = Элементы.Товары.ТекущиеДанные;
                ВыбранныйТовар = ДанныеТекущейСтроки.Товар;
                ДанныеТекущейСтроки.Артикул = РаботаСОбъектами.ПолучитьРеквизитИзБазыДанных(ВыбранныйТовар,"Артикул");
                ДанныеТекущейСтроки.ЕдИзм = РаботаСОбъектами.ПолучитьРеквизитИзБазыДанных(ВыбранныйТовар,"ЕдиницаИзмерения");
                ДанныеТекущейСтроки.Цена = РаботаСОбъектами.ПолучитьРеквизитИзБазыДанных(ВыбранныйТовар,"Цена");
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы получаем доступ к данным текущей строки таблицы формы и помещаем их в переменную "ДанныеТекущейСтроки". Чтобы получить значение, содержащееся в конкретном поле текущей строки, нужно через точку указать имя этого поля (.Товар). Так мы получаем ссылку на выбранный товар и вместе с именем нужного реквизита передаём её в функцию ПолучитьРеквизитИзБазыДанных(), которая возвращает нам значение этого реквизита.</p>
    <p>Посмотрим теперь, какие серверные вызовы будут происходить в режиме 1С:Предприятие, откроем приходную накладную и сделаем выбор из справочника товаров в колонке Товар. После этого колонки табличной части "Артикул", "ЕдИзм" и "Цена" будут самостоятельно заполнены значениями из справочника Товары:</p>
    <img src="../img/1С-1/2024-03-28_10-50-35.png" class="screen" alt="">
    <p><span class="vue-r">Поначалу я подумал, какие 3 раза вызова сервера, ведь объект с первого раза должен закешироваться и потом уже из кешированного объекта получаем данные. Это так, наверно, но речь идёт о вызове сервера, а не о количестве обращений в БД. Функция из общего модуля находится на сервере и мы её из модуля формы вызываем 3 раза.</span></p>
    <img src="../img/1С-1/2024-03-28_10-58-02.png" class="screen" alt="">
    <p>Также вызовы сервера можно увидеть в информационной панели внизу:</p>
    <img src="../img/1С-1/2024-03-28_11-02-54.png" class="screen-2" alt="">
    <p>Там будет показано число вызовов сервера, в общем случае их будет 3 или больше. Больше трёх вызовов может быть при первом выполнении этого действия, т.к. платформа выполняет запрос к базе и кеширование необходимых данных. При втором и последующем выборе товара произойдёт три вызова сервера.</p>
    <p><span class="vue-r">У меня при выборе товара было 4 текущих вызова сервера, затем при выборе опять этого же товара уже 3 вызова. Потом при выборе другого товара опять 4 и при повторном выборе этого же товара - 3. Видно что при первом выборе товара 1 вызов видимо уходит на выполнение кеширования объекта.</span></p>
    <p>Как мы уже говорили выше, когда платформа самостоятельно обращается к серверу, на это мы повлиять не можем. Поэтому подробно исследовать, почему серверных вызовов больше трёх, мы не будем. Но три серверных вызова - это "наши вызовы", которые мы породили свои кодом. Рассмотрим подробнее, откуда они взялись.</p>
    <p>Так происходит потому, что в результате использования универсальной функции ПолучитьРеквизитИзБазыДанных() будет происходить обращение на сервер столько раз, сколько понадобится получить реквизитов объекта. Таким образом, при выборе товара в строке табличной части документа произошло три вызова сервера, так как нам понадобилось узнать значение трёх реквизитов выбранного товара.</p>
    <p><b>Второй способ решения</b></p>
    <p>На самом деле нет необходимости три раза вызывать сервер. Ведь мы точно знаем, что каждый раз при добавлении нового товара нам понадобятся все три его реквизита. А значит, все их можно получить за один серверный вызов. Это будет более правильным решением.</p>
    <p>В данном случае универсальность выбранного нами решения нужно принести в жертву правильности работы конкретной формы в конкретном случае. В данном случае прежде всего нас должна заботить не универсальность, а прикладная логика работы формы. Универсальность сама по себе хороша, но не в данном случае. Т.е. нет одного решения на все времена. В каждой форме нужно думать заного.</p>
    <p>Для воплощения этого решения в обработчике события ПриИзменении() поля Товар табличной части документа ПриходнаяНакладная нужно вызвать функцию, возвращающую  в виде структуры сразу все нужные нам реквизиты выбранного объекта. Поэтому в модуле формы документа поместим функцию ПолучитьРеквизитыТовара(), выполняющуюся на сервере без контекста формы:</p>
    <div class="code-style">
        <pre>
            &НаСервереБезКонтекста
            Функция ПолучитьРеквизитыТовара(Ссылка)
                РеквизитыТовара = Новый Структура;
                РеквизитыТовара.Вставить("Артикул", Ссылка.Артикул);
                РеквизитыТовара.Вставить("ЕдиницаИзмерения", Ссылка.ЕдиницаИзмерения);
                РеквизитыТовара.Вставить("Цена", Ссылка.Цена);
                Возврат РеквизитыТовара;
            КонецФункции
        </pre>
    </div>
    <p>В этой функции мы создаём структуру и заполняем её поля Артикул, ЕдиницаИзмерения и Цена значениями соответствующих реквизитов справочника Товары.</p>
    <p>Единственное значение данных формы, которое нам понадобится в этой функции, - это ссылка на элемент справочника, его мы передаём в параметре Ссылка. Поэтому мы выполняем внеконтекстовый серверный вызов, который будет работать значительно быстрее, чем вызов сервера с контекстом. Подробнее этот вопрос будет рассмотрен в следующем примере.</p>
    <p>Как видим, функция будет совершенно не универсальная, зато форма будет работать быстро за счёт уменьшения серверных вызовов. Т.е. вместо трёх вызовов, как раньше, будет происходить всего один.</p>
    <p>Теперь изменим обработчик события ПриИзменении() поля Товар следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыТоварПриИзменении(Элемент)
                ДанныеТекущейСтроки = Элементы.Товары.ТекущиеДанные;
                ВыбранныйТовар = ДанныеТекущейСтроки.Товар;
                РеквизитыТовара = ПолучитьРеквизитыТовара(ВыбранныйТовар);
                
                ДанныеТекущейСтроки.Артикул = РеквизитыТовара.Артикул;
                ДанныеТекущейСтроки.ЕдИзм = РеквизитыТовара.ЕдиницаИзмерения;
                ДанныеТекущейСтроки.Цена = РеквизитыТовара.Цена;
            КонецПроцедуры
        </pre>
    </div>
    <p>Теперь если запустить пользовательский режим и добавить первый товар, то внизу ф панели будет теперь 2 вызова сервера, но если ещё раз добавить этот же товар, то уже будет 1 вызов. Как и писали ранее, при первом выборе товаров один лишний вызов делает сама платформа.</p>
    <p>Таким образом мы видим настоящий выигрыш в производительности прикладного решения по сравнению с предыдущим способом.</p>
    <p>Однако заметьте, что мы получали реквизиты товара по его ссылке. Эта возможность платформы очень удобная, но приводящая к загрузке всего объекта в память, что не всегда нужно. Допустим, нам нужно получить только три реквизита товара, а всего их пятьдесят. Поэтому правильнее использовать запрос для получения реквизитов товара.</p>
    <p><span class="vue-r">Замечу от себя, почему всегда правильнее использовать запрос, даже если мы выбираем 3 реквизита, а там их всего три и поэтому можно и через ссылку, но может так случиться, что в дальнейшем справочник Товары разрастётся в своих реквзитах до пятидесяти, вот тогда и сразу просядет написаный нами ранее код, через ссылку получающий реквизиты. Поэтому пишем всегда через запрос, как я понял.</span></p>
    <p>В связи с этим изменим функцию для получения реквизитов товара в модуле формы следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаСервереБезКонтекста
            Функция ПолучитьРеквизитыТовара2(ТоварСсылка)
                РеквизитыТовара = Новый Структура;
                
                Запрос = Новый Запрос;
                Запрос.Текст = "ВЫБРАТЬ
                            |	Товары.Артикул,
                            |	Товары.ЕдиницаИзмерения,
                            |	Товары.Цена
                            |ИЗ
                            |	Справочник.Товары КАК Товары
                            |ГДЕ
                            |	Товары.Ссылка = &Ссылка";
                Запрос.УстановитьПараметр("Ссылка", ТоварСсылка);
                Выборка = Запрос.Выполнить().Выбрать();
                Если Выборка.Следующий() Тогда
                    Артикул = Выборка.Артикул;
                    ЕдиницаИзмерения = Выборка.ЕдиницаИзмерения;
                    Цена = Выборка.Цена;
                Иначе
                    Артикул = 0;
                    ЕдиницаИзмерения = 0;
                    Цена = 0;
                КонецЕсли;

                РеквизитыТовара.Вставить("Артикул", Артикул);
                РеквизитыТовара.Вставить("ЕдиницаИзмерения", ЕдиницаИзмерения);
                РеквизитыТовара.Вставить("Цена", Цена);
                Возврат РеквизитыТовара;
            КонецФункции
        </pre>
    </div>
    <p><b>Подитожим</b></p>
    <p>В процессе работы прикладного решения любое обращение на сервер сказывается на его производительности. Поэтому нужно стараться получить всю необходимую информацию за один вызов сервера.</p>
    <p>Таким образом, из показанных способов решения задачи более правильным будет второй способ.</p>

    <p><b id="chapter4.3.2">Использование внеконтекстных серверных процедур в модуле формы</b></p>
    <p>Серверные процедуры и функции могут исполняться с передачей контекста формы на сервер и без.</p>
    <p>При контекстных серверных вызовах процедур в модуле формы форма передаёт свои данные (реквизиты) и элементы на сервер и обратно. Данные формы становятся доступны на сервере, но нужно понимать, что передача контекста формы на сервер - это целый непростой процесс.</p>
    <p>Ведь контекст формы сначала на клиенте нужно подготовить к передаче, упаковать, а потом на сервере создать специальную среду, в которой будет исполняться код, развернуть весь полученный контекст, инициализировать им эту среду и т.д. После выполнения процедуры изменённые данные снова "поедут" на клиент, если их нужно отображать в форме. На всё это, естественно, тратятся время и ресурсы системы.</p>
    <p>Однако использование контекстных серверных процедур необходимо, когда нужно, например, поменять данные во всей табличной части или когда нужно при этом поработать с тем объектом, который отображается в форме, выполнить его экспортируемый метод и т.п.</p>
    <p>Во внеконтекстных серверных процедурах недоступен контекст формы. Это значит, что при вызове этих процедур не происходит передача данных формы на сервер и обратно. Соответственно, производительность прикладного решения в таком случае будет выше.</p>
    <p>Использование с контекстом или без зависит от решения конкретной задачи. Рассмотрим пример.</p>
    <p>Предположим, в периодическом регистре сведений Цены содержатся розничные цены товаров из справочника Товары. Для расходования товаров существует документ "РасходнаяНакладная", в табличную часть которого подбираются товары.</p>
    <p>Хочется, чтобы пользователь, выбрав товар, видел в документе не только ссылку, но сразу же и цену выбранного товара из регистра сведений, актуальную на дату документа.</p>
    <p>Рассмотрим возможные способы решения задачи.</p>
    <p><b>Первый способ решения</b></p>
    <p>Чтобы обеспечить подстановку актуальной цены в расходную накладную при выборе товара, мы будем "уходить" на сервер, там определять цену товара, подставлять её в документ и затем возвращаться обратно на клиент. Ведь получить доступ к базе данных мы сможем только на сервере - поэтому сразу же сделаем всё, что нам нужно, прямо на сервере.</p>
    <p>Для этого создадим форму документа и обработчик события ПриИзменении() для поля формы Товар, содержащегося в таблице формы Товары:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыТоварПриИзменении(Элемент)
                РозничнаяЦена();
            КонецПроцедуры

            &НаСервере
            Процедура РозничнаяЦена() 
                Идентификатор = Элементы.Товары.ТекущаяСтрока;
                ДанныеТекущейСтроки = Объект.Товары.НайтиПоИдентификатору(Идентификатор);
                
                Отбор = Новый Структура;
                Отбор.Вставить("Товар", ДанныеТекущейСтроки.Товар);
                ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(Объект.Дата, Отбор);
                ДанныеТекущейСтроки.Цена = ЗначенияРесурсов.Цена;
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Кстати для меня было открытие, что Элементы.Товары.ТекущиеДанные не доступно на сервере. Доступно только свойство ТекущаяСтрока. Поэтому мы тут и получем по идентификатору.</span></p>
    <p>Тут мы вызываем на клиенте контекстную серверную процедуру РозничнаяЦена(). Эту процедуру мы поместим в модуле формы документа.</p>
    <p>В этой процедуре мы получаем Идентификатор текущей строки таблицы формы. По этому идентификатору находим эту строку в объекте ДанныеФормыКоллекция, содержащем табличную часть документа - Объект.Товары. Таким образом мы получаем доступ к данным текущей строки таблицы формы в переменной ДанныеТекущейСтроки и через точку от неё можем обращаться к значению колонок таблицы.</p>
    <p>Затем создаём структуру Отбор, содержащую отбор по измерению регистра Товар, и устанавливаем его равным ссылке на выбранный товар(ДанныеТекущейСтроки.Товар).</p>
    <p>Затем мы выполняем метод менеджера регистра сведений "Цена" - ПолучитьПоследнее() и присваиваем значение ресурса Цена на иболее поздней записи регистра на дату документа(Объект.Дата) для выбранного товара(Отбор) соответствующей колонке таблицы формы.</p>
    <p>Заметьте, что значения реквизитов документа(Объект.Дата, Объект.Товары) и свойства эдементов формы(Элементы.Товары.ТекущаяСтрока) доступны на сервере, так как при использовании директивы компипиляции &НаСервере в процедуру передаётся весь контекст формы.</p>
    <p>Запустим пользовательский режим, выберем товар в табличной части и убедимся, что цена для него подставилась. В результате использования РозничнаяЦена() для подстановки в документ будет происходит одно обращение на сервер.</p>
    <p><span class="vue-r">У меня как и раньше при первом выборе товара происходит 2 вызова сервера, один наш, второй кеш платформой наверное. При повторном выборе того же товара уже один вызов.</span></p>
    <p>Также вот картинка вызова сервера и количество принятых и переданных данных, которые пригодятся нам для сравнения контекстного и без контекстного вызова:</p>
    <img src="../img/1С-1/2024-03-29_10-11-05.png" class="screen-2" alt="">
    <p><b>Второй способ решения</b></p>
    <p>Один вызов сервера, происходящий при подстановке цены товара, неизбежен и опрравдан. Но обратим внимание на объём данных, передаваемых на сервер и обратно показанный на картинке выше. Можно ли его уменьшить? Можно. И правда, зачем "гонять" весь контекст формы туда и обратно, когда нам нужна всего лишь одна цена товара?</p>
    <p>На самом деле в функции для получения актуальной цены РозничнаяЦена() кроме ссылки на товар используется только Дата. Вместо того чтобы передавать весь контекст формы на сервер, можно передать эти значения в функцию в качестве параметров. Описание функции в модуле формы мы начнём директивой компиляции &НаСервереБезКонтекста. Таким образом мы не будем передавать данные формы на сервер, и наше прикладное решение будет работать быстрее.</p>
    <p>И если раньше мы подставляли цену в документ на сервере, то теперь мы будем делать это на клиенте. Именно для этого действия сервер совершенно не нужен, это можно прекрасно сделать прямо на клиенте.</p>
    <p>Для этого изменим обработчик события ПриИзменении() поля Товар:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыТоварПриИзменении(Элемент)
                ДанныеТекущейСтроки = Элементы.Товары.ТекущиеДанные;
                ДанныеТекущейСтроки.Цена = РозничнаяЦена(ДанныеТекущейСтроки.Товар, Объект.Дата);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы получаем доступ к данным текущей строки таблицы формы и через точку от неё можем обращаться в значениям колонок таблицы. Ссылку на выбранный товар и дату документа мы передаём в функцию для получения актуальной цены и присваиваем возвращённое значение колонке табличной части Цена.</p>
    <p>В модуле формы поместим функцию РозничнаяЦена(), выполняющуюся на сервере без контекста формы:</p>
    <div class="code-style">
        <pre>
            &НаСервереБезКонтекста
            Функция РозничнаяЦена(ВыбранныйТовар, АктуальнаяДата) 
                Отбор = Новый Структура;
                Отбор.Вставить("Товар", ВыбранныйТовар);
                ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(АктуальнаяДата, Отбор);
                Возврат ЗначенияРесурсов.Цена;
            КонецФункции
        </pre>
    </div>
    <p>Запустим пользовательский режим, откроем расходную накладную и сделаем выбор из справочника товаров в колонке Товар.</p>
    <p>Как видим функциональность прикладного решения будет такой же, как и в первом случае, но объём передаваемых данных на червер будет значительно меньше (вместо 3 080 - 2 271 теперь 1 125 - 1 082). Это благодаря использованию внеконтекстного вызова сервера.</p>
    <img src="../img/1С-1/2024-03-29_18-19-11.png" class="screen-2" alt="">
    <p>Но с другой стороны, использование процедур с параметрами тоже может иметь свои недостатки. Слишком большое количество параметров в процедуре может снижать производительность. "Слишком большое" - понятие относительное, конкретные числовые оценки дать нельзя. Но, например, если есть выбор: передать 100 параметров или передать всего 2 параметра, - то, конечно же, нужно передавать 2 параметра, а не 100. Поэтому разработчику всегда нужно искать золотую середину между читаемостью и отладкой кода.</p>
    <p>В связи с этим можно на клиенте формировать структуру параметров, передаваемых в функцию, и затем передавать её целиком, одним параметром.</p>
    <p>В данном конкретном случае мы передаём всего два параметра. Это нормально, можно передавать их по отдельности, и нет нужды сокращать их количество. Но на этом примере мы покажем, как в принципе можно это сделать. Например, сгруппировать логически связанные между собой параметры в один, который является структурой.</p>
    <p>Итак, объединим два параметра, передаваемых в функцию для получения актуальной цены, в структуру, и передадим её целиком как структуру параметров.</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыТоварПриИзменении2(Элемент)
                ДанныеТекущейСтроки = Элементы.Товары.ТекущиеДанные;
                Отбор = Новый Структура("Товар", ДанныеТекущейСтроки.Товар);
                ПараметрыФункции = Новый Структура("Отбор, АктуальнаяДата", Отбор, Объект.Дата);
                ДанныеТекущейСтроки.Цена = РозничнаяЦена2(ПараметрыФункции);
            КонецПроцедуры

            &НаСервереБезКонтекста
            Функция РозничнаяЦена2(ПараметрыФункции) 
                ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(ПараметрыФункции.АктуальнаяДата, ПараметрыФункции.Отбор);
                Возврат ЗначенияРесурсов.Цена;
            КонецФункции
        </pre>
    </div>
    <p>Обратим внимание, если мы сравним объём передаваемых данных, то оказывается, что он больше, чем когда мы передавали параметры в функцию по отдельности:</p>
    <img src="../img/1С-1/2024-03-29_21-03-10.png" class="screen-2" alt="">
    <p>Получается, что для данного примера это действительно ненужная "отладка кода". Как мы и говорили, два параметра в этом примере - это хорошо, и мы даже получили увеличение объёма передаваемых данных, когда упаковали их в одну структуру. Но когда параметров слишком много, обстановка может быть обратной. Поэтому в каждом случае нужно думать, как лучше поступить, и упаковка параметров в один должна быть логически понятна и объяснима.</p>
    <p><b>Подитожим</b></p>
    <p>Применение внеконтекстных процедур позволяет значительно уменьшить объём передаваемых данных между клиентом и сервером и уменьшить нагрузку на систему.</p>
    <p>Контекстную передачу управления на сервер целесообразно использовать при работе с большими объёмами данных (реквизитами формы типа табличных документов и коллекциями элементов типа "ДанныеФормыКоллекция", "ДанныеФормыСтруктураСКоллекцией", "ДанныеФормыДерево"). В этих случаях платформа самостоятельно наладит объём передаваемых данных в обоих направлениях. При этом затраты ресурсов сервера на инициализацию контекста формы оправдываются существенным снижением объёма данных между клиентом и сервером и снижением числа вызовов сервера.</p>
    <p>В остальных случаях нужно использовать внеконтекстные серверные процедуры, а если требуется передавать туда какие-то данные формы, то можно одно-два значения передавать в качестве параметров.</p>
    <p>Таким образом, из показанных способов решения задачи более правильным будет второй - за счёт использования внеконтекстного серверного вызова.</p>

    <p><b id="chapter4.3.3">Использование клиентских процедур для небольших расчётов данных формы</b></p>
    <p>В процессе разработки конфигурации часто возникает вопрос: "Где выполнять пересчёт данных формы: на клиенте или на сервере?". Однозначного ответа тут нет.</p>
    <p>С одной стороны, <i style="text-decoration: underline;">на клиенте должно быть меньше кода</i>, потому что такова идеология клиентского приложения. Клиентского кода по определению не должно быть много. Основной подход заключается в том, что на клиенте должен исполняться только тот код, который управляет формой и отображением данных в ней. Все расчёты должны выполняться на сервере.</p>
    <p>С другой стороны, <i style="text-decoration: underline;">нужно избегать лишних обращений на сервер</i>. И хотя процесс вычислений произойдёт на сервере значительно быстрее, но сам вызов сервера, да ещё с контекстом формы, снизит производительность прикладного решения.</p>
    <p>Что выбрать, зависит от конкретной задачи. Рассмотрим пример.</p>
    <p>Предположим, в форме документа об оказании услуг содержится цена услуги, процент вознаграждения и сумма услуги. При изменении цены услуги нужно рассчитывать сумму услуги, равную цене услуги плюс процент вознаграждения. Процент вознаграждения устанавливается в зависимости от цены услуги</p>
    <img src="../img/1С-1/2024-03-30_10-37-01.png" class="screen" alt="">
    <p>Таким образом, в то миг, когда пользователь изменит поле "ЦенаУслуги", поля "Вознаграждение" и "Сумма" нужно расчитать по описанному выше алгоритму.</p>
    <p>Рассмотрим возможные способы решения этой задачи.</p>
    <p><b>Первый способ решения</b></p>
    <p>Чтобы обеспечить перерасчёт суммы услуги при изменении цены, мы сразу пойдём на сервер (ведь расчёты нужно делать на сервере), там расчитаем вознаграждение и сумму услуги и поместим их в форму. Затем вернёмся на клиент с готовой формой.</p>
    <p>Для этого создадим форму документа "ОказаниеУслуги" и обработчик события "ПриИзменении" для поля формы "ЦенвУслуги":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЦенаУслугиПриИзменении(Элемент)
                РасчетСуммыУслуги();
            КонецПроцедуры

            &НаСервере
            Процедура РасчетСуммыУслуги()
                Если Объект.ЦенаУслуги > 1000 Тогда
                    Объект.Вознаграждение = 10;        	
                Иначе
                    Объект.Вознаграждение = 5;        	
                КонецЕсли;
                Объект.Сумма = Объект.ЦенаУслуги + Объект.ЦенаУслуги * Объект.Вознаграждение / 100;
            КонецПроцедуры
        </pre>
    </div>
    <p>В процедуру расчёта передаётся контекст формы, так как в ней изменяются реквизита "Вознаграждение" и "Сумма". Отключим для соответствующих полей формы свойство Доступность, так как они рассчитываются при изменении поля "ЦенаУслуги":</p>
    <img src="../img/1С-1/2024-03-30_10-37-02.png" class="screen" alt="">
    <p>В итоге будет сделано одно обращение на сервер, кроме того, этот вызов будет контекстным:</p>
    <img src="../img/1С-1/2024-03-30_17-15-55.png" class="screen-2" alt="">
    <p><b>Второй способ решения</b></p>
    <p>Чтобы оценить правильность своих действий, можно изучить, что же было сделано. Ход рассуждений может быть примерно таким:</p>
    <ul class="list">
        <li>"Контекстный вызов. А он нужен? Можно было обойтись снеконтекстным вызовом?"</li>
        <li>"Внеконтекстный вызов. А он нужен? Вообще тут нужен вызов сервера? Есть что-то, что нельзя сделать на клиенте?"</li>
        <li>"Если это делать на клиенте, это сложные вычисления? Сложнее, чем если бы их делали на сервере?"</li>
    </ul>
    <p>На самом деле обращения на сервер для пересчёта данных формы могло бы и не быть. Как мы увидим ниже, более правильно этот расчёт будет работаь на клиенте.</p>
    <p>Поскольку все данные для пересчёта доступны на клиенте (это поля основного реквизита формы Объект - ЦенаУслуги, Вознаграждение, Сумма), то нет смысла лишний раз обращаться на сервер. Код пересчёта - небольшой, и он быстро выполнится из клиентской процедуры при изменении цены услуги.</p>
    <p>Для этого изменим обработчик события ПриИзменении() след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЦенаУслугиПриИзменении(Элемент)
                Если Объект.ЦенаУслуги > 1000 Тогда
                    Объект.Вознаграждение = 10;        	
                Иначе
                    Объект.Вознаграждение = 5;        	
                КонецЕсли;
                Объект.Сумма = Объект.ЦенаУслуги + Объект.ЦенаУслуги * Объект.Вознаграждение / 100;
            КонецПроцедуры
        </pre>
    </div>
    <p>Откроем пользовательский режим, откроем документ, выберем услугу и внесём цену услуги. После этого поля Вознаграждение и Сумма сами пересчитаются.</p>
    <p>Как видим функциональность прикладного решения не изменится и будет такой же как и в предыдущем примере, но производительность будет выше, т.к. мы выполнили перерасчёт данных на клиенте, без обращения к серверу.</p>
    <p><b>Подитожим</b></p>
    <p>Таким образом, если в процедуре пересчёта требуется массированная обработка данных формы или в ней используются свойства и методы объектов, недоступных на клиенте, то выполнять пересчёт данных формы нужно на сервере. Для этого необходимо поместить код в контекстную серверную процедуру модуля формы. Или поместить код в процедуру модуля объекта и вызвать этот метод объекта, предварительно конвертировав данные формы в объект.</p>
    <p>Если в расчёте участвует немного данных формы и все эти данные уже есть на клиенте, то лучше это делать в клиентской процедуре модуля формы.</p>
    <p>Не следует выполнять на клиенте сложные алгоритмы, требующие значительных ресурсов компьютера. В таких случаях выполнение алгоритма на клиенте может занимать гораздо больше времени, чем передача управления с клиента на сервер и возврат результата обратно на клиент.</p>
    <p>Клиентский код должен как можно быстро выполнить что-то на клиенте, без обращений к серверу. Он не должен содержать большой объём бизнес-логики. Например, быстро пересчитать сумму по количеству и цене или расчитать значение какого-то реквизита на основе другого и т.п.</p>
    <p>Поэтому не нужно без необходимости использовать контекстные серверные вызовы.</p>

    <p><b id="chapter4.3.4">Использование контекстных серверных процедур для пересчёта данных коллекций форм</b></p>
    <p>Теперь рассмотрим пример, когда пересчёт данных формы более правильно выполнять на сервере. Мы уже говорили в предыдущем примере, что на сервере вычисления необходимо выполнять, когда на клиенте нет нужных типов данных, или когда используется сложный алгоритм расчётов, содержащий много кода, или когда требуется обратиться к объекту, содержащемуся в форме, напрямую.</p>
    <p>Однако в данном примере будет рассмотрен другой вопрос: где наиболее правильно выполнять перерасчёт большого количества строк табличной части - на сервере или на клиенте?</p>
    <p>С одной стороны, на серверный контекстный вызов платформа тратит время и ресурсы. Желательно бы этого избежать.</p>
    <p>С другой стороны, на клиенте присутствуют не все строки коллекций форм (табличный частей, таблиц значений), а только их видимая часть. Остальные "дочитываются" с сервера по мере того как пользователь прокручивает таблицу. Или по мере того как разработчик перебирает коллекцию данных в реквизите формы (например, Объект.Товары) из встроенного языка.</p>
    <p>Таким образом, при массовом пересчёте на клиенте все строки табличной части будут получены с сервера на клиент и все вернутся обратно при следующем контекстном вызове сервера.</p>
    <p>Посмотрим, какое решение более оптимально. Рассмотрим пример.</p>
    <p>Предположим, в табличной части расходной накладной содержатся товары и их цены. При нажатии кнопки "Пересчет цен", расположенной в форме документа, должно производиться повышение цен товаров на 10%, а также пересчёт сумм продажи товаров как произведения их количества и цены:</p>
    <img src="../img/1С-1/2024-03-30_20-32-07.png" class="screen" alt="">
    <p><b>Первый способ решения</b></p>
    <p>Чтобы обеспечить пересчёт цен товаров в табличной части расходной накладной, не будем вызывать сервер. Пересчитаем все цены на клиенте, ведь все необходимые данные на нём есть и обращаться к серверу вроде бы незачем.</p>
    <p>Для этого создадим форму документа и её команду "ПересчетЦен". Перетащим команду в командную панель таблицы формы Товары. Обработчик команды заполним след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПересчетЦен(Команда)
                Для Каждого ТекСтрокаТовары Из Объект.Товары Цикл
                    ТекСтрокаТовары.Цена = ТекСтрокаТовары.Цена * 1.1;
                    ТекСтрокаТовары.Сумма = ТекСтрокаТовары.Количество * ТекСтрокаТовары.Цена;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы в цикле обходим табличную часть документа и пересчитываем цены и сыммы товаров.</p>
    <p>Запустим пользовательский режим, откроем документ "РасходнаяНакладная" №2 (он содержит 1000 позиций товаров) и нажмём кнопку "Пересчет цен". После этого цены и суммы товаров пересчитаются по зпдпнному алгоритму.</p>
    <p>Пересчёт всех строк табличной части произойдёт непосредственно на клиенте. Но при нажатии кнопки "Пересчет цен" произойдёт 28 вызовов сервера. Так происходит потому, что при открытии формы на клиент передаётся 35 строк табличной части, и затем, по мере программного обращения, остальные строки "дочитываются" с сервера порциями по 35 строк (1015 = 28* 35 + 35).</p>
    <p>При следующем контекстном вызове все изменённые данные, т.е. все 1000 строк, "поедут" обратно на сервер.</p>
    <p><span class="vue-r">Заметка!!! У меня при нажатии на кнопку "Пересчет цен" в панели внизу показывает всего 4 вызова сервера. Книга старенькая, может разработчики уже как то наладили подгрузку строк табличной части по другому. Получается, если у меня всего 4 вызова, то платформа подгружает по 250 строк?</span></p>
    <img src="../img/1С-1/2024-03-30_22-21-56.png" class="screen-2" alt="">
    <img src="../img/1С-1/2024-03-30_22-25-08.png" class="screen-2" alt="">
    <p>Например, сделаем команду "Вызов сервера", после пересчёта цен вызовем из неё пустую серверную контекстную процедуру и посмотрим на показатели производительности:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ЗаполнитьТовары()

            КонецПроцедуры

            &НаКлиенте
            Процедура ВызовСервера(Команда)
                ЗаполнитьТовары();
            КонецПроцедуры
        </pre>
    </div>
    <img src="../img/1С-1/2024-03-30_22-30-49.png" class="screen-2" alt="">
    <p>Как видно, отправленно огроммное количество данных на сервер.</p>
    <p>Для наглядности рассмотим схему передачи данных между клиентом и сервером:</p>
    <img src="../img/1С-1/2024-03-30_22-35-35.png" class="screen" alt="">
    <p>Рассмотрим подробнее, сколько вызовов сервера при этом произойдёт и каков будет объём передаваемых данных между клиентом и сервером. Мы специально рассматриваем пример документа с большой табличной частью, так как на нём лучше сравнивать показатели производительности.</p>
    <p><span class="vue-r">Эти показатели из книги:</span></p>
    <img src="../img/1С-1/2024-03-30_22-42-24.png" class="screen" alt="">
    <p><span class="vue-r">А это мои:</span></p>
    <img src="../img/1С-1/2024-03-30_22-52-47.jpg" class="screen" alt="">
    <p><span class="vue-r">Далее идёт описание вызовов из кники, как уже сказал, у меня в текущем врмени уже отличается количество вызовов.</span></p>
    <p>При открытии формы 2 вызова сервера происходит при открытии формы в первый раз, при следующем открытии - 1 ызов.</p>
    <p>Объём принятых данных отражает обстановку, когда на клиент "приезжают" форма и "видимые" 35 строк табличной части.</p>
    <p>При пересчёте табличной части 28 вызовов сервера тратятся на "дочитование" строк табличной части документа на клиент порциями по 35 строк.</p>
    <p>Объём принятых данных отражает обстановку, когда табличная часть "доехала" в форму документа на клиент.</p>
    <p>Объём отправленных данных показывает, когда форма сообщает серверу, какие строки и в каком порядке получить.</p>
    <p>При следующем контекстном вызове объём отправленных данных показывет, что все 1000 изменённых строк табличной части "уезжают" на сервер.</p>
    <p>Таким образом, объём принятой информации - 16 343 + 161 774 = 178 117 байтов, а объём отправленной 205 591 байт.</p>
    <p>Если сравнить объём принятых и переданных данных, то получится, что форма и 100 строк, переданные на клиент, меньше, чем 1000 строк, переданных с клиента на сервер. Это действительно так, потому что обратно передаются не только строки, но и служебная информация о том, что строка изменена.</p>
    <p>Таким обрахом, в первом случае 161 774 байта информации передаётся на клиент и 205 591 байт передаётся на сервер. Как видите, объём передаваемых данных будет довольно большим (161 774 + 205 591 = 367 365 байтов). На самом деле, как будет показано ниже, более правильно этот расчёт будет работать на сервере.</p>
    <p><b>Второй способ решения</b></p>
    <p>Форма всегда создаётся на сервере, а не на клиенте. Таким образом, при открытии формы все данные для пересчёта уже есть на сервере. Поэтому лучше выполнять пересчёт строк табличной части на сервере, а не на клиенте, так как строки пересчёта не будут передаваться на клиент.</p>
    <p>Поэтому в данном решении мы сразу "уйдём" на сервер вместе с контекстом формы и там всё пересчитатем. И затем вернёмся на клиент.</p>
    <p>Для этого изменим обработчик команды "ПересчетЦен" след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПересчетЦен(Команда)  
                ПересчетЦенНаСервере();
            КонецПроцедуры

            &НаСервере
            Процедура ПересчетЦенНаСервере()
                Для Каждого ТекСтрокаТовары Из Объект.Товары Цикл
                    ТекСтрокаТовары.Цена = ТекСтрокаТовары.Цена * 1.1;
                    ТекСтрокаТовары.Сумма = ТекСтрокаТовары.Количество * ТекСтрокаТовары.Цена;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>Запустим 1С:Предприятие, откроем документ №2 (он содержит 1000 позиций товаров) и нажмём кнопку "Пересчёт цен".</p>
    <p>Посмотрим на схему программного взаимодействия клиента и сервера в этом случае:</p>
    <img src="../img/1С-1/2024-03-31_09-16-34.png" class="screen" alt="">
    <p>Функциональность прикладного решения будет такой же, как и в первом случае, но производительность будет выше, хотя мы и выполнили контекстный серверный вызов.</p>
    <p>Посмотрим теперь на показатели производительности:</p>
    <p><span class="vue-v">Текущие вызовы: 1, отправленные: 1 711, принятые: 205 006</span></p>
    <p><span class="vue-r">Короче, что я заметил. При открытии формы, если не листать список товаров вниз, а сразу нажать "Пересчёт цен", то получу вот такой показатель производительности:</span></p>
    <p><span class="vue-v">Текущие вызовы: 1, отправленные: 1 908, принятые: 8 729</span></p>
    <p><span class="vue-r">О чём тут говорится? Что на клиент "прибыла" какая то часть строк таблицы, но не все и при нажатии на кноку пересчёта обратно "уехал" контекст на сервер в объёме 1 908 байт и прибыли данные в размере 8 729 байт. Т.е. прибыли не все изменённые строки таблицы, а только часть.</span></p>
    <p><span class="vue-r">Если промотать немного список товаров вниз, примерно до позиции 35, то внизу в панели увидим, что произошёл вызов сервера и к нам приехала очередная порция строк таблицы. Теперь если опять нажать кнопку "Пересчет цен", то увидим, что отправленных опять 1 908, а принятых уже больше:</span></p>
    <p><span class="vue-v">Текущие вызовы: 1, отправленные: 1908, принятые: 15 901</span></p>
    <p><span class="vue-r">Если ещё прокрутить список примерно до 70 позиции, то опять сработает вызов сервера и опять прибавится порция строк. При нажатии кнопки в этом состоянии, принятых станет ещё больше:</span></p>
    <p><span class="vue-v">Текущие вызовы: 1, отправленные: 1908, принятые: 23 015</span></p>
    <p><span class="vue-r">Лично в моём случае при прокрутке произойдёт все 4 таких вызова сервера, за которые подгрузятся все 1000 товаров и вот уже после 4 вызова, который может загрузить сразу все недостающие товары, если нажать пересчёт, то увидим в принятых такое же количество как и в книге</span></p>
    <p><span class="vue-v">Текущие вызовы: 1, отправленные: 1908, принятые: 205 006</span></p>
    <p><span class="vue-r">Можно сделать вывод, что чем больше мы подгружаем в список товаров, то столько же товаров к нам вернётся изменённых на сервере. Если подгрузить весь список и нажать на кнопку, то вернутся все 1000 изменённых товара к нам. И сразу все 1000 будут доступны без подзагрузок.</span></p>
    <p><span class="vue-r">Ещё одно что также можно заметить. ЧТо при вызове контекстной процедуры на сервере, мы передаёт контекст формы, но всё время в одном размере - 1 908 байт. Можно сделать вывод, что все товары, которые мы подгрузили на клиент обратно не передаются на сервер. Передаётся только служебная информация, которая на сервере рассказывает что надо делать.</span></p>
    <p><span class="vue-r">Ещё одно замечание. В чём отличие от книги. В книге говорится, что при открытии формы мы ничего не подгружаем, прокручивая список, а сразу жмём кнопку "Пересчет цен" и нам вернутся все строки в количестве 205 006 байт, у меня же по другому, сначала нужно пролистать список и подгрузить все строки, и только потом вернётся все изменённые строки.</span></p>
    <p>Продолжаем из книги. Рассмотрим подробнее, сколько вызовов сервера при этом произойдёт и каков будет объём передаваемых между клиентом и сервером данных.</p>
    <img src="../img/1С-1/2024-03-31_10-45-14.png" class="screen" alt="">
    <p>При пересчёте табличной части на сервере объём принятых данных отражает обстановку, когда все 1000 изменённых строк табличной части "приезжают" на клиент.</p>
    <p>Таким образом, во втором способе передаётся 205 006 байтов информации против 367 365 байтов в первом. Заметим, что мы здесь сравниваем только объём передаваемых данных, инициируемых разработчиком.</p>
    <p>Подитожим</p>
    <p>Изменять данные коллекций форм(табличные части, таблицы значений) лучше на сервере. Если же подобные действия выполнять на клиенте, то все данные коллекций форм будут переданы на клиент, хотя они не требуются для отображения в форме.</p>

    <p><b id="chapter4.3.5">Управление открываемой формой путём передачи параметров</b></p>
    <p>Часто бывает нужно открыть форму не руками, а из встроенного языка. Как правило, при этом в зависимости от различных условий форма должна иметь тот или иной вид.</p>
    <p>Чтобы открыть форму, используется метод глобального контекста ОткрытьФорму(). ПРи этом в форму передаются параметры - стандартные или созданные разработчиком. Они используются для того, чтобы открыть форму в некотором нужном состоянии.</p>
    <p>Параметры формы представляют собой структуру, каждый элемент которой описывает один параметр формы. Эта структура передаётся в метод ОткрытьФорму() вторым параметром, и в результате форма открывается за один серверный вызов в нужном состоянии.</p>
    <p>Другим способом является получение формы методом ПолучитьФорму(). Используя возвращённый этим методом объект "ФормаКлиентскогоПриложения", можно обращаться к её свойствам и методам, а также к свойствам и методам её элементов, чтобы подготовить форму к открытию в нужном состоянии. И затем открыть форму методом Открыть().</p>
    <p>Какой же способ наибелее правилен? Рассмотрим пример.</p>
    <p>Предположим, в конфигурации существует иерархический справочник Товары и документ "ПриходнаяНакладная" с табличной частью Товары, содержащей перечень приходуемых товаров. При нажатии кнопки "Подбор", расположенной в форме документа, должен производится подбор товаров в табличную часть приходной накладной. При этом форма выбора из справочника Товары должна открываться в режиме множественного выбора, и иерархический список товаров должен быть представлен  ввиде дерева:</p>
    <img src="../img/1С-1/2024-03-31_15-07-47.png" class="screen" alt="">
    <p><span class="vue-r">Снимал картинку с другой базы, поэтому не обращаем внимание на несовпадение названий документа и формы выбора. Напомню кратко, как вообще такое сделать из конфигуратора. Чтобы открыть форму выбора справочника, нужно её создать у справочника и для таблицы формы выбора задать свойства "Множественный выбор" и "Отображение" соотвествующие значения. ВНимание, не для формы выбора задать значения этих свойств, а для таблицы формы выбора,в которой отображается динамический список.</span></p>
    <p>Заметим, что если форма выбора всегда должна открываться в заданном виде, то можно задать свойства формы в конфигураторе и ничего не программировать. Однако форма выбора может открываться из разных мест конфигурации, и её внешний вид может зависить от различных условий. В таком случае нужно программно формировать внешний вид формы при её открытии.</p>
    <p>Случай с программрованием мы сейчас и рассмотрим в разных способах решения.</p>
    <p><b>Первый способ решения</b></p>
    <p>В данном решении мы получим форму на клиенте, установим нужные свойства этой формы и затем откроем её.</p>
    <p>Чтобы обеспечить подбор товаров в табличную часть приходной накладной, создадим форму документа и её команду "Подбор". Перетащим команду в командную панель таблицы формы Товары. Обработчик команды "Подбор" заполним следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Подбор(Команда)
                ФормаВыбора = ПолучитьФорму("Справочник.Товары.ФормаВыбора",, Элементы.Товары);
                ФормаВыбора.Элементы.Список.МножественныйВыбор = Истина;
                ФормаВыбора.Элементы.Список.Отображение = ОтображениеТаблицы.Дерево;
                ФормаВыбора.Открыть();
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы получаем основную форму выбора справочника Товары как подчинённую таблице Товары. Таким образом, переменная ФормаВыбора будет содержать объект "ФормаКлиентскогоПриложения". Используя коллекцию элементов (Элементы) этой формы, мы устанавливаем свойство "МножественныйВыбор" для таблицы формы Список в значение Истина и свойство "Отображение" в значение системного перечисления ОтображениеТаблицы.Дерево.</p>
    <p>Тем самым мы добьёмся того, что форма, отражающая иерархический список товаров, будет открываться в режиме множественного выбора и таблица списка будет представлена в виде дерева. И затем мы открываем форму выбора методом Открыть().</p>
    <p>При выборе из формы выбора справочника выбранное значение будет передано в обработчик события "ОбработкаВыбора" таблицы формы Товары, так как она является владельцем открытой формы выбора. Причём при множественном выборе форма возвращает не один элемент, а массив элементов.</p>
    <p>Поэтому создадим обработчик события "ОбработкаВыбора" таблицы формы Товары и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ТоварыОбработкаВыбора(Элемент, ВыбранноеЗначение, СтандартнаяОбработка)
                Для Каждого ВыбранныйЭлемент Из ВыбранноеЗначение Цикл
                    НоваяСтрока = Объект.Товары.Добавить();
                    НоваяСтрока.Товар = ВыбранныйЭлемент;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы организуем цикл обхода массива переданных элементов(ВыбранноеЗначение). И в этом цикле добавим новую строку в таблицную чпсть документа (Объект.Товары) и присвоим её полю Товар значение очередного элемента массива выбранных товаров.</p>
    <p>Запустим 1С:Предприятие, откроем приходную накладную и нажмём кнопку Подбор. После этого форма выбора из справочника товаров будет открыта в режиме множественного выбора и иерархический список товаров будет представлен в виде дерева. При нажатии кнопки "Выбрать" выделенные записи из справочника товаров будут добавлены в табличную часть приходной накладной.</p>
    <p>Если мы посмотрим на показатели производительности, то увидим, что при открытии формы выбора в процедуре Подбор() произойдут два вызова сервера.:</p>
    <img src="../img/1С-1/2024-04-01_08-46-00.png" class="screen-2" alt="">
    <p>Для наглядности рассмотрим схему программного взаимодействия клиента и сервера:</p>
    <img src="../img/1С-1/2024-04-01_10-28-10.jpg" class="screen" alt="">
    <p>Один вызов происходит при выполнении метода ПолучитьФорму(), и он оправдан, так как его делает сама платформа.</p>
    <p>А вот второго вызова, который происходит при изменении свойства "Отображение" таблицы формы Список, могло бы и не быть.</p>
    <p><span class="vue-r">Не совсем понял, что именно вызывает сервер в строке с присвоением значения в свойство "Отображение". Могу предположить, что получение значения из системного перечисления "ОтображениеТаблицы.Дерево".</span></p>
    <p>Ниже мы покажем, как этого избежать.</p>
    <p>Второй способ рещения</p>
    <p>На семом деле более правильно открывать форму методом ОткрытьФорму(), при этом передавая в неё параметры. Параметры будут доступны в обработчике события формы выбора "ПриСозданииНаСервере", где и нужно управлять состоянием формы при её открытии.</p>
    <p>Для этого изменим обработчик команды "Подбор" след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Подбор(Команда)
                ПараметрыФормы = Новый Структура;
                ПараметрыФормы.Вставить("МножественныйВыбор", Истина);
                ПараметрыФормы.Вставить("РежимОтображения", "Дерево");
                
                ОткрытьФорму("Справочник.Товары.ФормаВыбора", ПараметрыФормы, Элементы.Товары);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы создаём структуру и заполняем её параметрами. Причём "МножественныйВыбор" - это стандартный параметр формы для динамического списка, который при открытии формы выбора устанавливает соответсвующее свойство для таблицы динамического списка. Это платформа делаем самостоятельно.</p>
    <p>А параметр "РежимОтображения" мы создаём сами, чтобы передать в обработчик события "ПриСозданииНаСервере" формы выбора справочника режим отображения таблицы динамического списка в виде дерева.</p>
    <p>Затем мы открываем основную форму выбора справочника Товары как подчинённую таблице Товары методом ОткрытьФорму(), который производит одно обращение к серверу.</p>
    <p>Для проверки параметра "РежимОтображения" создадим форму выбора справочника Товары и обработчик события формы "ПриСозданииНаСервере". Заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
                <span class="vue-g">//параметр "МножественныйВыбор" не вставляем, потому как он
                //является стандартным, как было уже сказано. Достаточно в него
                //просто втавить своё значение и платформа сама его применит.
                //Как понять какие свойства стандартные, а какие нет? Как я заметил
                //стандартные свойства выскакивают в подсказке, а свои нет</span>

                Если Параметры.РежимОтображения = "Дерево" Тогда
                    Элементы.Список.Отображение = ОтображениеТаблицы.Дерево;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Вот для чего мы передаём с клиента значение строкового типа "Дерево", чтобы потом находясь на сервере получить из базы значение этого системного перечисления по значению "Дерево". С методом ПолучитьФорму() нам так не удавалось сделать, потому что всё выполнялось на клиенте и за значением "дерево" нужно было идти на сервер.</span></p>
    <p><span class="vue-r">Хотя я первый раз когда сам делал с методом ОткрытьФорму(), то в параметр "РежимОтображения" вставлял значение "ОтображениеТаблицы.Дерево". Получается я делал неправильно, потому что с клиента ходил на сервер лишний раз за этим значением. Да и частенько я так делаю, когда использую метод ОткрытьФорму(), вставляю в структуру значения из системных перечислений и получается делаю лишние вызовы сервера.</span></p>
    <p>Запустим 1С:Предприятие и проделаем всё то же что и в первом примере. Как мы видим функциональность решения будет такой же, как и в первом случае, но производительность будет выше, так как для открытия формы выбора при помощи метода ОткрытьФорму() потребовался только один вызов сервера:</p>
    <img src="../img/1С-1/2024-04-01_11-12-01.png" class="screen-2" alt="">
    <p><span class="vue-r">И то этот один вызов происходит только со второго раза, с первого там вообще бывает 7 или 4 вызова.</span></p>
    <p>Подитожим</p>
    <p>Чтобы открыть форму в некотором нужном состоянии, советуем использовать метод ОткрытьФорму() и при этом передавать в него параметры. Форма будет открыта за один серверный вызов.</p>
    <p>Не советуем открывать форму с помощью метода ПолучитьФорму() и затем обращаться к её свойствам и методам, так как изменение свойств и методов формы на клиенте может привести к лишним обращениям на сервер.</p>
    <p>Кроме того, программный код будет выглядеть при этом менее стройным и читаемым. Он может вообще перестать работать, если, например, в форме переименовали какой-то реквизит, к которому обращались снаружи.</p>
    <p>Таким образом, из показанных способов решения задачи более правильным будет второй.</p>

    <p><b id="chapter4.3.6">Воплощение функциональности в клиентских и серверных обработчиках событий формы в зависимости от их назначения</b></p>
    <p>Для воплощения в жизнь функциональности форм разработчик может использовать клиентские и серверные обработчики событий формы. Но делать это нужно правильно и по назначению.</p>
    <p>Например, при интерактивном или программном создании формы с существующими в инфобазе данными вызывается серверное событие "ПриЧтенииНаСервере". Затем для всех форм вызывается серверное событие "ПриСозданииНаСервере". В обработчиках этих двух событий можно и нужно подготавливать форму к работе.</p>
    <p>Затем вызывается клиентское событие формы "ПриОткрытии", в обработчике которого можно выполнять действия, доступные только на клиенте, например, общение с пользователем.</p>
    <p>Часто бывает нужно задать функциональность формы сразу при её открытии - например, заполнить какие-то реквизиты формы или установить какие-то свойства её элементов и т.п. В обработчике какого же события: "ПриСозданииНаСервере", "ПриЧтенииНаСервере" или "ПриОткрытии" - это нужно сделать? Рассмотрим пример.</p>
    <p>Предположем, в периодическом регистре сведений Цены содержатся розничные цены товаров из справочника Товары. При открытии формы уже существующего товара в поле "Розничная цена" должна подставляться цена из регистра сведений, и это поле должно быть недоступно для редактирвания.</p>
    <p>Рассмотрим способы решения этой задачи.</p>
    <p><b>Первый способ решения</b></p>
    <p>Чтобы обеспечить нужную функциональность формы при её открытии, все действия будем выполнять в обработчике события "ПриОткрытии". Подходящее название, зачем задумываться о назначении других обработчиков? "При открытии" - название события говорит само за себя, значит, в нём всё и сделаем.</p>
    <p>Для этого создадим форму элемента справочника Товары. Создадим реквизит формы "РозничнаяЦена" типа Число и перетащим его в дерево элементов формы. Затем создадим обработчик события формы "ПриОткрытии" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПриОткрытии(Отказ)
                Если НЕ Параметры.Ключ.Пустая() Тогда
                    РозничнаяЦена = РозничнаяЦена(Объект.Ссылка);
                    Элементы.РозничнаяЦена.Доступность = Ложь;
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы изучаем значение параметра формы "Ключ". Если там ссылка не пустая, то товарв уже существует. Мы узнаем его цену на текущую дату из регистра сведений и присваиваем её реквизиту "РозничнаяЦена". Также мы устанавливаем для поля "РозничнаяЦена" свойство Доступность в значение Ложь.</p>
    <p>Теперь поместим в модуль формы функцию для получения актуальной цены товара из регистра сведений, выполняющуюся на сервере без контекста формы:</p>
    <div class="coe-style">
        <pre>
            &НаСервереБезКонтекста
            Функция РозничнаяЦена(ТоварСсылка)
                Отбор = Новый Структура("Товар", ТоварСсылка);
                ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(, Отбор);
                Возврат ЗначенияРесурсов.Цена;
            КонецФункции
        </pre>
    </div>
    <p>В этой функции мы создаём структуру Отбор, содержащую отбор по измерению регистра "Товар", и устанавливаем его равным ссылке на товар, переданной в функцию. Затем при помощи метода ПолучитьПоследнее() мы возвращаем последнюю цену на текущую дату товара.</p>
    <p>Запустим 1С:Предприятие и откроем форму одного из товаров. В открывшемся окне поле "РозничнаяЦена" сама заполнится последней ценой этого товара и будет недоступна.</p>
    <p>Однако при открытии формы существующего объекта будут сделаны два обращения на сервер:</p>
    <img src="../img/1С-1/2024-04-02_07-45-14.png" class="screen-2" alt="">
    <p><span class="vue-r">Опять же это со второго раза, с первого открытия там вообще было до 10 вызовов и около 40 тысяч принятых байтов. Надо разузнать почему так. Ага. В сноске в книге объяснили почему при первом вызове много вызовов сервера. Потому что платформа кеширует информацию о форме при первом запуске и мы как бы это во внимание не берём.</span></p>
    <p>Для наглядности рассмотрим схему программного взаимодействия клиента и сервера. Короче схему не буду тут показывать, рисовать много. Скажу кратко, первый вызов делает сама платформа, ей же нужно пойти на сервер и создать там форму и вернуть обратно, а второй вызов делаем мы вызовом функции РозничнаяЦена(). Этот лишний серверный вызов произошёл с клиента, из обработчика события "ПриОткрытии". Ниже мы покажем как этого избежать.</p>
    <p><b>Второй способ решения</b></p>
    <p>На самом деле, когда открывается форма с существующими в информационной базе данными, вызывается серверной событие "ПриЧтенииНаСервере". В обработчике этого события, в параметре ТекущийОбъект, нам доступен прикладной объект, содержащийся в форме, со всей его функциональностью. Таким образом, здесь мы можем подготовить данные формы, зависящие от данных объекта, к открытию.</p>
    <p>Затем вызывается серверное событие формы "ПриСозданииНаСервере". Это событие не зависит от того, какие данные форма отображает, и вызывается при открытии у всех форм. Именно в обработчике этого события нужно полностью подготавливать саму форму, её внешнее представление, к открытию. Для подготовки данных формы лучше использовать событие "ПриЧтенииНаСервере".</p>
    <p>Таким образом, к мигу передачи формы на клиент и возникновению события "ПриОткрытии" вся подготовительная работа будет уже сделана. Остаётся только выполнить какое-то общение с пользователем(показать предупреждение, задать вопрос и т.п.), если это нужно.</p>
    <p>В данном решении мы используем обработчик события "ПриЧтенииНаСервере". Это событие вызывается только для существующих объектов, при создании новых оно не вызывается.</p>
    <p>Поэтому для воплощения нужной функциональности формы мы можем стандартно сконфигурировать поле РозничнаяЦена недоступным(имеется ввиду ручками в свойстве Доступность убраь галочку, чтобы для всех форм товаров это поле было недостуным).</p>
    <p>Итак, создадим обработчик события формы элемента справочника Товары "ПриЧтенииНаСервере" и переместим в него код из функции РозничнаяЦена():</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЧтенииНаСервере(ТекущийОбъект)
                Отбор = Новый Структура;
                Отбор.Вставить("Товар", ТекущийОбъект.Ссылка);
                ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(, Отбор);
                РозничнаяЦена = ЗначенияРесурсов.Цена;
            КонецПроцедуры
        </pre>
    </div>
    <p>Отключим свойство Доступность для поля РозничнаяЦена. Поскольку обработчик "ПриЧтенииНаСервере" будет отрабатывать только для существующих объектов, то и для существующих товаров мы заполняем поле "РозничнаяЦена" последней ценой.</p>
    <p>Как мы видим, функциональность прикладного решения будет такой жеЮ как и в первом случае, но производительность будет выше, так как не будет лишних вызовов сервера:</p>
    <img src="../img/1С-1/2024-04-02_15-47-27.png" class="screen-2" alt="">
    <p><b>Подитожим</b></p>
    <p>Для воплощения в жизнь функциональности форм разработчик должен правильно и по назначению использовать клиентские и серверные обработчики событий формы.</p>
    <p>Большая часть кода должна быть написана в серверных обработчиках событий формы. Например, форма должна быть наиболее подготовлена для открытия в обработчиках событий "ПриЧтенииНаСервере" и "ПриСозданииНаСервере", а в обработчике "ПриОткрытии" нужно выполнять только действия, недоступные на сервере: показать предупреждение, задать вопрос и т.д.</p>
    <p>При открытии формы настоятельно не советуем выполнять обращения на сервер из кода модуля формы в обработчиках клиентских событий формы.</p>

    <p><b id="chapter4.3.7">Использование стандартных полей запроса в динамических списках на клиенте</b></p>
    <p>Формы списка объектов конфигурации построенны с помощью динамического списка. Динамический список формируется путём запроса к основной таблице, указанной в свойстве реквизита типа "ДинамическийСписок", или путём произвольного запроса к базе данных.</p>
    <p>Обычно далеко не все поля динамического списка используются для отображения в форме. Например, в форме списка справочника это поля "Код" и "Наименование" плюс реквизиты созданные разработчиком. В запросе на сервере из таблицы справочника могут быть выбраны и переданы на клиент и другие его стандартные реквизиты. Например, для иерархического справочника это поля "Ссылка", "ЭтоГруппа", "Родитель", "Предопределенный" и т.д.</p>
    <p>Особенность в том, что запросом выбираются и передаются на клиент значения только тех реквизитов, в свойствах которых стоит отметка "Использовать всегда" или они отображаются в форме:</p>
    <img src="../img/1С-1/2024-04-03_08-29-41.png" class="screnn" alt="">
    <p>Таким образом, при помощи свойства полей динамического списка "Использовать всегда" можно получить значения реквизитов объекта на клиенте, не обращаясь лишний раз к серверу.</p>
    <p>А можно "пойти" на сервер и получить эти реквизиты по ссылке, используя свойство таблицы динамического списка "ТекущаяСтрока".</p>
    <p>Какой же способ наиболее правильный? Рассмотрим этот вопрос на примере открытия текущего элемента из формы списка иерархического справочника.</p>
    <p>Предположим, в конфигурации существует иерархический справочник Товары. При открытии формы элемента справочника из формы списка нужно изучить, является ли выбранный элемент группой, и в зависимости от этого открывать форму группы или форму элемента справочника.</p>
    <p>Рассмотрим возможные способы решения этой задачи.</p>
    <p><b>Первый способ решения</b></p>
    <p>В данном решении мы будем получать ссылку на текущий элемент, отображаемый в списке, затем "пойдём" с ней на сервер, чтобы из инфобазы узнать, является элемент группой или нет. В зависимости от этого, вернувшись на клиент, будем открывать либо форму элемента, либо форму группы.</p>
    <p>Чтобы программно открывать форму элемента, создадим форму списка справочника Товары и её команду "Открыть товар". Перетащим команду в командную панель формы. Обработчик команды заполним след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОткрытьТовар(Команда)
                СсылкаНаЭлементСправочника = Элементы.Список.ТекущаяСтрока;
                ПараметрыФормы = Новый Структура("Ключ", СсылкаНаЭлементСправочника );
                    
                Если ЕслиЭтоГруппа(СсылкаНаЭлементСправочника) Тогда
                    ОткрытьФорму("Справочник.Товары.ФормаГруппы", ПараметрыФормы);
                Иначе
                    ОткрытьФорму("Справочник.Товары.ФормаОбъекта", ПараметрыФормы);
                КонецЕсли;
            КонецПроцедуры

            &НаСервереБезКонтекста
            Функция ЕслиЭтоГруппа(Ссылка)
                Возврат Ссылка.ЭтоГруппа;
            КонецФункции
        </pre>
    </div>
    <p>В этом обработчике, используя свойство "ТекущаяСтрока" таблицы формы Список, отражающей данные динамического списка, мы получаем ссылку на текущий элемент справочника. Значение ссылки мы присваиваем параметру формы "Ключ". И в зависимости от того, является ли данный элемент группой, открываем форму группы или форму элемента справочника с этим параметром.</p>
    <p>Для определния того, является ли элемент справочника группой по переданной ссылке, поместим в модуле формы функцию, исполняющуюся на сервере без контекста формы.</p>
    <p>Запустим 1С:Предприятие, выделим группу в форме списка товаров и нажмём кнопку "Открыть товар". В итоге будет открыта форма группы справочника товаров. Затем выделим элемент справочника и нажмём кнопку "Открыть товар". В итоге будет открыта форма элемента справочника товаров.</p>
    <p>Однако в обоих случаях при открытии формы будут сделаны два обращения на сервер:</p>
    <img src="../img/1С-1/2024-04-03_19-48-14.png" class="screen-2" alt="">
    <p>Первый вызов сервера это наша процедура ЕслиЭтоГруппа(), а второй вызов сервера это метод ОткрытьФорму().</p>
    <p>Первого вызова могло бы и не быть. Ниже мы покажем , как этого избежать.</p>
    <p><b>Второй способ решения</b></p>
    <p>В данном решении мы не будем специально "ходить" на сервер и определять, является текущий элемент группой или нет, потому что эти данные уже есть в динамическом списке. Просто сделаем так, чтобы они присутствовали в нём, даже несмотря на то что они не отображаются в форме.Тогда всё, что нам нужно знать об этом элементе, мы сможем выяснить прямо на клиенте, без вызова сервера.</p>
    <p>Установим флажок "Использовать всегда" для поля "ЭтоГруппа" в свойствах основного реквизита формы Список:</p>
    <img src="../img/1С-1/2024-04-04_08-46-05.png" class="screen" alt="">
    <p>Эта галочка значит, что данные этого поля будут передаваться на клиент, даже несмотря на то что в форме они нигде не отображаются. Такая возможность сделана как раз на случай только программного использования этих данных.</p>
    <p>Теперь изменим обработчик команды "ОткрытьТовар" след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОткрытьТовар(Команда)
                СсылкаНаЭлементСправочника = Элементы.Список.ТекущаяСтрока;
                ПараметрыФормы = Новый Структура("Ключ", СсылкаНаЭлементСправочника );
                
                Если Элементы.Список.ТекущиеДанные.ЭтоГруппа Тогда
                    ОткрытьФорму("Справочник.Товары.ФормаГруппы", ПараметрыФормы);
                Иначе
                    ОткрытьФорму("Справочник.Товары.ФормаОбъекта", ПараметрыФормы);
                КонецЕсли;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике для определения того, является ли элемент справочника группой, мы используем свойство "ТекущиеДанные" таблицы формы Список, отражающей данные динамического списка. И затем через точку от него обращаемся к полю "ЭтоГруппа" текущей строки этой таблицы.</p>
    <p>Поскольку значение этого поля уже доступно на клиенте, нам не понадобится лишний раз обращаться на сервер. В результате та же функциональность будет воплощена за один серверный вызов, а производительность прикладного решения будет выше.</p>
    <p><b>Подитожим</b></p>
    <p>В формах списка объектов конфигурации, построенных с помощью динамического списка, часто бывает нужно использовать значения стандартных реквизитов текущего объекта списка.</p>
    <p>Для этого нужно получать значения стандартных реквизитов объекта в динамических списках на клиенте, устанавливая флажок "Использовать всегда", вместо того чтобы обращаться на сервер за этими значениями.</p>
    <p>Таким образом, из показанных способов решения задачи более правильным будет второй - за счёт получения реквизитов динамического списка на клиенте без обращения к серверу.</p>
    <p>Тут есть один интересный миг. Заметим, что в этом случае можно было бы использовать метод ПоказатьЗначение(, Элементы.Список.ТекущаяСтрока) - он один заменяет собой весь код выше(это тот, который "идёт" на сервер за значением поля ЭтоГруппа). Но в этом случае для иерархического справочника будет каждый раз происходить обращение к серверу для определения того, является открываемый элемент группой или нет. Но если это будет не иерархический справочник, а обычный, или другой объект конфигурации, документ, например, этого обращения не будет.</p>
    <p>Этот пример хорошо показывает то, что нет "рецептов на все времена" и каждый раз нужно думать и делать выводы, как решить конкретную задачу наиболее правильно.</p>

    <p><b id="chapter4.3.8">Использование стандартного параметра формы отчёта для самостоятельного формирования отчёта при его открытии</b></p>
    <p>Пользователю часто может понадобится сформировать отчёт сразу при его открытии. Эту очень удобную возможность предоставляет платформа 1С:Предприятие.</p>
    <p>Для этого можно испоьзовать параметр "СформироватьПриОткрытии", поставляемый расширением формы для отчёта и передавать его в форму при открытии:</p>
    <img src="../img/1С-1/2024-04-05_08-37-08.png" class="screen-2" alt="">
    <p>Или же можно установить этот параметр в значение Истина в обработчике события формы "ПриСозданииНаСервере".</p>
    <p>Казалось бы, можно сформировать отчёт и в обработчике события "ПриОткрытии" методом <b>СкомпоноватьРезультат()</b>, доступном в модуле формы на клиенте.</p>
    <p>Но посмотрим, какое решение будет наиболее правильное.</p>
    <p>Предположим, в конфигурации существует отчёт "РеестОказанныхУслуг", выводящий список существующих в инфобазе документов "ОказаниеУслуги". При открытии формы отчёта список документов должен формироваться самостоятельно, без нажатия кнопки "Сформировать".</p>
    <p>Для примера взят самый простой отчёт, но он, тем не менее, позволит рассмотреть возможные способы решения этой задачи.</p>
    <p><b>Первый способ решения</b></p>
    <p>Чтобы программно сформировать отчёт "РеестОказанныхУслуг" при открытии, в форме отчёта, в обработчике события "ПриОткрытии", вызовем самостоятельное формирование отчёта.</p>
    <p>Для этого создадим форму отчёта и обработчик события формы "ПриОткрытии" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ПриОткрытии(Отказ)
                СкомпоноватьРезультат();
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике при открытии формы на клиенте отчёт формируется методом СкомпоноватьРезультат(), поставляемый расширением формы для отчёта.</p>
    <p>Запустим 1С:Предприятие и откроем отчёт "РеестОказанныхУслуг" из группы команд Отчеты. Отчёт сразу будет сформирован при открытии формы. Вроде бы всё хорошо, но в данном случае при повторном открытии формы отчёта будут сделаны два обращения на сервер.</p>
    <p>Для наглядности рассмотрим схему программного взаимодействия клиента и сервера:</p>
    <img src="../img/1С-1/2024-04-05_09-07-12.jpg" class="screen" alt="">
    <p>Один вызов происходит при открытии формы отчёта, и его делает сама платформа. А вот второго вызова, который происходит при выполнении метода СкомпоноватьРезультат(), можно избежать.</p>
    <p><b>Второй способ решения</b></p>
    <p>На самом деле можно выполнить открытие формы отчёта и его формирование за один серверный вызов. Для этого нужно установить параметр формы "СформироватьПриОткрытии" в значение Истина в обработчике события формы "ПриСозданииНаСервере".</p>
    <p>Итак, создадим обработчик события формы отчёта "РеестОказанныхУслуг" - "ПриСозданииНаСервере" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)	
                Параметры.СформироватьПриОткрытии = Истина;
            КонецПроцедуры
        </pre>
    </div>
    <p>А обработчик события "ПриОткрытии" удалим.</p>
    <p>Запустим пользовательский режим и откроем отчёт "РеестОказанныхУслуг". Как видим, функциональность будет такой же. но производительность будет выше, так как для открытия формы отчёта и его формирования потребовался только один вызов.</p>
    <p><b>Третий способ решения</b></p>
    <p>Для формирования отчёта в первых двух случаях мы использовали стандартную команду открытия формы отчёта, самостоятельно помещаемую платформой в глобальные команды приложения(Отчеты). При этом в обоих случаях отчёт всегда будет формироваться при открытии с помощью этой стандартной команды.</p>
    <p>Теперь покажем способ программного открытия формы отчёта с параметром "СформироватьПриОткрытии".</p>
    <p>Для этого создадим общую команду "СписокОказанныхУслуг" и поместим её в группу "ПанельНавигации.Важное":</p>
    <img src="../img/1С-1/2024-04-05_10-54-39.png" class="screen" alt="">
    <p>В модуле команды напишем след. код:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОбработкаКоманды(ПараметрКоманды, ПараметрыВыполненияКоманды)	
                ПараметрыФормы = Новый Структура("СформироватьПриОткрытии", Истина);
                ОткрытьФорму("Отчет.РеестрОказанныхУслуг.Форма", ПараметрыФормы);	
            КонецПроцедуры
        </pre>
    </div>
    <p>Форму отчёта теперь можно совсем удалить, поскольку она больше не нужна. А также уберём видимость у стандартной команды открытия формы отчёта в командном интерфейсе конфигурации:</p>
    <img src="../img/1С-1/2024-04-05_11-00-05.png" class="screen-2" alt="">
    <p>В пользовательском режиме команда отчёта теперь будет тут:</p>
    <img src="../img/1С-1/2024-04-05_11-02-12.png" class="screen" alt="">
    <p>Отчёт будет сформирован сразу при открытии формы за один серверный вызов</p>
    <p><b>Подитожим</b></p>
    <p>Платформа 1С:Предприятие предосавляет очень удобную возможность формировать отчёт, построенный с помощью СКД, сразу при его открытии.</p>
    <p>Для этого нужно использовать параметр "СформироватьПриОткрытии", поставляемый расширением формы для отчёта, и передавать его в форму при открытии. Или же можно установить параметр формы "СформироватьПриОткрытии" в значение Истина в обработчике события формы "ПриСозданииНаСервере".</p>
    <p>Использовать первый способ не советуется.</p>

    <p><b id="chapter4.3.9">Получение предопределённых значений на клиенте</b></p>
    <p>Как уже не раз говорилось, работа с данными прикладных объектов на клиенте невозможна. Однако с помощью метода глобального контекста <b>ПредопределенноеЗначение()</b> на клиенте можно получать значения ссылок на предопределённые элементы справочников, планов видов характеристик, ссылки на значения перечислений и т.п.</p>
    <p>Поэтому если нужно выполнить какое-то действие на клиенте, например, открыть форму и передать в качестве параметра при её открытии какое-то предопределённое значение, то можно получить его тут же, на клиенте, не обращаясь для этого на сервер.</p>
    <p>Но если не задумываться о уменьшении серверных вызовов с клиента и делать всё "по старинке", то можно получить это предопределённое значение с сервера непостредственно перед открытием параметризованной формы.</p>
    <p>Посмотрим, какое решение будет наиболее правильным.</p>
    <p>Предположим в конфигурации существует документ "ОказаниеУслуги", содержащий реквизит "ВидРаботы". При заполнении соответсвующего поля документа указывается, где выполнялась услуга: на дому или в офисе. Выбор нужного значения тумблера выполняется из значений перечисления "ВидыРабот"("ВОфисе", "НаДому").</p>
    <p>При нажатии кнопки "Список услуг на дому" из формы списка документов "ОказаниеУслуги" должен открываться отчёт "РеестрОказанныхУслуг", выводящий список документов об оказании услуг, выполненных на дому. Т.е. при формировании отчёта к списку услуг должен быть применён отбор по виду работы. И при этом отчёт должен быть сформирован сразу же при его открытии:</p>
    <img src="../img/1С-1/2024-04-06_11-17-28.png" class="screen" alt="">
    <p><b>Первый способ решения</b></p>
    <p>Создадим форму списка документа "ОказаниеУслуг" и её команду "СписокУслугНаДому". Перетащим команду в командную панель формы. Обработчик команды заполним следующим образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СписокУслугНаДому(Команда)	
                ОтборПоВидуРаботы = Новый Структура("ВидРаботы", ПолучитьВидРаботы());
                ПараметрыФормы = Новый Структура("Отбор, СформироватьПриОткрытии", ОтборПоВидуРаботы, Истина);
                ОткрытьФорму("Отчет.РеестрОказанныхУслуг.Форма", ПараметрыФормы);
            КонецПроцедуры

            &НаСервереБезКонтекста
            Функция ПолучитьВидРаботы()	
                Возврат Перечисления.ВидыРабот.НаДому;
            КонецФункции 
        </pre>
    </div>
    <p>В этом обработчике мы создаём структуру "ОтборПоВидуРаботы", которая задаёт условие отбора - по виду работ, которые оказывались на дому. Для того чтобы получить ссылку на значение "НаДому" перечисления "ВидыРабот", мы используем функцию ПолучитьВидыРабот(), которая выполняется на сервере без контекста формы.</p>
    <p>Затем формируем структуру параметров формы (ПараметрыФормы), описав в ней значения двух стандартных параметров, поставляемых расширением отчёта: "Отбор" и "СформироватьПриОткрытии". Последний параметр устанавливаем в Истина, чтобы отчёт формировался сразу же при его открытии. Этот вопрос мы подробно рассматривали в предыдущем примере, поэтому не будем ещё раз на нём останавливаться.</p>
    <p>И затем откроем форму отчёта, передав в неё указанные параметры.</p>
    <p>Для получения ссылки на значение перечисления "ВидыРабот", поместим в модуле формы функцию ПолучитьВидРаботы(), исполняющуюся на сервере без контекста формы.</p>
    <p>Запустим пользовательский режим, окроем список документов "ОказаниеУслуг" и нажмём кнопку "Список услуг на дому". В итоге будет открыт и сразу же сформирован отчёт "РеестрОказанныхУслуг", выводящий список документов об окозании услуг, выполненных на дому.</p>
    <p>Вроде бы мы всё сделали правильно - открыли форму отчёта с параметрами, но всё равно при этом были сделаны два обращения на сервер.</p>
    <p>Для наглядности рассмотрим схему программного взаимодействия клиента и сервера. Ну тут схему рисовать не буду, просто напишу, что первый вызов сервера это наша процедура ПолучитьВидРаботы(), а второй вызов сервера это работа метода ОткрытьФорму().</p>
    <p>Первый вызов можно избежать, как это сделать будет во втором способе.</p>
    <p><b>Второй способ решения</b></p>
    <p>На самом деле для получения ссылки на значение перечисления вовсе не обязательно обращаться на сервер. Это можно сделать на клиенте с помощью метода ПредопределенноеЗначение(). И затем уже передавать полученное значение в форму отчёта при её открытии.</p>
    <p>Итак, изменим обработчик команды "СписокУслугНаДому" след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СписокУслугНаДому2(Команда)
                ПараметрыОтбора = Новый Структура("ВидРаботы", ПредопределенноеЗначение("Перечисление.ВидыРабот.НаДому"));
                ПараметрыФормы = Новый Структура("Отбор, СформироватьПриОткрытии", ПараметрыОтбора, Истина);
                ОткрытьФорму("Отчет.РеестрОказанныхУслуг.Форма", ПараметрыФормы,,,,,, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца); 
            КонецПроцедуры
        </pre>
    </div>
    <p>А функцию ПолучитьВидРаботы() удалим из модуля формы. Запустим платформу, откроем список документов и запустим команду. Посколько ссылку на значение перечисления ВидыРабот мы получаем на клиенте, нам не понадобится лишний раз обращаться на сервер. В итоге та же функциональность будет воплощена за один серверный вызов, и производительность прикладного решения будет выше.</p>
    <p><span class="vue-r">На самом деле не совсем так. Метод ПредопределенноеЗначение() обращается на сервер за получением значения, но после первого обращения кеширует полученное значение и уже во второй раз берёт значение из кеша и вызова сервера не происходит.</span></p>
    <p>Итог сильно описывать не буду, там говорится, что нужно использовать второй способ.</p>

    <p><b id="chapter4.3.10">Запись данных объекта в единой транзакции за один серверный вызов</b></p>
    <p>В процессе работы прикладного решения значения реквизитов объекта могут меняться не только "руками", но и программно. При этом запись данных объекта в инфобазу должна выполняться в единой транзакции за один серверный вызов.</p>
    <p>Рассмотрим этот вопрос на примере работы с файлами и картинками.</p>
    <p>Предположим, в форме элемента справочника Товары содержится поле, откражающее картинку товара. При нажатии кнопки "Загрузить картинку", расположенной в форме документа, должен открываться диалог выбора файла картинки. Выбранная картинка должна быть отображена в форме элемента и записана в соотвествующий реквизит объекта.</p>
    <p>Сначала пользователь должен выбрать картинку товара. Единственный способ работы с файлами пользователя - интерактивно выбрать картинку и поместить её во временное хранилище на сервере.</p>
    <p>Затем получить её из временного хранилища и записать в базу данных, например в реквизит объекта.</p>
    <p>В форме картинка отображается самостотельно по навигационной ссылке на временное хранилище или на реквизит объекта, содержащей эту картинку в базе.</p>
    <p>Когда же нужно записывать картинку из временного хранилища в соответствующий реквизит объекта? Можно записать картинку сразу после выбора, но более правильно записывать её тогда, когда пользователь захочет сохранить объект.</p>
    <p>Рассмотрим возможные способы решения этой задачи.</p>
    <p>Первый способ решения</p>
    <p>В данном решении запишем в базу данных сразу же после её выбора.</p>
    <p>Итак, создадим форму элемента справочника Товары. Добавим в форму реквизит "АдресКартинки"(тип Строка), в котором будет хранится навигационная ссылка на реквизит справочника "ДанныеФайлаКартинки". Перетащим реквизит "АдресКартинки" в дерево элементов формы. Установим свойства элемента: Вид - Поле картинки и ПоложениеЗаголовка - Нет.</p>
    <p>Создадим команду формы "ЗагрузитьКартинку" и поместим её в командную панель формы. При нажатии этой кнопки будут выполняться выбор файла картинки с диска, запись данных картинки в реквизит справочника "ДанныеФайлаКартинки" и отображение картинки в форме.</p>
    <p>Обработчик команды заполним след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьКартинку(Команда)
                Оповещение = Новый ОписаниеОповещения("ЗагрузитьКартинкуЗавершение", ЭтотОбъект);
                
                НачатьПомещениеФайлаНаСервер(Оповещение,,,,, УникальныйИдентификатор);
            КонецПроцедуры
        </pre>
    </div>
    <p>Загрузка картинки выполняется с помощью немодального метода НачатьПомещениеФайлаНаСервер(), который мы подробно рассматривали в главе 3.18.</p>
    <p>В первом параметре этого метода описывается процедура обработки оповещения ЗагрузитьКартинкуЗавершение(), в которой в случае выбора файла картинки пользователем будут выполняться действия по загрузке картинки товара:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьКартинкуЗавершение(ОписаниеФайла, ДопПараметры) Экспорт
                Если ОписаниеФайла &lt;> Неопределено Тогда
                    Объект.ИмяФайла = ОписаниеФайла.СсылкаНаФайл.Файл.Имя;
                    АдресКартинки = ОписаниеФайла.Адрес;
                    
                    ПоместитьФайлКартинки();
                КонецЕсли;

                АдресКартинки = ПолучитьНавигационнуюСсылку(Объект.Ссылка, "ДанныеФайлаКартинки");
            КонецПроцедуры 
        </pre>
    </div>
    <p>В процедуру обработки оповещения в параметре "ОписаниеФайла" мы найдём адрес во временном хранилище, по которому был помещён файл картинки. Также в нём найдём путь до выбранного файла.</p>
    <p>В случае успешного выбора картинки, короткое имя картинки сохраняется в реквизите справочника "ИмяФайла", и данные файла картинки помещаются во временное хранилище. Адрес данных в этом хранилище сохраняется в реквизите формы "АдресКартинки".</p>
    <p>Затем в процедуре ПоместитьФайлКартинки() выполняется запись данных картинки в реквизит справочника "ДанныеФайлаКартинки". И затем с помощью метода ПолучитьНавигационнуюСсылку() реквизиту "АдресКартинки" присваивается навигационная ссылка на реквизит "ДанныеФайлаКартинки", и картинка отображается в форме. В первом параметре метода ПолучитьНавигационнуюСсылку() передаётся ссылка на объект, а во втором имя реквизита этого объекта, в котором лежат данные картинки.</p>
    <p>Контекстную серверную процедуру ПоместитьФайлКартинки() заполним след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПоместитьФайлКартинки()  
                ЭлементСправочника = РеквизитФормыВЗначение("Объект");
                ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресКартинки);
                ЭлементСправочника.ДанныеФайлаКартинки = Новый ХранилищеЗначения(ДвоичныеДанные, Новый СжатиеДанных());
                ЭлементСправочника.Записать();
                УдалитьИзВременногоХранилища(АдресКартинки);
                ЗначениеВРеквизитФормы(ЭлементСправочника, "Объект");      
            КонецПроцедуры
        </pre>
    </div>
    <p>Чтобы мы могли записать объект, в этой процедуре значение основного реквизита формы Объект преобразуется в значение объекта - элемента справочника. Затем в переменной "ДвоичныеДанные" сохраняются данные, полученные из временного хранилища по адресу "АдресКартинки". Затем создаётся объект "ХранилищеЗначения", в него помещается значение переменной "ДвоичныеДанные", и значение объекта "ХранилищеЗначения" сохраняется в реквизите справочника "ДанныеФайлаКартинки". Затем данные объекта - элемента справочника записываются, временное хранилище очищается, и значение изменённого объекта преобразовывается обратно в значение основного реквизита формы.</p>
    <p>Теперь осталось обеспечить чтение картинки при чтении данных уже существующего объекта. Для этого создадим обработчик события формы "ПриЧтенииНаСервере" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЧтенииНаСервере(ТекущийОбъект)	
                АдресКартинки = ПолучитьНавигационнуюСсылку(ТекущийОбъект.Ссылка, "ДанныеФайлаКартинки");	
            КонецПроцедуры
        </pre>
    </div>
    <p>Запустим польз. режим и откроем форму элемента справочника Товары. Если у товара уже была выбрана картинка, она откроется в форме. Нажмём кнопку "Загрузить картику" и изменим картинку товара. Выбранная картинка отобразится в поле картинки товара и будет записана в реквизит объекта "ДанныеФайлаКартинки".</p>
    <p>Таким образом мы добились нужной функциональности формы, но посмотрим теперь на показатели производительности. В итоге из обработчика команды "Загрузить картинку" будет сделано целых пять вызовов сервера!</p>
    <p>Два вызова сервера произойдут при выполнении метода НачатьПомещениеФайлаНаСервер(), и эти вызовы оправданы, так как их делает платформа. Один раз сервер вызывается при исполнении этого метода, так как он передаёт картинку с клиентского компа во временное хранилище, а второй вызов происходит, потому что навигационная ссылка помещается в реквизит формы "АдресКартинки"(АдресКартинки = ОписаниеФайла.Адрес;). Это приводит к тому, что форма обновляется, чтобы отобразить картинку по этой ссылке.</p>
    <p>Один вызов сервера будет сделан при записи картинки объекта при вызове серверной процедуры ПоместитьФайлКартинки(). Этого вызова можно избежать, если не записывать картинку сразу при выборе, а хранить данные картинки во временном хранилище до тех пор, пока объект не записан.</p>
    <p>И ещё два вызова произойдут при выполнении метода ПолучитьНавигационнуюСсылку(). Этот метод выполняет обращение к серверу при получении ссылки на реквизит. Здесь один серверный вызов происходит при получении навигационной ссылки, а второй потому что она сразу присваивается реквизиту формы "АдресКартинки". Этих вызовов также можно избежать, если использовать навигационную ссылку на временное хранилище для отображения картинки в форме до тех пор, пока объект не записан.</p>
    <p><b>Второй способ решения</b></p>
    <p>Итак, устраним описанные выше ошибки. Для этого изменим обработчик команды "ЗагрузитьКартинку" след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЗагрузитьКартинку(Команда)
                Оповещение = Новый ОписаниеОповещения("ЗагрузитьКартинкуЗавершение", ЭтотОбъект);
                
                НачатьПомещениеФайлаНаСервер(Оповещение,,,,, УникальныйИдентификатор);
            КонецПроцедуры

            &НаКлиенте
            Процедура ЗагрузитьКартинкуЗавершение(ОписаниеФайла, ДопПараметры) Экспорт
                Если ОписаниеФайла &lt;> Неопределено Тогда
                    Объект.ИмяФайла = ОписаниеФайла.СсылкаНаФайл.Файл.Имя;
                    АдресКартинки = ОписаниеФайла.Адрес;
                    
                    Модифицированность = Истина;
                КонецЕсли;
            КонецПроцедуры 
        </pre>
    </div>
    <p>В этом обработчике методом НачатьПомещениеФайлаНаСервер() открывается диалог выбора файла картинки с диска.</p>
    <p>В процедуре обработки оповещения в случае выбора файла картинки пользователем будут выполняться действия по загрузке картинки товара.</p>
    <p>В случае успешного выбора картинки короткое имя сохраняется в реквизите справочника ИмяФайла, и данные файла картинки помещаются во временное хранилище (АдресВХранилище). Адрес данных в этом хранилище сохраняется в переменной ОписаниеФайла.</p>
    <p>Параметр "УникальныйИдентификатор" связывает эти данные хранилища с нашей формой. Когда форма будет закрыта, данные из хранилища будут самостоятельно удалены. Свойству формы Модифицированность присвваивается значение Истина, чтобы указать, что форма уже изменена, так как мы выбрали картинку товара.</p>
    <p>Как мы уже говорили, при выборе картинки данные ещё не записаны в объект базы данных. Возможно пользователь и не станет сохранять данные. В этом случае мы закроем форму, и данные временного хранилища, связанные с этой формой, будут самостоятельно удалены. Но если пользователь решит записать данные формы, то тогда нам нужно будет взять картинку из временного хранилища и сохранить её в базе данных. Для этого создадим обработчик события формы "ПередЗаписьюНаСервере" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)	
                Если ЭтоАдресВременногоХранилища(АдресКартинки) Тогда 
                    ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресКартинки);
                    ТекущийОбъект.ДанныеФайлаКартинки = Новый ХранилищеЗначения(ДвоичныеДанные, Новый СжатиеДанных());
                КонецЕсли;		
            КонецПроцедуры
        </pre>
    </div>
    <p>Это событие выполняется непосредственно перед записью объекта из формы, когда пользователь нажал "Записать" или "Записать и закрыть".</p>
    <p>В этой процедуре мы сохраняем значение картинки в том случае, если у нас есть ссылка на временное хранилище. В переменной "ДвоичныеДанные" сохраняются данные, полученные из временного хранилища. Затем создаётся объект ХранилищеЗначения, в него помещается значение переменной "ДвоичныеДанные", и значение объекта ХранилищеЗначения сохраняется в реквизите справочника "ДанныеФайлаКартинки".</p>
    <p>После записи картинки в объект нужно очистить временное хранилище и установить для реквизита формы "АдресКартинки" новую навигационную ссылку на реквизит объекта, хранящий теперь данные картинки. Потому что до этого картинка показывалась из временного хранилища. Для этого создадим обработчик чобытия формы "ПриЗаписиНаСервере" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)              
                Если ЭтоАдресВременногоХранилища(АдресКартинки) Тогда 
                    УдалитьИзВременногоХранилища(АдресКартинки);
                КонецЕсли;	
                АдресКартинки = ПолучитьНавигационнуюСсылку(ТекущийОбъект.Ссылка, "ДанныеФайлаКартинки");               
            КонецПроцедуры
        </pre>
    </div>
    <p>Это событие выполняется после записи данных объекта, но ещё до окончания транзакции записи. Так что если по каким-то причинам объект не был записан в базу, в форме останется всё по прежнему и реквизит "АдресКартинки" будет указывать на временное хранилище, в котором будет находится картинка.</p>
    <p>Процедуру ПоместитьФайлКартинки() теперь можно удалить из модуля формы, так как она больше не нужна.</p>
    <p>Запустим 1С:Предприятие и откроем форму элемента справочника Товары. Если у товара уже была выбрана картинка, она отразится в форме. Нажмём кнопку "Загрузить картинку" и изменим картинку товара. Выбранная картинка отобразится в поле картинки товара и будет записана в реквизит объекта "ДанныеФайлаКартинки" в тот миг, когда пользователь решит записать товар.</p>
    <p>В результате из обработчика события кнопки "Загрузить картинку" будут сделаны два вызова сервера.</p>
    <p>Эти вызовы произойдут при выполнении метода НачатьПомещениеФайлаНаСервер(), и они оправданы, так как их делает платформа.</p>
    <p>Посмотрим теперь, сколько вызовов сервера будет сделано при записи элемента справочника. Ведь именно в этот миг картинка окажется в базе данных. В форме товара нажмём кнопку "Записать".</p>
    <p>При первом нажатии произойдут три серверных вызова и затем - два вызова, если мы, не закрывая формы, снова и снова нажимаем кнопку "Записать".</p>
    <p>Первый вызов происходит, когда устанавливается объектная блокировка на записываемые данные. Второй контекстный вызов сервера выполняется платформой, чтобы записать данные, отображаемые в форме. Третий - при обновлении динамического списка, открытого в основном окне программы. При последующих нажатиях кнопки "Записать" выполняются последние два вызова. Блокировка устанавливается только один раз и будет снята при звкрытии формы.</p>
    <p>Таким образом видно, что при записи выполняются "обычные" вызовы сервера, которые платформа сделала бы в любом случае. Т.е. на запись картинки товара мы не потратили дополнительных вызовов сервера.</p>
    <p>В итоге мы избавились от трёх лишних вызовов сервера, которые были у нас в первом случае при вызове методов ПоместитьФайлКартинки() и ПолучитьНавигационнуюСсылку().</p>
    <p><b>Подитожим</b></p>
    <p>Запись объектов конфигурации в инфобазу должна производится не когда придётся, а в нужный миг, и не должна понижать производительность прикладного решения.</p>
    <p>Действия, логически объединённые в одну транзакцию (например, запись реквизитов объекта), нужно выполнять в одном серверном вызове. Это обеспечит согласованность данных объекта и избавит от лишних вызовов сервера.</p>
    <p>При выборе картинки объекта, пока объект не записан пользователем, загруженные картинки должны быть во временном хранилище. Как только объект записывается, нужно переносить картинки из временного хранилища в реквизит и записывать синхронно с объектом (в одной транзакции).</p>
    <p>Что плохого, если записывать картинку в базу сразу после её выбора? При этом будут произведены лишние вызовы сервера, ведь нет уверенности, что именно эта картинка и окажется в объекте в результате действий пользователя. Пользователь может вообще отказаться от записи объекта в базу данных. Также тут есть вопрос согласованности данных. Картинку записали, а объект "не смогли". В итоге данные могут быть несогласованными. Т.е. такие изменения должны выполняться в одной транзакции, за один серверный вызов.</p>
    <p>Поэтому не нужно записывать картинку в базу данных сразу при её выборе, а делать это нужно непосредственно перед записью самого объекта в базу данных.</p>
    <p>Второй способ предпочтительнее.</p>

    <p><b id="chapter4.3.11">Использование временного хранилища для передачи данных между формами</b></p>
    <p>В процессе работы прикладного решения часто бывает нужно передавать данные из одной формы в другую. Примером такого обмена данными между формами является передача табличной части из формы документа в форму подбора и обратно.</p>
    <p>Можно передавать данные через клиент в параметре типа "ДанныеФормыКоллекция", а можно использовать для этого временное хранилище, работа с которым будет происходить на сервере.</p>
    <p>С одной стороны, при передаче данных через клиент мы уменьшаем вызовы сервера. Но объём передаваемых данных при этом может быть довольно большим. Кроме того, поскольку на клиенте присутствуют не все данные коллекций форм, а только их видимая часть, то данные при передаче будут дочитываться постепенно с сервера.</p>
    <p>С другой стороны, этого можно избежать, передавая данные через временное хранилище, минуя клиент, но для этого потребуются дополнительные вызовы сервера.</p>
    <p>Посмотрим, какой пример будет более отлаженным.</p>
    <p>Предположим, в табличную часть документа "РасходнаяНакладная" подбираются товары из справочника Товары. При нажатии кнопки "Подбор", расположенной в форме документа, должна открываться форма подбора, в которую передаются строки табличной части документа. После того как пользователь произведёт подбор товаров из справочника и закроет форму подбора, отобранные товары передаются обратно в табличную часть расходной накладной:</p>
    <img src="../img/1С-1/2024-04-09_08-35-13.png" class="screen" alt="">
    <p><b>Первый способ решения</b></p>
    <p>Итак, создадим форму документа "РасходнаяНакладная". Создадим команду формы "Подбор" и перетащим её в командную панель таблицы формы Товары. Обработчик команды "Подбор" заполним след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура Подбор(Команда)	
                ПараметрыПодбора = Новый Структура("ТчТоваровДокумента", Объект.Товары);
                ФормаПодбора = ОткрытьФорму("Документ.РасходнаяНакладная.Форма.ФормаПодбора", ПараметрыПодбора, ЭтаФорма);
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы создаём структуру "ПараметрыФормы" и добавляем в неё элемент "ТчТоваровДокумента", который будет содержать табличную часть документа(Объект.Товары). Затем мы открываем форму подбора документа "ФормаПодбора" с параметром типа "ДанныеФормыКоллекция" как подчинённую форме документа.</p>
    <p>Теперь создадим форму документа с именем "ФормаПодбора" с основным реквизитом "СписокТоваров" типа "ДинамическийСписок", отражающим данные справочника Товары.</p>
    <p><span class="vue-r">Поясню от себя. Создаём произвольную форму документа, создаём в ней новый реквизит, обзываем "СписокТоваров", назначаем ему тип "ДинамическийСписок" и в свойствах ставим галочку у свойства "Основной реквизит", а в свойстве "ОсновнаяТаблица" выбираем справочник Товары.</span></p>
    <p>Затем создадим реквизит формы "ОтобранныеТовары" типа "ТаблицаЗначений" (с колонками Товар типа "Справочник.Ссылка.Товары" и Количество с типом Число), который будет содержать список отобранных товаров и их количество.</p>
    <p>Перетащим реквизиты "СписокТоваров" и "ОтобранныеТовары" в форму, а также зададим свойства этих таблиц формы: "Заголовок", "Положение заголовка" - Верх, "Положение командной панели" - Нет. Зададим также свойство формы "Заголовок" - "Подбор товара" и выключим свойство "Автозаголовок", "Положение командной панели" - Низ.</p>
    <p>Чтобы обеспечить заполнение реквизита "ОтобранныеТовары" данными табличной части расходной накладной, создадим обработчик события формы "ПриСозданииНаСервере" и заполним его след. образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы "ФормаПодбора"

            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)              
                ТчТоваровДокумента = Параметры.ТчТоваровДокумента;
                Для Каждого ТоварТч Из ТчТоваровДокумента Цикл
                    Элемент = ОтобранныеТовары.Добавить();
                    Элемент.Товар = ТоварТч.Товар;
                    Элемент.Количество = ТоварТч.Количество;
                КонецЦикла;
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы в цикле обходим коллекцию данных, которую мы сюда передали через параметры, и заполняем таблицу значений "ОтобранныеТовары" элементами из этой коллекции.</p>
    <p>Таким образом, список отобранных товаров при открытии формы подбора будет заполнен данными табличной части расходной накладной.</p>
    <p>Затем воплотим возможнось добавления товаров из списка товаров справочника Товары в таблицу отобранных товаров. Для этого создадим обработчик события "ВыборЗначения" у таблицы формы "СписокТоваров" и включим у этой таблицы свойство "Режим выбора"(иначен событие не сработает):</p>
    <div class="code-style">
        <pre>
            --модуль формы "ФормаПодбора"

            &НаКлиенте
            Процедура СписокТоваровВыборЗначения(Элемент, Значение, СтандартнаяОбработка)	
                СтандартнаяОбработка = Ложь;
                ДобавитьТовар(Значение);	
            КонецПроцедуры
        </pre>
    </div>
    <p>Тут же в модуле формы поместим процедуру ДобавитьТовар(), в которой выполняется добавление товаров из списка товаров в таблицу отобранных товаров. Но заметим, что эта процедура не имеет отношения к передаче данных между формами:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ДобавитьТовар(Товар)	
                Элемент = ОтобранныеТовары.Вставить(0);
                Элемент.Товар = Товар;
                Элемент.Количество = 1;
                Элементы.ОтобранныеТовары.ТекущаяСтрока = Элемент.ПолучитьИдентификатор();	
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">От себя допишу. Есть ещё один способ как добавить из списка товаров товар в таблицу "ОтобранныеТовары":</span></p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СписокТоваровВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
                СтандартнаяОбработка = Ложь;

                Товар = ОтобранныеТовары.Добавить();
                Товар.Товар = ВыбраннаяСтрока;
                Товар.Количество = 0;	
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Для этого использую событие "Выбор", оно срабатывает когда нажимаем два раза мышью по строке или кнопкой Enter. Обязательно Стандартную обработку ставим в Ложь, чтобы не открывалась по умолчанию форма элемента справочника.</span></p>
    <p>Продолжаем. Затем при нажатии конпки ОК, форма подбора должна закрываться, и список отобранных товаров должен передаваться обратно в табличную часть расходной накладной.</p>
    <p><span class="vue-r">Напомню, мы командную панель формы сместили вниз и убрали галочку "Автозаполнение", чтобы исчезли все команды из неё. Затем в эту командную панель добавили 2 стандартные команды ОК и Отмена. Также свойству "Горизонтальное положение" ставим "Право"</span></p>
    <p>Обработчик команды ОК заполним следующим образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы "ФормаПодбора"

            &НаКлиенте
            Процедура ОК(Команда)
                //когда мы открывали эту форму, то в метод ОткрытьФорму() 3м
                //параметром передали, кто владелей этой формы и 
                //у этой формы в свойстве ВладелецФормы теперь содержится её владелей,
                //т.е. форма документа и у неё вызывем процедуру
                ВладелецФормы.ОбработатьПодбор(ОтобранныеТовары);
                Закрыть();
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике, перед тем как закрыть форму подбора, мы вызываем экспортируемую процедуру ОбработатьПодбор() владельца формы, т.е. формы объекта-документа РасходнаяНакладная, и передаём в неё список отобранных товаров:</p>
    <div class="code-style">
        <pre>
            --модуль формы документа "РасходнаяНакладная"

            &НаКлиенте
            Процедура ОбработатьПодбор(ОтобранныеТовары) Экспорт	
                Объект.Товары.Очистить();
                Для Каждого ТоварТч Из ОтобранныеТовары Цикл
                    Элемент = Объект.Товары.Добавить();
                    Элемент.Товар = ТоварТч.Товар;
                    Элемент.Количество = ТоварТч.Количество;
                КонецЦикла;
                Модифицированность = Истина;	
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре, помещённой в модуле документа РасходнаяНакладная, мы очищаем табличную часть документа, затем в цикле обходим коллекцию данных, содержащуюся в параметре "ОтобранныеТовары", и заполняем табличную часть документа элементами этой коллекции. И затем свойство формы Модифицированность устанавливаем в значение Истина, так как мы изменили табличную часть документа.</p>
    <p>Таким образом, табличная часть расходной накладной при закрытии формы подбора по кнопке ОК будет заполнена списком отобранных товаров.</p>
    <p>Запустим 1С:Предприятие, откроем документ РасходнаяНакладная №3(он содержит 1000 позиций товаров) и нажмём кнопку "Подбор". После этого откроется форма подбора, в которую будут переданы строки табличной части документа.</p>
    <p>Посмотрим, сколько вызовов сервера при этом произойдёт и какой будет объём передаваемых данных между клиентом и сервером. Мы специально рассматриваем пример документа с большой табличной частью, так как в нём лучше сравнивать показатели производительности:</p>
    <img src="../img/1С-1/2024-04-09_20-30-42.png" class="screen-2" alt="">
    <p>Мы видим, что сервер вызывается 29 раз. Один вызов происходит, чтобы открыть форму подбора, и 28 вызовов сервера тратятся на "дочитывание" строк табличной части в форму документа порциями по 35 строк.</p>
    <p><span class="vue-r">На сегодняшний день у меня намного меньше вызовов сервера. Видимо за время прошедшее с написания книги, разработчики уже немного отладили этот процесс. Я заметил, что не все сразу загружаются товары в список тобранных товаров, а при листании списка вниз они подгружаются.</span></p>
    <p>Объём принятых данных отражает обстановку, когда табличная часть "доехала" в форму документа на клиент, так как с клиента мы "отправляем" Объект.Товары в параметрах открываемой формы.</p>
    <p>Объём отправленных данных отражает обстановку, когда вся табличная часть с клиента "уехала" на сервер, так как она передаётся в параметре метода ОткрытьФорму().</p>
    <p>После того как пользователь произведёт подбор товаров из справочника(в нашем примере выбран всего один товар) и закроет форму подбора, отобранные товары и их количество будут переданы обратно в табличную часть расходной накладной.</p>
    <p>Посмотрим теперь на показатели производительности:</p>
    <img src="../img/1С-1/2024-04-10_08-42-17.png" class="screen-2" alt="">
    <p>28 вызовов сервера тратятся на "дочитывание" строк таблицы значений "ОтобранныеТовары" в форму подбора на клиент порциями по 35 строк.</p>
    <p>Объём принятых данных отражает обстановку, когда таблица "ОтобранныеТовары" "доехала" в форму подбора на клиент, так как с клиента мы вызываем процедуру ОбработатьПодбор(), в которую передаём эту таблицу в качестве параметра.</p>
    <p>Может возникнуть вопрос: "Почему в первой таблице, когда в форму документа дочитывалась табличная часть, было передано 153 302, а тут, когда те же данные дочитываются в форму подбора, передано всего 97 690?"</p>
    <p>Дело в том, что в первой таблице дочитывалась именно табличная часть. Во второй таблице дочитывалась не табличная часть, а таблица значений. Таблица значений устроена проще, чем табличная часть, поэтому она сериализуется лучше (объём данных меньше). Кроме того, в первом примере табличная часть содержит три колонки, а таблица значений во втором случае содержит 2 колонки.За счёт этого во втором случае и получается меньший объём принятых данных.</p>
    <p>В итоге мы добились нужной функциональности формы, но при большом массиве передаваемых данных. Такой способ обмена данными между формами будет не отлаженным.</p>
    <p><b>Второй способ решения</b></p>
    <p>На самом деле более правильно передавать данные между формами через временное хранилище, работа с которым будет происходить на сервере. Ведь основная масса строк табличной части находится на сервере, а не на клиенте, и поэтому логично было бы передать их другой форме прямо с сервера, не таская их на клиент.</p>
    <p>Для этого перед открытием формы подбора нужно сначала записать данные табличной части документа во временное хранилище, а в форме подбора прочитать его и загрузить в список отобранных товаров.</p>
    <p>Изменим обработчик команды "Подбор" след. образом:</p>
    <div class="code-style">
        <pre>
            --модуль формы документа "РасходнаяНакладная"

            &НаКлиенте
            Перем АдресТоваровВХранилище;

            &НаКлиенте
            Процедура Подбор(Команда)
                АдресТоваровВХранилище = ПоместитьТоварыВХранилище();	
                ПараметрыПодбора = Новый Структура("АдресТоваровДокументов", АдресТоваровВХранилище);
                ФормаПодбора = ОткрытьФорму("Документ.РасходнаяНакладная.Форма.ФормаПодбора2", ПараметрыПодбора, ЭтаФорма);	
            КонецПроцедуры 

            &НаСервере
            Функция ПоместитьТоварыВХранилище()
                Возврат ПоместитьВоВременноеХранилище(Объект.Товары.Выгрузить(, "Товар, Количество"));	
            КонецФункции
        </pre>
    </div>
    <p>В самом начале модуля формы документа мы определяем клиентскую переменную "АдресТоваровВХранилище", чтобы потом получить по этому адресу список отобранных товаров из формы подбора.</p>
    <p>Теперь создадим в форме подбора строковый реквизит "АдресТоваровДокумента" для хранения адреса товаров в хранилище. Заполнять его будем в обработчике события формы "ПриСозданииНаСервере":</p>
    <div class="code-style">
        <pre>
            --модуль формы "ФормаПодбора"

            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)	
                АдресТоваровДокумента = Параметры.АдресТоваровДокумента;
                ОтобранныеТовары.Загрузить(ПолучитьИзВременногоХранилища(АдресТоваровДокумента));
            КонецПроцедуры
        </pre>
    </div>
    <p><span class="vue-r">Мне не совсем понятно для чего мы создаём строковый реквизит "АдресТоваровДокумента". Можно просто создать переменную и в неё сохранить адрес. Понял, мы же отправим созданную форму подбора на клиента и там нам понадобится адрес сохранённый в реквизите, а переменная исчезнет на сервере, как только обработчик "ПриСозданииНаСервере" отработает.</span></p>
    <p>В этом обработчике мы сохраняем в реквизите "АдресТоваровДокумента" адрес товаров во временном хранилище, получаем из хранилища данные по этому адресу и загружаем их в таблицу значений "ОтобранныеТовары".</p>
    <p>Таким образом, список отобранных товаров при открытии формы подбора будет заполнен данными табличной части расходной накладной.</p>
    <p>Теперь при закрытии формы подбора по нажатию кнопки ОК нужно записать список отобранных товаров во временное хранилище, а в форме документа прочитать его и загрузить обратно в табличную часть. Изменим обработчик команды ОК след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОК(Команда)
                ЗаписатьПодборВХранилище();
                ВладелецФормы.ОбработатьПодбор();
                Закрыть();
            КонецПроцедуры
        </pre>
    </div>
    <p>Поместим в модуле формы подбора процедуру ЗаписатьПодборВХранилище(), выполняющуюся на сервере с контекстом формы, для записи данных таблицы значений ОтобранныеТовары во временное хранилище по адресу "АдресТоваровВХранилище":</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ЗаписатьПодборВХранилище() 	
                ПоместитьВоВременноеХранилище(ОтобранныеТовары.Выгрузить(), АдресТоваровДокумента);	
            КонецПроцедуры
        </pre>
    </div>
    <p>Процедуру ОбработатьПодбор() владельца формы, т.е. формы объекта-документа "РасходнаяНакладная", изменим след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ОбработатьПодбор() Экспорт	
                ПолучитьТоварыИзХранилища(АдресТоваровВХранилище);  
                Модифицированность = Истина;	
            КонецПроцедуры

            &НаСервере
            Процедура ПолучитьТоварыИзХранилища(АдресТоваровВХранилище)	
                Объект.Товары.Загрузить(ПолучитьИзВременногоХранилища(АдресТоваровВХранилище));	
            КонецПроцедуры
        </pre>
    </div>
    <p>Поместим в модуле формы документа процедуру ПолучитьТоварыИзХранилища(), выполняющуюся на сервере с контекстом формы, для чтения данных из временного хранилища. В процедуру мы передаём адрес этих данных в хранилище, хранящийся в клиентской переменной "АдресТоваровВХранилище".</p>
    <p>В этой процедуре мы получаем товары из временного хранилища и загружаем их в табличную часть документа.</p>
    <p>Таким образом, табличная часть расходной накладной при закрытии формы подбора по кнопке ОК будет заполнена списком отобранных товаров.</p>
    <p>Посмотрим сколько вызовов сервера произойдёт при этом способе:</p>
    <img src="../img/1С-1/2024-04-11_09-05-54.png" class="screen-2" alt="">
    <p>Мы видим, что сервер вызывается 2 раза. Один вызов происходит при записи данных табличной части в хранилище, а второй при открытии формы подбора.</p>
    <p><span class="vue-r">Далее по книги графики сравнения передаваемых данных между клиентом и сервером в этих двух способах. Если нужно будет, то глянуть в книге.</span></p>
    <p><b>Подитожим</b></p>
    <p>При отладке клиент-серверного взаимодействия нужно стремиться не только уменьшить вызовы сервера, но и следить за объёмом передаваемых данных между сервером и клиентом.</p>
    <p>При передаче данных между формой объекта и формой подбора лучше использовать временное хранилище, чтение и запись которого должны выполняться на сервере.</p>
    <p>Большой объём данных не нужно передавать в качестве параметра при открытии формы подбора.</p>

    <p><b id="chapter4.3.12">Пересчёт данных объекта в модуле объекта или в модуле формы в зависимости от логики объекта</b></p>
    <p>Для воплощения той или иной функциональности объектов конфигурации часто бывает нужно выполнить пересчёт данных объекта, содержащегося в форме. Сделать это можно как в контекстной серверной процедуре модуля формы, так и в экспортируемой процедуре модуля объекта.</p>
    <p>В первом случае производится пересчёт непосредственно данных формы без получения объекта, а при записи объекта из формы эти данные конвертируются в объект и записываются.</p>
    <p>Во втором случае предварительно нужно получить объект, преобразовав данные формы в обект, произвести перерасчёт и выполнить обратное преобразование объекта в данные формы. На это требуется дополнительное время, но зато процедура, скрытая в объекте, может вызываться из других мест конфигурации как отдельный метод этого объекта.</p>
    <p>Когда же нужно помещать процедуру перерасчёта данных объекта в модуле формы, а когда в модуле объекта? Однозначного ответа тут нет. Решение зависит от конкретной задачи. Рассмотрим пример.</p>
    <p>Предположим, в конфигурации существует справочник Клиенты. В нём для каждого клиента хранится процент скидки, предоставляемый ему при оказании услуг. В форме документа об оказании услуг содержатся услуга, цена услуги, клиент, которому она оказывается, сумма скидки и сумма услуги. При выборе клиента нужно выяснить, предоставляется ли ему скидка, и расчитать сумму скидки как процент от цены услуги. При этом сумма услуги расчитывается как цена услуги минус сумма скидки:</p>
    <img src="../img/1С-1/2024-04-12_08-03-26.png" class="screen" alt="">
    <p>Таким образом, в тот миг, когда пользователь изменит поле "Клиент" или поле "ЦенаУслуги", поля "СуммаСкидки" и "СуммаУслуги" нужно расчитать по описанному выше алгоритму.</p>
    <p>Рассмотрим возможные способы решения этой задачи.</p>
    <p><b>Первый сособ</b></p>
    <p>В данном решении поместим процедуру для расчёта скидки клиенту в модуле формы документа "ОказаниеУслуги".</p>
    <p>Чтобы обеспечить перерасчёт суммы скидки и суммы услуги при изменении её цены и выборе клиента, создадим в модуле формы обработчик события "ПриИзменении" для поля формы "Клиент", ссылаяющегося на справочник "Клиенты":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура КлиентПриИзменении(Элемент)	
                НачислитьСкидку();	
            КонецПроцедуры

            &НаСервере
            Процедура НачислитьСкидку()	
                Объект.СуммаСкидки = Объект.ЦенаУслуги * Объект.Клиент.Скидка / 100;
                Объект.СуммаУслуги = Объект.ЦенаУслуги - Объект.СуммаСкидки;	
            КонецПроцедуры
        </pre>
    </div>
    <p>Тут мы вызываем контекстную серверную процедуру для начисления скидки клиенту, расположенную в модуле формы. В этой процедуре мы получаем значение реквизита "Скидка" по ссылке на текущий элемент справочника "Клиенты"(Объект.Клиент). Лучше получать через запрос это значение, но для упрощения мы получаем через ссылку.</p>
    <p>И затем пересчитываем поля "СуммаСкидки" и "СуммаУслуги" документа "ОказываниеУслуги" по заданному алгоритму.</p>
    <p>Теперь обеспечим пересчёт суммы услуги при изменении цены услуги:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура ЦенаУслугиПриИзменении(Элемент)	
                Объект.СуммаУслуги = Объект.ЦенаУслуги - Объект.СуммаСкидки;	
            КонецПроцедуры
        </pre>
    </div>
    <p>Включим для полей формы "СуммаСкидки" и "СуммаУслуги" свойство "ТолькоПросмотр", так как они являются расчётными.</p>
    <p>Запустим решение, создадим документ об оказании услуги, выберем услугу и внесём цену услуги. При этом сумма услуги становится равной цене услуги. Затем выберем клиента. Расчитается сумма услуги и сумма скидки.</p>
    <p>Посмотрим теперь на показатели производительности. При выборе клиента произойдёт один вызов сервера.</p>
    <p><span class="vue-r">Напоминаю, что при первом разе вызовов сервера может быть больше, потому что платформа кеширует данные.</span></p>
    <p>Этот вызов происходит при выполнении контекстной серверной процедуре НачислитьСкидку().</p>
    <p>Итак, мы поместили процедуру для начисления скидки клиенту в модуле формы документа. После записи или проведения документа из формы пересчитанные данные формы будут преобразованы в объект и записаны. Таким образом, в данном решении мы посчитали процедуру начисления скидки "частным" делом этой формы. Снаружи данная функциональность формы не видна.</p>
    <p><b>Второй способ</b></p>
    <p>На самом деле может быть более логично поместить процедуру для начисления скидки клиенту в модуле объекта. Потому что начисление скидки - это часть прикладной логики самого документа "ОказаниеУслуги".</p>
    <p>Изменим процедуру НачислитьСкидку() в модуле формы документа след. образом:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура НачислитьСкидку()	
                Документ = РеквизитФормыВЗначение("Объект");
                Документ.НачислитьСкидкуКлиенту();
                ЗначениеВРеквизитФормы(Документ, "Объект");	
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре мы сначала получаем объект, отображающийся в форме. Для этого преобразуем основной реквизит формы в объект-документ "ОказаниеУслуги". Затем выполняем экспортируемый метод объекта НачислитьСкидкуКлиенту() и выполняем обратное преобразование объекта в реквизит формы Объект.</p>
    <p>Затем откроем модуль объекта и поместим в нём процедуру для начисления скидки клиенту:</p>
    <div class="code-style">
        <pre>
            Процедура НачислитьСкидкуКлиенту() Экспорт	
                СуммаСкидки = ЦенаУслуги * Клиент.Скидка / 100;
                СуммаУслуги = ЦенаУслуги - СуммаСкидки;	
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре мы воплощаем тот же алгоритм пересчёта, что и в предыдущем способе, но только пересчитываем не данные формы, а данные самого объекта. Эти изменения после преобразования объекта обратно в основной реквизит формы отобразятся в форме документа.</p>
    <p>Запустим 1С:Предприятие, выполним всё то же что и в первом примере.</p>
    <p>Посмотрим теперь на показатели производительности. При выборе клиента произойдёт один вызов сервера.</p>    
    <p>Итак, мы поместили процедуру для начисления скидки клиенту в модуле объекта. Тем самым мы предоставили доступ к данному методу документа из других мест конфигурации: форм, обработок и т.д. Таким образом, в данном решении мы подсчитали процедуру начисления скидки частью прикладной логики объекта.</p>
    <p>Данная функциональность документа доступна, например, из формы списка документов об оказании услуг. т.е. мы можем изменить клиенту процент скидки, затем выделить документ об оказании услуги и пересчитать по нему скидку, не открывая документа.</p>
    <p>Для этого создадим форму списка документа "ОказаниеУслуги" и её команду "НачислитьСкидку". Перетащим команду в командную панель формы. Обработчик команды "НачислитьСкидку" заполним след. образом:</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура НачислитьСкидку(Команда)	
                НачислитьСкидкуНаСервере(Элементы.Список.ТекущаяСтрока);	
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы вызываем внеконтекстную серверную процедуру модуля формы НачислитьСкидкуНаСервере() и передаём в неё сылку на текущий документ:</p>
    <div class="code-style">
        <pre>
            &НаСервереБезКонтекста
            Процедура НачислитьСкидкуНаСервере(СсылкаНаДокумент)	
                Документ = СсылкаНаДокумент.ПолучитьОбъект();
                Документ.НачислитьСкидкуКлиенту();
                Документ.Записать();	
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре по переданной ссылке на документ мы получаем объект, выполняем экспортируемый метод объекта НачислитьСкидкуКлиенту() и записываем документ.</p>
    <p><b>Подитожим</b></p>
    <p>Пересчитывать данные объекта можно как в контекстной серверной процедуре модулы формы объекта, так и в экспортируемой процедуре модуля объекта.</p>
    <p>Когда процедура пересчёта является частью прикладной логики объекта, нужно воплотить процедуру в модуле объекта как его экспортируемый метод</p>
    <p>Когда процедура пересчёта отражает функциональность конкретной формы, можно воплотить её в модуле этой формы.</p>
    <p>Таким образом, из покаанных способов решения задачи более правильным будет второй - за счёт воплощения пересчёта данных в экспортируемом методе объекта. Этот метод будет доступен из других мест конфигурации: форм, обработок и т.д.</p>

    <p><b id="chapter4.3.13">Изменение оформительских свойств элементов формы, не требуюущих обращения к серверу</b></p>
    <p>Для воплощения той или иной функциональности формы часто бывает нужно изменять свойства её элементов(например, менять их оформление) в зависимости от конткретных действий пользователя.</p>
    <p>Первое, что приходит в голову, - использовать для этого обработчик события элементов формы "ПриИзменении" и программно изменять требуемые свойства на клиенте.</p>
    <p>Но нужно учитывать, что если свойства, влияющие на размер элементов формы, меняются программно (например, свойство "Шрифт"), то форма должна полностью "пересчитать" рассположение полей. Это выполняется на сервере и требует определённых затрат времени.</p>
    <p>В платформе 1С:Предпритие начиная с версии 8.3.7 сделан новый механизм расстановки элементов формы. В этом механизме созданы новые возможности размещения элементов в форме, изменения большинства оформительских свойств элементов формы на клиенте больше не требуют обращения к серверу.</p>
    <p>Поэтому при программном изменении на клиенте желательно использовать свойства элементов формы, изменение которых не приводит к обращениям на сервер. Например, вместо свойства "Шрифт" можно использовать свойства "ЦветФона" или "ЦветТекста".</p>
    <p>Если же, требуется изменить именно шрифт элемента, то для этого можно использовать условное оформление. При этом изменение шрифта элемента формы с помощью условного оформления не влияет на размер элемента и, соответсвенно, не приводит к обращению на сервер.</p>
    <p>Какой же способ предпочтительнее? Рассмотрим пример.</p>
    <p>Предположим, в форме документа об оказании услуг содержатся цена услуги, флажок скидки, сумма скидки и сумма услуги. В случае установки флажка "Скидка" поле "СуммаСкидки" должно быть выделено жирным начертанием и зеленым цветом текста. При снятии флажка "Скидка" поле "СуммаСкидки" должно обнуляться и выводится обычным начертанием и красным цветом текста:</p>
    <img src="../img/1С-1/2024-04-13_17-26-25.jpg" class="screen-2" alt="">
    <p>Кроме того, при изменении цены услуги и суммы скидки, в зависимости от состояния флажка "Скидка", нужно рассчитать сумму услуги, равную цене услуги за вычетом суммы скидки. Сразу оговоримся, что прямого отношения к теме примера эта функциональность не имеет.</p>
    <p><b>Первый способ решения</b></p>
    <p>Чтобы выполнить поставленную задачу, создадим форму документа "ОказаниеУслуги" и обработчик события "ПриИзменении" для поля формы "Скидка":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СкидкаПриИзменении(Элемент)	
                Если Объект.Скидка Тогда
                    Элементы.СуммаСкидки.Шрифт = Новый Шрифт(,, Истина);
                    Элементы.СуммаСкидки.ЦветТекста = WebЦвета.ЗеленаяЛужайка;
                    
                    Объект.СуммаУслуги = Объект.ЦенаУслуги - Объект.СуммаСкидки;
                Иначе
                    Элементы.СуммаСкидки.Шрифт = Новый Шрифт();
                    Элементы.СуммаСкидки.ЦветТекста = WebЦвета.Коралловый;
                    
                    Объект.СуммаСкидки = 0;
                    Объект.СуммаУслуги = Объект.ЦенаУслуги;
                КонецЕсли;		
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы узнаём значение реквизита документа "Скидка" типа "булево" и в зависимости от него устанавливаем цвет и жирность начертания для поля формы "СуммаСкидки". Новое начертание поля мы создаём контсруктором - Новый Шрифт(), при создании которого в третьем параметре указываем жирность.</p>
    <p>Кроме того, при изменении флажка "Скидка" мы производим пересчёт суммы услуги.</p>
    <p>Далее в книге идут коды для полей "ЦенаУслуги" и "СуммаСкидки" при их изменении и пересчёт. Не буду их описывать.</p>
    <p>И в заключении установим оформление поля "СуммаСкидки" в зависимости от отметки в поле "Скидка" в обработчике события формы "ПриСозданииНаСервере":</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)	
                Если Объект.Скидка Тогда
                    Элементы.СуммаСкидки.Шрифт = Новый Шрифт(,, Истина);
                    Элементы.СуммаСкидки.ЦветТекста = WebЦвета.ЗеленаяЛужайка;
                Иначе
                    Элементы.СуммаСкидки.Шрифт = Новый Шрифт();
                    Элементы.СуммаСкидки.ЦветТекста = WebЦвета.Коралловый;
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>
    <p>Запустим 1С:Предприятие, создадим документ, выберем услугу, клиента и внесём цену услуги. Первоначально флажок "Скидка" не установлен, сумма услуги равна цене услуги, а сумма скидки отображается красным цветом обычной жирности. Внесём сумму скидки - сумма услуги не изменится. Установим флажок "Скидка". После этого поле "СуммаСкидки" отобразится жирным начертанием и зелёным цветом текста, а поле "СуммаУслуги" самостоятельно пересчитается по заданному нами алгоритму.</p>
    <p>При снятии флажка "Скидка" поле "СуммаСкидки" обнуляется и отображается красным, а поле "СуммаУслуги" снова пересчитывается.</p>
    <p>Посмотрим теперь на показатели производительности. У нас есть один вызов сервера.</p>
    <p>Пересчёт поля "СуммаУслуги" происходит на клиенте и не требует обращения к серверу. Также "безболезненно" произойдёт и изменение цвета текста поля "СуммаСкидки". А вот при изменении свойства "Шрифт" на клиенте произойдёт нежелательный вызов сервера, т.к. изменение этого свойства влияет на размер элемента формы. Это приведёт к пересчёту местоположения элементов формы, которое происходит на сервере.</p>
    <p><b>Второй способ решениия</b></p>
    <p>На самом деле можно обойтись без вызова сервера, если использовать для изменения начертания поля "СуммаСкидки" условное оформление формы.</p>
    <p>Для этого зададим условное оформление поля "СуммаСкидки": жирное начернтание и зелёный цвет текста, в случае если значение поля "Скидка" истинно, и красный цвет текста, если значение поля "Скидка" ложно:</p>
    <img src="../img/1С-1/2024-04-14_09-27-18.png" class="screen" alt="">
    <img src="../img/1С-1/2024-04-14_09-28-27.png" class="screen" alt="">
    <p>Теперь изменим обработчик события "ПриИзменении" поля формы "Скидка":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СкидкаПриИзменении(Элемент)	
                Если Объект.Скидка Тогда
                    Объект.СуммаУслуги = Объект.ЦенаУслуги - Объект.СуммаСкидки;
                Иначе
                    Объект.СуммаСкидки = 0;
                    Объект.СуммаУслуги = Объект.ЦенаУслуги;
                КонецЕсли;		
            КонецПроцедуры
        </pre>
    </div>
    <p>В этом обработчике мы только оставляем пересчёт суммы услуги в соответствии с заданным алгоритмом, а оформление поля мы задали с помощью условного оформления формы.</p>
    <p>Обработчик события формы "ПриСозданииНаСервере" можно теперь удалить, т.к. он больше не нужен.</p>
    <p>Запустим 1С:Предприятие, сделаем всё те же действия. Как видим, функциональность решения будет такой же, но производительность будет выше, т.к. изменение начертания поля формы с помощью условного оформления не приведёт к обращению на сервер.</p>
    <p><b>Третий сособ решения</b></p>
    <p>В качестве другого способа при изменении оформления поля "СуммаСкидки" можно использовать одно из свойств, изменение которых не требует обращения к серверу. Например, свойство "ЦветРамки" вместо свойства "Шрифт".</p>
    <p>Попутно сделаем ещё одно полезное усовершениствование. Дело в том, что программное изменение оформление поля "СуммаСкидки" выполняется два раза: при изменении поля "Скидка"(в обработчике события "ПриИзменении") и при создании формы документа (в обработчике события "ПриСозданииНаСервере"). Воэтому в первом способе решения один и тот же код повторяется в каждом из этих обработчиков.</p>
    <p>Но лучше "навести порядок" в модуле формы и перенести код, изменяющий оформление поля, в отдельную процедуру. И затем вызывать её из обработчиков событий "ПриИзменении" и "ПриСозданииНаСервере".</p>
    <p>Какой же будет директива компиляции этой процедуры? Ведь она должна вызываться как с сервера, так и с клиента. Если мы предварим процедуру &НаКлиенте, то мы не сможем вызывать её с сервера. Точнее модуль формы не пройдёт синтаксическую проверку в контексте сервера.</p>
    <p>Единтсвенная подходящая лиректива - &НаКлиентеНаСервереБезКонтекста. Процедура, описанная такой директивой компиляции, будет выполняться то на сервере, то на клиенте - в зависимости от того, откуда она была вызвана. Но, поскольку процедура будет выполняться без контекста формы, мы должны самостотельно передать этот контекст в параметре типа "ФормаКлиентскогоПриложения".</p>
    <p>Итак, добавим в модуль формы процедуру УстановитьОформление() и перенесём в неё код, изменяющий оформление поля "СуммаСкидки" в зависимости от отметки в поле "Скидка":</p>
    <div class="code-style">
        <pre>
            &НаКлиентеНаСервереБезКонтекста
            Процедура УстановитьОформление(Форма)	
                Если Форма.Объект.Скидка Тогда
                    Форма.Элементы.СуммаСкидки.ЦветРамки = WebЦвета.ЗеленаяЛужайка;
                Иначе
                    Форма.Элементы.СуммаСкидки.ЦветРамки = WebЦвета.Коралловый;
                КонецЕсли;	
            КонецПроцедуры
        </pre>
    </div>
    <p>В этой процедуре в параметре Форма мы получаем контекст формы документа и, использую этот контекст, получаем доступ к коллекции элементов формы (Форма.Элементы) и к реквизиту документа Скидка(Форма.Объект.Скидка).</p>
    <p>Затем изменим обработчик события формы ПриСозданииНаСервере:</p>
    <div class="code-style">
        <pre>
            &НаСервере
            Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)	
                УстановитьОформление(ЭтотОбъект);	
            КонецПроцедуры
        </pre>
    </div>
    <p>А в обработчике события "ПриИзменении" поля формы "Скидка" оставим только пересчёт поля "СуммаУслуги":</p>
    <div class="code-style">
        <pre>
            &НаКлиенте
            Процедура СкидкаПриИзменении(Элемент)	
                Если Объект.Скидка Тогда
                    Объект.СуммаУслуги = Объект.ЦенаУслуги - Объект.СуммаСкидки;
                Иначе
                    Объект.СуммаСкидки = 0;
                    Объект.СуммаУслуги = Объект.ЦенаУслуги;
                КонецЕсли;
                
                УстановитьОформление(ЭтотОбъект);	
            КонецПроцедуры
        </pre>
    </div>
    <p>Запустим 1С:Предприятие, откроем документ об оказании услуги, в котором установлена скидка. Флажок "Скидка" установлен, и поле "СуммаСкидки" обрамлено зелёной рамкой. При снятии отметки в поле Скидка рамка поля "СуммаСкидки" становится красной и значение поля обнуляется. После этого поле "СуммаУслуги" пересчитывается.</p>
    <p>Как мы видим, функциональность прикладного решения будет практически такой же, как и в первом способе, но производительность будет выше, т.к. изменение свойства "ЦветРамки" на клиенте не приведёт к обращению на сервер.</p>
    <p><b>Подитожим</b></p>
    <p>Таким образом, если логика интерактифной работы формы требует изменения её внешнего вида, то лучше использовать те свойства, изменение которых на клиенте не приводит к обращениям на сервер.</p>
    <p>Размер начертания учитывается при самостоятельном определении размеров элементов формы, поэтому при программном изменении начертания на клиенте выполняется обращение к серверу.</p>
    <p>Изменение размера начертания, выполненное с помощью условного оформления формы и динамического списка, не влияет на размер элемента формы. Поэтому советуют заменить программное изменение начертания на клиенте на использование условного офрмления.</p>
    <p>Сеоветуется  не использовать формы, меняющие состав и положение элементов. И вообще, если есть такая возможность, лучше не использовать свойства и методы втроенного языка, приводящие к вызову сервера(это указано в синтакс помощнике).</p>
    <p>Таким образом, из показанных способов решения задачи более правильным будут второй способ - за счёт изменения начертания с помощью условного оформления, и третий - за счёт изменения свойства поля формы "ЦветРамки" вместо свойства "Шрифт". В результате в обоих случаях оформление поля на клиенте не потребовало обращения к серверу.</p>











    <h2 class="header-style" id="chap5">Часть 5. Мобильный клиент</h2>
    <p>Оглавление 5 части на 868 странице</p>




    <h3 class="header-style2" id="chapter5.1">Глава 5.1 Что такое мобильный клиент. Стр 869</h3>
    <p>Пока не буду описывать.</p>

    <h3 class="header-style2" id="chapter5.2">Глава 5.2 Адаптация конфигураций для работы в мобильном клиенте. Стр 871</h3>
    <p class="title-size16"><b id="chapter5.2.1">Общий подход</b></p>
    <p class="title-size16"><b id="chapter5.2.2">Интерфейс мобильного клиента</b></p>

</div>
