<div class="wrap">
   
    <h2 class="header-style">Анимация JS совместно с CSS</h2>
    <h3 class="header-style2">Пример 1</h3>
    <p>В этом примере показано как плавно скрыть и показать блок с помощью js и css. Казалось бы что тут сложного, но сложности есть. Например мы сделали в css класс в котором opacity ставим в значение 0  и прописываем <b>transition: opasity 1s;</b>. Затем в js находим нужный нам блок и по клику добавляем этому блоку наш класс. Всё работает и блок по клику плавно становится прозрачным. И тут первая проблема как убрать физически блок из потока. Мы можем добавить <b>display: none;</b>, но как узнать через сколько времени его надо убрать. Можно конечно глянуть в css и посмотреть сколько там секунд идёт анимация и потом в js с помощью setTimeout() убрать блок через определённое время. А если кто то поменял время в css? придётся искать и в коде это время и менять. setTimeout не выход. На помощь приходит такое событие как <b>transitionend</b>. Вешаем его на наш блок и как только анимация перехода на блоке завершится, так и сработает наше событие и уже в обработчике этого события мы скрываем блок <b>display: none;</b>. Но тут есть ещё одна засада. Событие <b>transitionend</b> нужно после отработки удалить, иначе при плавном 
    показе блока оно снова отработает и вместо показа скроет опять наш блок.</p>
    <p>Ещё одной засадой будет анимация при показе блока. Какую логику мы вешаем на кнопку показа? Естественно мы делаем <b>display: block;</b> и казалось бы нам нужно сделать ещё один класс, в которм мы opacity делаем 1 и <b>transition: opasity 1s;</b> и по клику добавляем наш класс и всё по идее должно работать, но плавности появления блока не получится. Потому что когда блок появляется с помощью <b>display: block;</b>, то он уже по умолчанию имеет <b>opasity: 1;</b> и перехода от 1 до 1 просто нет. Знчит по логике мы могли бы добавить класс - <b>opasity: 0;  transition: opasity 1s;</b> и это верная логика, но браузер не успевает сделать такую анимацию. Тогда мы могли бы подождать немного пока браузер очнётся и применить setTimeout(), но есть хорошая функция, которая делает это вместо setTimeout() и более экономно - это requestAnimationFrame(). Вот пример такой работы:</p>
    <p>Стили:</p>
    <div class="code-style">
    <pre>
    .wrapper{
        width: 400px;
        margin: 30px auto;
    }
    .h{
        opacity: 0;
        transform: translateX(100px);
        transition: opacity 2s, transform 2s;
    }
    .d{
        transform: translateX(-100px);
    }
    .s{
        transition: opacity 2s, transform 2s;
    }
    </pre>
    </div>
    <p>HTML:</p>
    <div class="code-style">
    <pre>
    < div class="wrapper">
      < button class="btn btn-primary">Показать< /button>
      < button class="btn btn-info">Скрыть< /button>
      < hr>
      < div class="training">
        < p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Adipisci vel praesentium officia excepturi, dolorem enim provident quos voluptatibus dignissimos aut, quae et esse doloribus! Accusamus sit nam fugiat ducimus illo?< /p>
      < /div>
      < hr>
      < p>Тут ещё текст< /p>
    < /div>
    </pre>
    </div>
    <p>JS:</p>
    <div class="code-style">
    <pre>
      'use strict';

      let hide = document.querySelector('.btn-info');
      let show = document.querySelector('.btn-primary');
      let tren = document.querySelector('.training');

      hide.addEventListener('click', handlerHide);
      show.addEventListener('click', handlerShow);

      function handlerHide(){
        tren.classList.add('h');
        tren.addEventListener('transitionend', handlerHide2);

        function handlerHide2(){
          this.style.display = 'none';
          tren.removeEventListener('transitionend', handlerHide2);
        }
      }

      function handlerShow(){
        tren.style.display = 'block';
        tren.classList.add('s');
        tren.classList.add('d');

        raf(function(){
          tren.classList.remove('h');
          tren.classList.remove('d');
        })
      }

      function raf(f){
        requestAnimationFrame(function(){
          f();
        });
      }
    </pre>
    </div>
    <iframe src="articles/iframe/js-animate1/js-animate1.html" frameborder="1" width="730" height="400"></iframe>
    <p>Мы сначала добавляем классы с прозрачностью 0 и сдвигом влево на 100px и потом в этой функции мы убираем эти классы и блок возвращается в свои состояния по умолчанию - это прозрачность 1 и позиция на 0 по X. А смысл этой функции в том, что она даёт время браузеру на отрисовку состояний прозрачности в 0 и сдвигает влево на 100px и как только браузер это отрисует функция выполняется и удаляются эти классы и блок плавно возвращается в состояния по умолчанию. Если бы всё делалось без этой функции, то браузер не успел бы сдвинуть влево и прозрачность добавить 0, а cразу бы блок был уже в прозрачности 1 и на своём месте в позиции 0 по X.</p>
</div>